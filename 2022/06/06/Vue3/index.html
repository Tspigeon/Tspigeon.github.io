
<!DOCTYPE html>
<html lang="zh-CN" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Vue3 - Tspigeon &#39;s blog</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="Fechin,"> 
    <meta name="description" content="My blog,Vue31.创建一个vue3项目1.1cli创建cli创建要求vue版本高于4.5.0，我们可以在cmd中通过vue -V查看
然后按照脚手架的方式创建：vue create -name
进入之后选,"> 
    <meta name="author" content="Tspigeon"> 
    <link rel="alternative" href="atom.xml" title="Tspigeon &#39;s blog" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    
    
    
    <meta name="twitter:card" content="summary"/>
    <meta name="twitter:title" content="Vue3 - Tspigeon &#39;s blog"/>
    <meta name="twitter:description" content="My blog,Vue31.创建一个vue3项目1.1cli创建cli创建要求vue版本高于4.5.0，我们可以在cmd中通过vue -V查看
然后按照脚手架的方式创建：vue create -name
进入之后选,"/>
    
    
    
    
    <meta property="og:site_name" content="Tspigeon &#39;s blog"/>
    <meta property="og:type" content="object"/>
    <meta property="og:title" content="Vue3 - Tspigeon &#39;s blog"/>
    <meta property="og:description" content="My blog,Vue31.创建一个vue3项目1.1cli创建cli创建要求vue版本高于4.5.0，我们可以在cmd中通过vue -V查看
然后按照脚手架的方式创建：vue create -name
进入之后选,"/>
    
<link rel="stylesheet" href="/css/diaspora.css">

<meta name="generator" content="Hexo 6.0.0"></head>

<body class="loading">
    <span id="config-title" style="display:none">Tspigeon &#39;s blog</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="http://yoursite.com"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">Vue3</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">Vue3</h1>
        <div class="stuff">
            <span>六月 06, 2022</span>
            
  <ul class="post-tags-list" itemprop="keywords"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/vue/" rel="tag">vue</a></li></ul>


        </div>
        <div class="content markdown">
            <h1 id="Vue3"><a href="#Vue3" class="headerlink" title="Vue3"></a>Vue3</h1><h2 id="1-创建一个vue3项目"><a href="#1-创建一个vue3项目" class="headerlink" title="1.创建一个vue3项目"></a>1.创建一个vue3项目</h2><h3 id="1-1cli创建"><a href="#1-1cli创建" class="headerlink" title="1.1cli创建"></a>1.1cli创建</h3><p>cli创建要求vue版本高于4.5.0，我们可以在cmd中通过<code>vue -V</code>查看</p>
<p>然后按照脚手架的方式创建：<code>vue create -name</code></p>
<p>进入之后选择vue3脚手架即可</p>
<h3 id="1-2-vite创建"><a href="#1-2-vite创建" class="headerlink" title="1.2 vite创建"></a>1.2 vite创建</h3><p>vite是新一代的前端构建工具，由vue团队开发，为了挑战webpack的地位</p>
<p>vite的速度更快更轻量级，使用vite构建工程的方法如下：</p>
<p><img src="D:\新建文件夹\文件\GitHub\pic\vue\vue3\vite.png" alt="vite"></p>
<p>启动不再是<code>npm run serve</code>而是<code>npm run dev</code></p>
<p>我们会发现启动快了很多，但是vite是<strong>等你进入网址再进行动态加载页面</strong></p>
<h2 id="2-vue3结构"><a href="#2-vue3结构" class="headerlink" title="2.vue3结构"></a>2.vue3结构</h2><p>vue3中的<code>main.js</code>中的代码和<code>vue2</code>不同，它使用一个轻量级的app管理组件，提供了挂载和卸载功能</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//引入调用vue的工厂函数 createApp</span><br><span class="line">import &#123; createApp &#125; from &#x27;vue&#x27;</span><br><span class="line">import App from &#x27;./App.vue&#x27;</span><br><span class="line"></span><br><span class="line">// 创建一个app对象，类似于vue2中的vm，但是app更轻</span><br><span class="line">const app = createApp(App)</span><br><span class="line"></span><br><span class="line">// 挂载</span><br><span class="line">app.mount(&#x27;#app&#x27;)</span><br><span class="line"></span><br><span class="line">// 卸载</span><br><span class="line">app.unmount(&#x27;#app&#x27;)</span><br></pre></td></tr></table></figure>

<p>在组件中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;!-- 可以不再需要一个根标签 --&gt;</span><br><span class="line">  &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot;&gt;</span><br><span class="line">  &lt;HelloWorld msg=&quot;Welcome to Your Vue.js App&quot;/&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>



<p>tips：我们可以使用#region和#endRegion括住注释的两端，实现折叠功能</p>
<h2 id="3-composition-API"><a href="#3-composition-API" class="headerlink" title="3.composition API"></a>3.composition API</h2><h3 id="3-1-set-up"><a href="#3-1-set-up" class="headerlink" title="3.1 set up"></a>3.1 set up</h3><p><code>set up</code>是一个配置项，它的值是一个函数，里面存放了数据，方法等（感觉有点像模块化的vuex）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">setup() &#123;</span><br><span class="line">  let name = &quot;tony&quot;;</span><br><span class="line">  let age = 18</span><br><span class="line"></span><br><span class="line">  function sayHello() &#123;</span><br><span class="line">    alert(`I am $&#123;name&#125;,I am $&#123;age&#125; years old`)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 在setup中数据需要return出去</span><br><span class="line">  return&#123;</span><br><span class="line">    name,</span><br><span class="line">    age,</span><br><span class="line">    sayHello</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>return出来的数据可以在外部调用，也可以<code>return</code>一个渲染函数<code>render</code></p>
<p>而且在模板中引用时需要使用this.xxx而不是xxx.value</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt;我是App组件&lt;/h1&gt;</span><br><span class="line">&lt;h2&gt;person:&#123;&#123;this.name&#125;&#125; &#123;&#123;this.age&#125;&#125;&lt;/h2&gt;</span><br><span class="line">&lt;button @click=&quot;sayHello&quot;&gt;hello&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<p>注意set up 不要和vue2中的data，method混用，会有优先级的问题</p>
<p><strong>set up也不能是一个async函数</strong>，被async修饰后我们得到的就是一个promise包裹的对象了，所以被禁止了。</p>
<h3 id="3-2-ref"><a href="#3-2-ref" class="headerlink" title="3.2 ref"></a>3.2 ref</h3><p>ref在vue2中是一个属性，而在vue3中是一个函数，用于实现数据响应式</p>
<p>先引入ref</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; ref &#125; from &quot;vue&quot;;</span><br></pre></td></tr></table></figure>

<p>为了实现ref，我们在定义数据时需要</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let name = ref(&quot;tony&quot;)</span><br><span class="line">let age = ref(18)</span><br></pre></td></tr></table></figure>

<p>这样ref将我们的数据转换成了一个对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RefImpl &#123;__v_isShallow: false, dep: Set(1), __v_isRef: true, _rawValue: &#x27;tony&#x27;, _value: &#x27;tony&#x27;&#125;</span><br><span class="line">dep: Set(1) &#123;ReactiveEffect&#125;</span><br><span class="line">__v_isRef: true</span><br><span class="line">__v_isShallow: false</span><br><span class="line">_rawValue:&quot; 李四&quot;</span><br><span class="line">_value: &quot;李四&quot;</span><br><span class="line">value: &quot;李四&quot;</span><br></pre></td></tr></table></figure>

<p>我们使用value值就可以调用setter，实现响应式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 设置响应式数据</span><br><span class="line">    function changeHello()&#123;</span><br><span class="line">      console.log(name);</span><br><span class="line">      name.value = &#x27;李四&#x27;,</span><br><span class="line">      age.value = 48 </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>我们还可以使用ref操作对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let job = ref(&#123;</span><br><span class="line">  type:&#x27;前端&#x27;,</span><br><span class="line">  salary:&#x27;30k&#x27;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>但是修改对象中的数据使用的是 <code>   job.value.salary=&#39;60k&#39;</code>，</p>
<p>因为对象的封装不再是refimpl，而是proxy</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Proxy</span><br><span class="line">[[Handler]]: Object</span><br><span class="line">[[Target]]: Object</span><br><span class="line">salary: &quot;60k&quot;</span><br><span class="line">type: &quot;前端&quot;</span><br><span class="line">[[Prototype]: Object</span><br><span class="line">[[IsRevoked]]: false</span><br></pre></td></tr></table></figure>



<h3 id="3-3-reactive"><a href="#3-3-reactive" class="headerlink" title="3.3 reactive"></a>3.3 reactive</h3><p>reactive适用于管理对象和数组类型的数据，但不能用于管理基本数据类型</p>
<p>也是将对象封装成一个proxy</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let job = reactive(&#123;</span><br><span class="line">  type:&#x27;前端&#x27;,</span><br><span class="line">  salary:&#x27;30k&#x27;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>更改数据的时候只需要</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">job.salary=&#x27;60k&#x27;</span><br><span class="line">console.log(job)</span><br></pre></td></tr></table></figure>

<p>我们的ref管理的基本类型数据也可以通过封装成对象中的属性让reactive进行管理</p>
<p>在vue2中我们的新增和删除要体现在页面上需要使用</p>
<p>Vue.delete()和Vue.set()或者this.$set()和this.$delete()</p>
<p>vue3中的响应式，只要是reactive中管理的数据，我们就可以直接使用delete删除</p>
<p>vue3是通过proxy调用set和get进行数据的更改，deleteProperty实现删除</p>
<p><img src="D:\新建文件夹\文件\GitHub\pic\vue\vue3\proxy.png" alt="proxy"></p>
<p>在vue2中我们使用props实现父向子传值，子组件接收需要使用props</p>
<p>但是如果不使用props，我们也能在vc身上的<code>$attr</code>中看到</p>
<p>在vue3中setup的执行时间比beforeCreate早</p>
<p>而且setup中的this是undefined</p>
<p>setup中的参数第一个是 props第二个是context</p>
<h4 id="3-3-1使用自定义事件"><a href="#3-3-1使用自定义事件" class="headerlink" title="3.3.1使用自定义事件"></a>3.3.1使用自定义事件</h4><p>vue3中的自定义事件与vue2有区别</p>
<p>首先向子组件传值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;setUp user=&quot;pigeon&quot; pwd=&quot;123456&quot; @hello=&quot;hello&quot;&gt;&lt;/setUp&gt;</span><br></pre></td></tr></table></figure>

<p>然后在子组件接收</p>
<p>注意与vue2不同vue3中需要使用emits属性获取传入的自定义事件，然后使用context参数（必须是把前面的props写上，因为context是第二个参数）触发传参</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    emits: [&#x27;hello&#x27;],</span><br><span class="line">    setup(prop,context) &#123;</span><br><span class="line">        function hello()&#123;</span><br><span class="line">            context.emit(&#x27;hello&#x27;,666)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return&#123;</span><br><span class="line">            hello</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-计算属性与监视"><a href="#4-计算属性与监视" class="headerlink" title="4.计算属性与监视"></a>4.计算属性与监视</h2><h3 id="4-1-computed"><a href="#4-1-computed" class="headerlink" title="4.1 computed"></a>4.1 computed</h3><p>vue3中也可以vue2的计算属性，但是不推荐</p>
<p>vue3中的计算属性需要引入然后写入在setup中</p>
<p>我们写一个案例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import &#123; reactive, computed &#125; from &#x27;vue&#x27;;</span><br><span class="line">export default &#123;</span><br><span class="line">    name: &#x27;setUp&#x27;,</span><br><span class="line">    setup() &#123;</span><br><span class="line">        let person = reactive(&#123;</span><br><span class="line">            firstName : &#x27;tony&#x27;,</span><br><span class="line">            lastName : &#x27;stake&#x27;,</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        // //书写计算属性使用computed-简写形式</span><br><span class="line">        // person.fullName = computed(()=&gt;&#123;</span><br><span class="line">        //     return person.firstName+&#x27;-&#x27;+person.lastName</span><br><span class="line">        // &#125;)</span><br><span class="line"></span><br><span class="line">        // getter 和setter形式</span><br><span class="line">        person.fullName = computed(&#123;</span><br><span class="line">            get()&#123;</span><br><span class="line">                return person.firstName+&#x27;-&#x27;+person.lastName</span><br><span class="line">            &#125;,</span><br><span class="line">            set(newVal)&#123;</span><br><span class="line">                const nameArr = newVal.split(&#x27;-&#x27;)</span><br><span class="line">                person.firstName=nameArr[0]</span><br><span class="line">                person.lastName=nameArr[1]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        return&#123;</span><br><span class="line">            person</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和vue2一样如果需要修改计算得到的值要把计算属性写成扩写形式，写出set方法</p>
<h3 id="4-2-监视属性"><a href="#4-2-监视属性" class="headerlink" title="4.2 监视属性"></a>4.2 监视属性</h3><h4 id="ref"><a href="#ref" class="headerlink" title="ref:"></a>ref:</h4><p>对ref使用监视属性监视简单数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import &#123; ref, watch &#125; from &#x27;vue&#x27;;</span><br><span class="line">export default &#123;</span><br><span class="line">    name: &#x27;setUp&#x27;,</span><br><span class="line">    setup() &#123;</span><br><span class="line">        let sum = ref(0)</span><br><span class="line">        let msg = ref(&#x27;hello&#x27;)</span><br><span class="line">        //watch-情况一</span><br><span class="line">        // watch(sum, (newVal,oldVal)=&gt;&#123;</span><br><span class="line">        //     console.log(&quot;sum改变了&quot;+oldVal+newVal);</span><br><span class="line">        // &#125;)</span><br><span class="line">        </span><br><span class="line">        //watch-情况二-监视多个</span><br><span class="line">        watch([sum, msg], (newVal,oldVal)=&gt;&#123;</span><br><span class="line">            console.log(oldVal,newVal);</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        return&#123;</span><br><span class="line">            sum,</span><br><span class="line">            msg</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意情况二的数据，得到的oldVal和newVal是数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, &#x27;hello&#x27;] =&gt; [0, &#x27;hello&#x27;]</span><br></pre></td></tr></table></figure>

<p>当需要打开深度监视和立即监视的时候在后面写配置项</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">watch(sum, (oldVal,newVal)=&gt;&#123;</span><br><span class="line">    console.log(&quot;sum改变了&quot;+oldVal+newVal);</span><br><span class="line">&#125;,&#123;immediate:true, deep:true&#125;)</span><br></pre></td></tr></table></figure>



<h4 id="reactive："><a href="#reactive：" class="headerlink" title="reactive："></a>reactive：</h4><p>reactive操作对象数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">个人信息：&lt;input v-model=&quot;person.name&quot;/&gt;</span><br><span class="line">&lt;br/&gt;</span><br><span class="line">&lt;input v-model=&quot;person.age&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>我们使用reactive包裹一个对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let person = reactive(&#123;</span><br><span class="line">    name:&#x27;on&#x27;,</span><br><span class="line">    age:&#x27;18&#x27;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//watch-情况三-监视对象</span><br><span class="line">watch(person,(oldVal,newVal)=&gt;&#123;</span><br><span class="line">    console.log(oldVal,newVal);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但是我们得到的数据是:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Proxy &#123;name: &#x27;jkl&#x27;, age: &#x27;18&#x27;&#125; =&gt; Proxy &#123;name: &#x27;jkl&#x27;, age: &#x27;18&#x27;&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现没有oldValue了，只有newValue，而且自动开启了<strong>深度监视</strong></p>
<p>如果我们需要使用oldValue就只有使用ref</p>
<p>还有几种情况：</p>
<p><img src="D:\新建文件夹\文件\GitHub\pic\vue\vue3\watch的几种情况.png" alt="watch的几种情况"></p>
<p>注意一个特殊情况：这里的job是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">job:&#123;</span><br><span class="line">    j1:&#123;</span><br><span class="line">        salary:&quot;1K&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如果要监视一种属性，要监听里面的数据，要用到深度监视配置deep</strong></p>
<h4 id="value："><a href="#value：" class="headerlink" title="value："></a>value：</h4><p>我们使用ref包裹基本数据的时候，很多人会习惯了<code>.value</code>，但是在watch中，我们不能使用<code>.value</code>，因为value取到的是值，但是我们需要监视的是一个<code>RefImpl</code>的结构</p>
<p>但是如果我们包裹的是对象数据，<strong>情况就不一样了</strong>，我们就需要使用<code>.value</code>，因为对象中的<code>.value</code>是一个proxy，它才是真正的监听数据，一般的person只是一个内存地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">watch(person.value,(oldVal,newVal)=&gt;&#123;</span><br><span class="line">   console.log(oldVal,newVal);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>还有一种不使用<code>.value</code>的方法，开启深度监视</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">watch(person,(oldVal,newVal)=&gt;&#123;</span><br><span class="line">   console.log(oldVal,newVal);</span><br><span class="line">&#125;,&#123;deep: true&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="watchEffect："><a href="#watchEffect：" class="headerlink" title="watchEffect："></a>watchEffect：</h4><p>vue3中的新属性</p>
<p>官方文档的定义：立即运行一个函数，同时响应式地追踪其依赖，并在依赖更改时重新执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">watchEffect(()=&gt;&#123;</span><br><span class="line">    const x = person.name;</span><br><span class="line">    console.log(&quot;name改变了&quot;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>我们发现我们更改person.name的时候，就会触发回调</p>
<p>只要我们在回调中用到的数据改变，就会触发回调</p>
<p>其实watchEffect有点类似computed，<strong>回调中依赖的数据变化，就会执行回调</strong></p>
<h3 id="5-生命周期"><a href="#5-生命周期" class="headerlink" title="5.生命周期"></a>5.生命周期</h3><p>生命周期大体上和vue2差不多，更新了两个钩子</p>
<p>取消了beforedestroy和destroy</p>
<p>更新了：</p>
<p>beforeUnmount</p>
<p>在一个组件实例被卸载之前调用。</p>
<ul>
<li><p><strong>类型</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface ComponentOptions &#123;</span><br><span class="line">  beforeUnmount?(this: ComponentPublicInstance): void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>详细信息</strong></p>
<p>当这个钩子被调用时，组件实例依然还保有全部的功能。</p>
<p><strong>这个钩子在服务端渲染时不会被调用。</strong></p>
</li>
</ul>
<p>和</p>
<p>unmounted</p>
<p>在一个组件实例被卸载之后调用。</p>
<ul>
<li><p><strong>类型</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface ComponentOptions &#123;</span><br><span class="line">  unmounted?(this: ComponentPublicInstance): void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>详细信息</strong></p>
<p>一个组件在以下情况下被视为已卸载：</p>
<ul>
<li>其所有子组件都已经被卸载。</li>
<li>所有相关的响应式作用 (渲染作用以及 <code>setup()</code> 时创建的计算属性和侦听器) 都已经停止。</li>
</ul>
<p>可以在这个钩子中手动清理一些副作用，例如计时器、DOM 事件监听器或者与服务器的连接。</p>
<p><strong>这个钩子在服务端渲染时不会被调用。</strong></p>
</li>
</ul>
<p>一般形式和我们vue2中很像，所以我们这里介绍</p>
<h4 id="组合式API："><a href="#组合式API：" class="headerlink" title="组合式API："></a>组合式API：</h4><p><img src="D:\新建文件夹\文件\GitHub\pic\vue\vue3\生命周期组件式API.png" alt="生命周期组件式API"></p>
<p>导入之后就可以在setUp中写</p>
<p>导入：<code>import &#123; reactive, ref, onBeforeMount &#125; from &#39;vue&#39;;</code></p>
<p>使用：（在setup中）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">setup() &#123;</span><br><span class="line">    let sum = ref(0)</span><br><span class="line">    let msg = ref(&#x27;hello&#x27;)</span><br><span class="line">    let person = reactive(&#123;</span><br><span class="line">        name:&#x27;on&#x27;,</span><br><span class="line">        age:&#x27;18&#x27;,</span><br><span class="line">        job:&#123;</span><br><span class="line">            j1:&#123;</span><br><span class="line">                salary:&quot;1K&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    onBeforeMount(()=&gt;&#123;</span><br><span class="line">        console.log(&quot;===onBeforeMount===&quot;);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    return&#123;</span><br><span class="line">        sum,</span><br><span class="line">        msg,</span><br><span class="line">        person,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是不提倡组合式api和函数式混用，导致项目结构不清晰</p>
<h3 id="6-hook"><a href="#6-hook" class="headerlink" title="6.hook"></a>6.hook</h3><p>hook是一个函数，在setup中对组合式api进行封装</p>
<p>比如我们需要一个获取鼠标坐标的函数，这种函数如果经常用到，我们就需要将它写成模块</p>
<p>这个模块就是hook</p>
<p>新建一个src/hook文件夹：写入文件<code>usePoint.js</code></p>
<p><strong>引入，暴露，函数，返回值都要有</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import &#123; reactive, onMounted, onBeforeUnmount &#125; from &#x27;vue&#x27;;</span><br><span class="line">export default function () &#123;</span><br><span class="line">    let points = reactive(&#123;</span><br><span class="line">        x: 0,</span><br><span class="line">        y: 0,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    //自定义函数</span><br><span class="line">    function savePoint(event) &#123;</span><br><span class="line">        points.x = event.pageX;</span><br><span class="line">        points.y = event.pageY;</span><br><span class="line">        console.log(points.x+&quot; &quot;+points.y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //生命周期钩子</span><br><span class="line">    onMounted(()=&gt;&#123;</span><br><span class="line">        window.addEventListener(&#x27;click&#x27;, savePoint)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    //销毁钩子</span><br><span class="line">    onBeforeUnmount(()=&gt;&#123;</span><br><span class="line">        window.removeEventListener(&#x27;click&#x27;, savePoint)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    //因为要作为函数调用，最后要返回出去</span><br><span class="line">    return points</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后这个模块可以在</p>
<p>组件中被引入，然后通过函数调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">当前求和为：&#123;&#123;sum&#125;&#125;</span><br><span class="line">&lt;button @click=&quot;sum++&quot;&gt;点我加1&lt;/button&gt;</span><br><span class="line">&lt;br/&gt;</span><br><span class="line">获取当前鼠标坐标：X:&#123;&#123;points.x&#125;&#125;,y:&#123;&#123;points.y&#125;&#125;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import usePoint from &#x27;@/hooks/usePoint&#x27;;</span><br><span class="line">import &#123; ref, &#125; from &#x27;vue&#x27;;</span><br><span class="line">export default &#123;</span><br><span class="line">    name: &#x27;setUp&#x27;,</span><br><span class="line">    setup() &#123;</span><br><span class="line">        let sum = ref(0)</span><br><span class="line">        </span><br><span class="line">        //获取hook中的调用</span><br><span class="line">        let points = usePoint() </span><br><span class="line"></span><br><span class="line">        return&#123;</span><br><span class="line">            sum,</span><br><span class="line">            points</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>



<h3 id="7-toRef"><a href="#7-toRef" class="headerlink" title="7.toRef"></a>7.toRef</h3><p>当我们需要单独将name拿出来存储的时候，</p>
<p>有需要和之前的person产生联系使用</p>
<p>相当于一个浅拷贝，有引用关系和指针指向问题</p>
<p><img src="D:\新建文件夹\文件\GitHub\pic\vue\vue3\toRef.png" alt="toRef"></p>
<p>或者可以使用<code>toRefs</code>对一个对象的数据进行toRef操作，如果是有深度的数据就需要使用的时候加上层级关系</p>
<p>但是return的时候需要使用<code>...toRefs(xxx)</code>，展开来进行返回</p>
<h2 id="…some-tips"><a href="#…some-tips" class="headerlink" title="…some tips"></a>…some tips</h2><h3 id="1-vue3全局挂载"><a href="#1-vue3全局挂载" class="headerlink" title="1.vue3全局挂载"></a>1.vue3全局挂载</h3><p>在vue2中使用全局挂载是直接调用Vue的原型（prototype）</p>
<p>但是vue3中，我们不再创建vue实例，所以无法在原型上做更改</p>
<p>我们引进一个全新的函数 <code>config.globalProperties</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const app = createApp(App)</span><br><span class="line">app.config.globalProperties.$axios = axios</span><br><span class="line">app.mount(&#x27;#app&#x27;)</span><br></pre></td></tr></table></figure>

<p>这样也可以实现全局挂载的效果</p>
<h3 id="2-跨域配置"><a href="#2-跨域配置" class="headerlink" title="2.跨域配置"></a>2.跨域配置</h3><p>vue3的跨域问题配置也是同vue2一样在vue.config.js中（没有就创建一个）</p>
<p>其中target中相当于<code>baseurl</code>是跳转的一个默认地址</p>
<p><code>changOrigin: true,</code>实现我们允许跨域的效果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//vue.config.js</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    devServer: &#123;</span><br><span class="line">      open: true, //是否自动弹出浏览器页面</span><br><span class="line">      // host: &quot;localhost&quot;,</span><br><span class="line">      // port: &#x27;8080&#x27;,</span><br><span class="line">      proxy: &#123;  //配置跨域，可以配置多个跨域</span><br><span class="line">      &#x27;/api&#x27;: &#123;</span><br><span class="line">        target: &#x27;http://127.0.0.1/&#x27;,  //这里后台的地址模拟的;应该填写你们真实的后台接口</span><br><span class="line">        changOrigin: true,  //允许跨域</span><br><span class="line">        pathRewrite: &#123;</span><br><span class="line">          /* 重写路径，当我们在浏览器中看到请求的地址为：http://localhost:8080/api/core/getData/userInfo 时</span><br><span class="line">            实际上访问的地址是：http://121.121.67.254:8185/core/getData/userInfo,因为重写了 /api</span><br><span class="line">           */</span><br><span class="line">          &#x27;^/api&#x27;: &#x27;&#x27; </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-获取全局实例"><a href="#3-获取全局实例" class="headerlink" title="3.获取全局实例"></a>3.获取全局实例</h3><p>因为vue3中setup不能使用this</p>
<p>所以为了获取我们全局挂载上的方法，我们需要使用<code>getCurrentInstance</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const &#123;proxy&#125; = getCurrentInstance()</span><br><span class="line"></span><br><span class="line">const $axios = proxy.$axios</span><br></pre></td></tr></table></figure>


            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title="0" data-url="http://link.hhtjim.com/163/425570952.mp3"></li>
                        
                    
                        
                            <li title="1" data-url="http://link.hhtjim.com/163/425570952.mp3"></li>
                        
                    
                </ul>
            
        </div>
        
    <div id="gitalk-container" class="comment link"
		data-enable="false"
        data-ae="false"
        data-ci=""
        data-cs=""
        data-r=""
        data-o=""
        data-a=""
        data-d="false"
    >查看评论</div>


    </div>
    
</div>


    </div>
</div>
</body>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>






</html>
