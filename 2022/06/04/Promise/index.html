
<!DOCTYPE html>
<html lang="zh-CN" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Promise - Tspigeon &#39;s blog</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="Fechin,"> 
    <meta name="description" content="My blog,Promise1.何为Promise首先说一下promise 是什么？
1、本质是构造函数中主要用于异步计算
2、可以将异步操作队列化，按照期望的顺序执行，返回符合预期的结果
其次主要处理异步和操作,"> 
    <meta name="author" content="Tspigeon"> 
    <link rel="alternative" href="atom.xml" title="Tspigeon &#39;s blog" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    
    
    
    <meta name="twitter:card" content="summary"/>
    <meta name="twitter:title" content="Promise - Tspigeon &#39;s blog"/>
    <meta name="twitter:description" content="My blog,Promise1.何为Promise首先说一下promise 是什么？
1、本质是构造函数中主要用于异步计算
2、可以将异步操作队列化，按照期望的顺序执行，返回符合预期的结果
其次主要处理异步和操作,"/>
    
    
    
    
    <meta property="og:site_name" content="Tspigeon &#39;s blog"/>
    <meta property="og:type" content="object"/>
    <meta property="og:title" content="Promise - Tspigeon &#39;s blog"/>
    <meta property="og:description" content="My blog,Promise1.何为Promise首先说一下promise 是什么？
1、本质是构造函数中主要用于异步计算
2、可以将异步操作队列化，按照期望的顺序执行，返回符合预期的结果
其次主要处理异步和操作,"/>
    
<link rel="stylesheet" href="/css/diaspora.css">

<meta name="generator" content="Hexo 6.0.0"></head>

<body class="loading">
    <span id="config-title" style="display:none">Tspigeon &#39;s blog</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="http://yoursite.com"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">Promise</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">Promise</h1>
        <div class="stuff">
            <span>六月 04, 2022</span>
            
  <ul class="post-tags-list" itemprop="keywords"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/Promise/" rel="tag">Promise</a></li></ul>


        </div>
        <div class="content markdown">
            <h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><h2 id="1-何为Promise"><a href="#1-何为Promise" class="headerlink" title="1.何为Promise"></a>1.何为Promise</h2><p>首先说一下promise 是什么？</p>
<p>1、本质是构造函数中主要用于异步计算</p>
<p>2、可以将异步操作队列化，按照期望的顺序执行，返回符合预期的结果</p>
<p>其次主要处理异步和操作同步化</p>
<h2 id="2-Promise的好处"><a href="#2-Promise的好处" class="headerlink" title="2.Promise的好处"></a>2.Promise的好处</h2><h3 id="2-1-指定回调函数的方式更加灵活"><a href="#2-1-指定回调函数的方式更加灵活" class="headerlink" title="2.1.指定回调函数的方式更加灵活"></a>2.1.指定回调函数的方式更加灵活</h3><p>（1）：旧的回调必须在启动异步任务前指定，比如setTimeout</p>
<p>（2）：promise则是：启动异步任务 =&gt; 返回promise对象 =&gt; 给promise对象绑定回调函数</p>
<h3 id="2-2-支持链式调用，可以解决回调地狱问题"><a href="#2-2-支持链式调用，可以解决回调地狱问题" class="headerlink" title="2.2.支持链式调用，可以解决回调地狱问题"></a>2.2.支持链式调用，可以解决回调地狱问题</h3><p>（1）：回调地狱？</p>
<p>回调地狱就是回调函数的嵌套调用，外部回调函数异步执行的结果是嵌套的回调执行的条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">asFunc1(opt, (...args1)=&gt;&#123;</span><br><span class="line">	asFunc2(opt, (...args2)=&gt;&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>（2）：解决方案？</p>
<p>promise的链式调用</p>
<h2 id="3-Promise的小应用"><a href="#3-Promise的小应用" class="headerlink" title="3.Promise的小应用"></a>3.Promise的小应用</h2><h3 id="3-1-一个小小的抽奖程序"><a href="#3-1-一个小小的抽奖程序" class="headerlink" title="3.1.一个小小的抽奖程序"></a>3.1.一个小小的抽奖程序</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//rand生成随机数</span><br><span class="line">function rand(m, n) &#123;</span><br><span class="line">    return Math.ceil(Math.random() * (n - m + 1) + m - 1)</span><br><span class="line">&#125;</span><br><span class="line">const btn = document.querySelector(&quot;#btn&quot;)</span><br><span class="line">// 绑定点击事件</span><br><span class="line">btn.addEventListener(&#x27;click&#x27;, function () &#123;</span><br><span class="line">    // console.log(&quot;hello promise&quot;)</span><br><span class="line">    //创建一个promise的实例对象</span><br><span class="line">    //resolve代表解决 函数类型对象</span><br><span class="line">    //reject代表拒绝 函数类型对象</span><br><span class="line">    const p = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            let n = rand(1, 100)</span><br><span class="line">            //进入判断</span><br><span class="line">            if(n &lt;= 50)&#123;</span><br><span class="line">                resolve()//将promise对象的状态设置为-成功</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                reject()//将promise队形的状态设置为-失败</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,1000);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    //调用then方法</span><br><span class="line">    p.then(() =&gt;&#123;//resolve调用</span><br><span class="line">        alert(&#x27;恭喜中奖&#x27;)</span><br><span class="line">    &#125;,()=&gt;&#123;//reject调用</span><br><span class="line">        alert(&#x27;再接再厉&#x27;);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>1.Promise的实例对象需要创建，其中包含了我们的异步任务</p>
<p>2.Promise实例化后用过then方法运行，实现触发回调</p>
<p>但是如果我们想知道自己的中奖号码是多少怎么办呢？</p>
<p>还记得resolve和reject这两个函数吗？我们就用这两个函数传参</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (n &lt;= 50) &#123;</span><br><span class="line">    resolve(n)//将promise对象的状态设置为-成功</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    reject(n)//将promise队形的状态设置为-失败</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p.then((value) =&gt; &#123;//resolve调用，参数叫value--成功的值</span><br><span class="line">    alert(&#x27;恭喜中奖,号码为&#x27; + value)</span><br><span class="line">&#125;, (reason) =&gt; &#123;//reject调用，参数叫reason--失败的原因</span><br><span class="line">    alert(&#x27;再接再厉&#x27; + reason);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="3-2-读取文件"><a href="#3-2-读取文件" class="headerlink" title="3.2.读取文件"></a>3.2.读取文件</h3><p>在原生js中我们读取文件的方式是使用fs模块</p>
<p>原生：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//引入fs模块</span><br><span class="line">const fs = require(&#x27;fs&#x27;);</span><br><span class="line"></span><br><span class="line">fs.readFile(&#x27;./resource/content.txt&#x27;,(err,data)=&gt;&#123;</span><br><span class="line">    //出错</span><br><span class="line">    if(err) throw err;</span><br><span class="line">    //输出文件</span><br><span class="line">    console.log(data.toString())</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>同样，这样子的异步问题，我们依然可以使用Promise解决</p>
<p>Promise：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&#x27;fs&#x27;);</span><br><span class="line"></span><br><span class="line">let p = new Promise((resolve , reject)=&gt;&#123;</span><br><span class="line">    fs.readFile(&#x27;./resource/content.txt&#x27;,(err,data)=&gt;&#123;</span><br><span class="line">        //出错</span><br><span class="line">        if(err) reject(err)</span><br><span class="line">        //成功回调</span><br><span class="line">        resolve(data)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">//调用then</span><br><span class="line">p.then(value=&gt;&#123;</span><br><span class="line">    console.log(value.toString())//不加toString那么得到的就会是数字码</span><br><span class="line">&#125;,reason=&gt;&#123;</span><br><span class="line">    console.log(reason)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="3-3-发送Ajax请求"><a href="#3-3-发送Ajax请求" class="headerlink" title="3.3.发送Ajax请求"></a>3.3.发送Ajax请求</h3><p>现在问题来到了Ajax身上，Ajax同样也是一个异步操作，我们用Promise进行封装</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const p = new Promise((reslove, reject) =&gt; &#123;</span><br><span class="line">    btn.addEventListener(&#x27;click&#x27;, function () &#123;</span><br><span class="line">        const xhr = new XMLHttpRequest()</span><br><span class="line">        xhr.open(&#x27;GET&#x27;, &#x27;https://api.apiopen.top/getJoke&#x27;)</span><br><span class="line">        xhr.send()</span><br><span class="line">        //处理结果</span><br><span class="line">        xhr.onreadystatechange = function () &#123;</span><br><span class="line">            if (xhr.readyState === 4) &#123;</span><br><span class="line">                if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) &#123;</span><br><span class="line">                    reslove(xhr.response)</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    reject(xhr.status)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>以后会有axios给我们使用，axios就是promise风格的发送Ajax请求的方法</p>
<h3 id="3-4-自动封装函数Promisify"><a href="#3-4-自动封装函数Promisify" class="headerlink" title="3.4.自动封装函数Promisify"></a>3.4.自动封装函数Promisify</h3><p>如果对函数进行promise封装每次都要我们手写，那实在是十分不妥</p>
<p>接下来我们引入 util 模块中的promisify方法，帮助我们实现自动封装</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//引入util</span><br><span class="line">const util = require(&#x27;util&#x27;)</span><br><span class="line">//引入fs</span><br><span class="line">const fs = require(&#x27;fs&#x27;)</span><br><span class="line">//返回一个新函数,将readFile封装成promise风格</span><br><span class="line">let readMyFile = util.promisify(fs.readFile)</span><br><span class="line"></span><br><span class="line">readMyFile(&#x27;./resource/content.txt&#x27;).then(value =&gt; &#123;</span><br><span class="line">    console.log(value.toString());</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>非常好用！</p>
<h3 id="3-5-promise对象的状态"><a href="#3-5-promise对象的状态" class="headerlink" title="3.5.promise对象的状态"></a>3.5.promise对象的状态</h3><p>Promise实例对象中会有一个状态属性——PromiseState</p>
<p>这个属性有三个可能值：1.pending（未决定的）2.resolved/fullfilled（正确状态）3.rejected（错误状态）</p>
<p>这些属性之间的转换：只能是由padding转化为resolved或者rejected</p>
<p>通过resolve，reject，throw改变状态</p>
<h3 id="3-6-promise对象的结果"><a href="#3-6-promise对象的结果" class="headerlink" title="3.6.promise对象的结果"></a>3.6.promise对象的结果</h3><p>Promise实例对象中会有一个结果属性——PromiseResult</p>
<p>这个属性存着Promise对象的结果</p>
<p>改变这个结果只能通过resolve和reject两个方法进行改变</p>
<h2 id="4-Promise的API"><a href="#4-Promise的API" class="headerlink" title="4.Promise的API"></a>4.Promise的API</h2><h3 id="4-1-execator和catch"><a href="#4-1-execator和catch" class="headerlink" title="4.1.execator和catch"></a>4.1.execator和catch</h3><p>execator代表我们(resolve,reject) =&gt; {} 中的内容，它和我们的const p 是同步调用的，也就是这里面的代码是会立即执行的</p>
<p>catch是Promise对象的对于失败的回调，类似于我们的then ，但是它只管理失败回调</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    let p = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        console.log(&#x27;111&#x27;);</span><br><span class="line">        reject(&#x27;error&#x27;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    console.log(222);</span><br><span class="line">    p.catch(reason =&gt; &#123;</span><br><span class="line">        console.log(reason);</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>这里的输出顺序是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">111</span><br><span class="line">222</span><br><span class="line">error</span><br></pre></td></tr></table></figure>



<h3 id="4-2-resolve"><a href="#4-2-resolve" class="headerlink" title="4.2 resolve"></a>4.2 resolve</h3><p>resolve是一个Promise下的方案，使用<code>Promise.reslove()</code>调用与以往new Promise的调用不同</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//传入的参数是一个非Promise的值,得到一个fulfilled的Promise对象</span><br><span class="line">let p = Promise.resolve(521)</span><br><span class="line">console.log(p)</span><br><span class="line">//传入参数是一个Promise对象，得到和传入Promise对象相同的Promise对象</span><br><span class="line">let q = Promise.resolve(new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    reject(&quot;err&quot;)</span><br><span class="line">&#125;))</span><br><span class="line">//消除报错</span><br><span class="line">q.catch(reason =&gt; &#123;</span><br><span class="line">    console.log(reason);</span><br><span class="line">&#125;)</span><br><span class="line">//这里是rejected状态的Promise对象</span><br><span class="line">console.log(q)</span><br></pre></td></tr></table></figure>

<p>唯一需要注意的是传入的参数为Promise对象时的情况</p>
<h3 id="4-3-rejecte"><a href="#4-3-rejecte" class="headerlink" title="4.3 rejecte"></a>4.3 rejecte</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let r = Promise.reject(521)</span><br><span class="line">let j = Promise.reject(new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    resolve(&quot;OK&quot;)</span><br><span class="line">&#125;))</span><br><span class="line">//返回的Promise对象依然失败，失败的原因是我们传入的Promise对象</span><br><span class="line">console.log(j);</span><br></pre></td></tr></table></figure>

<p>与resolve不同的是，即使给reject传入一个成功的Promise对象，所返回的Promise对象状态依然是rejected</p>
<h3 id="4-4-all"><a href="#4-4-all" class="headerlink" title="4.4 all"></a>4.4 all</h3><p>当我们有多个Promise对象的时候，使用我们的all方案</p>
<p>all方法参数可以是一个Promise数组，只要数组中有一个失败Promise那么返回的Promise就会失败，多个失败结果只会返回第一个查找到的失败结果值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let p1 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    resolve(&quot;ok&quot;)</span><br><span class="line">&#125;)</span><br><span class="line">let p2 = Promise.resolve(&quot;right&quot;)</span><br><span class="line">let p3 = Promise.reject(&quot;err&quot;)</span><br><span class="line">const all = Promise.all([p1, p2, p3])</span><br><span class="line">console.log(all);</span><br></pre></td></tr></table></figure>

<p>得到的结果是一个原因为<code>err</code>，状态为<code>rejected</code>的Promise对象</p>
<h3 id="4-5-race"><a href="#4-5-race" class="headerlink" title="4.5 race"></a>4.5 race</h3><p>也是传入一个数组作为参数，返回第一个改变状态的Promise对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let r1 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        resolve(&quot;ok&quot;)  </span><br><span class="line">    &#125;, 1000);</span><br><span class="line">&#125;)</span><br><span class="line">let r2 = Promise.resolve(&quot;right&quot;)</span><br><span class="line">let r3 = Promise.reject(&quot;err&quot;)</span><br><span class="line">//返回第一个改变结果的Promise对象-r2</span><br><span class="line">const race = Promise.race([r1,r2,r3])</span><br><span class="line">console.log(race);</span><br></pre></td></tr></table></figure>

<p>这里因为r1延迟resolve了，所以race中第一个改变的对象是r2</p>
<h3 id="4-6-then方法的返回结果"><a href="#4-6-then方法的返回结果" class="headerlink" title="4.6 then方法的返回结果"></a>4.6 then方法的返回结果</h3><p>then方法的返回结果是一个Promise对象，对象的PromiseState和PromiseResult与传入的参数有关</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">let p = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    resolve(&#x27;OK&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line">let result = p.then(value =&gt; &#123;</span><br><span class="line">    //第一种返回throw  得到错误对象</span><br><span class="line">    // throw &quot;err&quot;</span><br><span class="line">    //第二次返回非Promise对象 得到成功对象</span><br><span class="line">    // return 521</span><br><span class="line">    //第三次返回Promise对象 得到Promise状态和原因</span><br><span class="line">    return  new Promise((resolve,reject) =&gt;&#123;</span><br><span class="line">        resolve(&quot;right&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br><span class="line">reason =&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;) </span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure>

<h3 id="4-7-Promise串联任务"><a href="#4-7-Promise串联任务" class="headerlink" title="4.7 Promise串联任务"></a>4.7 Promise串联任务</h3><p>使用then的链式调用串联任务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">let p = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    resolve(&#x27;OK&#x27;)</span><br><span class="line">&#125;)</span><br><span class="line">let result = p.then(value =&gt; &#123;</span><br><span class="line">    //第一种返回throw  得到错误对象</span><br><span class="line">    // throw &quot;err&quot;</span><br><span class="line">    //第二次返回非Promise对象 得到成功对象</span><br><span class="line">    // return 521</span><br><span class="line">    //第三次返回Promise对象 得到Promise状态和原因</span><br><span class="line">    return  new Promise((resolve,reject) =&gt;&#123;</span><br><span class="line">        resolve(&quot;right&quot;)</span><br><span class="line">    &#125;).then(value =&gt; &#123;</span><br><span class="line">        console.log(value);</span><br><span class="line">    &#125;).then(value =&gt; &#123;</span><br><span class="line">        console.log(value);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br><span class="line">reason =&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;) </span><br><span class="line">console.log(result);//得到一个state为fulfilled，result为undefined的对象</span><br></pre></td></tr></table></figure>



<h3 id="4-8-异常穿透"><a href="#4-8-异常穿透" class="headerlink" title="4.8 异常穿透"></a>4.8 异常穿透</h3><p>在串联任务中我们不需要每个then都指定失败的回调</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let p = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    reject(&#x27;err&#x27;)</span><br><span class="line">&#125;) </span><br><span class="line">p.then(value =&gt; &#123;</span><br><span class="line">    console.log(111);</span><br><span class="line">&#125;).then(value =&gt;&#123;</span><br><span class="line">    console.log(222);</span><br><span class="line">&#125;).then(value =&gt;&#123;</span><br><span class="line">    console.log(333);</span><br><span class="line">&#125;).catch(reason =&gt;&#123;</span><br><span class="line">    console.log(reason);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>只要发生了异常，就会触发catch的失败回调</p>
<h3 id="4-9-中断链式"><a href="#4-9-中断链式" class="headerlink" title="4.9 中断链式"></a>4.9 中断链式</h3><p>中断链式需要then方法返回一个pending状态的promise对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let p = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">     resolve(&#x27;err&#x27;)</span><br><span class="line"> &#125;) </span><br><span class="line"> p.then(value =&gt; &#123;</span><br><span class="line">     console.log(111);</span><br><span class="line">     //返回一个pending类型的promise对象时中断链式</span><br><span class="line">     return new Promise(() =&gt;&#123;&#125;)</span><br><span class="line"> &#125;).then(value =&gt;&#123;</span><br><span class="line">     console.log(222);</span><br><span class="line"> &#125;).then(value =&gt;&#123;</span><br><span class="line">     console.log(333);</span><br><span class="line"> &#125;).catch(reason =&gt;&#123;</span><br><span class="line">     console.log(reason);</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure>


            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title="0" data-url="http://link.hhtjim.com/163/425570952.mp3"></li>
                        
                    
                        
                            <li title="1" data-url="http://link.hhtjim.com/163/425570952.mp3"></li>
                        
                    
                </ul>
            
        </div>
        
    <div id="gitalk-container" class="comment link"
		data-enable="false"
        data-ae="false"
        data-ci=""
        data-cs=""
        data-r=""
        data-o=""
        data-a=""
        data-d="false"
    >查看评论</div>


    </div>
    
</div>


    </div>
</div>
</body>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>






</html>
