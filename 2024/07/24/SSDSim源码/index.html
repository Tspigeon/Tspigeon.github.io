

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="https://imgse.com/i/p9yX0tP">
  <link rel="icon" href="https://imgse.com/i/p9yX0tP">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Tspigeon">
  <meta name="keywords" content="">
  
    <meta name="description" content="解析SSDSim源码">
<meta property="og:type" content="article">
<meta property="og:title" content="SSDSim_code">
<meta property="og:url" content="http://yoursite.com/2024/07/24/SSDSim%E6%BA%90%E7%A0%81/index.html">
<meta property="og:site_name" content="Tspigeon &#39;s blog">
<meta property="og:description" content="解析SSDSim源码">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-07-23T16:00:00.000Z">
<meta property="article:modified_time" content="2024-10-11T11:32:31.579Z">
<meta property="article:author" content="Tspigeon">
<meta property="article:tag" content="SSD">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>SSDSim_code - Tspigeon &#39;s blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="//cdn.jsdelivr.net/gh/bynotes/texiao/source/css/toubudaziji.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"yoursite.com","root":"/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 100vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>No pigeon</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://s1.ax1x.com/2023/05/12/p9yX20s.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="SSDSim_code"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-07-24 00:00" pubdate>
          2024年7月24日 凌晨
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          81k 字
        
      </span>
    

    

    
    
  </div>


        
      </div>

      
        <div class="scroll-down-bar">
          <i class="iconfont icon-arrowdown"></i>
        </div>
      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">SSDSim_code</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="SSDSim-Code"><a href="#SSDSim-Code" class="headerlink" title="SSDSim_Code"></a>SSDSim_Code</h1><p>运行代码：切换WSL环境，执行<code>make clean</code>，执行<code>make all</code>，执行<code>./ssd 1 1 ./trace/hm_0.csv</code>，后面是trace文件路径</p>
<h2 id="WSL："><a href="#WSL：" class="headerlink" title="WSL："></a>WSL：</h2><h3 id="1-确保使用-WSL-远程环境"><a href="#1-确保使用-WSL-远程环境" class="headerlink" title="1. 确保使用 WSL 远程环境"></a>1. 确保使用 WSL 远程环境</h3><p>首先，确保你使用的是 <strong>WSL 远程环境</strong> 而不是 Windows 环境：</p>
<ul>
<li>启动 VS Code。</li>
<li>按 <code>Ctrl+Shift+P</code>，输入并选择 <code>Remote-WSL: New Window</code>。</li>
<li>在新的 WSL 远程窗口中，打开你的项目文件夹。</li>
</ul>
<h2 id="GBD："><a href="#GBD：" class="headerlink" title="GBD："></a>GBD：</h2><p>b设置断点：<code>b ssd.c:11</code></p>
<p>p打印变量</p>
<p>n下一步执行</p>
<h2 id="SSD："><a href="#SSD：" class="headerlink" title="SSD："></a>SSD：</h2><h3 id="main函数："><a href="#main函数：" class="headerlink" title="main函数："></a>main函数：</h3><p>输入参数设置：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Read parameters to the main function.\n&quot;</span>);<br><span class="hljs-built_in">sscanf</span>(argv[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;%d&quot;</span>, &amp;sTIMES);		<span class="hljs-comment">//把argv[1]转换为%d格式存入sTIMES</span><br><span class="hljs-built_in">sscanf</span>(argv[<span class="hljs-number">2</span>], <span class="hljs-string">&quot;%f&quot;</span>, &amp;speed_up);<br><span class="hljs-built_in">sscanf</span>(argv[<span class="hljs-number">3</span>], <span class="hljs-string">&quot;%s&quot;</span>, &amp;(ssd-&gt;tracefilename));<br><span class="hljs-comment">// sscanf(argv[4], &quot;%s&quot;, &amp;(ssd-&gt;tracefilename1));</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Running trace file: %s.\n&quot;</span>, ssd-&gt;tracefilename);<br><span class="hljs-built_in">sscanf</span>(argv[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;%s&quot;</span>, &amp;ssd-&gt;run_trace_times);<br></code></pre></td></tr></table></figure>

<p>第一个argv[1]是模拟次数一般是1，第二个参数argv[2]是请求速度，argv[3]是trace路径，argv[4]一般默认为1</p>
<p>然后主要是调用<code>simulate_mupltiple</code>函数，然后调用<code>statistic_output</code>函数输出数据到结果文件</p>
<h3 id="simulate-multiple函数："><a href="#simulate-multiple函数：" class="headerlink" title="simulate_multiple函数："></a>simulate_multiple函数：</h3><p>设置基本参数，读取trace文件，然后判断开不开缓存（不开缓存则进入no_buffer_distribute函数）然后是process函数和trace_output函数</p>
<p>执行完以上操作之后是</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-comment">// 如果 flag 的值为 0，并且请求队列（ssd-&gt;request_queue）为空，则将 flag 设为 100</span><br><span class="hljs-function"><span class="hljs-title">if</span>(flag == 0 &amp;&amp; ssd-&gt;</span>request_queue == NULL)<br>	flag = <span class="hljs-number">100</span>;<br><span class="hljs-function"><span class="hljs-title">if</span>(ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">completed_request_count</span> &gt; ((int)(ssd-&gt;</span>total_request_num/<span class="hljs-number">10000</span>))*<span class="hljs-number">10000</span>*(simulate_times+<span class="hljs-number">1</span>))&#123;  <span class="hljs-comment">//</span><br>	printf(<span class="hljs-string">&quot;It should be terminated.\n&quot;</span>);<br>	flag = <span class="hljs-number">100</span>;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>然后fclose关闭文件，模拟次数simulate_times++，然后返回SSD状态。</p>
<h3 id="no-buffer-distribute函数："><a href="#no-buffer-distribute函数：" class="headerlink" title="no_buffer_distribute函数："></a>no_buffer_distribute函数：</h3><p>不开缓存进行SSD运行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(req-&gt;operation==READ)<br>&#123;<br>	<span class="hljs-keyword">while</span>(lpn&lt;=last_lpn)<span class="hljs-comment">//为每一个逻辑页创建子请求</span><br>	&#123;<br>		sub_state=(ssd-&gt;dram-&gt;<span class="hljs-built_in">map</span>-&gt;map_entry[lpn].state&amp;<span class="hljs-number">0x7fffffff</span>);<br>		sub_size=size(sub_state); <span class="hljs-comment">//子请求大小（即子页数目）</span><br>		sub=creat_sub_request(ssd,lpn,sub_size,sub_state,req,req-&gt;operation,<span class="hljs-number">0</span>);<br>		lpn++;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>以上函数是为每一个逻辑页面的READ创建子请求</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(req-&gt;operation==WRITE) <span class="hljs-comment">//写请求</span><br>&#123;<br>    <span class="hljs-keyword">int</span> target_page_type;<br>    <span class="hljs-keyword">int</span> random_num;<br>    random_num = rand() % <span class="hljs-number">100</span>;<br>    <br>    <span class="hljs-comment">// 决定目标页类型，在TLC当中的不同地址段</span><br>    <span class="hljs-keyword">if</span>(random_num &lt; ssd-&gt;parameter-&gt;turbo_mode_factor)&#123;<br>        target_page_type = TARGET_LSB;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(random_num &lt; ssd-&gt;parameter-&gt;turbo_mode_factor_2)&#123;<br>        target_page_type = TARGET_CSB;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        target_page_type = TARGET_MSB;<br>    &#125;<br>    <br>    <span class="hljs-keyword">while</span>(lpn &lt;= last_lpn)<br>    &#123;<br>        <span class="hljs-comment">// 设置掩码</span><br>        <span class="hljs-keyword">if</span>(ssd-&gt;parameter-&gt;subpage_page == <span class="hljs-number">32</span>)&#123;<br>            mask = <span class="hljs-number">0xffffffff</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            mask = ~(<span class="hljs-number">0xffffffff</span> &lt;&lt; (ssd-&gt;parameter-&gt;subpage_page));<br>        &#125;<br>        <br>        state = mask;<br>        <br>        <span class="hljs-comment">// 如果是第一个逻辑页</span><br>        <span class="hljs-keyword">if</span>(lpn == first_lpn)<br>        &#123;<br>            offset1 = ssd-&gt;parameter-&gt;subpage_page - ((lpn + <span class="hljs-number">1</span>) * ssd-&gt;parameter-&gt;subpage_page - req-&gt;lsn);<br>            state = state &amp; (<span class="hljs-number">0xffffffff</span> &lt;&lt; offset1);<br>        &#125;<br>        <br>        <span class="hljs-comment">// 如果是最后一个逻辑页</span><br>        <span class="hljs-keyword">if</span>(lpn == last_lpn)<br>        &#123;<br>            offset2 = ssd-&gt;parameter-&gt;subpage_page - ((lpn + <span class="hljs-number">1</span>) * ssd-&gt;parameter-&gt;subpage_page - (req-&gt;lsn + req-&gt;size));<br>            <span class="hljs-keyword">if</span>(offset2 != <span class="hljs-number">32</span>)&#123;<br>                state = state &amp; (~(<span class="hljs-number">0xffffffff</span> &lt;&lt; offset2));<br>            &#125;<br>        &#125;<br>        <br>        sub_size = size(state); <span class="hljs-comment">// 根据掩码状态计算子请求大小</span><br>        sub = creat_sub_request(ssd, lpn, sub_size, state, req, req-&gt;operation, target_page_type);<br>        lpn++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这段代码处理写请求，代码会根据不同的策略决定目标页类型，然后为每个逻辑页号创建子请求。</p>
<p>在掩码部分：</p>
<p><strong><code>if(ssd-&gt;parameter-&gt;subpage_page == 32)</code></strong>:</p>
<ul>
<li>检查SSD参数中的<code>subpage_page</code>是否等于32。如果是，说明一个逻辑页包含32个子页。</li>
<li>在这种情况下，掩码（mask）被设置为<code>0xffffffff</code>，即32位全1。这表示整个逻辑页内的所有子页都是有效的。</li>
</ul>
<p><strong><code>else</code></strong>:</p>
<ul>
<li><p>如果<code>subpage_page</code>不是32，说明一个逻辑页包含的子页数少于32。</p>
</li>
<li><p>在这种情况下，掩码（mask）通过以下步骤计算：</p>
<ul>
<li><p>首先，将<code>0xffffffff</code>左移<code>subpage_page</code>位，然后取反（按位非运算）。</p>
</li>
<li><p>例如，如果</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">subpage_page</span><br></code></pre></td></tr></table></figure>

<p>是16，那么：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">c复制代码<span class="hljs-number">0xffffffff</span> &lt;&lt; <span class="hljs-number">16</span> = <span class="hljs-number">0xffff0000</span><span class="hljs-comment">;</span><br>~<span class="hljs-number">0xffff0000</span> = <span class="hljs-number">0x0000ffff</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li>
<li><p>结果是一个掩码，其中低<code>subpage_page</code>位为1，高位为0。这表示逻辑页内只有低位的子页是有效的。</p>
</li>
</ul>
</li>
</ul>
<p>在逻辑页地址部分：</p>
<p>**计算<code>offset1</code>**：</p>
<ul>
<li><code>offset1 = ssd-&gt;parameter-&gt;subpage_page - ((lpn + 1) * ssd-&gt;parameter-&gt;subpage_page - req-&gt;lsn);</code></li>
<li><code>ssd-&gt;parameter-&gt;subpage_page</code>：表示每个逻辑页内的子页数。</li>
<li><code>(lpn + 1) * ssd-&gt;parameter-&gt;subpage_page</code>：计算到当前逻辑页末尾的子页位置。</li>
<li><code>req-&gt;lsn</code>：请求的起始逻辑扇区号。</li>
<li>通过以上计算，<code>offset1</code>表示从当前逻辑页起始位置到请求起始位置之间的子页数。</li>
</ul>
<p>**调整<code>state</code>**：</p>
<ul>
<li><code>state = state &amp; (0xffffffff &lt;&lt; offset1);</code></li>
<li><code>0xffffffff &lt;&lt; offset1</code>：将全1的掩码左移<code>offset1</code>位，生成一个掩码，表示从请求起始位置到逻辑页末尾的子页。</li>
<li><code>state &amp; (0xffffffff &lt;&lt; offset1)</code>：通过按位与操作，调整<code>state</code>，使其仅包含从请求起始位置开始的有效子页。</li>
</ul>
<h3 id="trace-output函数："><a href="#trace-output函数：" class="headerlink" title="trace_output函数："></a>trace_output函数：</h3><p>trace_output()函数是在每一条请求的所有子请求经过process()函数处理完后，打印输出相关的运行结果到outputfile文件中，这里的结果主要是运行的时间,该函数对SSD的请求队列中的每个请求进行处理，检查请求是否已完成，如果已完成，则输出请求的相关信息并进行统计工作。对于未完成的请求，函数会检查所有子请求是否已完成，如果是，则输出请求信息并进行统计。该函数用于在SSD仿真运行结束后输出处理结果和统计数据，以便后续分析和评估性能。</p>
<p>首先进行写请求基本信息：</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">fprintf</span>(ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">outputfile</span>,&quot;%16lld %10d %6d %2d %16lld %16lld %10lld\n&quot;,req-&gt;</span><span class="hljs-function"><span class="hljs-title">time</span>,req-&gt;</span><span class="hljs-function"><span class="hljs-title">lsn</span>, req-&gt;</span><span class="hljs-function"><span class="hljs-title">size</span>, req-&gt;</span><span class="hljs-function"><span class="hljs-title">operation</span>, req-&gt;</span><span class="hljs-function"><span class="hljs-title">begin_time</span>, req-&gt;</span><span class="hljs-function"><span class="hljs-title">response_time</span>, req-&gt;</span><span class="hljs-function"><span class="hljs-title">response_time</span>-req-&gt;</span><span class="hljs-built_in">time</span>);<br><span class="hljs-function"><span class="hljs-title">fflush</span>(ssd-&gt;</span>outputfile);<br><span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span>completed_request_count++;<br></code></pre></td></tr></table></figure>

<p>然后按照天数进行模拟，进行多天的模拟</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">if</span>(this_day&gt;ssd-&gt;</span>time_day)&#123;<br>	printf(<span class="hljs-string">&quot;Day %d begin......\n&quot;</span>, this_day);<br>	<span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span>time_day = this_day;<br>	<span class="hljs-function"><span class="hljs-title">if</span>((ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">dr_switch</span>==1)&amp;&amp;(this_day%ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span>dr_cycle==<span class="hljs-number">0</span>))&#123;<br>		<span class="hljs-function"><span class="hljs-title">for</span>(channel=0;channel&lt;ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span>channel_number;channel++)&#123;<br>			dr_for_channel(ssd, channel);<br>			&#125;<br>		&#125;<br>	&#125;<br></code></pre></td></tr></table></figure>



<h3 id="statistic-output函数："><a href="#statistic-output函数：" class="headerlink" title="statistic_output函数："></a>statistic_output函数：</h3><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">for</span> (i = 0; i &lt; ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span>channel_number; i++) &#123;  <span class="hljs-comment">// 遍历所有通道</span><br>    <span class="hljs-function"><span class="hljs-title">for</span> (j = 0; j &lt; ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span>chip_channel[<span class="hljs-number">0</span>]; j++) &#123;  <span class="hljs-comment">// 遍历每个通道中的所有芯片</span><br>        <span class="hljs-function"><span class="hljs-title">for</span> (k = 0; k &lt; ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span>die_chip; k++) &#123;  <span class="hljs-comment">// 遍历每个芯片中的所有die</span><br>            <span class="hljs-function"><span class="hljs-title">for</span> (p = 0; p &lt; ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span>plane_die; p++) &#123;  <span class="hljs-comment">// 遍历每个die中的所有plane</span><br>                plane_erase = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 初始化当前plane的擦除计数</span><br>                <span class="hljs-function"><span class="hljs-title">for</span> (m = 0; m &lt; ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span>block_plane; m++) &#123;  <span class="hljs-comment">// 遍历每个plane中的所有block</span><br>                    <span class="hljs-function"><span class="hljs-title">if</span> (ssd-&gt;</span>channel_head[i].chip_head[j].die_head[k].plane_head[p].blk_head[m].erase_count &gt; <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 如果当前block的擦除计数大于0</span><br>                        <span class="hljs-function"><span class="hljs-title">erase</span> += ssd-&gt;</span>channel_head[i].chip_head[j].die_head[k].plane_head[p].blk_head[m].erase_count;  <span class="hljs-comment">// 累加总擦除计数</span><br>                        <span class="hljs-function"><span class="hljs-title">plane_erase</span> += ssd-&gt;</span>channel_head[i].chip_head[j].die_head[k].plane_head[p].blk_head[m].erase_count;  <span class="hljs-comment">// 累加当前plane的擦除计数</span><br>                    &#125;<br>                &#125;<br>                <span class="hljs-comment">// 输出当前plane的擦除计数到文件</span><br>                <span class="hljs-function"><span class="hljs-title">fprintf</span>(ssd-&gt;</span>outputfile, <span class="hljs-string">&quot;the %d channel, %d chip, %d die, %d plane has : %13d erase operations\n&quot;</span>, i, j, k, p, plane_erase);<br>                <span class="hljs-function"><span class="hljs-title">fprintf</span>(ssd-&gt;</span>statisticfile, <span class="hljs-string">&quot;the %d channel, %d chip, %d die, %d plane has : %13d erase operations\n&quot;</span>, i, j, k, p, plane_erase);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这段代码的主要功能是：</p>
<ul>
<li><strong>遍历所有通道、芯片、die和plane</strong>：对SSD的所有层次结构进行遍历。</li>
<li><strong>统计每个plane的擦除操作次数</strong>：计算每个plane中的擦除操作次数，并累加到总擦除计数。</li>
<li><strong>输出擦除操作次数</strong>：将每个plane的擦除操作次数输出到两个文件中（<code>outputfile</code>和<code>statisticfile</code>）。</li>
</ul>
<p>然后进行输出内容到文件当中</p>
<h2 id="flash："><a href="#flash：" class="headerlink" title="flash："></a>flash：</h2><h3 id="process函数："><a href="#process函数：" class="headerlink" title="process函数："></a>process函数：</h3><p>请求处理函数，代码首先判断了是否有读写子请求，没有读写操作时才可以进行GC操作</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">for</span>(i=0;i&lt;ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span>channel_number;i++)  <span class="hljs-comment">//判断所有channel中是否有读或写的子请求</span><br>&#123;<br>	<span class="hljs-function"><span class="hljs-title">if</span>((ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[i].subs_r_head==NULL)&amp;&amp;(ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[i].subs_w_head==NULL)&amp;&amp;(ssd-&gt;</span>subs_w_head==NULL))<br>	&#123;<br>		flag=<span class="hljs-number">1</span>;  <span class="hljs-comment">//没有</span><br>	&#125;<br>	<span class="hljs-keyword">else</span><br>	&#123;<br>		flag=<span class="hljs-number">0</span>;  <span class="hljs-comment">//有</span><br>		break;<br>	&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(flag==<span class="hljs-number">1</span>)<span class="hljs-comment">//没有读写子请求，代表是空闲时间段，可进行GC</span><br>&#123;<br>	<span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span>flag=<span class="hljs-number">1</span>;<br>	<span class="hljs-function"><span class="hljs-title">if</span> (ssd-&gt;</span>gc_request&gt;<span class="hljs-number">0</span>) <span class="hljs-comment">/*SSD中有gc操作的请求*/</span><br>	&#123;<br>		gc(ssd,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);     <span class="hljs-comment">/*这个gc要求所有channel都必须遍历到*/</span><br>	&#125;<br>	return ssd;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>	<span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span>flag=<span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>然后SSD开始处理读写请求，主要是判断各个channel有没有在做GC，如果在做GC就跳过该channel</p>
<p>然后再判断该channel有没有读写子请求，有则进行处理</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">if</span>(debug_0918)&#123;<br>	<span class="hljs-selector-tag">printf</span>(<span class="hljs-string">&quot;completed requests: %d\n&quot;</span>, ssd-&gt;completed_request_count);<br>	&#125;<br><br><span class="hljs-selector-tag">if</span>(req-&gt;response_time-req-&gt;begin_time==<span class="hljs-number">0</span>)<br>&#123;<br>	<span class="hljs-selector-tag">printf</span>(<span class="hljs-string">&quot;the response time is 0?? \n&quot;</span>);<br>	<span class="hljs-selector-tag">getchar</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>以上函数进行了<code>debug_0981</code>的判断和<code>响应时间</code>为0的异常判断</p>
<p>然后以下函数进行了读写请求的分别处理，并对写请求的写入子页位置进行了判断</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">if</span> (req-&gt;</span>operation == READ) &#123;  <span class="hljs-comment">// 如果请求类型为读</span><br>    <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span>read_request_count++;  <span class="hljs-comment">// 增加读请求计数</span><br>    <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">read_avg</span> = ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">read_avg</span> + (req-&gt;</span><span class="hljs-function"><span class="hljs-title">response_time</span> - req-&gt;</span><span class="hljs-built_in">time</span>);  <span class="hljs-comment">// 更新读请求的平均响应时间</span><br>    <span class="hljs-comment">//===========================================</span><br>    <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span>newest_read_request_count++;  <span class="hljs-comment">// 增加最新的读请求计数</span><br>    <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">newest_read_avg</span> = ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">newest_read_avg</span> + (end_time - req-&gt;</span><span class="hljs-built_in">time</span>);  <span class="hljs-comment">// 更新最新的读请求平均响应时间</span><br>    <span class="hljs-comment">//===========================================</span><br>&#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 如果请求类型为写</span><br>    <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span>write_request_count++;  <span class="hljs-comment">// 增加写请求计数</span><br>    <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">write_avg</span> = ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">write_avg</span> + (req-&gt;</span><span class="hljs-function"><span class="hljs-title">response_time</span> - req-&gt;</span><span class="hljs-built_in">time</span>);  <span class="hljs-comment">// 更新写请求的平均响应时间</span><br>    <span class="hljs-comment">//===========================================</span><br>    <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span>newest_write_request_count++;  <span class="hljs-comment">// 增加最新的写请求计数</span><br>    <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">newest_write_avg</span> = ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">newest_write_avg</span> + (end_time - req-&gt;</span><span class="hljs-built_in">time</span>);  <span class="hljs-comment">// 更新最新的写请求平均响应时间</span><br>    <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">last_write_lat</span> = end_time - req-&gt;</span><span class="hljs-built_in">time</span>;  <span class="hljs-comment">// 记录最新写请求的延迟时间</span><br>    <span class="hljs-comment">//--------------------------------------------</span><br>    int new_flag = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 标志变量，用于判断子请求的页类型是否一致（LSB。。。）</span><br>    int origin;  <span class="hljs-comment">// 存储第一个子请求的页类型</span><br>    struct sub_request *next_sub_a;  <span class="hljs-comment">// 子请求指针</span><br>    <span class="hljs-function"><span class="hljs-title">next_sub_a</span> = req-&gt;</span>subs;  <span class="hljs-comment">// 获取第一个子请求</span><br>    <span class="hljs-function"><span class="hljs-title">origin</span> = next_sub_a-&gt;</span>allocated_page_type;  <span class="hljs-comment">// 记录第一个子请求的页类型</span><br>    <span class="hljs-function"><span class="hljs-title">next_sub_a</span> = next_sub_a-&gt;</span>next_subs;  <span class="hljs-comment">// 获取下一个子请求</span><br>    <span class="hljs-keyword">while</span> (next_sub_a != NULL) &#123;  <span class="hljs-comment">// 遍历所有子请求</span><br>        <span class="hljs-function"><span class="hljs-title">if</span> (next_sub_a-&gt;</span>allocated_page_type != origin) &#123;  <span class="hljs-comment">// 如果子请求的页类型与第一个子请求不同</span><br>            new_flag = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 标志置为0，表示不一致</span><br>            break;  <span class="hljs-comment">// 退出循环</span><br>        &#125;<br>        <span class="hljs-function"><span class="hljs-title">next_sub_a</span> = next_sub_a-&gt;</span>next_subs;  <span class="hljs-comment">// 获取下一个子请求</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (new_flag == <span class="hljs-number">1</span>) &#123;  <span class="hljs-comment">// 如果所有子请求的页类型一致</span><br>        <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span>newest_write_request_completed_with_same_type_pages++;  <span class="hljs-comment">// 增加一致类型的写请求计数</span><br>        <span class="hljs-keyword">if</span> (origin == <span class="hljs-number">1</span>) &#123;  <span class="hljs-comment">// 如果页类型为MSB</span><br>            <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span>newest_msb_request_a++;  <span class="hljs-comment">// 增加MSB类型写请求计数</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 否则为LSB类型</span><br>            <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span>newest_lsb_request_a++;  <span class="hljs-comment">// 增加LSB类型写请求计数</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>以下代码用于处理和移除SSD请求队列中的请求节点。它根据当前节点的位置（是否是队列的头节点或尾节点）来调整队列结构并释放内存。</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-keyword">if</span> (pre_node == NULL) &#123;  <span class="hljs-comment">// 如果前一个节点为空，即当前节点是队列头节点</span><br>    <span class="hljs-function"><span class="hljs-title">if</span> (req-&gt;</span>next_node == NULL) &#123;  <span class="hljs-comment">// 如果当前节点的下一个节点为空，即队列中只有一个节点</span><br>        <span class="hljs-function"><span class="hljs-title">free</span>(req-&gt;</span>need_distr_flag);  <span class="hljs-comment">// 释放need_distr_flag的内存</span><br>        <span class="hljs-function"><span class="hljs-title">req</span>-&gt;</span>need_distr_flag = NULL;  <span class="hljs-comment">// 将指针置为空</span><br>        free(req);  <span class="hljs-comment">// 释放当前请求节点的内存</span><br>        req = NULL;  <span class="hljs-comment">// 将指针置为空</span><br>        <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span>request_queue = NULL;  <span class="hljs-comment">// 将队列头置为空</span><br>        <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span>request_tail = NULL;  <span class="hljs-comment">// 将队列尾置为空</span><br>        <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span>request_queue_length--;  <span class="hljs-comment">// 减少队列长度</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 如果队列中有多个节点</span><br>        <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">request_queue</span> = req-&gt;</span>next_node;  <span class="hljs-comment">// 将队列头指向下一个节点</span><br>        pre_node = req;  <span class="hljs-comment">// 暂存当前节点</span><br>        <span class="hljs-function"><span class="hljs-title">req</span> = req-&gt;</span>next_node;  <span class="hljs-comment">// 移动到下一个节点</span><br>        <span class="hljs-function"><span class="hljs-title">free</span>(pre_node-&gt;</span>need_distr_flag);  <span class="hljs-comment">// 释放当前节点的need_distr_flag内存</span><br>        <span class="hljs-function"><span class="hljs-title">pre_node</span>-&gt;</span>need_distr_flag = NULL;  <span class="hljs-comment">// 将指针置为空</span><br>        free((void *)pre_node);  <span class="hljs-comment">// 释放当前节点的内存</span><br>        pre_node = NULL;  <span class="hljs-comment">// 将指针置为空</span><br>        <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span>request_queue_length--;  <span class="hljs-comment">// 减少队列长度</span><br>    &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 如果前一个节点不为空，即当前节点不是队列头节点</span><br>    <span class="hljs-function"><span class="hljs-title">if</span> (req-&gt;</span>next_node == NULL) &#123;  <span class="hljs-comment">// 如果当前节点的下一个节点为空，即当前节点是队列尾节点</span><br>        <span class="hljs-function"><span class="hljs-title">pre_node</span>-&gt;</span>next_node = NULL;  <span class="hljs-comment">// 将前一个节点的next_node置为空</span><br>        <span class="hljs-function"><span class="hljs-title">free</span>(req-&gt;</span>need_distr_flag);  <span class="hljs-comment">// 释放need_distr_flag的内存</span><br>        <span class="hljs-function"><span class="hljs-title">req</span>-&gt;</span>need_distr_flag = NULL;  <span class="hljs-comment">// 将指针置为空</span><br>        free(req);  <span class="hljs-comment">// 释放当前请求节点的内存</span><br>        req = NULL;  <span class="hljs-comment">// 将指针置为空</span><br>        <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span>request_tail = pre_node;  <span class="hljs-comment">// 将队列尾指向前一个节点</span><br>        <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span>request_queue_length--;  <span class="hljs-comment">// 减少队列长度</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 如果当前节点既不是头节点也不是尾节点</span><br>        <span class="hljs-function"><span class="hljs-title">pre_node</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">next_node</span> = req-&gt;</span>next_node;  <span class="hljs-comment">// 将前一个节点的next_node指向当前节点的下一个节点</span><br>        <span class="hljs-function"><span class="hljs-title">free</span>(req-&gt;</span>need_distr_flag);  <span class="hljs-comment">// 释放need_distr_flag的内存</span><br>        <span class="hljs-function"><span class="hljs-title">req</span>-&gt;</span>need_distr_flag = NULL;  <span class="hljs-comment">// 将指针置为空</span><br>        free((void *)req);  <span class="hljs-comment">// 释放当前请求节点的内存</span><br>        <span class="hljs-function"><span class="hljs-title">req</span> = pre_node-&gt;</span>next_node;  <span class="hljs-comment">// 将当前请求节点指向下一个节点</span><br>        <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span>request_queue_length--;  <span class="hljs-comment">// 减少队列长度</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>以上是response时间不等于0的情况，下面要处理的是response time等于0的情况</p>
<p>首先以下代码用于遍历请求的子请求链表，检查子请求的状态，确定整个请求的开始时间和完成时间，并判断请求是否完成。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">while</span> (<span class="hljs-function"><span class="hljs-keyword">sub</span> != <span class="hljs-title">NULL</span>) </span>&#123;  // 遍历所有子请求<br>    <span class="hljs-keyword">if</span> (start_time == <span class="hljs-number">0</span>)  // 初始化开始时间<br>        start_time = <span class="hljs-function"><span class="hljs-keyword">sub</span>-&gt;<span class="hljs-title">begin_time</span></span>;<br>    <span class="hljs-keyword">if</span> (start_time &gt; <span class="hljs-function"><span class="hljs-keyword">sub</span>-&gt;<span class="hljs-title">begin_time</span>)  // 更新开始时间，取最早的子请求开始时间</span><br><span class="hljs-function">        <span class="hljs-title">start_time</span> = <span class="hljs-title">sub</span>-&gt;<span class="hljs-title">begin_time</span></span>;<br>    <span class="hljs-keyword">if</span> (end_time &lt; <span class="hljs-function"><span class="hljs-keyword">sub</span>-&gt;<span class="hljs-title">complete_time</span>)  // 更新完成时间，取最晚的子请求完成时间</span><br><span class="hljs-function">        <span class="hljs-title">end_time</span> = <span class="hljs-title">sub</span>-&gt;<span class="hljs-title">complete_time</span></span>;<br>    // 如果子请求已经完成，或下一个状态是完成且预测完成时间小于等于当前时间<br>    <span class="hljs-keyword">if</span> ((<span class="hljs-function"><span class="hljs-keyword">sub</span>-&gt;<span class="hljs-title">current_state</span> == <span class="hljs-title">SR_COMPLETE</span>) || ((<span class="hljs-title">sub</span>-&gt;<span class="hljs-title">next_state</span> == <span class="hljs-title">SR_COMPLETE</span>) &amp;&amp; (<span class="hljs-title">sub</span>-&gt;<span class="hljs-title">next_state_predict_time</span> &lt;= <span class="hljs-title">ssd</span>-&gt;<span class="hljs-title">current_time</span>))) </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">sub</span> = <span class="hljs-title">sub</span>-&gt;<span class="hljs-title">next_subs</span></span>;  // 移动到下一个子请求<br>    &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-regexp">//</span> 如果有任意一个子请求未完成<br>        flag = <span class="hljs-number">0</span>;  <span class="hljs-regexp">//</span> 标记请求未完成<br>        <span class="hljs-keyword">break</span>;  <span class="hljs-regexp">//</span> 退出循环<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>剩下的代码与response time不为0的类似，以下是两者不同的部分</p>
<p>以下这段代码用于遍历和释放请求（<code>req</code>）的所有子请求（<code>subs</code>），并释放与每个子请求相关的资源。</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">while</span> (req-&gt;</span>subs != NULL) &#123;  <span class="hljs-comment">// 遍历所有子请求</span><br>    <span class="hljs-function"><span class="hljs-title">tmp</span> = req-&gt;</span>subs;  <span class="hljs-comment">// 暂存当前子请求</span><br>    <span class="hljs-function"><span class="hljs-title">req</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">subs</span> = tmp-&gt;</span>next_subs;  <span class="hljs-comment">// 移动到下一个子请求</span><br>    <br>    <span class="hljs-function"><span class="hljs-title">if</span> (tmp-&gt;</span>update != NULL) &#123;  <span class="hljs-comment">// 如果子请求有更新结构</span><br>        <span class="hljs-function"><span class="hljs-title">free</span>(tmp-&gt;</span><span class="hljs-function"><span class="hljs-title">update</span>-&gt;</span>location);  <span class="hljs-comment">// 释放更新结构中的location内存</span><br>        <span class="hljs-function"><span class="hljs-title">tmp</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">update</span>-&gt;</span>location = NULL;  <span class="hljs-comment">// 将location指针置为空</span><br>        <span class="hljs-function"><span class="hljs-title">free</span>(tmp-&gt;</span>update);  <span class="hljs-comment">// 释放更新结构内存</span><br>        <span class="hljs-function"><span class="hljs-title">tmp</span>-&gt;</span>update = NULL;  <span class="hljs-comment">// 将update指针置为空</span><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-title">free</span>(tmp-&gt;</span>location);  <span class="hljs-comment">// 释放子请求中的location内存</span><br>    <span class="hljs-function"><span class="hljs-title">tmp</span>-&gt;</span>location = NULL;  <span class="hljs-comment">// 将location指针置为空</span><br>    free(tmp);  <span class="hljs-comment">// 释放当前子请求的内存</span><br>    tmp = NULL;  <span class="hljs-comment">// 将tmp指针置为空</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="services-2-r-cmd-trans-and-complete函数："><a href="#services-2-r-cmd-trans-and-complete函数：" class="headerlink" title="services_2_r_cmd_trans_and_complete函数："></a>services_2_r_cmd_trans_and_complete函数：</h3><p>被process函数调用，专门为读子请求服务的函数</p>
<p><strong>遍历所有channel</strong>：对于每个channel，检查其读请求队列中的子请求。</p>
<p><strong>处理命令地址传输状态</strong>：如果子请求当前处于命令地址传输状态，并且命令已传输完成（预测时间 &lt;= 当前时间），则将子请求状态更新为”读状态”。</p>
<p><strong>处理请求完成</strong>：如果子请求已完成，或者即将完成（预测完成时间 &lt;= 当前时间），则将其从队列中删除。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs perl">Status services_2_r_cmd_trans_and_complete(struct ssd_info * ssd)<br>&#123;<br>    unsigned <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    struct sub_request * <span class="hljs-function"><span class="hljs-keyword">sub</span> = <span class="hljs-title">NULL</span>, * <span class="hljs-title">p</span> = <span class="hljs-title">NULL</span></span>;  // <span class="hljs-function"><span class="hljs-keyword">sub</span>是当前处理的子请求，<span class="hljs-title">p</span>是前一个子请求节点</span><br><span class="hljs-function"></span><br><span class="hljs-function">    // 遍历每个<span class="hljs-title">channel</span>，处理不需要<span class="hljs-title">channel</span>时间的情况（读命令已经到达芯片，芯片由<span class="hljs-title">ready</span>变为<span class="hljs-title">busy</span>）</span><br><span class="hljs-function">    <span class="hljs-title">for</span> (<span class="hljs-title">i</span> = 0</span>; i &lt; ssd-&gt;parameter-&gt;channel_number; i++) <br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">sub</span> = <span class="hljs-title">ssd</span>-&gt;<span class="hljs-title">channel_head</span>[<span class="hljs-title">i</span>].<span class="hljs-title">subs_r_head</span></span>;  // 获取当前channel的读请求队列的第一个子请求<br><br>        // 遍历当前channel的子请求链表，处理每个读请求<br>        <span class="hljs-keyword">while</span> (<span class="hljs-function"><span class="hljs-keyword">sub</span> != <span class="hljs-title">NULL</span>) </span><br><span class="hljs-function">        </span>&#123;<br>            // 如果当前子请求处于命令地址传输状态<br>            <span class="hljs-keyword">if</span> (<span class="hljs-function"><span class="hljs-keyword">sub</span>-&gt;<span class="hljs-title">current_state</span> == <span class="hljs-title">SR_R_C_A_TRANSFER</span>) </span><br><span class="hljs-function">            </span>&#123;<br>                // 如果子请求的下一状态预计时间小于等于当前时间，说明命令传输已完成<br>                <span class="hljs-keyword">if</span> (<span class="hljs-function"><span class="hljs-keyword">sub</span>-&gt;<span class="hljs-title">next_state_predict_time</span> &lt;= <span class="hljs-title">ssd</span>-&gt;<span class="hljs-title">current_time</span>)</span><br><span class="hljs-function">                </span>&#123;<br>                    // 将子请求状态从<span class="hljs-string">&quot;命令地址传输状态&quot;</span>更新为<span class="hljs-string">&quot;读状态&quot;</span><br>                    go_one_step(ssd, <span class="hljs-function"><span class="hljs-keyword">sub</span>, <span class="hljs-title">NULL</span>, <span class="hljs-title">SR_R_READ</span>, <span class="hljs-title">NORMAL</span>)</span>;  // 状态跳变函数<br>                &#125;<br>            &#125;<br>            // 如果子请求当前状态已经完成或即将完成<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((<span class="hljs-function"><span class="hljs-keyword">sub</span>-&gt;<span class="hljs-title">current_state</span> == <span class="hljs-title">SR_COMPLETE</span>) || </span><br><span class="hljs-function">                     ((<span class="hljs-title">sub</span>-&gt;<span class="hljs-title">next_state</span> == <span class="hljs-title">SR_COMPLETE</span>) &amp;&amp; (<span class="hljs-title">sub</span>-&gt;<span class="hljs-title">next_state_predict_time</span> &lt;= <span class="hljs-title">ssd</span>-&gt;<span class="hljs-title">current_time</span>)))</span><br><span class="hljs-function">            </span>&#123;<br>                // 如果当前完成的子请求不是队列头，调整链表以删除它<br>                <span class="hljs-keyword">if</span> (<span class="hljs-function"><span class="hljs-keyword">sub</span> != <span class="hljs-title">ssd</span>-&gt;<span class="hljs-title">channel_head</span>[<span class="hljs-title">i</span>].<span class="hljs-title">subs_r_head</span>) </span><br><span class="hljs-function">                </span>&#123;<br>                    p-&gt;next_node = <span class="hljs-function"><span class="hljs-keyword">sub</span>-&gt;<span class="hljs-title">next_node</span></span>;  // 将前一个节点p的<span class="hljs-keyword">next</span>指向当前节点<span class="hljs-function"><span class="hljs-keyword">sub</span>的下一个节点</span><br><span class="hljs-function">                &#125;</span><br><span class="hljs-function">                <span class="hljs-title">else</span>  // 当前完成的子请求是队列头</span><br><span class="hljs-function">                </span>&#123;<br>                    <span class="hljs-keyword">if</span> (ssd-&gt;channel_head[i].subs_r_head != ssd-&gt;channel_head[i].subs_r_tail) <br>                    &#123;<br>                        ssd-&gt;channel_head[i].subs_r_head = <span class="hljs-function"><span class="hljs-keyword">sub</span>-&gt;<span class="hljs-title">next_node</span></span>;  // 更新队列头为下一个子请求<br>                    &#125;<br>                    <span class="hljs-keyword">else</span>  // 如果队列中只有一个请求，清空队列<br>                    &#123;<br>                        ssd-&gt;channel_head[i].subs_r_head = NULL;<br>                        ssd-&gt;channel_head[i].subs_r_tail = NULL;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            p = <span class="hljs-function"><span class="hljs-keyword">sub</span></span>;  // 更新p为当前节点<span class="hljs-function"><span class="hljs-keyword">sub</span></span><br><span class="hljs-function">            <span class="hljs-title">sub</span> = <span class="hljs-title">sub</span>-&gt;<span class="hljs-title">next_node</span></span>;  // 继续处理下一个子请求<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> SUCCESS;  <span class="hljs-regexp">//</span> 返回成功状态<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="services-2-r-wait函数："><a href="#services-2-r-wait函数：" class="headerlink" title="services_2_r_wait函数："></a>services_2_r_wait函数：</h3><p>该函数被process调用，该函数通过检查SSD的读子请求队列，并根据是否支持<strong>两平面读命令（Two-Plane Read）和交错读命令（Interleave Read）</strong>，决定是否可以同时服务多个子请求。</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs xl">int services_2_r_wait(struct ssd_info * ssd,unsigned int channel,unsigned int * channel_busy_flag, unsigned int * change_current_time_flag)<br>&#123;<br>    unsigned int plane=<span class="hljs-number">0</span>, address_ppn=<span class="hljs-number">0</span>;<br>    struct sub_request * sub=NULL, * p=NULL;<br>    struct sub_request * sub_twoplane_one=NULL, * sub_twoplane_two=NULL;<br>    struct sub_request * sub_interleave_one=NULL, * sub_interleave_two=NULL;<br><br>    <span class="hljs-comment">// 获取该通道上的读子请求队列的头部</span><br>    <span class="hljs-function"><span class="hljs-title">sub</span> = ssd-&gt;</span>channel_head[channel].subs_r_head;<br><br>    <span class="hljs-comment">// 如果支持TWOPLANE读命令，寻找能执行two-plane操作的两个子请求</span><br>    <span class="hljs-function"><span class="hljs-title">if</span> ((ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span>advanced_commands &amp; AD_TWOPLANE_READ) == AD_TWOPLANE_READ) &#123;<br>        sub_twoplane_one = NULL;<br>        sub_twoplane_two = NULL;<br><br>        <span class="hljs-comment">// 查找适合执行two-plane读操作的两个子请求</span><br>        find_interleave_twoplane_sub_request(ssd, channel, sub_twoplane_one, sub_twoplane_two, TWO_PLANE);<br><br>        <span class="hljs-comment">// 如果找到两个可以执行two-plane读操作的子请求</span><br>        <span class="hljs-keyword">if</span> (sub_twoplane_two != NULL) &#123;<br>            <span class="hljs-comment">// 执行two-plane读操作</span><br>            go_one_step(ssd, sub_twoplane_one, sub_twoplane_two, SR_R_C_A_TRANSFER, TWO_PLANE);<br><br>            *change_current_time_flag = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 不需要更改当前时间</span><br>            *channel_busy_flag = <span class="hljs-number">1</span>;         <span class="hljs-comment">// 标记通道为忙碌状态，因为本周期已经占用了总线</span><br>        &#125; <br>        <span class="hljs-comment">// 如果没有找到满足条件的两个页，并且不支持INTERLEAVE操作，则只能执行单个page的读操作</span><br>        <span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span> ((ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span>advanced_commands &amp; AD_INTERLEAVE) != AD_INTERLEAVE) &#123;<br>            <span class="hljs-keyword">while</span> (sub != NULL) &#123;  <span class="hljs-comment">// 遍历读子请求队列</span><br>                <span class="hljs-function"><span class="hljs-title">if</span> (sub-&gt;</span>current_state == SR_WAIT) &#123;  <br>                    <span class="hljs-comment">// 判断目标die是否处于空闲状态，才能执行读操作</span><br>                    <span class="hljs-function"><span class="hljs-title">if</span> ((ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[sub-&gt;</span><span class="hljs-function"><span class="hljs-title">location</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">channel</span>].chip_head[sub-&gt;</span><span class="hljs-function"><span class="hljs-title">location</span>-&gt;</span>chip].current_state == CHIP_IDLE) || <br>                        ((<span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[sub-&gt;</span><span class="hljs-function"><span class="hljs-title">location</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">channel</span>].chip_head[sub-&gt;</span><span class="hljs-function"><span class="hljs-title">location</span>-&gt;</span>chip].next_state == CHIP_IDLE) &amp;&amp;<br>                        (<span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[sub-&gt;</span><span class="hljs-function"><span class="hljs-title">location</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">channel</span>].chip_head[sub-&gt;</span><span class="hljs-function"><span class="hljs-title">location</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">chip</span>].next_state_predict_time &lt;= ssd-&gt;</span>current_time))) &#123;<br><br>                        <span class="hljs-comment">// 执行单个子请求的读操作</span><br>                        go_one_step(ssd, sub, NULL, SR_R_C_A_TRANSFER, NORMAL);<br><br>                        *change_current_time_flag = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 不需要更改当前时间</span><br>                        *channel_busy_flag = <span class="hljs-number">1</span>;         <span class="hljs-comment">// 标记通道为忙碌状态</span><br>                        break;<br>                    &#125; <br>                &#125;<br>                <span class="hljs-function"><span class="hljs-title">sub</span> = sub-&gt;</span>next_node;  <span class="hljs-comment">// 移动到下一个子请求</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果支持INTERLEAVE读命令，寻找能执行INTERLEAVE操作的两个子请求</span><br>    <span class="hljs-function"><span class="hljs-title">if</span> ((ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span>advanced_commands &amp; AD_INTERLEAVE) == AD_INTERLEAVE) &#123;<br>        sub_interleave_one = NULL;<br>        sub_interleave_two = NULL;<br><br>        <span class="hljs-comment">// 查找适合执行INTERLEAVE读操作的两个子请求</span><br>        find_interleave_twoplane_sub_request(ssd, channel, sub_interleave_one, sub_interleave_two, INTERLEAVE);<br><br>        <span class="hljs-comment">// 如果找到两个可以执行INTERLEAVE读操作的子请求</span><br>        <span class="hljs-keyword">if</span> (sub_interleave_two != NULL) &#123;<br>            <span class="hljs-comment">// 执行INTERLEAVE读操作</span><br>            go_one_step(ssd, sub_interleave_one, sub_interleave_two, SR_R_C_A_TRANSFER, INTERLEAVE);<br><br>            *change_current_time_flag = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 不需要更改当前时间</span><br>            *channel_busy_flag = <span class="hljs-number">1</span>;         <span class="hljs-comment">// 标记通道为忙碌状态</span><br>        &#125; <br>        <span class="hljs-comment">// 如果没有找到两个满足条件的页，只能执行单个page的读操作</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">while</span> (sub != NULL) &#123;  <span class="hljs-comment">// 遍历读子请求队列</span><br>                <span class="hljs-function"><span class="hljs-title">if</span> (sub-&gt;</span>current_state == SR_WAIT) &#123;<br>                    <span class="hljs-comment">// 判断目标die是否处于空闲状态，才能执行读操作</span><br>                    <span class="hljs-function"><span class="hljs-title">if</span> ((ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[sub-&gt;</span><span class="hljs-function"><span class="hljs-title">location</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">channel</span>].chip_head[sub-&gt;</span><span class="hljs-function"><span class="hljs-title">location</span>-&gt;</span>chip].current_state == CHIP_IDLE) || <br>                        ((<span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[sub-&gt;</span><span class="hljs-function"><span class="hljs-title">location</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">channel</span>].chip_head[sub-&gt;</span><span class="hljs-function"><span class="hljs-title">location</span>-&gt;</span>chip].next_state == CHIP_IDLE) &amp;&amp;<br>                        (<span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[sub-&gt;</span><span class="hljs-function"><span class="hljs-title">location</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">channel</span>].chip_head[sub-&gt;</span><span class="hljs-function"><span class="hljs-title">location</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">chip</span>].next_state_predict_time &lt;= ssd-&gt;</span>current_time))) &#123;<br><br>                        <span class="hljs-comment">// 执行单个子请求的读操作</span><br>                        go_one_step(ssd, sub, NULL, SR_R_C_A_TRANSFER, NORMAL);<br><br>                        *change_current_time_flag = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 不需要更改当前时间</span><br>                        *channel_busy_flag = <span class="hljs-number">1</span>;         <span class="hljs-comment">// 标记通道为忙碌状态</span><br>                        break;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-function"><span class="hljs-title">sub</span> = sub-&gt;</span>next_node;  <span class="hljs-comment">// 移动到下一个子请求</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 当既不支持INTERLEAVE也不支持TWOPLANE命令时，只能执行单个子请求的读操作</span><br>    <span class="hljs-function"><span class="hljs-title">if</span> (((ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span>advanced_commands &amp; AD_INTERLEAVE) != AD_INTERLEAVE) &amp;&amp; <br>        ((<span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span>advanced_commands &amp; AD_TWOPLANE_READ) != AD_TWOPLANE_READ)) &#123;<br>        <span class="hljs-keyword">while</span> (sub != NULL) &#123;  <span class="hljs-comment">// 遍历读子请求队列</span><br>            <span class="hljs-function"><span class="hljs-title">if</span> (sub-&gt;</span>current_state == SR_WAIT) &#123;<br>                <span class="hljs-comment">// 判断目标die是否处于空闲状态，才能执行读操作</span><br>                <span class="hljs-function"><span class="hljs-title">if</span> ((ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[sub-&gt;</span><span class="hljs-function"><span class="hljs-title">location</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">channel</span>].chip_head[sub-&gt;</span><span class="hljs-function"><span class="hljs-title">location</span>-&gt;</span>chip].current_state == CHIP_IDLE) || <br>                    ((<span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[sub-&gt;</span><span class="hljs-function"><span class="hljs-title">location</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">channel</span>].chip_head[sub-&gt;</span><span class="hljs-function"><span class="hljs-title">location</span>-&gt;</span>chip].next_state == CHIP_IDLE) &amp;&amp;<br>                    (<span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[sub-&gt;</span><span class="hljs-function"><span class="hljs-title">location</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">channel</span>].chip_head[sub-&gt;</span><span class="hljs-function"><span class="hljs-title">location</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">chip</span>].next_state_predict_time &lt;= ssd-&gt;</span>current_time))) &#123;<br><br>                    <span class="hljs-comment">// 执行单个子请求的读操作</span><br>                    go_one_step(ssd, sub, NULL, SR_R_C_A_TRANSFER, NORMAL);<br><br>                    *change_current_time_flag = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 不需要更改当前时间</span><br>                    *channel_busy_flag = <span class="hljs-number">1</span>;         <span class="hljs-comment">// 标记通道为忙碌状态</span><br>                    break;<br>                &#125;<br>            &#125;<br>            <span class="hljs-function"><span class="hljs-title">sub</span> = sub-&gt;</span>next_node;  <span class="hljs-comment">// 移动到下一个子请求</span><br>        &#125;<br>    &#125;<br><br>    return SUCCESS;  <span class="hljs-comment">// 返回成功状态</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="services-2-r-data-trans函数："><a href="#services-2-r-data-trans函数：" class="headerlink" title="services_2_r_data_trans函数："></a>services_2_r_data_trans函数：</h3><p>这个函数也是只处理读子请求，处理chip当前状态是CHIP_WAIT，在当前channel的每个chip中寻找需要处理的读子请求。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><code class="hljs php">Status services_2_r_data_trans(struct ssd_info * ssd, unsigned <span class="hljs-keyword">int</span> channel, unsigned <span class="hljs-keyword">int</span> * channel_busy_flag, unsigned <span class="hljs-keyword">int</span> * change_current_time_flag)<br>&#123;<br>    <span class="hljs-keyword">int</span> chip = <span class="hljs-number">0</span>;<br>    unsigned <span class="hljs-keyword">int</span> <span class="hljs-keyword">die</span> = <span class="hljs-number">0</span>, plane = <span class="hljs-number">0</span>, address_ppn = <span class="hljs-number">0</span>, die1 = <span class="hljs-number">0</span>;<br>    struct sub_request * sub = <span class="hljs-literal">NULL</span>, * p = <span class="hljs-literal">NULL</span>, * sub1 = <span class="hljs-literal">NULL</span>;<br>    struct sub_request * sub_twoplane_one = <span class="hljs-literal">NULL</span>, * sub_twoplane_two = <span class="hljs-literal">NULL</span>;<br>    struct sub_request * sub_interleave_one = <span class="hljs-literal">NULL</span>, * sub_interleave_two = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-comment">// 遍历当前channel中的每个chip</span><br>    <span class="hljs-keyword">for</span> (chip = <span class="hljs-number">0</span>; chip &lt; ssd-&gt;channel_head[channel].chip; chip++)<br>    &#123;<br>        <span class="hljs-comment">// 如果chip处于等待状态或正准备数据传输，且时间到达当前时间</span><br>        <span class="hljs-keyword">if</span> ((ssd-&gt;channel_head[channel].chip_head[chip].current_state == CHIP_WAIT) ||<br>            ((ssd-&gt;channel_head[channel].chip_head[chip].next_state == CHIP_DATA_TRANSFER) &amp;&amp;<br>            (ssd-&gt;channel_head[channel].chip_head[chip].next_state_predict_time &lt;= ssd-&gt;current_time)))<br>        &#123;<br>            <span class="hljs-comment">// 在chip中寻找对应的读子请求</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">die</span> = <span class="hljs-number">0</span>; <span class="hljs-keyword">die</span> &lt; ssd-&gt;parameter-&gt;die_chip; <span class="hljs-keyword">die</span>++)<br>            &#123;<br>                sub = find_read_sub_request(ssd, channel, chip, <span class="hljs-keyword">die</span>);  <span class="hljs-comment">// 查找读子请求</span><br>                <span class="hljs-keyword">if</span> (sub != <span class="hljs-literal">NULL</span>)<br>                &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-comment">// 如果没有找到子请求，继续下一个chip</span><br>            <span class="hljs-keyword">if</span> (sub == <span class="hljs-literal">NULL</span>)<br>            &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-comment">/********************************************************************************************</span><br><span class="hljs-comment">             * 如果SSD支持高级命令，可以同时处理AD_TWOPLANE_READ或AD_INTERLEAVE的读请求</span><br><span class="hljs-comment">             * 1. 有可能产生two plane操作，将同一个die上的两个plane数据依次传输</span><br><span class="hljs-comment">             * 2. 有可能产生interleave操作，将不同die上的两个plane数据依次传输</span><br><span class="hljs-comment">             ********************************************************************************************/</span><br>            <span class="hljs-keyword">if</span> (((ssd-&gt;parameter-&gt;advanced_commands &amp; AD_TWOPLANE_READ) == AD_TWOPLANE_READ) ||<br>                ((ssd-&gt;parameter-&gt;advanced_commands &amp; AD_INTERLEAVE) == AD_INTERLEAVE))<br>            &#123;<br>                <span class="hljs-comment">// 如果支持two plane操作</span><br>                <span class="hljs-keyword">if</span> ((ssd-&gt;parameter-&gt;advanced_commands &amp; AD_TWOPLANE_READ) == AD_TWOPLANE_READ)<br>                &#123;<br>                    sub_twoplane_one = sub;  <span class="hljs-comment">// 第一个two plane子请求</span><br>                    sub_twoplane_two = <span class="hljs-literal">NULL</span>;<br><br>                    <span class="hljs-comment">// 设置当前plane的PPN为-1，以确保找到不同的子请求</span><br>                    ssd-&gt;channel_head[channel].chip_head[chip].die_head[<span class="hljs-keyword">die</span>].plane_head[sub-&gt;location-&gt;plane].add_reg_ppn = -<span class="hljs-number">1</span>;<br>                    sub_twoplane_two = find_read_sub_request(ssd, channel, chip, <span class="hljs-keyword">die</span>);  <span class="hljs-comment">// 查找同一个chip、die中的另一个子请求</span><br><br>                    <span class="hljs-comment">// 如果没有找到第二个子请求，则执行普通的状态转换</span><br>                    <span class="hljs-keyword">if</span> (sub_twoplane_two == <span class="hljs-literal">NULL</span>)<br>                    &#123;<br>                        go_one_step(ssd, sub_twoplane_one, <span class="hljs-literal">NULL</span>, SR_R_DATA_TRANSFER, NORMAL);<br>                        *change_current_time_flag = <span class="hljs-number">0</span>;<br>                        *channel_busy_flag = <span class="hljs-number">1</span>;<br>                    &#125;<br>                    <span class="hljs-comment">// 找到第二个子请求，则执行two plane的状态转换</span><br>                    <span class="hljs-keyword">else</span><br>                    &#123;<br>                        go_one_step(ssd, sub_twoplane_one, sub_twoplane_two, SR_R_DATA_TRANSFER, TWO_PLANE);<br>                        *change_current_time_flag = <span class="hljs-number">0</span>;<br>                        *channel_busy_flag = <span class="hljs-number">1</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-comment">// 如果支持interleave操作</span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((ssd-&gt;parameter-&gt;advanced_commands &amp; AD_INTERLEAVE) == AD_INTERLEAVE)<br>                &#123;<br>                    sub_interleave_one = sub;  <span class="hljs-comment">// 第一个interleave子请求</span><br>                    sub_interleave_two = <span class="hljs-literal">NULL</span>;<br><br>                    <span class="hljs-comment">// 设置当前plane的PPN为-1，以确保找到不同的子请求</span><br>                    ssd-&gt;channel_head[channel].chip_head[chip].die_head[<span class="hljs-keyword">die</span>].plane_head[sub-&gt;location-&gt;plane].add_reg_ppn = -<span class="hljs-number">1</span>;<br><br>                    <span class="hljs-comment">// 在不同的die上寻找另一个子请求</span><br>                    <span class="hljs-keyword">for</span> (die1 = <span class="hljs-number">0</span>; die1 &lt; ssd-&gt;parameter-&gt;die_chip; die1++)<br>                    &#123;<br>                        <span class="hljs-keyword">if</span> (die1 != <span class="hljs-keyword">die</span>)<br>                        &#123;<br>                            sub_interleave_two = find_read_sub_request(ssd, channel, chip, die1);<br>                            <span class="hljs-keyword">if</span> (sub_interleave_two != <span class="hljs-literal">NULL</span>)<br>                            &#123;<br>                                <span class="hljs-keyword">break</span>;<br>                            &#125;<br>                        &#125;<br>                    &#125;<br><br>                    <span class="hljs-comment">// 如果没有找到第二个子请求，则执行普通状态转换</span><br>                    <span class="hljs-keyword">if</span> (sub_interleave_two == <span class="hljs-literal">NULL</span>)<br>                    &#123;<br>                        go_one_step(ssd, sub_interleave_one, <span class="hljs-literal">NULL</span>, SR_R_DATA_TRANSFER, NORMAL);<br>                        *change_current_time_flag = <span class="hljs-number">0</span>;<br>                        *channel_busy_flag = <span class="hljs-number">1</span>;<br>                    &#125;<br>                    <span class="hljs-comment">// 找到第二个子请求，执行interleave状态转换</span><br>                    <span class="hljs-keyword">else</span><br>                    &#123;<br>                        go_one_step(ssd, sub_twoplane_one, sub_interleave_two, SR_R_DATA_TRANSFER, INTERLEAVE);<br>                        *change_current_time_flag = <span class="hljs-number">0</span>;<br>                        *channel_busy_flag = <span class="hljs-number">1</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 如果不支持高级命令，则逐一执行读子请求</span><br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                go_one_step(ssd, sub, <span class="hljs-literal">NULL</span>, SR_R_DATA_TRANSFER, NORMAL);<br>                *change_current_time_flag = <span class="hljs-number">0</span>;<br>                *channel_busy_flag = <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;  <span class="hljs-comment">// 结束当前chip的处理</span><br>        &#125;<br><br>        <span class="hljs-comment">// 如果channel已经忙碌，退出循环</span><br>        <span class="hljs-keyword">if</span> (*channel_busy_flag == <span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> SUCCESS;  <span class="hljs-comment">// 返回成功状态</span><br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="services-2-write函数："><a href="#services-2-write函数：" class="headerlink" title="services_2_write函数："></a>services_2_write函数：</h3><p>被process函数调用，写子请求的处理函数，分别处理了动态分配和静态分配策略下的写请求服务。</p>
<p><strong>函数结构</strong>：<code>services_2_write</code>函数负责处理SSD写请求，针对不同的分配方案（动态或静态）进行处理，支持高级命令（如Two-plane或Interleave）和普通命令。</p>
<p><strong>动态分配</strong>：根据SSD的令牌机制，将写子请求分配给合适的<code>chip</code>、<code>die</code>、<code>plane</code>，并确保令牌更新机制在每次成功处理后修改。</p>
<p><strong>静态分配</strong>：根据静态配置，逐个检查写请求，并处理相应的<code>chip</code>、<code>die</code>，同样支持高级命令。</p>
<p><strong>高级命令</strong>：如果SSD支持高级命令，会优先尝试执行这些命令以提高性能。如果不支持，则执行标准写操作。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><code class="hljs lisp">Status services_2_write(<span class="hljs-name">struct</span> ssd_info * ssd, unsigned int channel, unsigned int * channel_busy_flag, unsigned int * change_current_time_flag)<br>&#123;<br>    int j = 0, chip = 0;<br>    unsigned int k = 0;<br>    unsigned int old_ppn = 0, new_ppn = 0;<br>    unsigned int chip_token = 0, die_token = 0, plane_token = 0, address_ppn = 0;<br>    unsigned int die = 0, plane = 0;<br>    long long time = 0;<br>    struct sub_request * sub = NULL, * p = NULL;<br>    struct sub_request * sub_twoplane_one = NULL, * sub_twoplane_two = NULL;<br>    struct sub_request * sub_interleave_one = NULL, * sub_interleave_two = NULL;<br><br>    /************************************************************************************************************************<br>    * 写子请求挂在两个地方：一个是channel_head[channel].subs_w_head，另一个是ssd-&gt;subs_w_head，所以至少有一个队列不为空。<br>    * 同时子请求的处理分为动态分配和静态分配。<br>    *************************************************************************************************************************/<br>    if ((<span class="hljs-name">ssd-&gt;channel_head</span>[channel].subs_w_head != NULL) || (<span class="hljs-name">ssd-&gt;subs_w_head</span> != NULL)) // 有写子请求<br>    &#123;<br>        if (<span class="hljs-name">ssd-&gt;parameter-&gt;allocation_scheme</span> == <span class="hljs-number">1</span>) // 动态分配<br>        &#123;<br>            for (<span class="hljs-name">j</span> = <span class="hljs-number">0</span><span class="hljs-comment">; j &lt; ssd-&gt;channel_head[channel].chip; j++)</span><br>            &#123;<br>                if ((<span class="hljs-name">ssd-&gt;channel_head</span>[channel].subs_w_head == NULL) <span class="hljs-symbol">&amp;&amp;</span> (<span class="hljs-name">ssd-&gt;subs_w_head</span> == NULL)) // 该channel上没有子请求，跳出循环<br>                &#123;<br>                    break<span class="hljs-comment">;</span><br>                &#125;<br>                <br>                // 处理当前channel上的子请求<br>                chip_token = ssd-&gt;channel_head[channel].token<span class="hljs-comment">; // 从某一个chip开始分配（令牌）</span><br>                if (<span class="hljs-name">*channel_busy_flag</span> == <span class="hljs-number">0</span>) // 如果通道不忙<br>                &#123;<br>                    // 如果chip不忙<br>                    if ((<span class="hljs-name">ssd-&gt;channel_head</span>[channel].chip_head[chip_token].current_state == CHIP_IDLE) || <br>                        ((<span class="hljs-name">ssd-&gt;channel_head</span>[channel].chip_head[chip_token].next_state == CHIP_IDLE) <span class="hljs-symbol">&amp;&amp;</span> <br>                         (<span class="hljs-name">ssd-&gt;channel_head</span>[channel].chip_head[chip_token].next_state_predict_time &lt;= ssd-&gt;current_time)))<br>                    &#123;<br>                        if ((<span class="hljs-name">ssd-&gt;channel_head</span>[channel].subs_w_head == NULL) <span class="hljs-symbol">&amp;&amp;</span> (<span class="hljs-name">ssd-&gt;subs_w_head</span> == NULL))<br>                        &#123;<br>                            break<span class="hljs-comment">;</span><br>                        &#125;<br><br>                        die_token = ssd-&gt;channel_head[channel].chip_head[chip_token].token<span class="hljs-comment">;</span><br>                        <br>                        if (((<span class="hljs-name">ssd-&gt;parameter-&gt;advanced_commands</span> &amp; AD_INTERLEAVE) != AD_INTERLEAVE) <span class="hljs-symbol">&amp;&amp;</span> <br>                            ((<span class="hljs-name">ssd-&gt;parameter-&gt;advanced_commands</span> &amp; AD_TWOPLANE) != AD_TWOPLANE)) // 无高级命令<br>                        &#123;<br>                            sub = find_write_sub_request(<span class="hljs-name">ssd</span>, channel)<span class="hljs-comment">;</span><br>                            if (<span class="hljs-name">sub</span> == NULL)<br>                            &#123;<br>                                break<span class="hljs-comment">;</span><br>                            &#125;<br><br>                            if (<span class="hljs-name">sub-&gt;current_state</span> == SR_WAIT)<br>                            &#123;<br>                                plane_token = ssd-&gt;channel_head[channel].chip_head[chip_token].die_head[die_token].token<span class="hljs-comment">;</span><br><br>                                get_ppn(<span class="hljs-name">ssd</span>, channel, chip_token, die_token, plane_token, sub)<span class="hljs-comment">;</span><br><br>                                ssd-&gt;channel_head[channel].chip_head[chip_token].die_head[die_token].token = <br>                                    (<span class="hljs-name">ssd-&gt;channel_head</span>[channel].chip_head[chip_token].die_head[die_token].token + <span class="hljs-number">1</span>) % ssd-&gt;parameter-&gt;plane_die<span class="hljs-comment">;</span><br><br>                                *change_current_time_flag = 0;<br><br>                                if (ssd-&gt;parameter-&gt;ad_priority2 == 0)<br>                                &#123;<br>                                    ssd-&gt;real_time_subreq--;<br>                                &#125;<br>                                <br>                                go_one_step(ssd, sub, NULL, SR_W_TRANSFER, NORMAL); // 执行普通状态转变<br>                                delete_w_sub_request(ssd, channel, sub); // 删除处理完的写子请求<br><br>                                *channel_busy_flag = <span class="hljs-number">1</span><span class="hljs-comment">;</span><br>                                /**************************************************************************<br>                                * 跳出循环前修改令牌。<br>                                * 令牌的变化取决于写请求是否成功。<br>                                * 如果成功，退出；否则，修改token直到找到能写成功的通道。<br>                                ***************************************************************************/<br>                                ssd-&gt;channel_head[channel].chip_head[chip_token].token = <br>                                    (<span class="hljs-name">ssd-&gt;channel_head</span>[channel].chip_head[chip_token].token + <span class="hljs-number">1</span>) % ssd-&gt;parameter-&gt;die_chip<span class="hljs-comment">;</span><br>                                ssd-&gt;channel_head[channel].token = <br>                                    (<span class="hljs-name">ssd-&gt;channel_head</span>[channel].token + <span class="hljs-number">1</span>) % ssd-&gt;parameter-&gt;chip_channel[channel]<span class="hljs-comment">;</span><br>                                break<span class="hljs-comment">;</span><br>                            &#125;<br>                        &#125;<br>                        else // 使用高级命令<br>                        &#123;<br>                            if (<span class="hljs-name">dynamic_advanced_process</span>(<span class="hljs-name">ssd</span>, channel, chip_token) == NULL)<br>                            &#123;<br>                                *channel_busy_flag = 0;<br>                            &#125;<br>                            else<br>                            &#123;<br>                                *channel_busy_flag = <span class="hljs-number">1</span><span class="hljs-comment">; // 执行了一个请求，占用了总线，跳出循环</span><br>                                ssd-&gt;channel_head[channel].chip_head[chip_token].token = <br>                                    (<span class="hljs-name">ssd-&gt;channel_head</span>[channel].chip_head[chip_token].token + <span class="hljs-number">1</span>) % ssd-&gt;parameter-&gt;die_chip<span class="hljs-comment">;</span><br>                                ssd-&gt;channel_head[channel].token = <br>                                    (<span class="hljs-name">ssd-&gt;channel_head</span>[channel].token + <span class="hljs-number">1</span>) % ssd-&gt;parameter-&gt;chip_channel[channel]<span class="hljs-comment">;</span><br>                                break<span class="hljs-comment">;</span><br>                            &#125;<br>                        &#125;<br><br>                        ssd-&gt;channel_head[channel].chip_head[chip_token].token = <br>                            (<span class="hljs-name">ssd-&gt;channel_head</span>[channel].chip_head[chip_token].token + <span class="hljs-number">1</span>) % ssd-&gt;parameter-&gt;die_chip<span class="hljs-comment">;</span><br>                    &#125;<br>                &#125;<br><br>                ssd-&gt;channel_head[channel].token = (<span class="hljs-name">ssd-&gt;channel_head</span>[channel].token + <span class="hljs-number">1</span>) % ssd-&gt;parameter-&gt;chip_channel[channel]<span class="hljs-comment">;</span><br>            &#125;<br>        &#125;<br>        else if (<span class="hljs-name">ssd-&gt;parameter-&gt;allocation_scheme</span> == <span class="hljs-number">0</span>) // 静态分配<br>        &#123;<br>            for (<span class="hljs-name">chip</span> = <span class="hljs-number">0</span><span class="hljs-comment">; chip &lt; ssd-&gt;channel_head[channel].chip; chip++)</span><br>            &#123;<br>                if ((<span class="hljs-name">ssd-&gt;channel_head</span>[channel].chip_head[chip].current_state == CHIP_IDLE) || <br>                    ((<span class="hljs-name">ssd-&gt;channel_head</span>[channel].chip_head[chip].next_state == CHIP_IDLE) <span class="hljs-symbol">&amp;&amp;</span> <br>                     (<span class="hljs-name">ssd-&gt;channel_head</span>[channel].chip_head[chip].next_state_predict_time &lt;= ssd-&gt;current_time)))<br>                &#123;<br>                    if (<span class="hljs-name">ssd-&gt;channel_head</span>[channel].subs_w_head == NULL)<br>                    &#123;<br>                        break<span class="hljs-comment">;</span><br>                    &#125;<br><br>                    if (<span class="hljs-name">*channel_busy_flag</span> == <span class="hljs-number">0</span>)<br>                    &#123;<br>                        if (((<span class="hljs-name">ssd-&gt;parameter-&gt;advanced_commands</span> &amp; AD_INTERLEAVE) != AD_INTERLEAVE) <span class="hljs-symbol">&amp;&amp;</span> <br>                            ((<span class="hljs-name">ssd-&gt;parameter-&gt;advanced_commands</span> &amp; AD_TWOPLANE) != AD_TWOPLANE)) // 无高级命令<br>                        &#123;<br>                            for (<span class="hljs-name">die</span> = <span class="hljs-number">0</span><span class="hljs-comment">; die &lt; ssd-&gt;channel_head[channel].chip_head[chip].die_num; die++)</span><br>                            &#123;<br>                                if (<span class="hljs-name">ssd-&gt;channel_head</span>[channel].subs_w_head == NULL)<br>                                &#123;<br>                                    break<span class="hljs-comment">;</span><br>                                &#125;<br><br>                                sub = ssd-&gt;channel_head[channel].subs_w_head<span class="hljs-comment">;</span><br>                                while (<span class="hljs-name">sub</span> != NULL)<br>                                &#123;<br>                                    if ((<span class="hljs-name">sub-&gt;current_state</span> == SR_WAIT) <span class="hljs-symbol">&amp;&amp;</span><br>                                        (<span class="hljs-name">sub-&gt;location-&gt;channel</span> == channel) <span class="hljs-symbol">&amp;&amp;</span><br>                                        (<span class="hljs-name">sub-&gt;location-&gt;chip</span> == chip) <span class="hljs-symbol">&amp;&amp;</span><br>                                        (<span class="hljs-name">sub-&gt;location-&gt;die</span> == die)) // 该子请求是当前die的请求<br>                                    &#123;<br>                                        if (<span class="hljs-name">sub-&gt;update</span> != NULL)<br>                                        &#123;<br>                                            if ((<span class="hljs-name">sub-&gt;update-&gt;current_state</span> == SR_COMPLETE) || <br>                                                ((<span class="hljs-name">sub-&gt;update-&gt;next_state</span> == SR_COMPLETE) <span class="hljs-symbol">&amp;&amp;</span> <br>                                                 (<span class="hljs-name">sub-&gt;update-&gt;next_state_predict_time</span> &lt;= ssd-&gt;current_time))) // 被更新的页已读出<br>                                            &#123;<br>                                                break<span class="hljs-comment">;</span><br>                                            &#125;<br>                                        &#125;<br>                                        else<br>                                        &#123;<br>                                            break<span class="hljs-comment">;</span><br>                                        &#125;<br>                                    &#125;<br>                                    sub = sub-&gt;next_node<span class="hljs-comment">;</span><br>                                &#125;<br><br>                                if (<span class="hljs-name">sub</span> == NULL)<br>                                &#123;<br>                                    continue<span class="hljs-comment">;</span><br>                                &#125;<br><br>                                if (<span class="hljs-name">sub-&gt;current_state</span> == SR_WAIT)<br>                                &#123;<br>                                    sub-&gt;current_time = ssd-&gt;current_time<span class="hljs-comment">;</span><br>                                    sub-&gt;current_state = SR_W_TRANSFER<span class="hljs-comment">;</span><br>                                    sub-&gt;next_state = SR_COMPLETE<span class="hljs-comment">;</span><br><br>                                    if ((<span class="hljs-name">ssd-&gt;parameter-&gt;advanced_commands</span> &amp; AD_COPYBACK) == AD_COPYBACK)<br>                                    &#123;<br>                                        copy_back(<span class="hljs-name">ssd</span>, channel, chip, die, sub)<span class="hljs-comment">; // 使用copyback高级命令处理写子请求</span><br>                                        *change_current_time_flag = 0;<br>                                    &#125;<br>                                    else<br>                                    &#123;<br>                                        static_write(ssd, channel, chip, die, sub); // 不能使用copyback命令，执行普通写操作<br>                                        *change_current_time_flag = <span class="hljs-number">0</span><span class="hljs-comment">;</span><br>                                    &#125;<br><br>                                    delete_w_sub_request(<span class="hljs-name">ssd</span>, channel, sub)<span class="hljs-comment">;</span><br>                                    *channel_busy_flag = 1;<br>                                    break;<br>                                &#125;<br>                            &#125;<br>                        &#125;<br>                        else // 执行高级命令<br>                        &#123;<br>                            if (dynamic_advanced_process(ssd, channel, chip) == NULL)<br>                            &#123;<br>                                *channel_busy_flag = <span class="hljs-number">0</span><span class="hljs-comment">;</span><br>                            &#125;<br>                            else<br>                            &#123;<br>                                *channel_busy_flag = 1; // 执行了一个请求，占用了总线<br>                                break;<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    return SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="find-interleave-twoplane-sub-request函数："><a href="#find-interleave-twoplane-sub-request函数：" class="headerlink" title="find_interleave_twoplane_sub_request函数："></a>find_interleave_twoplane_sub_request函数：</h3><p>被services_2_r_wait函数调用，该函数用于在指定通道的子请求队列中寻找两个可以执行<strong>two-plane</strong>或<strong>interleave</strong>操作的读子请求。一旦找到合适的两个子请求，还要确保它们是同一主请求的子请求，并检查它们的逻辑扇区号范围是否匹配。</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs xl">int find_interleave_twoplane_sub_request(struct ssd_info * ssd, unsigned int channel, struct sub_request * sub_request_one, struct sub_request * sub_request_two, unsigned int command)<br>&#123;<br>    <span class="hljs-comment">// 将第一个读子请求初始化为该通道的子请求队列头部</span><br>    <span class="hljs-function"><span class="hljs-title">sub_request_one</span> = ssd-&gt;</span>channel_head[channel].subs_r_head;<br><br>    <span class="hljs-comment">// 遍历该通道的读子请求队列，寻找符合条件的两个可以执行two-plane或interleave操作的子请求</span><br>    <span class="hljs-keyword">while</span> (sub_request_one != NULL)<br>    &#123;<br>        <span class="hljs-comment">// 调用函数find_interleave_twoplane_page，判断是否有可以配对的第二个子请求</span><br>        sub_request_two = find_interleave_twoplane_page(ssd, sub_request_one, command); <span class="hljs-comment">/* 找出两个可以执行two-plane或interleave操作的页，包括位置和时间条件 */</span><br><br>        <span class="hljs-comment">// 如果没有找到合适的第二个子请求，继续检查下一个子请求</span><br>        <span class="hljs-keyword">if</span> (sub_request_two == NULL)<br>        &#123;<br>            <span class="hljs-function"><span class="hljs-title">sub_request_one</span> = sub_request_one-&gt;</span>next_node;<br>        &#125;<br>        <span class="hljs-comment">// 如果找到了符合条件的第二个子请求，则退出循环</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sub_request_two != NULL)<br>        &#123;<br>            break;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 检查是否找到了符合条件的两个子请求，并进一步检查请求队列的有效性</span><br>    <span class="hljs-keyword">if</span> (sub_request_two != NULL)<br>    &#123;<br>        <span class="hljs-comment">// 如果当前请求队列不为空，确保找到的两个子请求是同一个主请求的子请求</span><br>        <span class="hljs-function"><span class="hljs-title">if</span> (ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">request_queue</span> != ssd-&gt;</span>request_tail)<br>        &#123;<br>            <span class="hljs-comment">// 确保第一个子请求属于当前请求队列的第一个主请求</span><br>            <span class="hljs-function"><span class="hljs-title">if</span> ((ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">request_queue</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">lsn</span> - ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">subpage_page</span>) &lt; (sub_request_one-&gt;</span><span class="hljs-function"><span class="hljs-title">lpn</span> * ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span>subpage_page))<br>            &#123;<br>                <span class="hljs-comment">// 检查请求的逻辑扇区号（LSN）范围是否匹配</span><br>                <span class="hljs-function"><span class="hljs-title">if</span> ((ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">request_queue</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">lsn</span> + ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">request_queue</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">size</span> + ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">subpage_page</span>) &gt; (sub_request_one-&gt;</span><span class="hljs-function"><span class="hljs-title">lpn</span> * ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span>subpage_page))<br>                &#123;<br>                    <span class="hljs-comment">// 如果匹配，子请求有效</span><br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    sub_request_two = NULL;  <span class="hljs-comment">// 如果不匹配，取消第二个子请求的配对</span><br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                sub_request_two = NULL;  <span class="hljs-comment">// 如果不匹配，取消第二个子请求的配对</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果成功找到两个合适的子请求，返回成功状态</span><br>    <span class="hljs-keyword">if</span> (sub_request_two != NULL)<br>    &#123;<br>        return SUCCESS;<br>    &#125;<br>    <span class="hljs-comment">// 如果没有找到符合条件的两个子请求，返回失败状态</span><br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        return FAILURE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="find-interleave-twoplane-page函数："><a href="#find-interleave-twoplane-page函数：" class="headerlink" title="find_interleave_twoplane_page函数："></a>find_interleave_twoplane_page函数：</h3><p>函数被<code>find_interleave_twoplane_sub_request</code>调用，函数用于寻找是否存在一个可以与 <code>one_page</code> 一起执行 two-plane 或 interleave 操作的子请求。</p>
<p>它首先检查 <code>one_page</code> 的状态和其所属芯片的空闲状态，然后根据传入的命令（<code>TWO_PLANE</code> 或 <code>INTERLEAVE</code>）寻找合适的第二个子请求。</p>
<p>对于 <code>TWO_PLANE</code> 操作，两个子请求必须在同一个chip、die、block和page上，且plane不同。</p>
<p>对于 <code>INTERLEAVE</code> 操作，两个子请求必须在同一个chip上，但属于不同的die。</p>
<p>如果找到符合条件的第二个子请求，返回该子请求；否则返回 <code>NULL</code>。</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs xl">struct sub_request *find_interleave_twoplane_page(struct ssd_info *ssd, struct sub_request *one_page, unsigned int command)<br>&#123;<br>    struct sub_request *two_page;<br><br>    <span class="hljs-comment">// 如果第一个子请求不处于等待状态，则返回 NULL，表示无法进行操作</span><br>    <span class="hljs-function"><span class="hljs-title">if</span> (one_page-&gt;</span>current_state != SR_WAIT)<br>    &#123;<br>        return NULL;<br>    &#125;<br><br>    <span class="hljs-comment">// 检查第一个子请求所属芯片的当前状态或下一个状态是否为空闲，并且空闲时间不晚于当前时间</span><br>    <span class="hljs-function"><span class="hljs-title">if</span> ((ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[one_page-&gt;</span><span class="hljs-function"><span class="hljs-title">location</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">channel</span>].chip_head[one_page-&gt;</span><span class="hljs-function"><span class="hljs-title">location</span>-&gt;</span>chip].current_state == CHIP_IDLE) ||<br>        ((<span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[one_page-&gt;</span><span class="hljs-function"><span class="hljs-title">location</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">channel</span>].chip_head[one_page-&gt;</span><span class="hljs-function"><span class="hljs-title">location</span>-&gt;</span>chip].next_state == CHIP_IDLE) &amp;&amp;<br>        (<span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[one_page-&gt;</span><span class="hljs-function"><span class="hljs-title">location</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">channel</span>].chip_head[one_page-&gt;</span><span class="hljs-function"><span class="hljs-title">location</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">chip</span>].next_state_predict_time &lt;= ssd-&gt;</span>current_time)))<br>    &#123;<br>        <span class="hljs-comment">// 将two_page初始化为one_page的下一个子请求节点</span><br>        <span class="hljs-function"><span class="hljs-title">two_page</span> = one_page-&gt;</span>next_node;<br><br>        <span class="hljs-comment">// 如果当前命令是TWO_PLANE操作，寻找可以进行two-plane操作的第二个子请求</span><br>        <span class="hljs-keyword">if</span> (command == TWO_PLANE)<br>        &#123;<br>            <span class="hljs-keyword">while</span> (two_page != NULL)<br>            &#123;<br>                <span class="hljs-comment">// 如果当前子请求不处于等待状态，继续检查下一个子请求</span><br>                <span class="hljs-function"><span class="hljs-title">if</span> (two_page-&gt;</span>current_state != SR_WAIT)<br>                &#123;<br>                    <span class="hljs-function"><span class="hljs-title">two_page</span> = two_page-&gt;</span>next_node;<br>                &#125;<br>                <span class="hljs-comment">// 检查两个子请求的位置是否在同一个chip、die、block和page，并且plane不同</span><br>                <span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span> ((one_page-&gt;</span><span class="hljs-function"><span class="hljs-title">location</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">chip</span> == two_page-&gt;</span><span class="hljs-function"><span class="hljs-title">location</span>-&gt;</span>chip) &amp;&amp;<br>                         (<span class="hljs-function"><span class="hljs-title">one_page</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">location</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">die</span> == two_page-&gt;</span><span class="hljs-function"><span class="hljs-title">location</span>-&gt;</span>die) &amp;&amp;<br>                         (<span class="hljs-function"><span class="hljs-title">one_page</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">location</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">block</span> == two_page-&gt;</span><span class="hljs-function"><span class="hljs-title">location</span>-&gt;</span><span class="hljs-keyword">block</span>) &amp;&amp;<br>                         (<span class="hljs-function"><span class="hljs-title">one_page</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">location</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">page</span> == two_page-&gt;</span><span class="hljs-function"><span class="hljs-title">location</span>-&gt;</span><span class="hljs-built_in">page</span>))<br>                &#123;<br>                    <span class="hljs-function"><span class="hljs-title">if</span> (one_page-&gt;</span><span class="hljs-function"><span class="hljs-title">location</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">plane</span> != two_page-&gt;</span><span class="hljs-function"><span class="hljs-title">location</span>-&gt;</span>plane)<br>                    &#123;<br>                        return two_page;  <span class="hljs-comment">// 找到了可以与one_page进行two-plane操作的页</span><br>                    &#125;<br>                    <span class="hljs-keyword">else</span><br>                    &#123;<br>                        <span class="hljs-function"><span class="hljs-title">two_page</span> = two_page-&gt;</span>next_node;  <span class="hljs-comment">// 如果plane相同，继续寻找下一个子请求</span><br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    <span class="hljs-function"><span class="hljs-title">two_page</span> = two_page-&gt;</span>next_node;  <span class="hljs-comment">// 如果不在同一个block，继续寻找下一个子请求</span><br>                &#125;<br>            &#125;<br><br>            <span class="hljs-comment">// 如果没有找到合适的第二个子请求，返回 NULL</span><br>            <span class="hljs-keyword">if</span> (two_page == NULL)<br>            &#123;<br>                return NULL;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果当前命令是INTERLEAVE操作，寻找可以进行interleave操作的第二个子请求</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (command == INTERLEAVE)<br>        &#123;<br>            <span class="hljs-keyword">while</span> (two_page != NULL)<br>            &#123;<br>                <span class="hljs-comment">// 如果当前子请求不处于等待状态，继续检查下一个子请求</span><br>                <span class="hljs-function"><span class="hljs-title">if</span> (two_page-&gt;</span>current_state != SR_WAIT)<br>                &#123;<br>                    <span class="hljs-function"><span class="hljs-title">two_page</span> = two_page-&gt;</span>next_node;<br>                &#125;<br>                <span class="hljs-comment">// 检查两个子请求是否在同一个chip但不同的die上</span><br>                <span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span> ((one_page-&gt;</span><span class="hljs-function"><span class="hljs-title">location</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">chip</span> == two_page-&gt;</span><span class="hljs-function"><span class="hljs-title">location</span>-&gt;</span>chip) &amp;&amp;<br>                         (<span class="hljs-function"><span class="hljs-title">one_page</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">location</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">die</span> != two_page-&gt;</span><span class="hljs-function"><span class="hljs-title">location</span>-&gt;</span>die))<br>                &#123;<br>                    return two_page;  <span class="hljs-comment">// 找到了可以与one_page进行interleave操作的页</span><br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    <span class="hljs-function"><span class="hljs-title">two_page</span> = two_page-&gt;</span>next_node;  <span class="hljs-comment">// 如果不在同一个chip或die上，继续寻找下一个子请求</span><br>                &#125;<br>            &#125;<br><br>            <span class="hljs-comment">// 如果没有找到合适的第二个子请求，返回 NULL</span><br>            <span class="hljs-keyword">if</span> (two_page == NULL)<br>            &#123;<br>                return NULL;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果没有找到可以进行two-plane或interleave操作的子请求，返回 NULL</span><br>    return NULL;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="go-one-step函数：（状态跳变处理函数-）"><a href="#go-one-step函数：（状态跳变处理函数-）" class="headerlink" title="go_one_step函数：（状态跳变处理函数 ）"></a>go_one_step函数：（状态跳变处理函数 ）</h3><p>这个函数非常重要，读子请求的状态转变，以及时间的计算都通过这个函数来处理，还有写子请求的执行普通命令时的状态，以及时间的计算也是通过这个函数来处理的。</p>
<p>该函数根据给定的 <code>aim_state</code>（目标状态）和 <code>command</code>（命令类型），处理 SSD 中的子请求，并更新 SSD 的 <code>channel</code> 和 <code>chip</code> 的状态。针对不同的目标状态（如读取命令传输、数据传输、写入等），它会根据 SSD 的时间参数进行状态预测，并调整子请求的下一个状态和完成时间。</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><code class="hljs xl">Status go_one_step(struct ssd_info * ssd, struct sub_request * sub1, struct sub_request * sub2, unsigned int aim_state, unsigned int command) &#123;<br>    unsigned int i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>,k=<span class="hljs-number">0</span>,m=<span class="hljs-number">0</span>;<br>    long long <span class="hljs-built_in">time</span>=<span class="hljs-number">0</span>;<br>    struct sub_request * sub=NULL;<br>    struct sub_request * sub_twoplane_one=NULL, * sub_twoplane_two=NULL;<br>    struct sub_request * sub_interleave_one=NULL, * sub_interleave_two=NULL;<br>    struct local * location=NULL;<br><br>    <span class="hljs-keyword">if</span>(sub1 == NULL) &#123;<br>        return ERROR;  <span class="hljs-comment">// 如果没有提供子请求，则返回错误</span><br>    &#125;<br><br>    <span class="hljs-comment">/***************************************************************************************************</span><br><span class="hljs-comment">     * 处理普通命令时，读子请求的目标状态分为以下几种情况：SR_R_READ、SR_R_C_A_TRANSFER、SR_R_DATA_TRANSFER</span><br><span class="hljs-comment">     * 写子请求的目标状态只有 SR_W_TRANSFER</span><br><span class="hljs-comment">     ****************************************************************************************************/</span><br>    <span class="hljs-keyword">if</span>(command == NORMAL) &#123;  <span class="hljs-comment">// 如果是普通命令</span><br>        sub = sub1;<br>        <span class="hljs-function"><span class="hljs-title">location</span> = sub1-&gt;</span>location;  <span class="hljs-comment">// 获取子请求的位置信息</span><br><br>        switch(aim_state) &#123;  <span class="hljs-comment">// 根据目标状态进行不同的处理</span><br>            case SR_R_READ:  <span class="hljs-comment">// 目标状态是读</span><br>            &#123;<br>                <span class="hljs-comment">/*****************************************************************************************************</span><br><span class="hljs-comment">                 * 这个目标状态是指 Flash 处于读取数据的状态，子请求的下一个状态应该是传输数据 SR_R_DATA_TRANSFER。</span><br><span class="hljs-comment">                 * 这时与 channel 无关，只与 chip 相关，所以需要修改 chip 的状态为 CHIP_READ_BUSY，下一状态为 CHIP_DATA_TRANSFER。</span><br><span class="hljs-comment">                 ******************************************************************************************************/</span><br>                <span class="hljs-function"><span class="hljs-title">sub</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">current_time</span> = ssd-&gt;</span>current_time;<br>                <span class="hljs-function"><span class="hljs-title">sub</span>-&gt;</span>current_state = SR_R_READ;  <span class="hljs-comment">// 当前状态设置为读取</span><br>                <span class="hljs-function"><span class="hljs-title">sub</span>-&gt;</span>next_state = SR_R_DATA_TRANSFER;  <span class="hljs-comment">// 下一个状态为数据传输</span><br>                <span class="hljs-function"><span class="hljs-title">sub</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">next_state_predict_time</span> = ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">current_time</span> + ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span>time_characteristics.tR;  <span class="hljs-comment">// 预测下一状态的时间</span><br><br>                <span class="hljs-comment">// 更新芯片状态</span><br>                <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[location-&gt;</span><span class="hljs-function"><span class="hljs-title">channel</span>].chip_head[location-&gt;</span>chip].current_state = CHIP_READ_BUSY;<br>                <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[location-&gt;</span><span class="hljs-function"><span class="hljs-title">channel</span>].chip_head[location-&gt;</span><span class="hljs-function"><span class="hljs-title">chip</span>].current_time = ssd-&gt;</span>current_time;<br>                <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[location-&gt;</span><span class="hljs-function"><span class="hljs-title">channel</span>].chip_head[location-&gt;</span>chip].next_state = CHIP_DATA_TRANSFER;<br>                <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[location-&gt;</span><span class="hljs-function"><span class="hljs-title">channel</span>].chip_head[location-&gt;</span><span class="hljs-function"><span class="hljs-title">chip</span>].next_state_predict_time = ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">current_time</span> + ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span>time_characteristics.tR;<br><br>                break;<br>            &#125;<br>            case SR_R_C_A_TRANSFER:  <span class="hljs-comment">// 目标状态是读命令地址传输</span><br>            &#123;<br>                <span class="hljs-comment">/*******************************************************************************************************</span><br><span class="hljs-comment">                 * 目标状态是命令地址传输时，子请求的下一个状态是 SR_R_READ。</span><br><span class="hljs-comment">                 * 这个状态与 channel、chip 相关，因此需要修改 channel 和 chip 的状态为 CHANNEL_C_A_TRANSFER、CHIP_C_A_TRANSFER。</span><br><span class="hljs-comment">                 * 下一状态分别是 CHANNEL_IDLE 和 CHIP_READ_BUSY。</span><br><span class="hljs-comment">                 *******************************************************************************************************/</span><br>                <span class="hljs-function"><span class="hljs-title">sub</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">current_time</span> = ssd-&gt;</span>current_time;<br>                <span class="hljs-function"><span class="hljs-title">sub</span>-&gt;</span>current_state = SR_R_C_A_TRANSFER;<br>                <span class="hljs-function"><span class="hljs-title">sub</span>-&gt;</span>next_state = SR_R_READ;<br>                <span class="hljs-function"><span class="hljs-title">sub</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">next_state_predict_time</span> = ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">current_time</span> + 7 * ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span>time_characteristics.tWC;<br>                <span class="hljs-function"><span class="hljs-title">sub</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">begin_time</span> = ssd-&gt;</span>current_time;  <span class="hljs-comment">// 开始时间</span><br><br>                <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[location-&gt;</span><span class="hljs-function"><span class="hljs-title">channel</span>].chip_head[location-&gt;</span><span class="hljs-function"><span class="hljs-title">chip</span>].die_head[location-&gt;</span><span class="hljs-function"><span class="hljs-title">die</span>].plane_head[location-&gt;</span><span class="hljs-function"><span class="hljs-title">plane</span>].add_reg_ppn = sub-&gt;</span>ppn;  <span class="hljs-comment">// 记录物理页号</span><br>                <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span>read_count++;  <span class="hljs-comment">// 读取计数</span><br><br>                <span class="hljs-comment">// 更新 channel 状态</span><br>                <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[location-&gt;</span>channel].current_state = CHANNEL_C_A_TRANSFER;<br>                <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[location-&gt;</span><span class="hljs-function"><span class="hljs-title">channel</span>].current_time = ssd-&gt;</span>current_time;<br>                <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[location-&gt;</span>channel].next_state = CHANNEL_IDLE;<br>                <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[location-&gt;</span><span class="hljs-function"><span class="hljs-title">channel</span>].next_state_predict_time = ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">current_time</span> + 7 * ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span>time_characteristics.tWC;<br><br>                <span class="hljs-comment">// 更新芯片状态</span><br>                <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[location-&gt;</span><span class="hljs-function"><span class="hljs-title">channel</span>].chip_head[location-&gt;</span>chip].current_state = CHIP_C_A_TRANSFER;<br>                <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[location-&gt;</span><span class="hljs-function"><span class="hljs-title">channel</span>].chip_head[location-&gt;</span><span class="hljs-function"><span class="hljs-title">chip</span>].current_time = ssd-&gt;</span>current_time;<br>                <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[location-&gt;</span><span class="hljs-function"><span class="hljs-title">channel</span>].chip_head[location-&gt;</span>chip].next_state = CHIP_READ_BUSY;<br>                <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[location-&gt;</span><span class="hljs-function"><span class="hljs-title">channel</span>].chip_head[location-&gt;</span><span class="hljs-function"><span class="hljs-title">chip</span>].next_state_predict_time = ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">current_time</span> + 7 * ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span>time_characteristics.tWC;<br><br>                break;<br>            &#125;<br>            case SR_R_DATA_TRANSFER:  <span class="hljs-comment">// 目标状态是数据传输</span><br>            &#123;<br>                <span class="hljs-comment">/**************************************************************************************************************</span><br><span class="hljs-comment">                 * 目标状态是数据传输时，子请求的下一个状态为 SR_COMPLETE，表示操作完成。</span><br><span class="hljs-comment">                 * 该状态与 channel 和 chip 相关，因此需要更新 channel 和 chip 的状态为 CHANNEL_DATA_TRANSFER、CHIP_DATA_TRANSFER。</span><br><span class="hljs-comment">                 * 下一状态分别是 CHANNEL_IDLE 和 CHIP_IDLE。</span><br><span class="hljs-comment">                 ***************************************************************************************************************/</span><br>                <span class="hljs-function"><span class="hljs-title">sub</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">current_time</span> = ssd-&gt;</span>current_time;<br>                <span class="hljs-function"><span class="hljs-title">sub</span>-&gt;</span>current_state = SR_R_DATA_TRANSFER;<br>                <span class="hljs-function"><span class="hljs-title">sub</span>-&gt;</span>next_state = SR_COMPLETE;<br>                <span class="hljs-function"><span class="hljs-title">sub</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">next_state_predict_time</span> = ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">current_time</span> + (sub-&gt;</span><span class="hljs-function"><span class="hljs-title">size</span> * ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">subpage_capacity</span>) * ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span>time_characteristics.tRC;<br>                <span class="hljs-function"><span class="hljs-title">sub</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">complete_time</span> = sub-&gt;</span>next_state_predict_time;  <span class="hljs-comment">// 记录完成时间</span><br><br>                <span class="hljs-comment">// 更新 channel 状态</span><br>                <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[location-&gt;</span>channel].current_state = CHANNEL_DATA_TRANSFER;<br>                <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[location-&gt;</span><span class="hljs-function"><span class="hljs-title">channel</span>].current_time = ssd-&gt;</span>current_time;<br>                <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[location-&gt;</span>channel].next_state = CHANNEL_IDLE;<br>                <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[location-&gt;</span><span class="hljs-function"><span class="hljs-title">channel</span>].next_state_predict_time = sub-&gt;</span>next_state_predict_time;<br><br>                <span class="hljs-comment">// 更新芯片状态</span><br>                <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[location-&gt;</span><span class="hljs-function"><span class="hljs-title">channel</span>].chip_head[location-&gt;</span>chip].current_state = CHIP_DATA_TRANSFER;<br>                <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[location-&gt;</span><span class="hljs-function"><span class="hljs-title">channel</span>].chip_head[location-&gt;</span><span class="hljs-function"><span class="hljs-title">chip</span>].current_time = ssd-&gt;</span>current_time;<br>                <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[location-&gt;</span><span class="hljs-function"><span class="hljs-title">channel</span>].chip_head[location-&gt;</span>chip].next_state = CHIP_IDLE;<br>                <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[location-&gt;</span><span class="hljs-function"><span class="hljs-title">channel</span>].chip_head[location-&gt;</span><span class="hljs-function"><span class="hljs-title">chip</span>].next_state_predict_time = sub-&gt;</span>next_state_predict_time;<br><br>                <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[location-&gt;</span><span class="hljs-function"><span class="hljs-title">channel</span>].chip_head[location-&gt;</span><span class="hljs-function"><span class="hljs-title">chip</span>].die_head[location-&gt;</span><span class="hljs-function"><span class="hljs-title">die</span>].plane_head[location-&gt;</span>plane].add_reg_ppn = -<span class="hljs-number">1</span>;  <span class="hljs-comment">// 清除寄存器页号</span><br><br>                break;<br>            &#125;<br>            case SR_W_TRANSFER:  <span class="hljs-comment">// 目标状态是写</span><br>            &#123;<br>                <span class="hljs-comment">/******************************************************************************************************</span><br><span class="hljs-comment">                 * 处理写子请求时，虽然写请求的状态较多，但实际上它们都可以简化为一个状态 SR_W_TRANSFER，子请求的下一个状态是 SR_COMPLETE。</span><br><span class="hljs-comment">                 * 在这个过程中，channel 和 chip 的状态会被更新为 CHANNEL_TRANSFER 和 CHIP_WRITE_BUSY。</span><br><span class="hljs-comment">                 *******************************************************************************************************/</span><br>                <span class="hljs-function"><span class="hljs-title">sub</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">current_time</span> = ssd-&gt;</span>current_time;<br>                <span class="hljs-function"><span class="hljs-title">sub</span>-&gt;</span>current_state = SR_W_TRANSFER;<br>                <span class="hljs-function"><span class="hljs-title">sub</span>-&gt;</span>next_state = SR_COMPLETE;<br>                <span class="hljs-function"><span class="hljs-title">sub</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">next_state_predict_time</span> = ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">current_time</span> + 7 * ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">time_characteristics</span>.tWC + (sub-&gt;</span><span class="hljs-function"><span class="hljs-title">size</span> * ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">subpage_capacity</span>) * ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span>time_characteristics.tWC;<br>                <span class="hljs-function"><span class="hljs-title">time</span> = sub-&gt;</span>next_state_predict_time;<br><br>                <span class="hljs-comment">// 更新 channel 状态</span><br>                <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[location-&gt;</span>channel].current_state = CHANNEL_TRANSFER;<br>                <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[location-&gt;</span><span class="hljs-function"><span class="hljs-title">channel</span>].current_time = ssd-&gt;</span>current_time;<br>                <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[location-&gt;</span>channel].next_state = CHANNEL_IDLE;<br>                <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[location-&gt;</span>channel].next_state_predict_time = <span class="hljs-built_in">time</span>;<br><br>                <span class="hljs-comment">// 更新芯片状态</span><br>                <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[location-&gt;</span><span class="hljs-function"><span class="hljs-title">channel</span>].chip_head[location-&gt;</span>chip].current_state = CHIP_WRITE_BUSY;<br>                <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[location-&gt;</span><span class="hljs-function"><span class="hljs-title">channel</span>].chip_head[location-&gt;</span>chip<br></code></pre></td></tr></table></figure>



<h2 id="initialize："><a href="#initialize：" class="headerlink" title="initialize："></a>initialize：</h2><h3 id="initiation函数-："><a href="#initiation函数-：" class="headerlink" title="initiation函数 ："></a>initiation函数 ：</h3><p>导入SSD配置文件，初始化dram，channel和超级块</p>
<p>初始化超级块：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust">   <span class="hljs-comment">//初始化超级块</span><br>ssd-&gt;superblock=(<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">superblock_info</span></span>*)malloc(ssd-&gt;parameter-&gt;chip_channel[<span class="hljs-number">0</span>] * ssd-&gt;parameter-&gt;block_plane * sizeof(<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">superblock_info</span></span>));<br>alloc_assert(ssd-&gt;superblock,<span class="hljs-string">&quot;ssd-&gt;superblock&quot;</span>);<br>memset(ssd-&gt;superblock,<span class="hljs-number">0</span>,ssd-&gt;parameter-&gt;chip_channel[<span class="hljs-number">0</span>] * ssd-&gt;parameter-&gt;block_plane * sizeof(<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">superblock_info</span></span>));<br>initialize_superblock(ssd);<br></code></pre></td></tr></table></figure>

<h3 id="initialize-superblock函数："><a href="#initialize-superblock函数：" class="headerlink" title="initialize_superblock函数："></a>initialize_superblock函数：</h3><p>初始化超级块结构，位置等信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 初始化超级块结构</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initialize_superblock</span><span class="hljs-params">(struct ssd_info *ssd)</span> </span>&#123;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> superblock_num = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 计算超级块的总数</span><br>    superblock_num = ssd-&gt;parameter-&gt;block_plane * ssd-&gt;parameter-&gt;chip_channel[<span class="hljs-number">0</span>];<br>    <br>    <span class="hljs-comment">// 遍历每个超级块</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; superblock_num; i++) &#123;<br>        <span class="hljs-comment">// 为每个超级块分配内存，大小为通道数量乘以superblock_channel结构体的大小</span><br>        ssd-&gt;superblock[i].super_blk_loc = (struct superblock_channel*) <span class="hljs-built_in">malloc</span>(ssd-&gt;parameter-&gt;channel_number * <span class="hljs-keyword">sizeof</span>(struct superblock_channel));<br>        <br>        <span class="hljs-comment">// 如果当前索引小于每plane的块数</span><br>        <span class="hljs-keyword">if</span> (i &lt; ssd-&gt;parameter-&gt;block_plane) &#123;<br>            <span class="hljs-comment">// 为每个通道初始化超级块位置</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; ssd-&gt;parameter-&gt;channel_number; ++j) &#123;<br>                ssd-&gt;superblock[i].super_blk_loc[j].channel = j; <span class="hljs-comment">// 设置通道号，j刚好是第二层循环的channel编号</span><br>                ssd-&gt;superblock[i].super_blk_loc[j].blk = i; <span class="hljs-comment">// 设置块号， 是第几个超级块</span><br>            &#125;<br>        &#125; <br>        <span class="hljs-comment">// 如果当前索引大于或等于每plane的块数</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i &gt;= ssd-&gt;parameter-&gt;block_plane) &#123;<br>            <span class="hljs-comment">// 为每个通道初始化超级块位置</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; ssd-&gt;parameter-&gt;channel_number; ++j) &#123;<br>                ssd-&gt;superblock[i].super_blk_loc[j].channel = j; <span class="hljs-comment">// 设置通道号</span><br>                ssd-&gt;superblock[i].super_blk_loc[j].blk = i - ssd-&gt;parameter-&gt;block_plane; <span class="hljs-comment">// 设置块号</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="pagemap："><a href="#pagemap：" class="headerlink" title="pagemap："></a>pagemap：</h2><h3 id="gc函数："><a href="#gc函数：" class="headerlink" title="gc函数："></a>gc函数：</h3><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-keyword">if</span> (flag == <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">/* 整个SSD都是IDLE的情况 */</span><br>    <span class="hljs-function"><span class="hljs-title">for</span> (i = 0; i &lt; ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span>channel_number; i++) &#123;<br>        <span class="hljs-comment">// 初始化标志变量</span><br>        flag_priority = <span class="hljs-number">0</span>;<br>        flag_direct_erase = <span class="hljs-number">1</span>;<br>        flag_gc = <span class="hljs-number">1</span>;<br>        flag_invoke_gc = <span class="hljs-number">1</span>;<br>        gc_node = NULL;<br>        gc_p = NULL;<br><br>        <span class="hljs-comment">// 检查通道是否处于空闲状态</span><br>        <span class="hljs-function"><span class="hljs-title">if</span> ((ssd-&gt;</span>channel_head[i].current_state == CHANNEL_IDLE) || <br>            (<span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span>channel_head[i].next_state == CHANNEL_IDLE &amp;&amp; <br>            <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[i].next_state_predict_time &lt;= ssd-&gt;</span>current_time)) &#123;<br>            channel = i;  <span class="hljs-comment">// 将当前通道设置为目标通道</span><br><br>            <span class="hljs-comment">// 如果当前通道有GC命令，则执行GC操作</span><br>            <span class="hljs-function"><span class="hljs-title">if</span> (ssd-&gt;</span>channel_head[channel].gc_command != NULL) &#123;<br>                gc_for_channel(ssd, channel);<br>            &#125;<br>        &#125;<br>    &#125;<br>    return SUCCESS;  <span class="hljs-comment">// 返回成功状态</span><br>&#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">/* 只需针对某个特定的channel，chip，die进行GC请求的操作 */</span><br>    <span class="hljs-comment">// 检查分配方案，如果为1（静态分配）或0（动态分配）</span><br>    <span class="hljs-function"><span class="hljs-title">if</span> ((ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span>allocation_scheme == <span class="hljs-number">1</span>) || <br>        ((<span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">allocation_scheme</span> == 0) &amp;&amp; (ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span>dynamic_allocation == <span class="hljs-number">1</span>))) &#123;<br>        <span class="hljs-comment">// 如果队列上有请求，则先服务请求</span><br>        <span class="hljs-function"><span class="hljs-title">if</span> ((ssd-&gt;</span>channel_head[channel].subs_r_head != NULL) || <br>            (<span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span>channel_head[channel].subs_w_head != NULL)) &#123;<br>            return <span class="hljs-number">0</span>;  <span class="hljs-comment">// 返回0表示先服务请求，不进行GC</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 调用GC函数进行垃圾回收</span><br>    return gc_for_channel(ssd, channel);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="gc-for-channel函数："><a href="#gc-for-channel函数：" class="headerlink" title="gc_for_channel函数："></a>gc_for_channel函数：</h3><p>这个函数的功能是处理channel的每个gc操作(这里都是不可中断的gc)</p>
<p>这一部分代码用于查找队列中gc请求是否是channel空闲而且是不可中断，如果是则代表优先级较高，则将flag_priority置为1</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">gc_node</span>=ssd-&gt;</span>channel_head[channel].gc_command;<br><span class="hljs-keyword">while</span> (gc_node!=NULL)<br>&#123;<br>	<span class="hljs-function"><span class="hljs-title">current_state</span>=ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[channel].chip_head[gc_node-&gt;</span>chip].current_state;<br>	<span class="hljs-function"><span class="hljs-title">next_state</span>=ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[channel].chip_head[gc_node-&gt;</span>chip].next_state;<br>	<span class="hljs-function"><span class="hljs-title">next_state_predict_time</span>=ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[channel].chip_head[gc_node-&gt;</span>chip].next_state_predict_time;<br>	<span class="hljs-function"><span class="hljs-title">if</span>((current_state==CHIP_IDLE)||((next_state==CHIP_IDLE)&amp;&amp;(next_state_predict_time&lt;=ssd-&gt;</span>current_time)))<br>	&#123;<br>		<span class="hljs-function"><span class="hljs-title">if</span> (gc_node-&gt;</span>priority==GC_UNINTERRUPT)   <span class="hljs-comment">/*这个gc请求是不可中断的，优先服务这个gc操作*/</span><br>		&#123;<br>			flag_priority=<span class="hljs-number">1</span>;<br>			break;<br>		&#125;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-title">gc_node</span>=gc_node-&gt;</span>next_node;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果没有不可中断的请求，则进行以下处理：找寻是否有channel空闲的node，有则进行下一步处理</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-keyword">if</span> (flag_priority!=<span class="hljs-number">1</span>)       <span class="hljs-comment">/*没有找到不可中断的gc请求，首先执行队首的gc请求*/</span><br>&#123;<br>	<span class="hljs-function"><span class="hljs-title">gc_node</span>=ssd-&gt;</span>channel_head[channel].gc_command;<br>	<span class="hljs-keyword">while</span> (gc_node!=NULL)<br>	&#123;<br>		<span class="hljs-function"><span class="hljs-title">current_state</span>=ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[channel].chip_head[gc_node-&gt;</span>chip].current_state;<br>		<span class="hljs-function"><span class="hljs-title">next_state</span>=ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[channel].chip_head[gc_node-&gt;</span>chip].next_state;<br>		<span class="hljs-function"><span class="hljs-title">next_state_predict_time</span>=ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[channel].chip_head[gc_node-&gt;</span>chip].next_state_predict_time;<br>		 <span class="hljs-comment">/**********************************************</span><br><span class="hljs-comment">		 *需要gc操作的目标chip是空闲的，才可以进行gc操作</span><br><span class="hljs-comment">		 ***********************************************/</span><br>		<span class="hljs-function"><span class="hljs-title">if</span>((current_state==CHIP_IDLE)||((next_state==CHIP_IDLE)&amp;&amp;(next_state_predict_time&lt;=ssd-&gt;</span>current_time)))<br>		&#123;<br>			break;<br>		&#125;<br>		<span class="hljs-function"><span class="hljs-title">gc_node</span>=gc_node-&gt;</span>next_node;<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>然后开始对符合条件的node进行gc，首先对于不可打断的进行处理，先进行擦除</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">if</span> (gc_node-&gt;priority==GC_UNINTERRUPT)   <span class="hljs-comment">//!!</span><br>&#123;<br>	flag_direct_erase=gc<span class="hljs-constructor">_direct_erase(<span class="hljs-params">ssd</span>,<span class="hljs-params">channel</span>,<span class="hljs-params">chip</span>,<span class="hljs-params">die</span>,<span class="hljs-params">plane</span>)</span>; <span class="hljs-comment">//先进行普通gc</span><br>	<span class="hljs-keyword">if</span> (flag_direct_erase!=SUCCESS) <span class="hljs-comment">//普通gc失败，需要进行不可打断的强制gc</span><br>	&#123;<br>		<span class="hljs-comment">// flag_gc=uninterrupt_gc(ssd,channel,chip,die,plane);  </span><br>		flag_gc=uninterrupt<span class="hljs-constructor">_gc_super(<span class="hljs-params">ssd</span>,<span class="hljs-params">channel</span>,<span class="hljs-params">chip</span>,<span class="hljs-params">die</span>,<span class="hljs-params">plane</span>,<span class="hljs-params">block</span>)</span>;    <span class="hljs-comment">/*当一个完整的gc操作完成时（已经擦除一个块，回收了一定数量的flash空间），返回1，将channel上相应的gc操作请求节点删除*/</span><br>		<span class="hljs-keyword">if</span> (flag_gc==<span class="hljs-number">1</span>) <span class="hljs-comment">// 等于1代表一个完整gc的完成</span><br>		&#123;<br>			delete<span class="hljs-constructor">_gc_node(<span class="hljs-params">ssd</span>,<span class="hljs-params">channel</span>,<span class="hljs-params">gc_node</span>)</span>;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">else</span> <span class="hljs-comment">// 普通gc成功，直接在gc链中删除对应节点</span><br>	&#123;<br>		delete<span class="hljs-constructor">_gc_node(<span class="hljs-params">ssd</span>,<span class="hljs-params">channel</span>,<span class="hljs-params">gc_node</span>)</span>;<br>	&#125;<br>	return SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可中断的gc请求，需要首先确认该channel上没有子请求在这个时刻需要使用这个channel，没有的话，在执行gc操作，有的话，不执行gc操作</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (gc_node-&gt;priority<span class="hljs-operator"> == </span>GC_FAST_UNINTERRUPT<span class="hljs-operator"> || </span><br><span class="hljs-operator">         </span>gc_node-&gt;priority<span class="hljs-operator"> == </span>GC_FAST_UNINTERRUPT_EMERGENCY<span class="hljs-operator"> || </span><br><span class="hljs-operator">         </span>gc_node-&gt;priority<span class="hljs-operator"> == </span>GC_FAST_UNINTERRUPT_IDLE) &#123;<br>    <span class="hljs-comment">/* 如果垃圾回收节点的优先级为GC_FAST_UNINTERRUPT、GC_FAST_UNINTERRUPT_EMERGENCY或GC_FAST_UNINTERRUPT_IDLE */</span><br>    <br>    <span class="hljs-comment">//printf(&quot;===&gt;GC_FAST on %d,%d,%d,%d begin.\n&quot;, channel, chip, die, plane);</span><br><br>    flag_direct_erase = gc<span class="hljs-constructor">_direct_fast_erase(<span class="hljs-params">ssd</span>, <span class="hljs-params">channel</span>, <span class="hljs-params">chip</span>, <span class="hljs-params">die</span>, <span class="hljs-params">plane</span>)</span>;<br>    <span class="hljs-comment">/* 尝试直接执行快速擦除操作 */</span><br><br>    <span class="hljs-keyword">if</span> (flag_direct_erase != SUCCESS) &#123;<br>        <span class="hljs-comment">/* 如果没有块可以直接擦除，进行进一步的GC操作 */</span><br>        <br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        printf(&quot;Something Weird happened.\n&quot;);</span><br><span class="hljs-comment">        return FAILURE;</span><br><span class="hljs-comment">        */</span><br>        <br>        <span class="hljs-comment">//printf(&quot;NO BLOCK CAN BE ERASED DIRECTLY.\n&quot;);</span><br><br>        flag_gc = uninterrupt<span class="hljs-constructor">_fast_gc(<span class="hljs-params">ssd</span>, <span class="hljs-params">channel</span>, <span class="hljs-params">chip</span>, <span class="hljs-params">die</span>, <span class="hljs-params">plane</span>, <span class="hljs-params">gc_node</span>-&gt;<span class="hljs-params">priority</span>)</span>;<br>        <span class="hljs-comment">/* 执行不可中断的快速GC操作 */</span><br><br>        <span class="hljs-keyword">if</span> (flag_gc<span class="hljs-operator"> == </span><span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">/* 如果GC操作成功，删除该GC节点 */</span><br>            delete<span class="hljs-constructor">_gc_node(<span class="hljs-params">ssd</span>, <span class="hljs-params">channel</span>, <span class="hljs-params">gc_node</span>)</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">/* 如果有块可以直接擦除，删除该GC节点 */</span><br>        <span class="hljs-comment">//printf(&quot;THERE IS BLOCK CAN BE ERASED DIRECTLY.\n&quot;);</span><br>        delete<span class="hljs-constructor">_gc_node(<span class="hljs-params">ssd</span>, <span class="hljs-params">channel</span>, <span class="hljs-params">gc_node</span>)</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//printf(&quot;===&gt;GC_FAST on %d,%d,%d,%d successed.\n&quot;, channel, chip, die, plane);</span><br>    return SUCCESS;  <span class="hljs-comment">// 快速GC操作成功</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>其他情况需要判断该请求是否可以被中断</p>
<p>这段代码判断当前通道是否可以执行GC操作，如果可以执行，则根据GC操作的具体情况（直接擦除或中断GC）来决定是否继续执行或者删除GC请求节点。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">else</span><br>&#123;<br>    <span class="hljs-comment">// 判断是否有子请求需要占用该channel，如果有子请求需要channel，GC操作将被中断</span><br>    flag_invoke_gc = decide<span class="hljs-constructor">_gc_invoke(<span class="hljs-params">ssd</span>, <span class="hljs-params">channel</span>)</span>;<br><br>    <span class="hljs-comment">// 如果没有子请求需要占用channel，可以继续执行GC操作</span><br>    <span class="hljs-keyword">if</span> (flag_invoke_gc<span class="hljs-operator"> == </span><span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-comment">// 尝试执行直接擦除操作，返回值用于判断是否需要中断或完成GC操作</span><br>        flag_direct_erase = gc<span class="hljs-constructor">_direct_erase(<span class="hljs-params">ssd</span>, <span class="hljs-params">channel</span>, <span class="hljs-params">chip</span>, <span class="hljs-params">die</span>, <span class="hljs-params">plane</span>)</span>;<br><br>        <span class="hljs-comment">// 如果不能直接擦除，执行GC中断操作</span><br>        <span class="hljs-keyword">if</span> (flag_direct_erase<span class="hljs-operator"> == </span>-<span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-comment">// 调用中断GC操作，返回值为1表示一个完整的GC操作已完成</span><br>            flag_gc = interrupt<span class="hljs-constructor">_gc(<span class="hljs-params">ssd</span>, <span class="hljs-params">channel</span>, <span class="hljs-params">chip</span>, <span class="hljs-params">die</span>, <span class="hljs-params">plane</span>, <span class="hljs-params">gc_node</span>)</span>;<br><br>            <span class="hljs-comment">// 如果GC操作已完成，删除该channel上的GC操作请求节点</span><br>            <span class="hljs-keyword">if</span> (flag_gc<span class="hljs-operator"> == </span><span class="hljs-number">1</span>)<br>            &#123;<br>                delete<span class="hljs-constructor">_gc_node(<span class="hljs-params">ssd</span>, <span class="hljs-params">channel</span>, <span class="hljs-params">gc_node</span>)</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 如果直接擦除操作成功（即flag_direct_erase为1），删除GC操作请求节点</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (flag_direct_erase<span class="hljs-operator"> == </span><span class="hljs-number">1</span>)<br>        &#123;<br>            delete<span class="hljs-constructor">_gc_node(<span class="hljs-params">ssd</span>, <span class="hljs-params">channel</span>, <span class="hljs-params">gc_node</span>)</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 成功完成GC操作，返回SUCCESS</span><br>        return SUCCESS;<br>    &#125;<br>    <span class="hljs-comment">// 如果子请求需要channel，GC操作被中断，返回FAILURE</span><br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        return FAILURE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="gc-direct-erase函数："><a href="#gc-direct-erase函数：" class="headerlink" title="gc_direct_erase函数："></a>gc_direct_erase函数：</h3><p>擦除操作，需要尽量做到多plane 的erase</p>
<p>以下代码是：当能处理TWOPLANE高级命令时，就在相应的channel，chip，die中两个不同的plane找到可以执行TWOPLANE操作的block</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">if</span>((ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span>advanced_commands&amp;AD_TWOPLANE)==AD_TWOPLANE) <span class="hljs-comment">//判断是否开启了twoplane高级命令</span><br>&#123;<br>	<span class="hljs-function"><span class="hljs-title">for</span>(lv_plane=0;lv_plane&lt;ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span>plane_die;lv_plane++) <span class="hljs-comment">//遍历平面</span><br>	&#123;<br>		<span class="hljs-function"><span class="hljs-title">direct_erase_node2</span>=ssd-&gt;</span>channel_head[channel].chip_head[chip].die_head[die].plane_head[plane].erase_node;     <span class="hljs-comment">//这里的plane应该改成lv_plane吧？？？ 遍历平面擦除节点</span><br>		<span class="hljs-keyword">if</span>((lv_plane!=plane)&amp;&amp;(direct_erase_node2!=NULL)) <span class="hljs-comment">//检查双平面冲突</span><br>		&#123;<br>			<span class="hljs-function"><span class="hljs-title">if</span>((direct_erase_node1-&gt;</span><span class="hljs-function"><span class="hljs-title">block</span>)==(direct_erase_node2-&gt;</span><span class="hljs-keyword">block</span>)) <span class="hljs-comment">// 检查块冲突</span><br>			&#123;<br>				muilt_plane_flag=TRUE; <span class="hljs-comment">//设置标志并退出循环</span><br>				break;<br>			&#125;<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>  以下代码是当能处理INTERLEAVE高级命令时，就在相应的channel，chip找到可以执行INTERLEAVE的两个block</p>
<p>  并置interleaver_flag为TRUE</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">if</span> ((ssd-&gt;parameter-&gt;advanced_commands &amp; AD_INTERLEAVE) == AD_INTERLEAVE) &#123;<br>    <span class="hljs-comment">/* 如果启用了高级命令中的AD_INTERLEAVE功能 */</span><br><br>    <span class="hljs-comment">// 遍历所有的die</span><br>    <span class="hljs-keyword">for</span> (lv_die = <span class="hljs-number">0</span>; lv_die &lt; ssd-&gt;parameter-&gt;die_chip; lv_die++) &#123;<br>        <span class="hljs-keyword">if</span> (lv_die != <span class="hljs-keyword">die</span>) &#123;  <span class="hljs-comment">// 排除当前操作的die</span><br><br>            <span class="hljs-comment">// 遍历所有的plane</span><br>            <span class="hljs-keyword">for</span> (lv_plane = <span class="hljs-number">0</span>; lv_plane &lt; ssd-&gt;parameter-&gt;plane_die; lv_plane++) &#123;<br><br>                <span class="hljs-comment">// 检查目标plane中是否有待擦除的块</span><br>                <span class="hljs-keyword">if</span> (ssd-&gt;channel_head[channel].chip_head[chip].die_head[<span class="hljs-keyword">die</span>].plane_head[plane].erase_node != <span class="hljs-literal">NULL</span>) &#123;<br>                    interleaver_flag = <span class="hljs-literal">TRUE</span>;  <span class="hljs-comment">// 如果存在待擦除的块，设置交错操作标志</span><br>                    <span class="hljs-keyword">break</span>;  <span class="hljs-comment">// 退出plane的遍历</span><br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果找到可以进行交错操作的plane，退出die的遍历</span><br>        <span class="hljs-keyword">if</span> (interleaver_flag == <span class="hljs-literal">TRUE</span>) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>以下代码逻辑，经过一层层的筛选，进行擦除操作</p>
<p>  1，如果既可以执行twoplane的两个block又有可以执行interleaver的两个block，那么就执行INTERLEAVE_TWO_PLANE的高级命令擦除操作</p>
<p>  2，如果只有能执行interleaver的两个block，那么就执行INTERLEAVE高级命令的擦除操作</p>
<p>  3，如果只有能执行TWO_PLANE的两个block，那么就执行TWO_PLANE高级命令的擦除操作</p>
<p>  4，没有上述这些情况，那么就只能够执行普通的擦除操作了</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">if</span> ((muilt_plane_flag<span class="hljs-operator"> == </span>TRUE)<span class="hljs-operator"> &amp;&amp; </span>(interleaver_flag<span class="hljs-operator"> == </span>TRUE)<span class="hljs-operator"> &amp;&amp;</span><br><span class="hljs-operator">    </span>((ssd-&gt;parameter-&gt;advanced_commands &amp; AD_TWOPLANE)<span class="hljs-operator"> == </span>AD_TWOPLANE)<span class="hljs-operator"> &amp;&amp;</span><br><span class="hljs-operator">    </span>((ssd-&gt;parameter-&gt;advanced_commands &amp; AD_INTERLEAVE)<span class="hljs-operator"> == </span>AD_INTERLEAVE)) &#123;<br>    <span class="hljs-comment">/* 如果多平面操作标志和交错操作标志均为TRUE，且启用了AD_TWOPLANE和AD_INTERLEAVE高级命令 */</span><br>    <br>    <span class="hljs-keyword">if</span> (erase<span class="hljs-constructor">_planes(<span class="hljs-params">ssd</span>, <span class="hljs-params">channel</span>, <span class="hljs-params">chip</span>, <span class="hljs-params">die</span>, <span class="hljs-params">plane</span>, INTERLEAVE_TWO_PLANE)</span><span class="hljs-operator"> == </span>SUCCESS) &#123;<br>        <span class="hljs-comment">/* 尝试进行交错与多平面组合擦除操作 */</span><br>        return SUCCESS;  <span class="hljs-comment">// 如果操作成功，返回SUCCESS</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((interleaver_flag<span class="hljs-operator"> == </span>TRUE)<span class="hljs-operator"> &amp;&amp; </span><br><span class="hljs-operator">         </span>((ssd-&gt;parameter-&gt;advanced_commands &amp; AD_INTERLEAVE)<span class="hljs-operator"> == </span>AD_INTERLEAVE)) &#123;<br>    <span class="hljs-comment">/* 如果交错操作标志为TRUE且启用了AD_INTERLEAVE高级命令 */</span><br>    <br>    <span class="hljs-keyword">if</span> (erase<span class="hljs-constructor">_planes(<span class="hljs-params">ssd</span>, <span class="hljs-params">channel</span>, <span class="hljs-params">chip</span>, <span class="hljs-params">die</span>, <span class="hljs-params">plane</span>, INTERLEAVE)</span><span class="hljs-operator"> == </span>SUCCESS) &#123;<br>        <span class="hljs-comment">/* 尝试进行交错擦除操作 */</span><br>        return SUCCESS;  <span class="hljs-comment">// 如果操作成功，返回SUCCESS</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((muilt_plane_flag<span class="hljs-operator"> == </span>TRUE)<span class="hljs-operator"> &amp;&amp; </span><br><span class="hljs-operator">         </span>((ssd-&gt;parameter-&gt;advanced_commands &amp; AD_TWOPLANE)<span class="hljs-operator"> == </span>AD_TWOPLANE)) &#123;<br>    <span class="hljs-comment">/* 如果多平面操作标志为TRUE且启用了AD_TWOPLANE高级命令 */</span><br>    <br>    <span class="hljs-keyword">if</span> (erase<span class="hljs-constructor">_planes(<span class="hljs-params">ssd</span>, <span class="hljs-params">channel</span>, <span class="hljs-params">chip</span>, <span class="hljs-params">die</span>, <span class="hljs-params">plane</span>, TWO_PLANE)</span><span class="hljs-operator"> == </span>SUCCESS) &#123;<br>        <span class="hljs-comment">/* 尝试进行多平面擦除操作 */</span><br>        return SUCCESS;  <span class="hljs-comment">// 如果操作成功，返回SUCCESS</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> ((normal_erase_flag<span class="hljs-operator"> == </span>TRUE)) &#123;<br>    <span class="hljs-comment">/* 如果没有满足上述条件，或者不支持高级命令，则进行普通的擦除操作 */</span><br>    <br>    <span class="hljs-keyword">if</span> (erase<span class="hljs-constructor">_planes(<span class="hljs-params">ssd</span>, <span class="hljs-params">channel</span>, <span class="hljs-params">chip</span>, <span class="hljs-params">die</span>, <span class="hljs-params">plane</span>, NORMAL)</span><span class="hljs-operator"> == </span>SUCCESS) &#123;<br>        return SUCCESS;  <span class="hljs-comment">// 普通擦除操作成功</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        return FAILURE;  <span class="hljs-comment">// 目标平面没有可擦除的块，操作失败</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="gc-direct-fast-erase函数："><a href="#gc-direct-fast-erase函数：" class="headerlink" title="gc_direct_fast_erase函数："></a>gc_direct_fast_erase函数：</h3><p>直接进行normal擦除</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">if</span> ((normal_erase_flag==TRUE))                              <span class="hljs-comment">/*不是每个plane都有可以直接删除的block，只对当前plane进行普通的erase操作，或者只能执行普通命令*/</span><br>&#123;<br>	<span class="hljs-keyword">if</span> (fast_erase_planes(ssd,channel,chip,die,plane,NORMAL)==SUCCESS)<br>	&#123;<br>		<span class="hljs-keyword">return</span> SUCCESS;<br>	&#125;<br>	<span class="hljs-keyword">else</span><br>	&#123;<br>		<span class="hljs-keyword">return</span> FAILURE;                                     <span class="hljs-comment">/*目标的plane没有可以直接删除的block，需要寻找目标擦除块后在实施擦除操作*/</span><br>	&#125;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>	printf(<span class="hljs-string">&quot;Wrong command for fast gc.\n&quot;</span>);<br>	<span class="hljs-keyword">return</span> FAILURE;<br>	&#125;<br></code></pre></td></tr></table></figure>

<h3 id="uninterrupt-gc-super函数："><a href="#uninterrupt-gc-super函数：" class="headerlink" title="uninterrupt_gc_super函数："></a>uninterrupt_gc_super函数：</h3><p>对不可打断的superblock进行gc，被gc_for_channel函数调用</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs xl">int uninterrupt_gc_super(struct ssd_info *ssd, unsigned int channel, unsigned int chip, unsigned int die, unsigned int plane, int blk_id) &#123;<br>    unsigned int free_page, i, <span class="hljs-keyword">block</span>;<br>    unsigned int page_move_count = <span class="hljs-number">0</span>, transfer_size = <span class="hljs-number">0</span>;<br>    struct local *location = NULL;<br><br>    <span class="hljs-comment">//***********************************************</span><br>    <span class="hljs-keyword">block</span> = blk_id;  <span class="hljs-comment">// 获取需要进行垃圾回收的块ID</span><br>    <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span>channel_head[channel].chip_head[chip].die_head[die].plane_head[plane].blk_head[<span class="hljs-keyword">block</span>].fast_erase = TRUE;<br>    <span class="hljs-comment">// 标记此块为快速擦除块</span><br>    <span class="hljs-comment">//***********************************************</span><br>    free_page = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-title">for</span> (i = 0; i &lt; ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span>page_block; i++) &#123;  <span class="hljs-comment">// 遍历块中的每一页</span><br>        <span class="hljs-function"><span class="hljs-title">if</span> ((ssd-&gt;</span>channel_head[channel].chip_head[chip].die_head[die].plane_head[plane].blk_head[<span class="hljs-keyword">block</span>].page_head[i].free_state &amp; PG_SUB) == <span class="hljs-number">0</span>x0000000f) &#123;<br>            free_page++;  <span class="hljs-comment">// 统计空闲页数</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (free_page != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// printf(&quot;\ntoo much free page. \t %d\t .%d\t%d\t%d\t%d\t\n&quot;, free_page, channel, chip, die, plane);</span><br>            <span class="hljs-comment">// 如果空闲页数不为零，打印调试信息（此处注释掉了打印）</span><br>        &#125;<br><br>        <span class="hljs-comment">// 检查每一页是否为有效页，如果是则需要进行数据迁移</span><br>        <span class="hljs-function"><span class="hljs-title">if</span> (ssd-&gt;</span>channel_head[channel].chip_head[chip].die_head[die].plane_head[plane].blk_head[<span class="hljs-keyword">block</span>].page_head[i].valid_state &gt; <span class="hljs-number">0</span>) &#123;<br>            location = (struct local *)malloc(sizeof(struct local));  <span class="hljs-comment">// 分配内存用于存储数据迁移的位置</span><br>            alloc_assert(location, <span class="hljs-string">&quot;location&quot;</span>);<br>            memset(location, <span class="hljs-number">0</span>, sizeof(struct local));  <span class="hljs-comment">// 初始化位置结构体</span><br>            <span class="hljs-function"><span class="hljs-title">location</span>-&gt;</span>channel = channel;<br>            <span class="hljs-function"><span class="hljs-title">location</span>-&gt;</span>chip = chip;<br>            <span class="hljs-function"><span class="hljs-title">location</span>-&gt;</span>die = die;<br>            <span class="hljs-function"><span class="hljs-title">location</span>-&gt;</span>plane = plane;<br>            <span class="hljs-function"><span class="hljs-title">location</span>-&gt;</span><span class="hljs-keyword">block</span> = <span class="hljs-keyword">block</span>;<br>            <span class="hljs-function"><span class="hljs-title">location</span>-&gt;</span><span class="hljs-built_in">page</span> = i;<br>            move_page(ssd, location, &amp;transfer_size);  <span class="hljs-comment">// 进行数据迁移</span><br>            page_move_count++;  <span class="hljs-comment">// 统计已迁移的页数</span><br>            free(location);  <span class="hljs-comment">// 释放分配的内存</span><br>            location = NULL;<br>        &#125;<br>    &#125;<br><br>    erase_operation(ssd, channel, chip, die, plane, <span class="hljs-keyword">block</span>);  <span class="hljs-comment">// 执行块的擦除操作</span><br><br>    <span class="hljs-comment">// 更新当前通道和芯片的状态为GC忙，设置当前时间，并设置下一状态为空闲</span><br>    <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span>channel_head[channel].current_state = CHANNEL_GC;<br>    <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[channel].current_time = ssd-&gt;</span>current_time;<br>    <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span>channel_head[channel].next_state = CHANNEL_IDLE;<br>    <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span>channel_head[channel].chip_head[chip].current_state = CHIP_ERASE_BUSY;<br>    <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[channel].chip_head[chip].current_time = ssd-&gt;</span>current_time;<br>    <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span>channel_head[channel].chip_head[chip].next_state = CHIP_IDLE;<br><br>    <span class="hljs-comment">/***************************************************************</span><br><span class="hljs-comment">    * 根据是否支持COPYBACK高级命令，计算通道和芯片下一个状态的预测时间</span><br><span class="hljs-comment">    ***************************************************************/</span><br>    <span class="hljs-function"><span class="hljs-title">if</span> ((ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span>advanced_commands &amp; AD_COPYBACK) == AD_COPYBACK) &#123;<br>        <span class="hljs-function"><span class="hljs-title">if</span> (ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span>greed_CB_ad == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">// 计算下一个状态的预测时间，考虑COPYBACK命令的情况</span><br>            <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[channel].next_state_predict_time = ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">current_time</span> + page_move_count * (7 * ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">time_characteristics</span>.tWC + ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">time_characteristics</span>.tR + 7 * ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">time_characteristics</span>.tWC + ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span>time_characteristics.tPROG);<br>            <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[channel].chip_head[chip].next_state_predict_time = ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[channel].next_state_predict_time + ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span>time_characteristics.tBERS;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 计算下一个状态的预测时间，不考虑COPYBACK命令的情况</span><br>        <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[channel].next_state_predict_time = ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">current_time</span> + page_move_count * (7 * ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">time_characteristics</span>.tWC + ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">time_characteristics</span>.tR) + transfer_size * SECTOR * ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span>time_characteristics.tRC;<br>        <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[channel].chip_head[chip].next_state_predict_time = ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[channel].next_state_predict_time + ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span>time_characteristics.tBERS;<br>    &#125;<br><br>    return <span class="hljs-number">1</span>;  <span class="hljs-comment">// 返回成功状态</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="delete-gc-node函数："><a href="#delete-gc-node函数：" class="headerlink" title="delete_gc_node函数："></a>delete_gc_node函数：</h3><p>函数的功能是当处理完一个gc操作时，需要把gc链上的gc_node删除掉（链表的指定删除操作）</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">int</span> delete_gc_node(struct ssd_info *ssd, unsigned <span class="hljs-keyword">int</span> channel, struct gc_operation *gc_node) &#123;<br>    struct gc_operation *gc_pre = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">// 用于指向前一个GC节点的指针</span><br><br>    <span class="hljs-keyword">if</span> (gc_node == <span class="hljs-literal">NULL</span>) &#123;  <span class="hljs-comment">// 检查传入的GC节点是否为空</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">ERROR</span>;  <span class="hljs-comment">// 如果为空，则返回错误</span><br>    &#125;<br><br>    <span class="hljs-comment">// 检查当前GC节点是否是通道的GC命令队列的头节点</span><br>    <span class="hljs-keyword">if</span> (gc_node == ssd-&gt;channel_head[channel].gc_command) &#123;<br>        <span class="hljs-comment">// 如果是头节点，则将通道的GC命令队列头指向下一个节点</span><br>        ssd-&gt;channel_head[channel].gc_command = gc_node-&gt;next_node;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 如果不是头节点，则遍历GC命令队列，找到要删除的节点</span><br>        gc_pre = ssd-&gt;channel_head[channel].gc_command;<br>        <span class="hljs-keyword">while</span> (gc_pre-&gt;next_node != <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">if</span> (gc_pre-&gt;next_node == gc_node) &#123;<br>                <span class="hljs-comment">// 找到要删除的节点，将前一个节点的 `next_node` 指针指向当前节点的下一个节点</span><br>                gc_pre-&gt;next_node = gc_node-&gt;next_node;<br>                <span class="hljs-keyword">break</span>;  <span class="hljs-comment">// 删除成功，退出循环</span><br>            &#125;<br>            gc_pre = gc_pre-&gt;next_node;  <span class="hljs-comment">// 移动到下一个节点</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 释放要删除的GC节点的内存</span><br>    free(gc_node);<br>    gc_node = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-comment">// 减少SSD的GC请求计数</span><br>    ssd-&gt;gc_request--;<br><br>    <span class="hljs-comment">// 返回成功状态</span><br>    <span class="hljs-keyword">return</span> SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="gc-direct-fast-erase函数：-1"><a href="#gc-direct-fast-erase函数：-1" class="headerlink" title="gc_direct_fast_erase函数："></a>gc_direct_fast_erase函数：</h3><p>gc_for_channel调用，检查是否支持高级命令，如果支持则设置flag等于true但不进行处理，如果不支持则进行擦除处理</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// 执行GC的normal模式下的快速擦除操作</span><br><span class="hljs-keyword">int</span> gc_direct_fast_erase(<span class="hljs-keyword">struct</span> ssd_info *ssd, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> channel, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> chip, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> die, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> plane) &#123;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> lv_die = <span class="hljs-number">0</span>, lv_plane = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 局部变量，用于避免重名</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> interleaver_flag = <span class="hljs-literal">FALSE</span>, muilt_plane_flag = <span class="hljs-literal">FALSE</span>;  <span class="hljs-comment">// 标志位，用于跟踪高级命令是否可用</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> normal_erase_flag = <span class="hljs-literal">TRUE</span>;  <span class="hljs-comment">// 标志位，表示执行普通的擦除操作</span><br><br>    <span class="hljs-keyword">struct</span> direct_erase *direct_erase_node1 = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">// 指向直接擦除节点的指针1</span><br>    <span class="hljs-keyword">struct</span> direct_erase *direct_erase_node2 = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">// 指向直接擦除节点的指针2</span><br><br>    <span class="hljs-comment">/********************************************************************************************************</span><br><span class="hljs-comment">    * 检查是否支持 TWOPLANE 高级命令。</span><br><span class="hljs-comment">    * 如果支持，则在相应的 channel、chip、die 中的两个不同的 plane 上找到可执行 TWOPLANE 操作的 block，</span><br><span class="hljs-comment">    * 并将 muilt_plane_flag 置为 TRUE。</span><br><span class="hljs-comment">    *********************************************************************************************************/</span><br>    <span class="hljs-keyword">if</span> ((ssd-&gt;parameter-&gt;advanced_commands &amp; AD_TWOPLANE) == AD_TWOPLANE) &#123;<br>        printf(<span class="hljs-string">&quot;Advanced commands are NOT supported.\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> FAILURE;  <span class="hljs-comment">// 如果支持 TWOPLANE，但当前函数不处理，返回失败</span><br>    &#125;<br><br>    <span class="hljs-comment">/******************************************************************************************</span><br><span class="hljs-comment">    * 检查是否支持 INTERLEAVE 高级命令。</span><br><span class="hljs-comment">    * 如果支持，则在相应的 channel 和 chip 中找到两个可以执行 INTERLEAVE 操作的 block，</span><br><span class="hljs-comment">    * 并将 interleaver_flag 置为 TRUE。</span><br><span class="hljs-comment">    ******************************************************************************************/</span><br>    <span class="hljs-keyword">if</span> ((ssd-&gt;parameter-&gt;advanced_commands &amp; AD_INTERLEAVE) == AD_INTERLEAVE) &#123;<br>        printf(<span class="hljs-string">&quot;Advanced commands are NOT supported.\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> FAILURE;  <span class="hljs-comment">// 如果支持 INTERLEAVE，但当前函数不处理，返回失败</span><br>    &#125;<br><br>    <span class="hljs-comment">/******************************************************************************************</span><br><span class="hljs-comment">    * 执行普通擦除操作。</span><br><span class="hljs-comment">    * 如果当前 plane 可以执行普通的擦除命令 (NORMAL)，则执行快速擦除操作。</span><br><span class="hljs-comment">    * 如果成功，返回 SUCCESS，否则返回 FAILURE 表示擦除失败。</span><br><span class="hljs-comment">    ******************************************************************************************/</span><br>    <span class="hljs-keyword">if</span> (normal_erase_flag == <span class="hljs-literal">TRUE</span>) &#123;  <span class="hljs-comment">// 检查是否进行普通擦除操作</span><br>        <span class="hljs-keyword">if</span> (fast_erase_planes(ssd, channel, chip, die, plane, NORMAL) == SUCCESS) &#123;<br>            <span class="hljs-keyword">return</span> SUCCESS;  <span class="hljs-comment">// 成功擦除，返回 SUCCESS</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> FAILURE;  <span class="hljs-comment">// 目标 plane 没有可以直接擦除的 block，返回失败</span><br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        printf(<span class="hljs-string">&quot;Wrong command for fast gc.\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> FAILURE;  <span class="hljs-comment">// 非法命令，返回失败</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="fast-erase-planes函数："><a href="#fast-erase-planes函数：" class="headerlink" title="fast_erase_planes函数："></a>fast_erase_planes函数：</h3><p>gc_direct_fast_erase函数调用，执行快速擦除，即进行一个条件判断然后直接使用normal模式</p>
<p>寻找即半个物理块的 LSB 页可用而且半个物理块的 MSB 页失效的原因是：</p>
<p>​    遍历块的目的是为了找到一个适合快速擦除的块，这些块具备以下特点：</p>
<ul>
<li>LSB 页未使用，意味着该块还有潜力被快速擦除。</li>
<li>MSB 页数据无效，减少了数据迁移的需求。</li>
<li>未标记为 <code>fast_erase</code>，表明该块可以被快速处理。</li>
</ul>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-comment">// 执行快速擦除操作的函数，支持普通命令 NORMAL</span><br>Status fast_erase_planes(struct ssd_info * ssd, unsigned int channel, unsigned int chip, unsigned int die1, unsigned int plane1, unsigned int command) &#123;<br>    unsigned int die = <span class="hljs-number">0</span>;<br>    unsigned int plane = <span class="hljs-number">0</span>;<br>    unsigned int <span class="hljs-keyword">block</span> = <span class="hljs-number">0</span>;<br>    struct direct_erase *direct_erase_node = NULL; <span class="hljs-comment">// 指向直接擦除节点的指针</span><br>    unsigned int block0 = <span class="hljs-number">0</span>xffffffff;  <span class="hljs-comment">// 初始化 block0，未使用</span><br>    unsigned int block1 = -<span class="hljs-number">1</span>;  <span class="hljs-comment">// 用于存储符合擦除条件的物理块</span><br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    // 如果没有 fast_erase_node 或者命令不是 NORMAL，则返回错误</span><br><span class="hljs-comment">    if ((ssd-&gt;channel_head[channel].chip_head[chip].die_head[die1].plane_head[plane1].fast_erase_node == NULL) || (command != NORMAL)) &#123;</span><br><span class="hljs-comment">        return ERROR;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    */</span><br><br>    <span class="hljs-comment">/************************************************************************************************************</span><br><span class="hljs-comment">    * 在执行擦除操作之前，通道和芯片的状态被设置为 CHANNEL_TRANSFER 和 CHIP_ERASE_BUSY，表示正在传送擦除命令。</span><br><span class="hljs-comment">    * 下一状态将分别是 CHANNEL_IDLE 和 CHIP_IDLE。</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * 检查目标 plane1 中的每个块，寻找符合以下条件的物理块 block1：</span><br><span class="hljs-comment">    * 1. free_msb_num 等于 page_block/2（即半个物理块的 LSB 页可用）。</span><br><span class="hljs-comment">    * 2. invalid_lsb_num 等于 page_block/2（即半个物理块的 MSB 页失效）。</span><br><span class="hljs-comment">    * 3. fast_erase 标志不为 TRUE（即该物理块未被标记为快速擦除）。</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * 如果找到符合条件的 block1，则标记其为 fast_erase（设置 fast_erase 为 TRUE）。</span><br><span class="hljs-comment">    *************************************************************************************************************/</span><br>    struct plane_info candidate_plane;<br>    <span class="hljs-function"><span class="hljs-title">candidate_plane</span> = ssd-&gt;</span>channel_head[channel].chip_head[chip].die_head[die1].plane_head[plane1];  <span class="hljs-comment">// 获取目标 plane 的信息</span><br><br>    <span class="hljs-function"><span class="hljs-title">while</span> (<span class="hljs-keyword">block</span> &lt; ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span>block_plane) &#123;  <span class="hljs-comment">// 遍历 plane 中的每个块</span><br>        <span class="hljs-function"><span class="hljs-title">if</span> ((candidate_plane.blk_head[<span class="hljs-keyword">block</span>].free_msb_num == ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span>page_block / <span class="hljs-number">2</span>) &amp;&amp; <br>            (<span class="hljs-function"><span class="hljs-title">candidate_plane</span>.blk_head[<span class="hljs-keyword">block</span>].invalid_lsb_num == ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span>page_block / <span class="hljs-number">2</span>) &amp;&amp; <br>            (candidate_plane.blk_head[<span class="hljs-keyword">block</span>].fast_erase != TRUE)) &#123;<br>            block1 = <span class="hljs-keyword">block</span>;  <span class="hljs-comment">// 找到符合条件的块</span><br>            break;<br>        &#125;<br>        <span class="hljs-keyword">block</span>++;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果没有找到符合条件的 block1，则返回 FAILURE</span><br>    <span class="hljs-keyword">if</span> (block1 == -<span class="hljs-number">1</span>) &#123;<br>        return FAILURE;<br>    &#125;<br><br>    <span class="hljs-comment">// 设置通道和芯片的状态，表示正在执行擦除命令</span><br>    <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span>channel_head[channel].current_state = CHANNEL_TRANSFER;<br>    <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[channel].current_time = ssd-&gt;</span>current_time;<br>    <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span>channel_head[channel].next_state = CHANNEL_IDLE;<br><br>    <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span>channel_head[channel].chip_head[chip].current_state = CHIP_ERASE_BUSY;<br>    <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[channel].chip_head[chip].current_time = ssd-&gt;</span>current_time;<br>    <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span>channel_head[channel].chip_head[chip].next_state = CHIP_IDLE;<br><br>    <span class="hljs-comment">/******************************************************************************************</span><br><span class="hljs-comment">    * 如果命令是 NORMAL，执行普通擦除操作：</span><br><span class="hljs-comment">    * 1. 标记找到的 block1 为 fast_erase（表示该块可以进行快速擦除）。</span><br><span class="hljs-comment">    * 2. 执行擦除操作，并更新状态预测时间。</span><br><span class="hljs-comment">    ******************************************************************************************/</span><br>    <span class="hljs-keyword">if</span> (command == NORMAL) &#123;  <span class="hljs-comment">// 检查是否为普通命令</span><br>        candidate_plane.blk_head[block1].fast_erase = TRUE;  <span class="hljs-comment">// 标记该块为 fast_erase</span><br>        erase_operation(ssd, channel, chip, die1, plane1, block1);  <span class="hljs-comment">// 执行擦除操作</span><br><br>        <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span>fast_gc_count++;  <span class="hljs-comment">// 增加快速GC计数</span><br>        <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[channel].next_state_predict_time = ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">current_time</span> + 5 * ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span>time_characteristics.tWC;<br>        <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span>channel_head[channel].chip_head[chip].next_state_predict_time = <br>            <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span>channel_head[channel].next_state_predict_time + <br>            <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span>time_characteristics.tWB + <br>            <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span>time_characteristics.tBERS;<br>        return SUCCESS;  <span class="hljs-comment">// 返回成功状态</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        printf(<span class="hljs-string">&quot;Wrong Command for fast gc.\n&quot;</span>);<br>        return ERROR;  <span class="hljs-comment">// 非法命令，返回错误</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="uninterrupt-fast-gc函数："><a href="#uninterrupt-fast-gc函数：" class="headerlink" title="uninterrupt_fast_gc函数："></a>uninterrupt_fast_gc函数：</h3><p>gc_for_channel函数调用，该函数根据优先级和阈值进行块选择，并对选择出来的，能进行垃圾回收的块进行垃圾回收</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><code class="hljs xl"> <span class="hljs-comment">// 首先，根据优先级和设置的阈值，选择一个失效的块（block1）作为垃圾回收的目标。如果找不到满足条件的块，则直接返回成功，不执行垃圾回收。</span><br> <span class="hljs-comment">// 根据优先级判断是否满足执行垃圾回收的条件，如果不满足，也直接返回成功，不执行垃圾回收。</span><br> <span class="hljs-comment">// 对选定的目标块（block1）进行垃圾回收操作，将其中的有效页移动到其他块中，并进行擦除操作。</span><br> <span class="hljs-comment">// 更新相关状态信息，如通道状态、芯片状态、垃圾回收计数等。</span><br> <span class="hljs-comment">// 计算通道和芯片的下一个状态预测时间，以便进入下一个状态。</span><br>int uninterrupt_fast_gc(struct ssd_info *ssd,unsigned int channel,unsigned int chip,unsigned int die,unsigned int plane,unsigned int priority)<br>&#123;<br>    <span class="hljs-comment">//printf(&quot;===&gt;Enter uninterrupt_fast_gc.\n&quot;);</span><br>    unsigned int i=<span class="hljs-number">0</span>, invalid_page=<span class="hljs-number">0</span>;<br>    unsigned int <span class="hljs-keyword">block</span>, block1, active_block, transfer_size, free_page, page_move_count=<span class="hljs-number">0</span>; <span class="hljs-comment">/* 记录失效页最多的块号 */</span><br>    struct local *location = NULL;<br>    unsigned int total_invalid_page_num = <span class="hljs-number">0</span>;<br><br>    block1 = -<span class="hljs-number">1</span>; <span class="hljs-comment">// 用于记录找到的符合条件的块号</span><br>    <span class="hljs-keyword">block</span> = <span class="hljs-number">0</span>; <span class="hljs-comment">// 遍历plane中的块</span><br>    struct plane_info candidate_plane;<br>    <span class="hljs-function"><span class="hljs-title">candidate_plane</span> = ssd-&gt;</span>channel_head[channel].chip_head[chip].die_head[die].plane_head[plane];<br>    unsigned int invalid_lsb_num = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 找到无效的页数最多的块</span><br>    <span class="hljs-function"><span class="hljs-title">while</span>(<span class="hljs-keyword">block</span> &lt; ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span>block_plane - <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">//printf(&quot;Enter while, %d\n&quot;, block);</span><br>        <span class="hljs-function"><span class="hljs-title">if</span>((candidate_plane.blk_head[<span class="hljs-keyword">block</span>].free_msb_num == ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span>page_block / <span class="hljs-number">2</span>) &amp;&amp; <br>           (candidate_plane.blk_head[<span class="hljs-keyword">block</span>].fast_erase != TRUE)) &#123; <br>            <span class="hljs-comment">// 检查块中是否没有可用的低页free_lsb_num，并且invalid_lsb_num最大</span><br>            <span class="hljs-keyword">if</span>(candidate_plane.blk_head[<span class="hljs-keyword">block</span>].free_lsb_num == <span class="hljs-number">0</span> &amp;&amp; <br>               candidate_plane.blk_head[<span class="hljs-keyword">block</span>].invalid_lsb_num &gt; invalid_lsb_num) &#123;<br>                block1 = <span class="hljs-keyword">block</span>; <span class="hljs-comment">// 记录该块号</span><br>                invalid_lsb_num = candidate_plane.blk_head[<span class="hljs-keyword">block</span>].invalid_lsb_num; <span class="hljs-comment">// 记录无效低页数</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">block</span>++;<br>    &#125;<br><br>    <span class="hljs-comment">// 若没有找到满足条件的块，则直接返回成功（step1）</span><br>    <span class="hljs-keyword">if</span> (block1 == -<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">//printf(&quot;====&gt;No block has invalid LSB page??\n&quot;);</span><br>        return SUCCESS;<br>    &#125;<br><br>    <span class="hljs-comment">// 根据优先级判断是否满足执行GC的条件 （step2）</span><br>    <span class="hljs-keyword">if</span>(priority == GC_FAST_UNINTERRUPT_EMERGENCY) &#123;<br>        <span class="hljs-comment">// 在紧急GC模式下，若无效低页数量不足，返回成功</span><br>        <span class="hljs-function"><span class="hljs-title">if</span>(candidate_plane.blk_head[block1].invalid_lsb_num &lt; ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">page_block</span> / 2 * ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span>fast_gc_filter_2) &#123;<br>            return SUCCESS;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(priority == GC_FAST_UNINTERRUPT) &#123;<br>        <span class="hljs-comment">// 普通GC模式下，若无效低页数量不足，返回成功</span><br>        <span class="hljs-function"><span class="hljs-title">if</span>(candidate_plane.blk_head[block1].invalid_lsb_num &lt; ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">page_block</span> / 2 * ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span>fast_gc_filter_1) &#123;<br>            return SUCCESS;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(priority == GC_FAST_UNINTERRUPT_IDLE) &#123;<br>        <span class="hljs-comment">// 空闲状态下的GC模式，若无效低页数量不足，返回成功</span><br>        <span class="hljs-function"><span class="hljs-title">if</span>(candidate_plane.blk_head[block1].invalid_lsb_num &lt; ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">page_block</span> / 2 * ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span>fast_gc_filter_idle) &#123;<br>            return SUCCESS;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span>idle_fast_gc_count++;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        printf(<span class="hljs-string">&quot;GC_FAST ERROR. PARAMETERS WRONG.\n&quot;</span>);<br>        return SUCCESS;<br>    &#125;<br>（step3）<br>    free_page = <span class="hljs-number">0</span>; <span class="hljs-comment">// 初始化空闲页数</span><br>    struct blk_info candidate_block;<br>    candidate_block = candidate_plane.blk_head[block1];<br>    <span class="hljs-comment">// 标记找到的块为快速擦除状态</span><br>    <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span>channel_head[channel].chip_head[chip].die_head[die].plane_head[plane].blk_head[block1].fast_erase = TRUE;<br><br>    <span class="hljs-comment">// 逐个检查每个page，如果有有效数据的page需要移动到其他地方存储</span><br>    <span class="hljs-function"><span class="hljs-title">for</span>(i = 0; i &lt; ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span>page_block; i++) &#123;<br>        <span class="hljs-keyword">if</span>(candidate_block.page_head[i].valid_state &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">/* 该页是有效页，需要copyback操作 */</span><br>            location = (struct local *)malloc(sizeof(struct local));<br>            alloc_assert(location, <span class="hljs-string">&quot;location&quot;</span>);<br>            memset(location, <span class="hljs-number">0</span>, sizeof(struct local));<br><br>            <span class="hljs-function"><span class="hljs-title">location</span>-&gt;</span>channel = channel;<br>            <span class="hljs-function"><span class="hljs-title">location</span>-&gt;</span>chip = chip;<br>            <span class="hljs-function"><span class="hljs-title">location</span>-&gt;</span>die = die;<br>            <span class="hljs-function"><span class="hljs-title">location</span>-&gt;</span>plane = plane;<br>            <span class="hljs-function"><span class="hljs-title">location</span>-&gt;</span><span class="hljs-keyword">block</span> = block1;<br>            <span class="hljs-function"><span class="hljs-title">location</span>-&gt;</span><span class="hljs-built_in">page</span> = i;<br><br>            move_page(ssd, location, &amp;transfer_size); <span class="hljs-comment">/* 真实的move_page操作 */</span><br>            page_move_count++;<br><br>            free(location);<br>            location = NULL;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 完成页面迁移后，执行块的擦除操作</span><br>    erase_operation(ssd, channel, chip, die, plane, block1);<br><br>    <span class="hljs-comment">// 更新GC和芯片的状态信息</span><br>    <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span>channel_head[channel].current_state = CHANNEL_GC;<br>    <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[channel].current_time = ssd-&gt;</span>current_time;<br>    <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span>channel_head[channel].next_state = CHANNEL_IDLE;<br>    <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span>channel_head[channel].chip_head[chip].current_state = CHIP_ERASE_BUSY;<br>    <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[channel].chip_head[chip].current_time = ssd-&gt;</span>current_time;<br>    <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span>channel_head[channel].chip_head[chip].next_state = CHIP_IDLE;<br><br>    <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span>fast_gc_count++;<br><br>    <span class="hljs-comment">// 根据是否支持COPYBACK高级命令计算channel和chip的下个状态预测时间</span><br>    <span class="hljs-function"><span class="hljs-title">if</span> ((ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span>advanced_commands &amp; AD_COPYBACK) == AD_COPYBACK) &#123;<br>        <span class="hljs-function"><span class="hljs-title">if</span> (ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span>greed_CB_ad == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[channel].next_state_predict_time = ssd-&gt;</span>current_time + <br>                <span class="hljs-function"><span class="hljs-title">page_move_count</span> * (7 * ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span>time_characteristics.tWC + <br>                <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">time_characteristics</span>.tR + 7 * ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span>time_characteristics.tWC + <br>                <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span>time_characteristics.tPROG);<br>            <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span>channel_head[channel].chip_head[chip].next_state_predict_time = <br>                <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[channel].next_state_predict_time + ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span>time_characteristics.tBERS;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[channel].next_state_predict_time = ssd-&gt;</span>current_time + <br>            <span class="hljs-function"><span class="hljs-title">page_move_count</span> * (7 * ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span>time_characteristics.tWC + <br>            <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">time_characteristics</span>.tR + 7 * ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span>time_characteristics.tWC + <br>            <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span>time_characteristics.tPROG) + transfer_size * SECTOR * <br>            (<span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">time_characteristics</span>.tWC + ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span>time_characteristics.tRC);<br>        <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span>channel_head[channel].chip_head[chip].next_state_predict_time = <br>            <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[channel].next_state_predict_time + ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span>time_characteristics.tBERS;<br>    &#125;<br><br>    <span class="hljs-comment">//printf(&quot;===&gt;Exit uninterrupt_fast_gc Successfully.\n&quot;);</span><br>    return <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="decide-gc-invoke函数："><a href="#decide-gc-invoke函数：" class="headerlink" title="decide_gc_invoke函数："></a>decide_gc_invoke函数：</h3><p>判断是否有子请求需要channel，若果没有返回1就可以发送gc操作，如果有返回0，就不能执行gc操作，gc操作被中断</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs xl">int decide_gc_invoke(struct ssd_info *ssd, unsigned int channel)<br>&#123;<br>    struct sub_request *sub; <span class="hljs-comment">// 指向子请求的指针</span><br>    struct local *location;  <span class="hljs-comment">// 存储当前子请求的物理位置</span><br><br>    <span class="hljs-comment">// 检查该通道是否有读或写子请求</span><br>    <span class="hljs-function"><span class="hljs-title">if</span> ((ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[channel].subs_r_head == NULL) &amp;&amp; (ssd-&gt;</span>channel_head[channel].subs_w_head == NULL))    <br>    &#123;<br>        <span class="hljs-comment">// 如果通道没有读写子请求，表示当前通道空闲，GC操作可以执行</span><br>        return <span class="hljs-number">1</span>; <span class="hljs-comment">// 表示此时通道空闲，可以执行GC操作</span><br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-comment">// 检查通道是否有写子请求</span><br>        <span class="hljs-function"><span class="hljs-title">if</span> (ssd-&gt;</span>channel_head[channel].subs_w_head != NULL)<br>        &#123;<br>            <span class="hljs-comment">// 有写子请求占用通道，GC操作不能执行</span><br>            return <span class="hljs-number">0</span>; <span class="hljs-comment">// 返回0，表示不允许执行GC操作</span><br>        &#125;<br>        <span class="hljs-comment">// 如果没有写请求，检查是否有读子请求</span><br>        <span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span> (ssd-&gt;</span>channel_head[channel].subs_r_head != NULL)<br>        &#123;<br>            <span class="hljs-comment">// 遍历通道上的所有读子请求</span><br>            <span class="hljs-function"><span class="hljs-title">sub</span> = ssd-&gt;</span>channel_head[channel].subs_r_head;<br>            <span class="hljs-keyword">while</span> (sub != NULL)<br>            &#123;<br>                <span class="hljs-comment">// 如果当前子请求的状态是等待状态（SR_WAIT），且其目标die处于空闲状态，则不允许执行GC操作</span><br>                <span class="hljs-function"><span class="hljs-title">if</span> (sub-&gt;</span>current_state == SR_WAIT)<br>                &#123;<br>                    <span class="hljs-function"><span class="hljs-title">location</span> = find_location(ssd, sub-&gt;</span>ppn); <span class="hljs-comment">// 获取子请求的物理位置</span><br><br>                    <span class="hljs-comment">// 如果当前目标chip处于空闲状态，或下一个状态是空闲且预计时间已到达，不能执行GC操作</span><br>                    <span class="hljs-function"><span class="hljs-title">if</span> ((ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[location-&gt;</span><span class="hljs-function"><span class="hljs-title">channel</span>].chip_head[location-&gt;</span>chip].current_state == CHIP_IDLE) || <br>                        ((<span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[location-&gt;</span><span class="hljs-function"><span class="hljs-title">channel</span>].chip_head[location-&gt;</span>chip].next_state == CHIP_IDLE) &amp;&amp; <br>                         (<span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[location-&gt;</span><span class="hljs-function"><span class="hljs-title">channel</span>].chip_head[location-&gt;</span><span class="hljs-function"><span class="hljs-title">chip</span>].next_state_predict_time &lt;= ssd-&gt;</span>current_time)))<br>                    &#123;<br>                        <span class="hljs-comment">// 释放内存，返回0，表示不允许执行GC操作</span><br>                        free(location);<br>                        location = NULL;<br>                        return <span class="hljs-number">0</span>;<br>                    &#125;<br>                    <span class="hljs-comment">// 释放内存</span><br>                    free(location);<br>                    location = NULL;<br>                &#125;<br>                <span class="hljs-comment">// 如果当前子请求的下一个状态是数据传输（SR_R_DATA_TRANSFER），且预计传输时间已经到达，则不能执行GC操作</span><br>                <span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span> (sub-&gt;</span>next_state == SR_R_DATA_TRANSFER)<br>                &#123;<br>                    <span class="hljs-function"><span class="hljs-title">location</span> = find_location(ssd, sub-&gt;</span>ppn); <span class="hljs-comment">// 获取子请求的物理位置</span><br><br>                    <span class="hljs-comment">// 如果目标chip的下一个状态预测时间已到达，则不允许执行GC操作</span><br>                    <span class="hljs-function"><span class="hljs-title">if</span> (ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[location-&gt;</span><span class="hljs-function"><span class="hljs-title">channel</span>].chip_head[location-&gt;</span><span class="hljs-function"><span class="hljs-title">chip</span>].next_state_predict_time &lt;= ssd-&gt;</span>current_time)<br>                    &#123;<br>                        <span class="hljs-comment">// 释放内存，返回0，表示不允许执行GC操作</span><br>                        free(location);<br>                        location = NULL;<br>                        return <span class="hljs-number">0</span>;<br>                    &#125;<br>                    <span class="hljs-comment">// 释放内存</span><br>                    free(location);<br>                    location = NULL;<br>                &#125;<br><br>                <span class="hljs-comment">// 遍历下一个子请求节点</span><br>                <span class="hljs-function"><span class="hljs-title">sub</span> = sub-&gt;</span>next_node;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 没有子请求占用通道，GC操作可以执行</span><br>        return <span class="hljs-number">1</span>; <span class="hljs-comment">// 返回1，表示可以执行GC操作</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="interrupt-gc函数："><a href="#interrupt-gc函数：" class="headerlink" title="interrupt_gc函数："></a>interrupt_gc函数：</h3><p>该函数被gc_for_channel调用，函数用于可以执行中断GC时，负责在指定的通道、芯片、die、plane上寻找无效页最多的块，将有效页移动到其他地方，并对全是无效页的块进行擦除。</p>
<p>目标的plane没有可以直接删除的block，需要寻找目标擦除块后再实施擦除操作，用在可以中断的gc操作中，成功删除一个块，返回1，没有删除一个块返回-1，在这个函数中，不用考虑目标channel,die是否是空闲的。</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs xl">int interrupt_gc(struct ssd_info *ssd, unsigned int channel, unsigned int chip, unsigned int die, unsigned int plane, struct gc_operation *gc_node)<br>&#123;<br>    unsigned int i, <span class="hljs-keyword">block</span>, active_block, transfer_size, invalid_page = <span class="hljs-number">0</span>;<br>    struct local *location; <span class="hljs-comment">// 用于存储数据块的位置信息</span><br><br>    <span class="hljs-function"><span class="hljs-title">active_block</span> = ssd-&gt;</span>channel_head[channel].chip_head[chip].die_head[die].plane_head[plane].active_block; <span class="hljs-comment">// 获取当前活跃块</span><br>    transfer_size = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 如果 gc_node-&gt;block 设定超过块数范围，寻找除活跃块以外的无效页最多的块，并将该块挂到 gc_node 上</span><br>    <span class="hljs-function"><span class="hljs-title">if</span> (gc_node-&gt;</span><span class="hljs-function"><span class="hljs-title">block</span> &gt;= ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span>block_plane)<br>    &#123;<br>        <span class="hljs-function"><span class="hljs-title">for</span> (i = 0; i &lt; ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span>block_plane; i++)<br>        &#123;<br>            <span class="hljs-comment">// 排除活跃块，选择无效页数最多的块</span><br>            <span class="hljs-function"><span class="hljs-title">if</span> ((active_block != i) &amp;&amp; (ssd-&gt;</span>channel_head[channel].chip_head[chip].die_head[die].plane_head[plane].blk_head[i].invalid_page_num &gt; invalid_page))<br>            &#123;<br>                <span class="hljs-function"><span class="hljs-title">invalid_page</span> = ssd-&gt;</span>channel_head[channel].chip_head[chip].die_head[die].plane_head[plane].blk_head[i].invalid_page_num;<br>                <span class="hljs-keyword">block</span> = i; <span class="hljs-comment">// 记录无效页最多的块号</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-title">gc_node</span>-&gt;</span><span class="hljs-keyword">block</span> = <span class="hljs-keyword">block</span>; <span class="hljs-comment">// 更新 gc_node 的块号</span><br>    &#125;<br><br>    <span class="hljs-comment">// 如果块中不全是无效页，需要进行数据移动（Copyback）</span><br>    <span class="hljs-function"><span class="hljs-title">if</span> (ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[channel].chip_head[chip].die_head[die].plane_head[plane].blk_head[gc_node-&gt;</span><span class="hljs-function"><span class="hljs-title">block</span>].invalid_page_num != ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span>page_block)<br>    &#123;<br>        <span class="hljs-comment">// 遍历块中的每一页</span><br>        <span class="hljs-function"><span class="hljs-title">for</span> (i = gc_node-&gt;</span><span class="hljs-function"><span class="hljs-title">page</span>; i &lt; ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span>page_block; i++)<br>        &#123;<br>            <span class="hljs-comment">// 如果该页为有效页，需要将其移动到其他地方</span><br>            <span class="hljs-function"><span class="hljs-title">if</span> (ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[channel].chip_head[chip].die_head[die].plane_head[plane].blk_head[gc_node-&gt;</span><span class="hljs-keyword">block</span>].page_head[i].valid_state &gt; <span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-comment">// 分配内存并存储当前页的位置信息</span><br>                location = (struct local *)malloc(sizeof(struct local));<br>                alloc_assert(location, <span class="hljs-string">&quot;location&quot;</span>);<br>                memset(location, <span class="hljs-number">0</span>, sizeof(struct local));<br><br>                <span class="hljs-function"><span class="hljs-title">location</span>-&gt;</span>channel = channel;<br>                <span class="hljs-function"><span class="hljs-title">location</span>-&gt;</span>chip = chip;<br>                <span class="hljs-function"><span class="hljs-title">location</span>-&gt;</span>die = die;<br>                <span class="hljs-function"><span class="hljs-title">location</span>-&gt;</span>plane = plane;<br>                <span class="hljs-function"><span class="hljs-title">location</span>-&gt;</span><span class="hljs-keyword">block</span> = <span class="hljs-keyword">block</span>;<br>                <span class="hljs-function"><span class="hljs-title">location</span>-&gt;</span><span class="hljs-built_in">page</span> = i;<br>                transfer_size = <span class="hljs-number">0</span>;<br><br>                <span class="hljs-comment">// 执行页的移动操作</span><br>                move_page(ssd, location, &amp;transfer_size);<br><br>                <span class="hljs-comment">// 释放内存</span><br>                free(location);<br>                location = NULL;<br><br>                <span class="hljs-function"><span class="hljs-title">gc_node</span>-&gt;</span><span class="hljs-built_in">page</span> = i + <span class="hljs-number">1</span>; <span class="hljs-comment">// 更新 gc_node 页数</span><br>                <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[channel].chip_head[chip].die_head[die].plane_head[plane].blk_head[gc_node-&gt;</span><span class="hljs-keyword">block</span>].invalid_page_num++; <span class="hljs-comment">// 更新无效页计数</span><br><br>                <span class="hljs-comment">// 更新通道和芯片的状态为数据传输状态</span><br>                <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span>channel_head[channel].current_state = CHANNEL_C_A_TRANSFER;<br>                <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[channel].current_time = ssd-&gt;</span>current_time;<br>                <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span>channel_head[channel].next_state = CHANNEL_IDLE;<br>                <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span>channel_head[channel].chip_head[chip].current_state = CHIP_COPYBACK_BUSY;<br>                <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[channel].chip_head[chip].current_time = ssd-&gt;</span>current_time;<br>                <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span>channel_head[channel].chip_head[chip].next_state = CHIP_IDLE;<br><br>                <span class="hljs-comment">// 判断是否启用 COPYBACK 高级命令来优化移动操作时间</span><br>                <span class="hljs-function"><span class="hljs-title">if</span> ((ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span>advanced_commands &amp; AD_COPYBACK) == AD_COPYBACK)<br>                &#123;<br>                    <span class="hljs-comment">// 使用 COPYBACK 命令优化时间计算</span><br>                    <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[channel].next_state_predict_time = ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">current_time</span> + 7 * ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">time_characteristics</span>.tWC + ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">time_characteristics</span>.tR + 7 * ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span>time_characteristics.tWC;<br>                    <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[channel].chip_head[chip].next_state_predict_time = ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[channel].next_state_predict_time + ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span>time_characteristics.tPROG;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    <span class="hljs-comment">// 不使用 COPYBACK 命令，正常计算数据传输时间</span><br>                    <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[channel].next_state_predict_time = ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">current_time</span> + (7 + transfer_size * SECTOR) * ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">time_characteristics</span>.tWC + ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">time_characteristics</span>.tR + (7 + transfer_size * SECTOR) * ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span>time_characteristics.tWC;<br>                    <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[channel].chip_head[chip].next_state_predict_time = ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[channel].next_state_predict_time + ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span>time_characteristics.tPROG;<br>                &#125;<br><br>                <span class="hljs-comment">// 由于尚未完成GC操作，返回0表示继续进行GC操作</span><br>                return <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 如果块中全是无效页，直接执行擦除操作</span><br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-title">erase_operation</span>(ssd, channel, chip, die, plane, gc_node-&gt;</span><span class="hljs-keyword">block</span>); <span class="hljs-comment">// 执行块擦除操作</span><br><br>        <span class="hljs-comment">// 更新通道和芯片状态为擦除状态</span><br>        <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span>channel_head[channel].current_state = CHANNEL_C_A_TRANSFER;<br>        <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[channel].current_time = ssd-&gt;</span>current_time;<br>        <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span>channel_head[channel].next_state = CHANNEL_IDLE;<br>        <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[channel].next_state_predict_time = ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">current_time</span> + 5 * ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span>time_characteristics.tWC;<br><br>        <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span>channel_head[channel].chip_head[chip].current_state = CHIP_ERASE_BUSY;<br>        <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[channel].chip_head[chip].current_time = ssd-&gt;</span>current_time;<br>        <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span>channel_head[channel].chip_head[chip].next_state = CHIP_IDLE;<br>        <span class="hljs-function"><span class="hljs-title">ssd</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[channel].chip_head[chip].next_state_predict_time = ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">channel_head</span>[channel].next_state_predict_time + ssd-&gt;</span><span class="hljs-function"><span class="hljs-title">parameter</span>-&gt;</span>time_characteristics.tBERS;<br><br>        <span class="hljs-comment">// 返回1，表示GC操作已完成，可以将channel上的GC请求节点删除</span><br>        return <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 打印错误提示信息</span><br>    printf(<span class="hljs-string">&quot;there is a problem in interrupt_gc\n&quot;</span>);<br>    return <span class="hljs-number">1</span>; <span class="hljs-comment">// 返回1表示有问题，并结束GC操作</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="get-ppn函数："><a href="#get-ppn函数：" class="headerlink" title="get_ppn函数："></a>get_ppn函数：</h3><p>该函数的功能是 <strong>为SSD中的子请求（<code>sub_request</code>）分配物理页号（PPN）</strong>。具体来说，它负责根据当前通道（<code>channel</code>）、芯片（<code>chip</code>）、晶圆（<code>die</code>）、平面（<code>plane</code>）的状态，找到一个合适的物理位置来存储逻辑页号（<code>lpn</code>）对应的数据，同时更新映射表和其他相关状态。</p>
<p><strong>LSB优先策略：</strong></p>
<ul>
<li>如果启用了<code>lsb_first_allocation</code>，将直接调用<code>get_ppn_lf</code>函数。否则进入后续的常规物理页号（PPN）分配逻辑。</li>
</ul>
<p><strong>参数初始化：</strong></p>
<ul>
<li>获取逻辑页号（<code>lpn</code>）、活跃块（<code>active_block</code>）等操作。</li>
</ul>
<p><strong>活跃块查找：</strong></p>
<ul>
<li>调用<code>find_active_block</code>查找在指定通道、芯片、晶圆和平面下的活跃块，并更新相关状态（如<code>last_write_page</code>）。</li>
</ul>
<p><strong>LSB、MSB、CSB页类型判断：</strong></p>
<ul>
<li>根据当前页号确定其类型（LSB、MSB、CSB），并更新相应的计数器和状态。</li>
</ul>
<p><strong>映射逻辑：</strong></p>
<ul>
<li>如果逻辑页号<code>lpn</code>第一次写入，建立映射关系。否则，更新之前的映射，标记旧页无效，并将新页映射到<code>lpn</code>。</li>
</ul>
<p><strong>物理地址更新：</strong></p>
<ul>
<li>更新子请求的物理地址信息（<code>ppn</code>、<code>location</code>）。</li>
</ul>
<p><strong>计数器更新：</strong></p>
<ul>
<li>逐级更新写入操作的统计计数。</li>
</ul>
<p><strong>GC操作清理：</strong></p>
<ul>
<li>调用<code>delete_gc_node</code>函数清理GC操作节点。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-function">struct ssd_info *<span class="hljs-title">get_ppn</span><span class="hljs-params">(struct ssd_info *ssd, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> channel, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> chip, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> die, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> plane, struct sub_request *sub)</span> </span>&#123;<br>    <span class="hljs-comment">// 如果设置了lsb优先策略，则直接调用get_ppn_lf</span><br>    <span class="hljs-keyword">if</span> (ssd-&gt;parameter-&gt;lsb_first_allocation == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> get_ppn_lf(ssd, channel, chip, die, plane, sub);<br>        <span class="hljs-comment">// 如果进入涡轮模式，可能在此处调用加速写入机制（此处注释掉）</span><br>        <span class="hljs-comment">// if ((rand() % 100) &lt; ssd-&gt;parameter-&gt;turbo_mode_factor) &#123;</span><br>        <span class="hljs-comment">//     printf(&quot;turbo write\n...&quot;);</span><br>        <span class="hljs-comment">//     return get_ppn_lf(ssd, channel, chip, die, plane, sub);</span><br>        <span class="hljs-comment">// &#125;</span><br>    &#125;<br><br>    <span class="hljs-comment">// 获取所需参数的变量初始化</span><br>    <span class="hljs-comment">//下面的就跟get_ppn_lf后半段一样了，找活跃块，找lpn对应的ppn，标记失效页，新增gc节点等等</span><br>    <span class="hljs-keyword">int</span> old_ppn = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> ppn, lpn, full_page;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> active_block;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> block;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> page, flag = <span class="hljs-number">0</span>, flag1 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> old_state = <span class="hljs-number">0</span>, state = <span class="hljs-number">0</span>, copy_subpage = <span class="hljs-number">0</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">local</span> *<span class="hljs-title">location</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">direct_erase</span> *<span class="hljs-title">direct_erase_node</span>, *<span class="hljs-title">new_direct_erase</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">gc_operation</span> *<span class="hljs-title">gc_node</span>;</span><br><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, k = <span class="hljs-number">0</span>, l = <span class="hljs-number">0</span>, m = <span class="hljs-number">0</span>, n = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> DEBUG</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;enter get_ppn, channel: %d, chip: %d, die: %d, plane: %d\n&quot;</span>, channel, chip, die, plane);<br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br>    <span class="hljs-comment">// 根据subpage_page的大小设置full_page掩码</span><br>    <span class="hljs-keyword">if</span> (ssd-&gt;parameter-&gt;subpage_page == <span class="hljs-number">32</span>) &#123;<br>        full_page = <span class="hljs-number">0xffffffff</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        full_page = ~(<span class="hljs-number">0xffffffff</span> &lt;&lt; ssd-&gt;parameter-&gt;subpage_page);  <span class="hljs-comment">// 左移subpage_page位再取反</span><br>    &#125;<br><br>    lpn = sub-&gt;lpn;  <span class="hljs-comment">// 获取子请求的逻辑页号</span><br><br>    <span class="hljs-comment">/*************************************************************************************</span><br><span class="hljs-comment">    * 调用find_active_block查找在指定channel、chip、die、plane下的活跃块</span><br><span class="hljs-comment">    * 并且更新此channel、chip、die、plane下的last_write_page和free_page_num</span><br><span class="hljs-comment">    **************************************************************************************/</span><br>    <span class="hljs-comment">// 没有活跃块就直接退出</span><br>    <span class="hljs-keyword">if</span> (find_active_block(ssd, channel, chip, die, plane) == FAILURE) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ERROR: there is no free page in channel: %d, chip: %d, die: %d, plane: %d\n&quot;</span>, channel, chip, die, plane);<br>        <span class="hljs-keyword">return</span> ssd;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取当前活跃块，并更新最后写入页和空闲页数</span><br>    active_block = ssd-&gt;channel_head[channel].chip_head[chip].die_head[die].plane_head[plane].active_block;<br>    <span class="hljs-comment">// 最后写入页增加</span><br>    ssd-&gt;channel_head[channel].chip_head[chip].die_head[die].plane_head[plane].blk_head[active_block].last_write_page++;<br>    <span class="hljs-comment">// 空闲页数量减少</span><br>    ssd-&gt;channel_head[channel].chip_head[chip].die_head[die].plane_head[plane].blk_head[active_block].free_page_num--;<br><br>    <span class="hljs-comment">// 如果写入页超过block中的页数，报错</span><br>    <span class="hljs-keyword">if</span> (ssd-&gt;channel_head[channel].chip_head[chip].die_head[die].plane_head[plane].blk_head[active_block].last_write_page &gt;= ssd-&gt;parameter-&gt;page_block) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;error! the last write page larger than the number of pages per block!!\n&quot;</span>);<br>        <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;&#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取需要写入的物理block和page</span><br>    block = active_block;<br>    page = ssd-&gt;channel_head[channel].chip_head[chip].die_head[die].plane_head[plane].blk_head[active_block].last_write_page;<br><br>    <span class="hljs-comment">// 判断当前页是LSB、MSB还是CSB并更新相应的计数</span><br>    <span class="hljs-keyword">if</span> (page % <span class="hljs-number">3</span> == <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// LSB页</span><br>        ssd-&gt;channel_head[channel].chip_head[chip].die_head[die].plane_head[plane].blk_head[active_block].last_write_lsb = page;<br>        ssd-&gt;free_lsb_count--;<br>        ssd-&gt;channel_head[channel].chip_head[chip].die_head[die].plane_head[plane].blk_head[active_block].free_lsb_num--;<br>        ssd-&gt;write_lsb_count++;<br>        ssd-&gt;newest_write_lsb_count++;<br>        sub-&gt;allocated_page_type = TARGET_LSB;  <span class="hljs-comment">// 记录子请求为LSB页</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (page % <span class="hljs-number">3</span> == <span class="hljs-number">2</span>) &#123;  <span class="hljs-comment">// MSB页</span><br>        ssd-&gt;channel_head[channel].chip_head[chip].die_head[die].plane_head[plane].blk_head[active_block].last_write_msb = page;<br>        ssd-&gt;channel_head[channel].chip_head[chip].die_head[die].plane_head[plane].blk_head[active_block].free_msb_num--;<br>        ssd-&gt;write_msb_count++;<br>        ssd-&gt;free_msb_count--;<br>        ssd-&gt;newest_write_msb_count++;<br>        sub-&gt;allocated_page_type = TARGET_MSB;  <span class="hljs-comment">// 记录子请求为MSB页</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// CSB页</span><br>        ssd-&gt;channel_head[channel].chip_head[chip].die_head[die].plane_head[plane].blk_head[active_block].last_write_csb = page;<br>        ssd-&gt;channel_head[channel].chip_head[chip].die_head[die].plane_head[plane].blk_head[active_block].free_csb_num--;<br>        ssd-&gt;write_csb_count++;<br>        ssd-&gt;free_csb_count--;<br>        ssd-&gt;newest_write_csb_count++;<br>        sub-&gt;allocated_page_type = TARGET_CSB;  <span class="hljs-comment">// 记录子请求为CSB页</span><br>    &#125;<br>    <span class="hljs-comment">/*至此，物理地址已找到，现在要做的就是建立映射</span><br><span class="hljs-comment">	首先，看这个物理地址是不是已经有数据了，</span><br><span class="hljs-comment">	若没有，直接把物理地址转换成ppn，然后建立lpn与ppn之间的映射关系即可</span><br><span class="hljs-comment">	若已经有数据了，就需原来的数据置为失效，现有的请求写到其他位置</span><br><span class="hljs-comment">	*/</span><br>    <span class="hljs-comment">// 建立逻辑页到物理页的映射</span><br>    <span class="hljs-keyword">if</span> (ssd-&gt;dram-&gt;<span class="hljs-built_in">map</span>-&gt;map_entry[lpn].state == <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 无映射关系，第一次写入</span><br>        <span class="hljs-keyword">if</span> (ssd-&gt;dram-&gt;<span class="hljs-built_in">map</span>-&gt;map_entry[lpn].pn != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Error in get_ppn()\n&quot;</span>);<br>        &#125;<br>        ssd-&gt;dram-&gt;<span class="hljs-built_in">map</span>-&gt;map_entry[lpn].pn = find_ppn(ssd, channel, chip, die, plane, block, page);  <span class="hljs-comment">// 查找空闲页的ppn</span><br>        ssd-&gt;dram-&gt;<span class="hljs-built_in">map</span>-&gt;map_entry[lpn].state = sub-&gt;state;<br>    &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 逻辑页已映射，更新操作，此时有映射关系，就说明对这个逻辑页进行了更新，需要将原来的页置为失效</span><br>        ppn = ssd-&gt;dram-&gt;<span class="hljs-built_in">map</span>-&gt;map_entry[lpn].pn;  <span class="hljs-comment">// 获取当前ppn</span><br>        location = find_location(ssd, ppn);  <span class="hljs-comment">// 查找ppn的具体位置</span><br>        <span class="hljs-keyword">if</span> (ssd-&gt;channel_head[location-&gt;channel].chip_head[location-&gt;chip].die_head[location-&gt;die].plane_head[location-&gt;plane].blk_head[location-&gt;block].page_head[location-&gt;page].lpn != lpn) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nError in get_ppn()\n&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 将之前的页标记为无效</span><br>        ssd-&gt;channel_head[location-&gt;channel].chip_head[location-&gt;chip].die_head[location-&gt;die].plane_head[location-&gt;plane].blk_head[location-&gt;block].page_head[location-&gt;page].valid_state = <span class="hljs-number">0</span>; <span class="hljs-comment">//表示其中某一页失效，同时标记valid和free状态都为0</span><br>        ssd-&gt;channel_head[location-&gt;channel].chip_head[location-&gt;chip].die_head[location-&gt;die].plane_head[location-&gt;plane].blk_head[location-&gt;block].page_head[location-&gt;page].free_state = <span class="hljs-number">0</span>; <span class="hljs-comment">//表示某一页失效，同时标记valid和free状态都为0</span><br>        ssd-&gt;channel_head[location-&gt;channel].chip_head[location-&gt;chip].die_head[location-&gt;die].plane_head[location-&gt;plane].blk_head[location-&gt;block].page_head[location-&gt;page].lpn = <span class="hljs-number">0</span>; <span class="hljs-comment">//删除该页的映射</span><br>        ssd-&gt;channel_head[location-&gt;channel].chip_head[location-&gt;chip].die_head[location-&gt;die].plane_head[location-&gt;plane].blk_head[location-&gt;block].invalid_page_num++; <span class="hljs-comment">//无效页++</span><br>        <span class="hljs-keyword">if</span> ((location-&gt;page) % <span class="hljs-number">3</span> == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//如果是lsb页，则无效的lsb页++</span><br>            ssd-&gt;channel_head[location-&gt;channel].chip_head[location-&gt;chip].die_head[location-&gt;die].plane_head[location-&gt;plane].blk_head[location-&gt;block].invalid_lsb_num++;<br>        &#125;<br>        <span class="hljs-built_in">free</span>(location);<br>        location = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-comment">// 更新条目数据</span><br>        ssd-&gt;dram-&gt;<span class="hljs-built_in">map</span>-&gt;map_entry[lpn].pn = find_ppn(ssd, channel, chip, die, plane, block, page);<br>        ssd-&gt;dram-&gt;<span class="hljs-built_in">map</span>-&gt;map_entry[lpn].state = (ssd-&gt;dram-&gt;<span class="hljs-built_in">map</span>-&gt;map_entry[lpn].state | sub-&gt;state);<br>    &#125;<br><br>    <span class="hljs-comment">// 更新子请求的物理地址信息</span><br>    sub-&gt;ppn = ssd-&gt;dram-&gt;<span class="hljs-built_in">map</span>-&gt;map_entry[lpn].pn;<br>    sub-&gt;location-&gt;channel = channel;<br>    sub-&gt;location-&gt;chip = chip;<br>    sub-&gt;location-&gt;die = die;<br>    sub-&gt;location-&gt;plane = plane;<br>    sub-&gt;location-&gt;block = active_block;<br>    sub-&gt;location-&gt;page = page;<br><br>    <span class="hljs-comment">// 更新SSD的写入计数器</span><br>    ssd-&gt;program_count++;<br>    ssd-&gt;channel_head[channel].program_count++;<br>    ssd-&gt;channel_head[channel].chip_head[chip].program_count++;<br>    ssd-&gt;channel_head[channel].chip_head[chip].die_head[die].program_count++;<br>    ssd-&gt;channel_head[channel].chip_head[chip].die_head[die].plane_head[plane].program_count++;<br>    ssd-&gt;write_flash_count++;<br><br>    <span class="hljs-keyword">if</span> (ssd-&gt;parameter-&gt;active_write == <span class="hljs-number">0</span>)  <span class="hljs-comment">/* 如果没有主动写入策略，只采用 gc_hard_threshold，并且无法中断 GC 过程 */</span><br>&#123;<br>    <span class="hljs-comment">// 如果平面 (plane) 中的空闲页数量小于 GC 硬阈值，则启动垃圾回收 (GC) 操作</span><br>    <span class="hljs-keyword">if</span> (ssd-&gt;channel_head[channel].chip_head[chip].die_head[die].plane_head[plane].free_page <br>        &lt; (ssd-&gt;parameter-&gt;page_block * ssd-&gt;parameter-&gt;block_plane * ssd-&gt;parameter-&gt;gc_hard_threshold))  <br>    &#123;<br>        <span class="hljs-keyword">int</span> blk_id = <span class="hljs-number">-1</span>;<br><br>        <span class="hljs-comment">// 获取超级块号并检测是否出错</span><br>        <span class="hljs-keyword">if</span> (get_blk(ssd, channel, chip, die, plane, &amp;blk_id) == ERROR) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Error: no blk\n&quot;</span>);<br>            getchar();  <span class="hljs-comment">// 暂停程序用于调试</span><br>        &#125;<br><br>        <span class="hljs-comment">// 遍历每个通道并为其创建 GC 操作节点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ssd-&gt;parameter-&gt;channel_number; i++)<br>        &#123;<br>            <span class="hljs-keyword">int</span> gc_change_block = <span class="hljs-number">-1</span>;<br>            <span class="hljs-comment">// 根据超级块号，找到需要进行垃圾回收的具体块号</span><br>            gc_change_block = find_superblock_change(ssd, i, chip, die, plane, &amp;blk_id);<br><br>            <span class="hljs-comment">// 如果未找到块号，报错并暂停程序</span><br>            <span class="hljs-keyword">if</span> (gc_change_block == ERROR) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Error: no find blk\n&quot;</span>);<br>                getchar();  <span class="hljs-comment">// 暂停程序用于调试</span><br>            &#125;<br><br>            <span class="hljs-comment">// 分配 GC 操作节点，并初始化内存</span><br>            gc_node = (struct gc_operation *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(struct gc_operation));<br>            alloc_assert(gc_node, <span class="hljs-string">&quot;gc_node&quot;</span>);<br>            <span class="hljs-built_in">memset</span>(gc_node, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(struct gc_operation));<br><br>            <span class="hljs-comment">// 初始化 GC 节点的各项参数</span><br>            gc_node-&gt;next_node = <span class="hljs-literal">NULL</span>;<br>            gc_node-&gt;chip = chip;<br>            gc_node-&gt;die = die;<br>            gc_node-&gt;plane = plane;<br>            gc_node-&gt;block = gc_change_block;<br>            gc_node-&gt;page = <span class="hljs-number">0</span>;<br>            gc_node-&gt;state = GC_WAIT;  <span class="hljs-comment">// 设置 GC 状态为等待</span><br>            gc_node-&gt;priority = GC_UNINTERRUPT;  <span class="hljs-comment">// 设置 GC 优先级为不可中断</span><br><br>            <span class="hljs-comment">// 将 GC 节点插入当前通道的 GC 操作链表的头部</span><br>            gc_node-&gt;next_node = ssd-&gt;channel_head[i].gc_command;<br>            ssd-&gt;channel_head[i].gc_command = gc_node;<br><br>            <span class="hljs-comment">// 增加 GC 请求计数</span><br>            ssd-&gt;gc_request++;<br><br>            <span class="hljs-comment">// 检查分配的块是否还有空闲页，若有则程序进入无限循环，用于调试</span><br>            <span class="hljs-keyword">if</span> (ssd-&gt;channel_head[i].chip_head[chip].die_head[die].plane_head[plane].blk_head[gc_change_block].free_page_num &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;---------------\n&quot;</span>);<br>                <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;&#125;  <span class="hljs-comment">// 无限循环，暂停程序用于调试</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 在为 plane 分配完物理页后，检查该 plane 是否有问题，如果出现问题则返回错误</span><br><span class="hljs-keyword">if</span> (check_plane(ssd, channel, chip, die, plane) == FALSE) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Something Wrong Happened.\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> FAILURE;  <span class="hljs-comment">// 返回错误，表明分配失败</span><br>&#125;<br><br><br>    <span class="hljs-keyword">return</span> ssd;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="进度："><a href="#进度：" class="headerlink" title="进度："></a>进度：</h2><p>2024 8-9月：查阅相关文献，阅读论文和SSDSim代码</p>
<p>2024 9-11月：完成baseline代码</p>
<p>2024 11月-2025年2月：调整参数，多次实验</p>
<p>2025年2月-2025年3月：论文初稿</p>
<p>2025年3月-2025年4月：修改并投稿</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/SSD/" class="category-chain-item">SSD</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/SSD/">#SSD</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>SSDSim_code</div>
      <div>http://yoursite.com/2024/07/24/SSDSim源码/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Tspigeon</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年7月24日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/07/18/Open_source/" title="一些好用的开源项目">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">一些好用的开源项目</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/07/23/superblock%20GC%E4%BC%98%E5%8C%96/" title="超级块GC优化">
                        <span class="hidden-mobile">超级块GC优化</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>No pigeon</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>




  
<script src="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/yinghua.js"></script>
<script src="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/love.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":300,"height":600},"mobile":{"show":false},"rect":"opacity:0.7","log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
