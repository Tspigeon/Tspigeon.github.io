

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="https://imgse.com/i/p9yX0tP">
  <link rel="icon" href="https://imgse.com/i/p9yX0tP">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Tspigeon">
  <meta name="keywords" content="">
  
    <meta name="description" content="阅读MQSim代码">
<meta property="og:type" content="article">
<meta property="og:title" content="MQSim源码解析">
<meta property="og:url" content="http://yoursite.com/2024/07/19/MQSim%E6%BA%90%E7%A0%81/index.html">
<meta property="og:site_name" content="Tspigeon &#39;s blog">
<meta property="og:description" content="阅读MQSim代码">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-07-18T16:00:00.000Z">
<meta property="article:modified_time" content="2024-07-23T02:15:09.299Z">
<meta property="article:author" content="Tspigeon">
<meta property="article:tag" content="SSD">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>MQSim源码解析 - Tspigeon &#39;s blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="//cdn.jsdelivr.net/gh/bynotes/texiao/source/css/toubudaziji.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"yoursite.com","root":"/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 100vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>No pigeon</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://s1.ax1x.com/2023/05/12/p9yX20s.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="MQSim源码解析"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-07-19 00:00" pubdate>
          2024年7月19日 凌晨
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          110k 字
        
      </span>
    

    

    
    
  </div>


        
      </div>

      
        <div class="scroll-down-bar">
          <i class="iconfont icon-arrowdown"></i>
        </div>
      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">MQSim源码解析</h1>
            
            
              <div class="markdown-body">
                
                <p>Trace中的数据是一条条的请求</p>
<h1 id="SSD文件"><a href="#SSD文件" class="headerlink" title="SSD文件"></a>SSD文件</h1><h2 id="Address-Mapping-Unit-Page-Level"><a href="#Address-Mapping-Unit-Page-Level" class="headerlink" title="Address_Mapping_Unit_Page_Level:"></a>Address_Mapping_Unit_Page_Level:</h2><p>变量：</p>
<ol>
<li>ideal_mapping_table（理想映射表）：then all the mapping entries are found in the DRAM and there is no need to read mapping entries from flash</li>
</ol>
<p><strong>~Cached_Mapping_Table：</strong>这段代码使用迭代器清理一个<code>std::unordered_map</code> 及 addressMap（地址映射表）中的元素。（析构函数）</p>
<p><strong>Exists_withoutData：</strong>这个函数用于检查给定的<code>streamID</code>和<code>lpa</code>是否存在于<code>addressMap（地址映射表）</code>中，而不涉及任何数据的操作。</p>
<p><strong>Cached_Mapping_Table::Exists：</strong>功能是在地址映射表中检查给定的<code>streamID（请求ID？）</code>和<code>LPA</code>（逻辑地址）是否存在并且其状态是有效的。</p>
<p>代码解析：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">inline <span class="hljs-built_in">bool</span> Cached_Mapping_Table::<span class="hljs-constructor">Exists(<span class="hljs-params">const</span> <span class="hljs-params">stream_id_type</span> <span class="hljs-params">streamID</span>, <span class="hljs-params">const</span> LPA_type <span class="hljs-params">lpa</span>)</span><br>&#123;<br>    <span class="hljs-comment">// 将streamID和lpa转换为唯一的键值</span><br>    LPA_type key = <span class="hljs-constructor">LPN_TO_UNIQUE_KEY(<span class="hljs-params">streamID</span>, <span class="hljs-params">lpa</span>)</span>;<br>    <br>    <span class="hljs-comment">// 在addressMap中查找该键值</span><br>    auto it = addressMap.find(key);<br>    <br>    <span class="hljs-comment">// 如果键值未找到，打印调试信息并返回false</span><br>    <span class="hljs-keyword">if</span> (it<span class="hljs-operator"> == </span>addressMap.<span class="hljs-keyword">end</span><span class="hljs-literal">()</span>) &#123;<br>        <span class="hljs-constructor">DEBUG(<span class="hljs-string">&quot;Address mapping table query - Stream ID:&quot;</span> &lt;&lt; <span class="hljs-params">streamID</span> &lt;&lt; <span class="hljs-string">&quot;, LPA:&quot;</span> &lt;&lt; <span class="hljs-params">lpa</span> &lt;&lt; <span class="hljs-string">&quot;, MISS&quot;</span>)</span><br>        return <span class="hljs-literal">false</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 如果键值找到，但其状态不是VALID，打印调试信息并返回false</span><br>    <span class="hljs-keyword">if</span> (it-&gt;second-&gt;Status != CMTEntryStatus::VALID) &#123;<br>        <span class="hljs-constructor">DEBUG(<span class="hljs-string">&quot;Address mapping table query - Stream ID:&quot;</span> &lt;&lt; <span class="hljs-params">streamID</span> &lt;&lt; <span class="hljs-string">&quot;, LPA:&quot;</span> &lt;&lt; <span class="hljs-params">lpa</span> &lt;&lt; <span class="hljs-string">&quot;, MISS&quot;</span>)</span><br>        return <span class="hljs-literal">false</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 如果键值找到且其状态是VALID，打印调试信息并返回true</span><br>    <span class="hljs-constructor">DEBUG(<span class="hljs-string">&quot;Address mapping table query - Stream ID:&quot;</span> &lt;&lt; <span class="hljs-params">streamID</span> &lt;&lt; <span class="hljs-string">&quot;, LPA:&quot;</span> &lt;&lt; <span class="hljs-params">lpa</span> &lt;&lt; <span class="hljs-string">&quot;, HIT&quot;</span>)</span><br>    return <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>Cached_Mapping_Table::Retrieve_ppa_without_move：</strong>函数用于在地址映射表中检索与给定的<code>streamID</code>和<code>LPA</code>（逻辑页地址）相关联的<code>PPA</code>（物理页地址）</p>
<p><strong>Cached_Mapping_Table::Retrieve_ppa：</strong>用于在地址映射表中检索与给定的<code>streamID</code>和<code>LPA</code>（逻辑页地址）相关联的<code>PPA</code>（物理页地址），并且将访问的条目移动到LRU（最近最少使用）列表的前面，以更新其使用状态。</p>
<p><strong>Cached_Mapping_Table::Get_bitmap_vector_of_written_sectors：</strong>用于获取与给定的<code>streamID</code>和<code>LPA</code>（逻辑页地址）相关联的写入扇区的位图向量。</p>
<p>代码解析：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">page_status_type Cached_Mapping_Table::<span class="hljs-constructor">Get_bitmap_vector_of_written_sectors(<span class="hljs-params">const</span> <span class="hljs-params">stream_id_type</span> <span class="hljs-params">streamID</span>, <span class="hljs-params">const</span> LPA_type <span class="hljs-params">lpn</span>)</span><br>&#123;<br>    <span class="hljs-comment">// 将streamID和lpn转换为唯一的键值</span><br>    LPA_type key = <span class="hljs-constructor">LPN_TO_UNIQUE_KEY(<span class="hljs-params">streamID</span>, <span class="hljs-params">lpn</span>)</span>;<br>    <br>    <span class="hljs-comment">// 在addressMap中查找该键值</span><br>    auto it = addressMap.find(key);<br>    <br>    <span class="hljs-comment">// 断言查找结果必须存在</span><br>    <span class="hljs-keyword">assert</span>(it != addressMap.<span class="hljs-keyword">end</span><span class="hljs-literal">()</span>);<br>    <br>    <span class="hljs-comment">// 断言查找到的项的状态必须是VALID</span><br>    <span class="hljs-keyword">assert</span>(it-&gt;second-&gt;Status<span class="hljs-operator"> == </span>CMTEntryStatus::VALID);<br>    <br>    <span class="hljs-comment">// 返回与该键值关联的写入状态位图</span><br>    return it-&gt;second-&gt;WrittenStateBitmap;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>Cached_Mapping_Table::Update_mapping_info：</strong>用于更新地址映射表中与给定的<code>streamID</code>和<code>LPA</code>（逻辑页地址）相关联的映射信息，包括物理页地址（PPA）、写入状态位图和其他相关信息。</p>
<p><strong>Cached_Mapping_Table::Insert_new_mapping_info：</strong>插入新信息</p>
<p><strong>Cached_Mapping_Table::Is_slot_reserved_for_lpn_and_waiting：</strong>用于检查是否有一个特定的逻辑页地址（LPA）和流ID（streamID）在地址映射表中被保留并处于等待状态。</p>
<p><strong>Cached_Mapping_Table::Reserve_slot_for_lpn：</strong>用于在地址映射表中为给定的逻辑页地址（LPA）和流ID（streamID）保留一个槽并将该键值对加入LRU列表头部。如果地址映射表中已经存在该键值或者表已满，抛出逻辑错误异常。</p>
<p><strong>Cached_Mapping_Table::Evict_one_slot_with_lpn：</strong>用于从地址映射表中移除与给定逻辑页地址（LPA）和流ID（streamID）相关的条目，并从LRU（最近最少使用）列表中删除对应的项。</p>
<p><strong>Cached_Mapping_Table::Evict_one_slot：</strong>用于从缓存中逐出（evict）一个条目。这通常用于缓存管理策略，例如LRU（最近最少使用）策略，当缓存已满或需要腾出空间时，选择一个条目进行逐出。</p>
<p><strong>Cached_Mapping_Table::Is_vaild：</strong>检查特定逻辑页地址（LPA）和流ID（streamID）对应的条目是否有效。</p>
<p><strong>Cached_Mapping_Table::Is_dirty：</strong>用于检查特定逻辑页地址（LPA）和流ID（streamID）对应的条目是否被标记为“脏”（dirty）。在缓存管理中，“脏”通常指示该条目已经被修改，需要写回到持久存储中。</p>
<p><strong>Cached_Mapping_Table::Make_clean：</strong>根据<code>streamID</code>和<code>lpn</code>生成一个唯一键。在地址映射表<code>addressMap</code>中查找该键值。如果找不到该键值，抛出逻辑错误异常，表示请求的槽不存在。如果找到该键值，将条目的<code>Dirty</code>状态设置为<code>false</code>，表示该条目已经被标记为“干净”。</p>
<p>**AddressMappingDomain :**构造函数，用于初始化一个地址映射域对象。构造函数中涉及多个参数，用于配置对象的内部数据结构和属性。</p>
<p><strong>~AddressMappingDomain()：</strong>上面对应的析构函数</p>
<p><strong>AddressMappingDomain::Update_mapping_info：</strong>用于更新逻辑页地址（LPA）到物理页地址（PPA）的映射信息。具体来说，这个函数会根据是否是“ideal_mapping”来决定是否更新<code>Cached_Mapping_Table</code>（CMT）。</p>
<p><strong>AddressMappingDomain::Get_page_status：</strong>用于获取逻辑页地址（LPA）对应的页面状态位图。</p>
<p><strong>AddressMappingDomain::Get_ppa：</strong>用于获取逻辑页地址（LPA）对应的物理页地址（PPA）</p>
<p><strong>AddressMappingDomain::Mapping_entry_accessible：</strong>用于检查逻辑页地址（LPA）对应的映射条目是否可访问。具体来说，这个函数会根据是否是“理想映射”来决定从全局映射表还是从缓存映射表（CMT）中检查映射条目的可访问性。</p>
<p><strong>Address_Mapping_Unit_Page_Level::Setup_triggers()：</strong>方法主要是设置一些触发器，以便在特定事件发生时执行相应的处理逻辑。在这段代码中，它主要连接了一个信号处理函数，以便在闪存控制器处理事务时触发相应的操作。</p>
<p><strong>Address_Mapping_Unit_Page_Level::Store_mapping_table_on_flash_at_start()：</strong>方法负责在模拟开始时将映射表存储到闪存中。该方法首先检查映射表是否已经存储在闪存上，如果没有，它会为每个流分配一个虚拟写事务，并通过调用适当的函数将映射表页写入闪存。</p>
<p><strong>Address_Mapping_Unit_Page_Level::Bring_to_CMT_for_preconditioning：</strong>方法在预处理过程中将逻辑页地址 (LPA) 映射信息加载到缓存映射表 (CMT) 中。如果 LPA 已存在于 CMT 中，则返回已经插入的条目数。如果 CMT 有空闲槽，则直接插入新的映射信息，否则先驱逐一个旧的条目，再插入新的映射信息。</p>
<p><strong>Address_Mapping_Unit_Page_Level::Translate_lpa_to_ppa_and_dispatch：</strong>方法用于将<strong>没有确定PPA以及没有被GC锁定的LPA</strong>转换为物理页地址 (PPA) 并提交到事务调度单元（TSU）</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-literal">void</span> Address_Mapping_Unit_Page_Level::Translate_lpa_to_ppa_and_dispatch(<span class="hljs-keyword">const</span> std::<span class="hljs-keyword">list</span>&lt;NVM_Transaction*&gt;&amp; transactionList)<br>&#123;<br>    <span class="hljs-regexp">// if(readCount &gt;= 1918030)&#123;</span><br><span class="hljs-regexp">    //</span>  std::cout &lt;&lt; std::endl;<br>    <span class="hljs-regexp">// &#125;</span><br><span class="hljs-regexp">    for (std::list&lt;NVM_Transaction*&gt;::const_iterator it = transactionList.begin(); it != transactionList.end(); ) &#123;</span><br><span class="hljs-regexp">        //</span> 检查事务的物理地址是否已确定，以及LPA是否被垃圾回收锁定<br>        <span class="hljs-keyword">if</span> <span class="hljs-function"><span class="hljs-params">(((NVM_Transaction_Flash*)(*<span class="hljs-literal">it</span>))-&gt;Physical_address_determined == <span class="hljs-literal">false</span> &amp;&amp; is_lpa_locked_for_gc((*<span class="hljs-literal">it</span>)-&gt;Stream_id, ((NVM_Transaction_Flash*)(*<span class="hljs-literal">it</span>))-&gt;LPA))</span> &#123;</span><br><span class="hljs-function">            // 处理被垃圾回收锁定的事务</span><br><span class="hljs-function">            <span class="hljs-title">manage_user_transaction_facing_barrier</span><span class="hljs-params">((NVM_Transaction_Flash*)*(<span class="hljs-literal">it</span>++))</span>;</span><br><span class="hljs-function">        &#125; <span class="hljs-title">else</span> <span class="hljs-title">if</span><span class="hljs-params">(((NVM_Transaction_Flash*)(*<span class="hljs-literal">it</span>))-&gt;Physical_address_determined == <span class="hljs-literal">false</span>)</span>&#123;</span><br><span class="hljs-function">            // 查询缓存映射表以确定物理地址</span><br><span class="hljs-function">            <span class="hljs-title">query_cmt</span><span class="hljs-params">((NVM_Transaction_Flash*)(*<span class="hljs-literal">it</span>))</span>;</span><br><span class="hljs-function">            <span class="hljs-title">it</span>++;</span><br><span class="hljs-function">        &#125; <span class="hljs-title">else</span> &#123;</span><br><span class="hljs-function">            // 如果事务的物理地址已经确定，直接移动到下一个事务</span><br><span class="hljs-function">            ++<span class="hljs-title">it</span>;</span><br><span class="hljs-function">        &#125;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">    // 如果事务列表不为空</span><br><span class="hljs-function">    <span class="hljs-title">if</span> <span class="hljs-params">(transactionList.size() &gt; <span class="hljs-number">0</span>)</span> &#123;</span><br><span class="hljs-function">        // 准备提交事务</span><br><span class="hljs-function">        <span class="hljs-title">ftl</span>-&gt;</span>TSU-&gt;Prepare_for_transaction_submit();<br>        <span class="hljs-keyword">for</span> (std::<span class="hljs-keyword">list</span>&lt;NVM_Transaction*&gt;::const_iterator <span class="hljs-literal">it</span> = transactionList.begin(); <span class="hljs-literal">it</span> != transactionList.end(); <span class="hljs-literal">it</span>++) &#123;<br>            <span class="hljs-keyword">if</span> <span class="hljs-function"><span class="hljs-params">(((NVM_Transaction_Flash*)(*<span class="hljs-literal">it</span>))-&gt;Physical_address_determined)</span> &#123;</span><br><span class="hljs-function">                // 提交已确定物理地址的事务</span><br><span class="hljs-function">                <span class="hljs-title">ftl</span>-&gt;</span>TSU-&gt;Submit_transaction(static_cast&lt;NVM_Transaction_Flash*&gt;(*<span class="hljs-literal">it</span>));<br>                <span class="hljs-keyword">if</span> <span class="hljs-function"><span class="hljs-params">(((NVM_Transaction_Flash*)(*<span class="hljs-literal">it</span>))-&gt;Type == Transaction_Type::WRITE)</span> &#123;</span><br><span class="hljs-function">                    <span class="hljs-title">if</span><span class="hljs-params">((((NVM_Transaction_Flash*)(*<span class="hljs-literal">it</span>))-&gt;Source == Transaction_Source_Type::USERIO) || (((NVM_Transaction_Flash*)(*<span class="hljs-literal">it</span>))-&gt;Source == Transaction_Source_Type::CACHE))</span>&#123;</span><br><span class="hljs-function">                        ;</span><br><span class="hljs-function">                    &#125;</span><br><span class="hljs-function">                    // 提交与写事务相关的读事务</span><br><span class="hljs-function">                    <span class="hljs-title">if</span> <span class="hljs-params">(((NVM_Transaction_Flash_WR*)(*<span class="hljs-literal">it</span>))-&gt;RelatedRead != NULL &amp;&amp; ((NVM_Transaction_Flash_WR*)(*<span class="hljs-literal">it</span>))-&gt;RelatedRead != (NVM_Transaction_Flash_RD*)(<span class="hljs-number">1</span>))</span> &#123;</span><br><span class="hljs-function">                        <span class="hljs-title">ftl</span>-&gt;</span>TSU-&gt;Submit_transaction<span class="hljs-function"><span class="hljs-params">(((NVM_Transaction_Flash_WR*)(*<span class="hljs-literal">it</span>))-&gt;RelatedRead)</span>;</span><br><span class="hljs-function">                    &#125;</span><br><span class="hljs-function">                &#125;</span><br><span class="hljs-function">            &#125;</span><br><span class="hljs-function">        &#125;</span><br><span class="hljs-function">        // 调度事务</span><br><span class="hljs-function">        <span class="hljs-title">ftl</span>-&gt;</span>TSU-&gt;Schedule();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>Address_Mapping_Unit_Page_Level::query_cmt：</strong>方法负责查询缓存映射表 (CMT) 以获取给定事务的物理页地址 (PPA)。如果映射条目存在，则使用CMT进行地址转换；否则，处理未命中情况，并可能请求缺失的映射条目。</p>
<p><strong>Address_Mapping_Unit_Page_Level::translate_lpa_to_ppa：</strong>用于LPA存在时使用CMT将LPA转换成PPA</p>
<p><strong>Address_Mapping_Unit_Page_Level::Allocate_address_for_preconditioning：</strong>方法的功能是为预处理分配地址。具体来说，它为每个channel、chip、die和plane创建一个 LPA（逻辑页地址）向量，用于存储要分配的 LPA 列表，然后将逻辑页地址 (LPA) 分配到平面，以及根据平面的实际使用情况和稳态分布调整地址分配（应该是磨损均衡？）。</p>
<p><strong>Address_Mapping_Unit_Page_Level::Allocate_new_page_for_gc：</strong>为GC写操作分配新的物理页面，并更新相应的映射表和统计数据。</p>
<p><strong>Address_Mapping_Unit_Page_Level::allocate_plane_for_preconditioning：</strong>方法负责根据不同的平面分配方案计算并分配适当的物理页地址。CWDP、CWPD、CDWP等，其实就是不同的并行性优先级</p>
<p><strong>Address_Mapping_Unit_Page_Level::allocate_plane_for_user_write：</strong>与上一个类似，按照不同的并行性优先级进行用户写请求的空间分配</p>
<p><strong>Address_Mapping_Unit_Page_Level::allocate_page_in_plane_for_user_write：</strong>函数负责在闪存中为用户写操作分配一个物理页面地址（PPA）。它处理了普通写操作和垃圾回收（GC）写操作，更新映射表并在需要时使旧页面失效。</p>
<p><strong>Address_Mapping_Unit_Page_Level::create_mpv_entry_for_reads：</strong>写入数据到block并将LPA与PPA关联起来。这个函数执行了以下几个主要任务：</p>
<ol>
<li>分配物理页面地址（PPA）</li>
<li>在块中分配页面并设置元数据（channel ID….）</li>
<li>更新映射表</li>
</ol>
<p>这个函数的主要意思其实是写数据，然后创建映射表条目方便以后读</p>
<p><strong>Address_Mapping_Unit_Page_Level::Add_mpvn_data()：</strong>这个函数遍历每个输入流中的每个逻辑页，为每个逻辑页创建映射页版本号（MVPN）数据，并将这些数据添加到全局翻译目录中。添加完成之后通过<code>block_manager-&gt;Program_transaction_serviced(address);</code>函数表示该address已经创建读_entry。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">NVM::FlashMemory::Physical_Page_Address address;<br>page_status_type temp = ~(<span class="hljs-number">0xffffffffffffffff</span> &lt;&lt; (<span class="hljs-keyword">int</span>)sector_no_per_page);<br></code></pre></td></tr></table></figure>

<p><code>temp</code> 是一个位图变量，表示当前页的所有扇区都已被使用。这里使用了位操作来生成全1的位图。</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-title">for</span> (stream_id_<span class="hljs-keyword">type</span> steam = 0; steam &lt; no_of_input_streams; steam++) &#123;<br>    for (<span class="hljs-type">LPA_type</span> lpa = 0; lpa &lt; domains[steam]-&gt;<span class="hljs-type">Total_logical_pages_no</span>; lpa++) &#123;<br></code></pre></td></tr></table></figure>

<p>外层循环遍历每个输入流。</p>
<p>内层循环遍历当前输入流中的每个逻辑页。最后进行if判断对符合条件的lpa进行处理。</p>
<p><strong>Address_Mapping_Unit_Page_Level::Add_vaild_data：</strong>和上一个类似，但是额外接收了一个rate变量，该变量的目的是根据指定的比率（rate）创建逻辑页的映射条目，并为这些条目创建read_entry然后标记这些条目为已处理。最后将rate存在addVaild_中。、</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">for</span><span class="hljs-params">(LPA_type lpa = <span class="hljs-number">0</span>; lpa &lt; domains[steam]-&gt;Total_physical_pages_no * rate; lpa++)</span></span><br></code></pre></td></tr></table></figure>

<p><strong>Address_Mapping_Unit_Page_Level::Add_invaild_data：</strong>同样接收一个rate，当rate小于addValid_时跳出（小于代表这些数据已经处理过了）</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">for</span>(LPA_type lpa = 0; lpa &lt; domains[steam]-&gt;</span>Total_physical_pages_no *  (rate - addValid_); lpa++)<br></code></pre></td></tr></table></figure>

<p>对于还没处理的数据进行处理</p>
<p><strong>Address_Mapping_Unit_Page_Level::create_invalid_entry_for_reads：</strong>该函数用于为读取操作创建一个无效条目。具体步骤包括分配块和页、设置元数据、无效化页并返回物理页地址 (PPA)。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">block_manager-&gt;<span class="hljs-constructor">Invalidate_page_in_block(<span class="hljs-params">stream_id</span>, <span class="hljs-params">read_address</span>)</span>;<br></code></pre></td></tr></table></figure>

<p>调用块管理器的 <code>Invalidate_page_in_block</code> 函数，无效化给定流 ID 和物理页地址的页。</p>
<p><strong>Address_Mapping_Unit_Page_Level::online_create_entry_for_reads：</strong>在上面的create_mpv_entry_for_reads的基础上，不仅把条目加入了全局映射表，还把条目加入了CMT。</p>
<p><strong>Address_Mapping_Unit_Page_Level::Get_data_mapping_info_for_gc：</strong>该函数用于在垃圾回收 (GC) 时获取数据映射信息，包括物理页地址 (PPA) 和页面状态。</p>
<ul>
<li>首先检查该条目是否存在在ideal_mapping_table中</li>
<li>如果可以访问，获取ppa和页面状态</li>
<li>如果不可以访问，则从全局映射表中获取ppa和页面状态</li>
</ul>
<p><strong>Address_Mapping_Unit_Page_Level::request_mapping_entry：</strong>该函数用于处理映射表条目的请求，根据逻辑页号 (LPA) 和流 ID (stream_id) 获取并管理相应的物理页号 (PPA)。</p>
<p><strong>Address_Mapping_Unit_Page_Level::generate_flash_writeback_request_for_mapping_data：</strong>用于生成将映射数据写回闪存的请求。</p>
<p><strong>Address_Mapping_Unit_Page_Level::generate_flash_read_request_for_mapping_data：</strong>用于生成读取映射数据的请求</p>
<p><strong>Address_Mapping_Unit_Page_Level::handle_transaction_serviced_signal_from_PHY：</strong>用于处理来自物理层的事务服务信号</p>
<p><strong>Address_Mapping_Unit_Page_Level::Set_barrier_for_accessing_physical_block：</strong>用于为访问物理块设置屏障，其实就是通过address来执行<code>Set_barrier_for_accessing_mvpn</code>，在闪存存储系统中，有时需要设置屏障以确保数据一致性或进行垃圾回收。当事务遇到这些屏障时，需要将其放在一个等待队列中，直到屏障被移除为止。这个方法就是将这些等待的事务添加屏障。</p>
<p><strong>Address_Mapping_Unit_Page_Level::Remove_barrier_for_accessing_lpa/Remove_barrier_for_accessing_mvpn：</strong>对应的解除封禁</p>
<p><strong>Address_Mapping_Unit_Page_Level::manage_user_transaction_facing_barrier：</strong>用于管理面对屏障的用户事务，将这些事务放到对应的屏障队列中（读/写），在闪存存储系统中，有时需要设置屏障以确保数据一致性或进行垃圾回收。当事务遇到这些屏障时，需要将其放在一个等待队列中，直到屏障被移除为止。这个方法就是将这些等待的事务添加屏障。</p>
<p><strong>Address_Mapping_Unit_Page_Level::mange_unsuccessful_translation：</strong>处理失败的映射，由于平面过满</p>
<p><strong>Address_Mapping_Unit_Page_Level::Start_servicing_writes_for_overfull_plane：</strong>用于处理在过满平面上等待的写入事务</p>
<h2 id="Data-Cache-Flash-cpp"><a href="#Data-Cache-Flash-cpp" class="headerlink" title="Data_Cache_Flash.cpp"></a>Data_Cache_Flash.cpp</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++">Data_Cache_Flash::<span class="hljs-built_in">Data_Cache_Flash</span>(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> capacity_in_pages) : <span class="hljs-built_in">capacity_in_pages</span>(capacity_in_pages) &#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Data_Cache_Flash::Exists</span><span class="hljs-params">(<span class="hljs-keyword">const</span> stream_id_type stream_id, <span class="hljs-keyword">const</span> LPA_type lpn)</span></span><br><span class="hljs-function"></span>&#123;<br>	LPA_type key = <span class="hljs-built_in">LPN_TO_UNIQUE_KEY</span>(stream_id, lpn);<br>	<span class="hljs-keyword">auto</span> it = slots.<span class="hljs-built_in">find</span>(key);<br>	<span class="hljs-keyword">if</span> (it == slots.<span class="hljs-built_in">end</span>()) &#123;<span class="hljs-comment">//意味着未找到该键，返回 false，表示缓存中不存在对应的数据。</span><br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>	&#125;<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>	&#125;<br></code></pre></td></tr></table></figure>

<p>这段代码实现了一个名为 <code>Data_Cache_Flash</code> 的类的部分功能，用于<em><strong>缓存数据页</strong></em></p>
<ol>
<li><strong>构造函数 <code>Data_Cache_Flash::Data_Cache_Flash</code></strong>:用于初始化闪存数据缓存</li>
<li><strong>成员函数 <code>Data_Cache_Flash::Exists</code></strong>:用于检查给定 <code>stream_id</code> 和 <code>lpn</code> 是否存在于缓存中</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">Data_Cache_Flash::~<span class="hljs-built_in">Data_Cache_Flash</span>()<br>&#123;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;slot : slots) &#123;<br>		<span class="hljs-keyword">delete</span> slot.second;<span class="hljs-comment">//确保对象销毁时，动态分配的资源被正确释放，避免内存泄漏</span><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这段代码是 <code>Data_Cache_Flash</code> 类的<strong>析构函数</strong>实现:</p>
<p>析构函数：在对象被销毁时自动调用，用于执行清理操作，E.g:释放动态分配的内存</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Data_Cache_Slot_Type <span class="hljs-title">Data_Cache_Flash::Get_slot</span><span class="hljs-params">(<span class="hljs-keyword">const</span> stream_id_type stream_id, <span class="hljs-keyword">const</span> LPA_type lpn)</span></span><br><span class="hljs-function"></span>&#123;<br>    LPA_type key = <span class="hljs-built_in">LPN_TO_UNIQUE_KEY</span>(stream_id, lpn);<span class="hljs-comment">//查找缓存条目</span><br>    <span class="hljs-keyword">auto</span> it = slots.<span class="hljs-built_in">find</span>(key);<span class="hljs-comment">//返回一个迭代器it</span><br>    <span class="hljs-built_in">assert</span>(it != slots.<span class="hljs-built_in">end</span>());<span class="hljs-comment">//使用断言确保在缓存中存在对应的条目</span><br><br>    <span class="hljs-comment">// Move the accessed slot to the front of LRU list if it&#x27;s not already there</span><br>    <span class="hljs-keyword">if</span> (lru_list.<span class="hljs-built_in">begin</span>()-&gt;first != key) &#123;<br>        lru_list.<span class="hljs-built_in">splice</span>(lru_list.<span class="hljs-built_in">begin</span>(), lru_list, it-&gt;second-&gt;lru_list_ptr);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> *(it-&gt;second);<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>这段代码展示了如何通过<strong>键值对</strong>查找缓存中的条目，并在访问时通过LRU策略管理条目的<strong>顺序</strong>。如果请求的条目不在LRU列表的开头，则将其移到开头，以确保最近访问的条目总是位于列表的前面，实现了LRU缓存淘汰策略。这种设计有助于提高访问效率，特别是对于频繁访问的条目</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Data_Cache_Flash::Check_free_slot_availability</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> slots.<span class="hljs-built_in">size</span>() &lt; capacity_in_pages;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>这段代码简单地比较了当前缓存中<strong>已使用的插槽数量</strong>和设定的<strong>最大容量</strong>，以确定<strong>是否还有空闲插槽</strong>可供使用。这种功能对于在向缓存中添加新数据之前进行空间检查非常有用，可以避免缓存溢出或者提前做出数据替换的决策</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++">	<span class="hljs-function">Data_Cache_Slot_Type <span class="hljs-title">Data_Cache_Flash::Evict_one_dirty_slot</span><span class="hljs-params">()</span></span><br><span class="hljs-function">	</span>&#123;<br>		<span class="hljs-built_in">assert</span>(slots.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>);<br>		<span class="hljs-keyword">auto</span> itr = lru_list.<span class="hljs-built_in">rbegin</span>();<span class="hljs-comment">//初始化一个反向迭代器‘itr’，从最近未使用端开始</span><br>		<span class="hljs-keyword">while</span> (itr != lru_list.<span class="hljs-built_in">rend</span>()) &#123;<span class="hljs-comment">//从末尾向开头检查每个槽的状态</span><br>            <span class="hljs-comment">//访问当前迭代器指向的槽的状态成员</span><br>			<span class="hljs-keyword">if</span> ((*itr).second-&gt;Status == Cache_Slot_Status::DIRTY_NO_FLASH_WRITEBACK) &#123;<br>				<span class="hljs-keyword">break</span>;<span class="hljs-comment">//表示找到需要驱逐的脏槽</span><br>			&#125;<br>			itr++;<br>		&#125;<br>    	Data_Cache_Slot_Type evicted_item = *lru_list.<span class="hljs-built_in">back</span>().second;<br>		<span class="hljs-keyword">if</span> (itr == lru_list.<span class="hljs-built_in">rend</span>()) &#123;<br>			evicted_item.Status = Cache_Slot_Status::EMPTY;<br>			<span class="hljs-keyword">return</span> evicted_item;<br>		&#125;<br><br>		slots.<span class="hljs-built_in">erase</span>(lru_list.<span class="hljs-built_in">back</span>().first);<span class="hljs-comment">//根据 lru_list 列表末尾的键（first）从 slots 容器中删除相应的缓存槽。</span><br>		<span class="hljs-keyword">delete</span> lru_list.<span class="hljs-built_in">back</span>().second;<span class="hljs-comment">// 删除 lru_list 列表末尾的值（second），即对应的缓存槽对象，防止内存泄漏。</span><br>		lru_list.<span class="hljs-built_in">pop_back</span>();<span class="hljs-comment">//移除 lru_list 中的最后一个元素（即最近最少使用的槽），完成驱逐操作。</span><br>	<br>		<span class="hljs-keyword">return</span> evicted_item;<span class="hljs-comment">//返回被驱逐的槽的副本或空槽的副本</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个函数的主要目的是在闪存数据缓存中查找并驱逐一个脏槽。它首先通过迭代 <code>lru_list</code> 找到一个 <code>DIRTY_NO_FLASH_WRITEBACK</code> 状态的槽，然后从 <code>slots</code> 和 <code>lru_list</code> 中移除该槽，并确保释放相应的资源。最后，返回被驱逐的槽的副本或者一个表示空槽的对象。</p>
<p>Data_Cache_Slot_Type：返回类型；表示返回一个<strong>数据缓存槽</strong>的对象</p>
<p>rbegin()：返回指向最后一个元素的反向迭代器；</p>
<p>rend():返回指向第一个元素的迭代器；end():指向最后一个元素的下一个元素</p>
<p><strong>LRU算法具体步骤：</strong></p>
<ul>
<li>新数据直接插入到列表头部</li>
<li>缓存数据被命中，将数据移动到列表头部（命中：在缓存中能找到所查找的数据）</li>
<li>缓存已满的时候，移除列表尾部数据。</li>
</ul>
<p><strong>缓存未命中率：</strong>搜索高速缓存时，未找到数据</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Data_Cache_Slot_Type <span class="hljs-title">Data_Cache_Flash::Evict_one_slot</span><span class="hljs-params">(LPA_type key)</span></span>&#123;<br>	<span class="hljs-keyword">auto</span> iter = lru_list.<span class="hljs-built_in">begin</span>();<br>	<span class="hljs-keyword">while</span>(iter != lru_list.<span class="hljs-built_in">end</span>())&#123;<br>		<span class="hljs-keyword">if</span>((*iter).first == key)&#123;<br>			<span class="hljs-keyword">break</span>;<br>		&#125;<br>		iter++;<br>	&#125;<br>	Data_Cache_Slot_Type evicted_item = *(slots[key]);<br>	<span class="hljs-keyword">delete</span> slots[key];<br>	slots.<span class="hljs-built_in">erase</span>(key);<br>	lru_list.<span class="hljs-built_in">erase</span>(iter);<br>	<span class="hljs-keyword">return</span> evicted_item;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>Evict_one_slot</strong> 函数用于从缓存中移除一个条目，由 <code>slots</code> 和 <code>lru_list</code> 管理，移除依据是 <code>key</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Data_Cache_Slot_Type <span class="hljs-title">Data_Cache_Flash::Evict_one_slot_lru</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">assert</span>(slots.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>);  <span class="hljs-comment">// 断言确保缓存中至少有一个条目</span><br><br>    <span class="hljs-comment">// 从 slots 中删除 lru_list 中最后一个条目的键</span><br>    slots.<span class="hljs-built_in">erase</span>(lru_list.<span class="hljs-built_in">back</span>().first);<br><br>    <span class="hljs-comment">// 复制并删除 lru_list 中最后一个条目的值</span><br>    Data_Cache_Slot_Type evicted_item = *lru_list.<span class="hljs-built_in">back</span>().second;<br>    <span class="hljs-keyword">delete</span> lru_list.<span class="hljs-built_in">back</span>().second;<br>    <br>    <span class="hljs-comment">// 从 lru_list 的末尾移除最近最少使用的条目</span><br>    lru_list.<span class="hljs-built_in">pop_back</span>();<br><br>    <span class="hljs-keyword">return</span> evicted_item;  <span class="hljs-comment">// 返回被移除的条目</span><br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>**Evict_one_slot_lru()**：实现了从缓存中按照LRU策略移除一个条目</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Data_Cache_Flash::Change_slot_status_to_writeback</span><span class="hljs-params">(<span class="hljs-keyword">const</span> stream_id_type stream_id, <span class="hljs-keyword">const</span> LPA_type lpn)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 将流ID和逻辑页面号转换为唯一的缓存键</span><br>    LPA_type key = <span class="hljs-built_in">LPN_TO_UNIQUE_KEY</span>(stream_id, lpn);<br>    <br>    <span class="hljs-comment">// 在 slots 中查找缓存条目</span><br>    <span class="hljs-keyword">auto</span> it = slots.<span class="hljs-built_in">find</span>(key);<br>    <br>    <span class="hljs-comment">// 确保找到了对应的条目</span><br>    <span class="hljs-built_in">assert</span>(it != slots.<span class="hljs-built_in">end</span>());<br>    <br>    <span class="hljs-comment">// 修改条目的状态为 DIRTY_FLASH_WRITEBACK</span><br>    it-&gt;second-&gt;Status = Cache_Slot_Status::DIRTY_FLASH_WRITEBACK;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><strong>Change_slot_status_to_writeback</strong>：用于修改缓存条目状态；用于控制何时将数据写回到闪存</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Data_Cache_Flash::Insert_read_data</span><span class="hljs-params">(<span class="hljs-keyword">const</span> stream_id_type stream_id, <span class="hljs-keyword">const</span> LPA_type lpn, <span class="hljs-keyword">const</span> data_cache_content_type content,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">const</span> data_timestamp_type timestamp, <span class="hljs-keyword">const</span> page_status_type state_bitmap_of_read_sectors)</span></span><br><span class="hljs-function"></span>&#123;<br>    LPA_type key = <span class="hljs-built_in">LPN_TO_UNIQUE_KEY</span>(stream_id, lpn);<br>    <br>    <span class="hljs-comment">// 检查是否存在重复的 lpn 插入到数据缓存中</span><br>    <span class="hljs-keyword">if</span> (slots.<span class="hljs-built_in">find</span>(key) != slots.<span class="hljs-built_in">end</span>()) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">logic_error</span>(<span class="hljs-string">&quot;Duplicate lpn insertion into data cache!&quot;</span>);<br>    &#125;<span class="hljs-comment">//如果找到了具有键 key 的元素，则 find(key) 函数返回指向该元素的迭代器。</span><br><span class="hljs-comment">//如果未找到具有键 key 的元素，则 find(key) 函数返回容器的 end() 迭代器，即指向容器末尾的迭代器</span><br>    <br>    <span class="hljs-comment">// 检查数据缓存是否已满</span><br>    <span class="hljs-keyword">if</span> (slots.<span class="hljs-built_in">size</span>() &gt;= capacity_in_pages) &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">logic_error</span>(<span class="hljs-string">&quot;Data cache overfull!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 创建新的缓存条目对象</span><br>    Data_Cache_Slot_Type* cache_slot = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Data_Cache_Slot_Type</span>();<br>    cache_slot-&gt;LPA = lpn;<br>    cache_slot-&gt;streamid = stream_id;<br>    cache_slot-&gt;State_bitmap_of_existing_sectors = state_bitmap_of_read_sectors;<br>    cache_slot-&gt;Content = content;<br>    cache_slot-&gt;Timestamp = timestamp;<br>    cache_slot-&gt;Status = Cache_Slot_Status::CLEAN;<br><br>    <span class="hljs-comment">// 将新条目插入 lru_list 的头部</span><br>    lru_list.<span class="hljs-built_in">push_front</span>(std::<span class="hljs-built_in">make_pair</span>(key, cache_slot));<br>    cache_slot-&gt;lru_list_ptr = lru_list.<span class="hljs-built_in">begin</span>();  <span class="hljs-comment">// 记录条目在 lru_list 中的位置</span><br><br>    <span class="hljs-comment">// 将新条目插入 slots 容器</span><br>    slots[key] = cache_slot;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><code>lru_list</code> 和 <code>slots</code> 是两种不同的数据结构，各自承担了不同的功能：<code>slots</code> 存储数据条目以支持<strong>快速查找</strong>，而 <code>lru_list</code> 管理条目的<strong>访问顺序</strong>。</p>
<p>将 <code>cache_slot-&gt;lru_list_ptr</code> 设置为 <code>lru_list.begin()</code>，能够保证每次插入新条目时，都能正确地在 <code>lru_list</code> 中标记其位置，保持管理的完整性和正确性。</p>
<h2 id="Data-Cache-Manager-Base-cpp"><a href="#Data-Cache-Manager-Base-cpp" class="headerlink" title="Data_Cache_Manager_Base.cpp"></a>Data_Cache_Manager_Base.cpp</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Data_Cache_Manager_Base.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;FTL.h&quot;</span></span><br><br><span class="hljs-keyword">namespace</span> SSD_Components<br>&#123;<br>	Data_Cache_Manager_Base* Data_Cache_Manager_Base::_my_instance = <span class="hljs-literal">NULL</span>;<br>	Caching_Mode* Data_Cache_Manager_Base::caching_mode_per_input_stream;<br><br>	Data_Cache_Manager_Base::<span class="hljs-built_in">Data_Cache_Manager_Base</span>(<span class="hljs-keyword">const</span> sim_object_id_type&amp; id, Host_Interface_Base* host_interface, NVM_Firmware* nvm_firmware,<br>		<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> dram_row_size, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> dram_data_rate, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> dram_busrt_size, sim_time_type dram_tRCD, sim_time_type dram_tCL, sim_time_type dram_tRP,<br>		Caching_Mode* caching_mode_per_input_stream, Cache_Sharing_Mode sharing_mode, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> stream_count)<br>		: MQSimEngine::<span class="hljs-built_in">Sim_Object</span>(id), <span class="hljs-built_in">host_interface</span>(host_interface), <span class="hljs-built_in">nvm_firmware</span>(nvm_firmware),<br>		<span class="hljs-built_in">dram_row_size</span>(dram_row_size), <span class="hljs-built_in">dram_data_rate</span>(dram_data_rate), <span class="hljs-built_in">dram_busrt_size</span>(dram_busrt_size), <span class="hljs-built_in">dram_tRCD</span>(dram_tRCD), <span class="hljs-built_in">dram_tCL</span>(dram_tCL), <span class="hljs-built_in">dram_tRP</span>(dram_tRP),<br>		<span class="hljs-built_in">sharing_mode</span>(sharing_mode), <span class="hljs-built_in">stream_count</span>(stream_count)<br>	&#123;<br>		_my_instance = <span class="hljs-keyword">this</span>;<br>		dram_burst_transfer_time_ddr = (<span class="hljs-keyword">double</span>) ONE_SECOND / (dram_data_rate * <span class="hljs-number">1000</span> * <span class="hljs-number">1000</span>);<br>		<span class="hljs-keyword">this</span>-&gt;caching_mode_per_input_stream = <span class="hljs-keyword">new</span> Caching_Mode[stream_count];<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; stream_count; i++) &#123;<br>			<span class="hljs-keyword">this</span>-&gt;caching_mode_per_input_stream[i] = caching_mode_per_input_stream[i];<br>		&#125;<br>	&#125;<br><br>	Data_Cache_Manager_Base::~<span class="hljs-built_in">Data_Cache_Manager_Base</span>() &#123;&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Data_Cache_Manager_Base::Setup_triggers</span><span class="hljs-params">()</span></span><br><span class="hljs-function">	</span>&#123;<br>		Sim_Object::<span class="hljs-built_in">Setup_triggers</span>();<br>		host_interface-&gt;<span class="hljs-built_in">Connect_to_user_request_arrived_signal</span>(handle_user_request_arrived_signal);<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Data_Cache_Manager_Base::Start_simulation</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>	<br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Data_Cache_Manager_Base::Validate_simulation_config</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Data_Cache_Manager_Base::Connect_to_user_request_serviced_signal</span><span class="hljs-params">(UserRequestServicedSignalHanderType function)</span></span><br><span class="hljs-function">	</span>&#123;<br>		connected_user_request_serviced_signal_handlers.<span class="hljs-built_in">push_back</span>(function);<br>	&#125;<br>	<br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Data_Cache_Manager_Base::broadcast_user_request_serviced_signal</span><span class="hljs-params">(User_Request* nvm_transaction)</span></span><br><span class="hljs-function">	</span>&#123;<br>		<span class="hljs-keyword">for</span> (std::vector&lt;UserRequestServicedSignalHanderType&gt;::iterator it = connected_user_request_serviced_signal_handlers.<span class="hljs-built_in">begin</span>();<br>			it != connected_user_request_serviced_signal_handlers.<span class="hljs-built_in">end</span>(); it++) &#123;<br>			(*it)(nvm_transaction);<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Data_Cache_Manager_Base::Connect_to_user_memory_transaction_serviced_signal</span><span class="hljs-params">(MemoryTransactionServicedSignalHanderType function)</span></span><br><span class="hljs-function">	</span>&#123;<br>		connected_user_memory_transaction_serviced_signal_handlers.<span class="hljs-built_in">push_back</span>(function);<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Data_Cache_Manager_Base::broadcast_user_memory_transaction_serviced_signal</span><span class="hljs-params">(NVM_Transaction* transaction)</span></span><br><span class="hljs-function">	</span>&#123;<br>		<span class="hljs-keyword">for</span> (std::vector&lt;MemoryTransactionServicedSignalHanderType&gt;::iterator it = connected_user_memory_transaction_serviced_signal_handlers.<span class="hljs-built_in">begin</span>();<br>			it != connected_user_memory_transaction_serviced_signal_handlers.<span class="hljs-built_in">end</span>(); it++) &#123;<br>			(*it)(transaction);<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Data_Cache_Manager_Base::handle_user_request_arrived_signal</span><span class="hljs-params">(User_Request* user_request)</span></span><br><span class="hljs-function">	</span>&#123;<br>		_my_instance-&gt;<span class="hljs-built_in">process_new_user_request</span>(user_request);<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Data_Cache_Manager_Base::Set_host_interface</span><span class="hljs-params">(Host_Interface_Base* host_interface)</span></span><br><span class="hljs-function">	</span>&#123;<br>		<span class="hljs-keyword">this</span>-&gt;host_interface = host_interface;<br>	&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>这是一个基于 SSD 的数据缓存管理器的<strong>基类</strong>,它包括了各种功能和方法来<strong>初始化、管理</strong>和与其他组件<strong>通信</strong>，以实现数据缓存的有效管理和控制。</p>
<h2 id="Data-Cache-Manager-Flash-Advanced-cpp"><a href="#Data-Cache-Manager-Flash-Advanced-cpp" class="headerlink" title="Data_Cache_Manager_Flash_Advanced.cpp"></a>Data_Cache_Manager_Flash_Advanced.cpp</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c++">Data_Cache_Manager_Flash_Advanced::<span class="hljs-built_in">Data_Cache_Manager_Flash_Advanced</span>(<br>    <span class="hljs-keyword">const</span> sim_object_id_type&amp; id, Host_Interface_Base* host_interface, NVM_Firmware* firmware, NVM_PHY_ONFI* flash_controller,<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> total_capacity_in_bytes,<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> dram_row_size, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> dram_data_rate, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> dram_busrt_size, sim_time_type dram_tRCD, sim_time_type dram_tCL, sim_time_type dram_tRP,<br>    Caching_Mode* caching_mode_per_input_stream, Cache_Sharing_Mode sharing_mode, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> stream_count,<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> sector_no_per_page, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> back_pressure_buffer_max_depth)<br>    <span class="hljs-comment">// 调用基类构造函数并初始化成员变量</span><br>    : <span class="hljs-built_in">Data_Cache_Manager_Base</span>(id, host_interface, firmware, dram_row_size, dram_data_rate, dram_busrt_size, dram_tRCD, dram_tCL, dram_tRP,<br>                              caching_mode_per_input_stream, sharing_mode, stream_count),<br>      <span class="hljs-comment">// 初始化其他成员变量</span><br>      <span class="hljs-built_in">flash_controller</span>(flash_controller),<br>      <span class="hljs-built_in">capacity_in_bytes</span>(total_capacity_in_bytes),<br>      <span class="hljs-built_in">sector_no_per_page</span>(sector_no_per_page),<br>      <span class="hljs-built_in">memory_channel_is_busy</span>(<span class="hljs-literal">false</span>),<br>      <span class="hljs-built_in">dram_execution_list_turn</span>(<span class="hljs-number">0</span>),<br>      <span class="hljs-built_in">back_pressure_buffer_max_depth</span>(back_pressure_buffer_max_depth)<br>&#123;<br>    <span class="hljs-comment">// 计算缓存页数容量</span><br>    capacity_in_pages = capacity_in_bytes / (SECTOR_SIZE_IN_BYTE * sector_no_per_page);<br><br>    <span class="hljs-comment">// 根据缓存共享模式进行初始化</span><br>    <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (sharing_mode)<br>    &#123;<br>        <span class="hljs-keyword">case</span> SSD_Components::Cache_Sharing_Mode::SHARED:<br>        &#123;<br>            <span class="hljs-comment">// 创建一个共享的 Data_Cache_Flash 实例</span><br>            Data_Cache_Flash* sharedCache = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Data_Cache_Flash</span>(capacity_in_pages);<br><br>            <span class="hljs-comment">// 将共享的缓存实例赋给每个输入流</span><br>            per_stream_cache = <span class="hljs-keyword">new</span> Data_Cache_Flash*[stream_count];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; stream_count; i++) &#123;<br>                per_stream_cache[i] = sharedCache;<br>            &#125;<br><br>            <span class="hljs-comment">// 分配单个队列和数组来管理DRAM执行和等待的用户请求</span><br>            dram_execution_queue = <span class="hljs-keyword">new</span> std::queue&lt;Memory_Transfer_Info*&gt;[<span class="hljs-number">1</span>];<br>            waiting_user_requests_queue_for_dram_free_slot = <span class="hljs-keyword">new</span> std::list&lt;User_Request*&gt;[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">this</span>-&gt;back_pressure_buffer_depth = <span class="hljs-keyword">new</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">this</span>-&gt;back_pressure_buffer_depth[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>            shared_dram_request_queue = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">case</span> SSD_Components::Cache_Sharing_Mode::EQUAL_PARTITIONING:<br>            <span class="hljs-comment">// 为每个输入流创建独立的 Data_Cache_Flash 实例</span><br>            per_stream_cache = <span class="hljs-keyword">new</span> Data_Cache_Flash*[stream_count];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; stream_count; i++) &#123;<br>                per_stream_cache[i] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Data_Cache_Flash</span>(capacity_in_pages / stream_count);<br>            &#125;<br><br>            <span class="hljs-comment">// 分配每个输入流对应的队列和数组来管理DRAM执行和等待的用户请求</span><br>            dram_execution_queue = <span class="hljs-keyword">new</span> std::queue&lt;Memory_Transfer_Info*&gt;[stream_count];<br>            waiting_user_requests_queue_for_dram_free_slot = <span class="hljs-keyword">new</span> std::list&lt;User_Request*&gt;[stream_count];<br>            <span class="hljs-keyword">this</span>-&gt;back_pressure_buffer_depth = <span class="hljs-keyword">new</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>[stream_count];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; stream_count; i++) &#123;<br>                <span class="hljs-keyword">this</span>-&gt;back_pressure_buffer_depth[i] = <span class="hljs-number">0</span>;<br>            &#125;<br>            shared_dram_request_queue = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 为每个输入流创建 Bloom Filter，用于快速查询缓存中是否存在某个逻辑页地址（LPA）</span><br>    bloom_filter = <span class="hljs-keyword">new</span> std::set&lt;LPA_type&gt;[stream_count];<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>这段构造函数代码的作用是根据输入的参数初始化 <code>Data_Cache_Manager_Flash_Advanced</code> 类的对象。它根据缓存共享模式和输入流的数量来<strong>分配和管理数据缓存</strong>、DRAM执行队列和用户请求队列。此外，还初始化了一些额外的成员变量和数据结构，以确保对象在使用过程中能够有效地管理和利用资源。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br>Data_Cache_Manager_Flash_Advanced::~<span class="hljs-built_in">Data_Cache_Manager_Flash_Advanced</span>()<br>&#123;<br>	std::cout &lt;&lt; <span class="hljs-string">&quot;arrivedReq &quot;</span> &lt;&lt; arrivedReq &lt;&lt; std::endl;<br>	std::cout &lt;&lt; <span class="hljs-string">&quot;restWrite &quot;</span> &lt;&lt; restWrite &lt;&lt; std::endl;<br>	<br>	<span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (sharing_mode)<br>	&#123;<br>		<span class="hljs-keyword">case</span> SSD_Components::Cache_Sharing_Mode::SHARED:<br>		&#123;<br>			std::cout &lt;&lt; <span class="hljs-string">&quot;back_pressure_buffer_depth is &quot;</span> &lt;&lt; back_pressure_buffer_depth[<span class="hljs-number">0</span>] &lt;&lt; std::endl;<br>			std::cout &lt;&lt; <span class="hljs-string">&quot;back_pressure_buffer_max_depth &quot;</span> &lt;&lt;back_pressure_buffer_max_depth &lt;&lt; std::endl;<br>			<span class="hljs-keyword">delete</span> per_stream_cache[<span class="hljs-number">0</span>];<br>			<span class="hljs-keyword">while</span> (dram_execution_queue[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()) &#123;<br>				<span class="hljs-keyword">delete</span> dram_execution_queue[<span class="hljs-number">0</span>].<span class="hljs-built_in">front</span>();<br>				dram_execution_queue[<span class="hljs-number">0</span>].<span class="hljs-built_in">pop</span>();<br>			&#125;<br>			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;req : waiting_user_requests_queue_for_dram_free_slot[<span class="hljs-number">0</span>]) &#123;<br>				<span class="hljs-keyword">delete</span> req;<br>			&#125;<br>			<span class="hljs-keyword">delete</span> back_pressure_buffer_depth;<br>			<span class="hljs-keyword">break</span>;<br>		&#125;<br>		<span class="hljs-keyword">case</span> SSD_Components::Cache_Sharing_Mode::EQUAL_PARTITIONING:<br>			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; stream_count; i++) &#123;<br>				<span class="hljs-keyword">delete</span> per_stream_cache[i];<br>				<span class="hljs-keyword">while</span> (dram_execution_queue[i].<span class="hljs-built_in">size</span>()) &#123;<br>					<span class="hljs-keyword">delete</span> dram_execution_queue[i].<span class="hljs-built_in">front</span>();<br>					dram_execution_queue[i].<span class="hljs-built_in">pop</span>();<br>				&#125;<br>				<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;req : waiting_user_requests_queue_for_dram_free_slot[i]) &#123;<br>					<span class="hljs-keyword">delete</span> req;<br>				&#125;<br>			&#125;<br>			<span class="hljs-keyword">delete</span>[] back_pressure_buffer_depth;<br>			<span class="hljs-keyword">break</span>;<br>		<span class="hljs-keyword">default</span>:<br>			<span class="hljs-keyword">break</span>;<br>	&#125;<br>	<br>	<span class="hljs-keyword">delete</span> per_stream_cache;<br>	<span class="hljs-keyword">delete</span>[] dram_execution_queue;<br>	<span class="hljs-keyword">delete</span>[] waiting_user_requests_queue_for_dram_free_slot;<br>	<span class="hljs-keyword">delete</span>[] bloom_filter;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这段<strong>析构函数</strong>代码的目的是确保在对象销毁时，释放所有动态分配的内存资源，清理对象所持有的所有资源，避免内存泄漏和资源泄露。根据 <code>sharing_mode</code> 的不同值，执行不同的清理操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Data_Cache_Manager_Flash_Advanced::Do_warmup</span><span class="hljs-params">(std::vector&lt;Utils::Workload_Statistics*&gt; workload_stats)</span></span><br><span class="hljs-function"><span class="hljs-title">switch</span> <span class="hljs-params">(sharing_mode)</span> </span>&#123;<br>    <span class="hljs-keyword">case</span> Cache_Sharing_Mode::SHARED:<br>        <span class="hljs-comment">// 处理共享缓存模式下的预热逻辑</span><br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> Cache_Sharing_Mode::EQUAL_PARTITIONING:<br>        <span class="hljs-comment">// 处理等分缓存模式下的预热逻辑</span><br>        <span class="hljs-keyword">break</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>这段代码是一个缓存管理器（Cache Manager）的实现，它根据不同的缓存共享模式（<code>sharing_mode</code>）和缓存模式（<code>caching_mode_per_input_stream</code>）对工作负载统计数据进行预热（warmup）。这段代码的目的是通过预热（warmup）<strong>来初始化或优化缓存管理器</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Data_Cache_Manager_Flash_Advanced::process_new_user_request</span><span class="hljs-params">(User_Request* user_request)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-comment">//This condition shouldn&#x27;t happen, but we check it</span><br>	<span class="hljs-keyword">if</span> (user_request-&gt;Transaction_list.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) &#123;<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br>	arrivedReq++;<span class="hljs-comment">//用于统计到达的请求数量</span><br>	<span class="hljs-keyword">if</span> (user_request-&gt;Type == UserRequestType::READ) &#123;<br>    <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (caching_mode_per_input_stream[user_request-&gt;Stream_id]) &#123;<br>        <span class="hljs-keyword">case</span> Caching_Mode::TURNED_OFF:<br>            <span class="hljs-comment">// 如果缓存模式为 TURNED_OFF，则直接调用地址映射单元处理请求</span><br>            <span class="hljs-keyword">static_cast</span>&lt;FTL*&gt;(nvm_firmware)-&gt;Address_Mapping_Unit-&gt;<span class="hljs-built_in">Translate_lpa_to_ppa_and_dispatch</span>(user_request-&gt;Transaction_list);<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">case</span> Caching_Mode::WRITE_CACHE:<br>        <span class="hljs-keyword">case</span> Caching_Mode::READ_CACHE:<br>        <span class="hljs-keyword">case</span> Caching_Mode::WRITE_READ_CACHE:<br>            <span class="hljs-comment">// 根据缓存模式处理读请求</span><br>            std::list&lt;NVM_Transaction*&gt;::iterator it = user_request-&gt;Transaction_list.<span class="hljs-built_in">begin</span>();<br>            <span class="hljs-keyword">while</span> (it != user_request-&gt;Transaction_list.<span class="hljs-built_in">end</span>()) &#123;<br>                NVM_Transaction_Flash_RD* tr = (NVM_Transaction_Flash_RD*)(*it);<br>                <span class="hljs-keyword">if</span> (per_stream_cache[tr-&gt;Stream_id]-&gt;<span class="hljs-built_in">Exists</span>(tr-&gt;Stream_id, tr-&gt;LPA)) &#123;<br>                    <span class="hljs-comment">// 如果缓存中存在请求的数据</span><br>                    page_status_type available_sectors_bitmap = per_stream_cache[tr-&gt;Stream_id]-&gt;<span class="hljs-built_in">Get_slot</span>(tr-&gt;Stream_id, tr-&gt;LPA).State_bitmap_of_existing_sectors &amp; tr-&gt;read_sectors_bitmap;<br>                    <span class="hljs-keyword">if</span> (available_sectors_bitmap == tr-&gt;read_sectors_bitmap) &#123;<br>                        <span class="hljs-comment">// 如果完全命中缓存中的所有扇区</span><br>                        user_request-&gt;Sectors_serviced_from_cache += <span class="hljs-built_in">count_sector_no_from_status_bitmap</span>(tr-&gt;read_sectors_bitmap);<br>                        NVM_Transaction *todel = (*it);<br>                        user_request-&gt;Transaction_list.<span class="hljs-built_in">erase</span>(it++);<br>                        <span class="hljs-keyword">delete</span> todel;<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (available_sectors_bitmap != <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-comment">// 如果部分命中缓存</span><br>                        user_request-&gt;Sectors_serviced_from_cache += <span class="hljs-built_in">count_sector_no_from_status_bitmap</span>(available_sectors_bitmap);<br>                        tr-&gt;read_sectors_bitmap = (tr-&gt;read_sectors_bitmap &amp; ~available_sectors_bitmap);<br>                        tr-&gt;Data_and_metadata_size_in_byte -= <span class="hljs-built_in">count_sector_no_from_status_bitmap</span>(available_sectors_bitmap) * SECTOR_SIZE_IN_BYTE;<br>                        it++;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-comment">// 如果未命中缓存</span><br>                        it++;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 如果缓存中不存在请求的数据</span><br>                    it++;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-comment">// 如果从缓存中服务了扇区，则通知DRAM访问请求完成</span><br>            <span class="hljs-keyword">if</span> (user_request-&gt;Sectors_serviced_from_cache &gt; <span class="hljs-number">0</span>) &#123;<br>                Memory_Transfer_Info* transfer_info = <span class="hljs-keyword">new</span> Memory_Transfer_Info;<br>                transfer_info-&gt;Size_in_bytes = user_request-&gt;Sectors_serviced_from_cache * SECTOR_SIZE_IN_BYTE;<br>                transfer_info-&gt;Related_request = user_request;<br>                transfer_info-&gt;next_event_type = Data_Cache_Simulation_Event_Type::MEMORY_READ_FOR_USERIO_FINISHED;<br>                transfer_info-&gt;Stream_id = user_request-&gt;Stream_id;<br>                <span class="hljs-built_in">service_dram_access_request</span>(transfer_info);<br>            &#125;<br><br>            <span class="hljs-comment">// 如果还有未处理的事务列表，则继续调用地址映射单元处理</span><br>            <span class="hljs-keyword">if</span> (user_request-&gt;Transaction_list.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">static_cast</span>&lt;FTL*&gt;(nvm_firmware)-&gt;Address_Mapping_Unit-&gt;<span class="hljs-built_in">Translate_lpa_to_ppa_and_dispatch</span>(user_request-&gt;Transaction_list);<br>            &#125;<br><br>            <span class="hljs-keyword">return</span>;<br>    &#125;<br>&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">else</span> <span class="hljs-comment">// This is a write request</span><br>&#123;<br>    <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (caching_mode_per_input_stream[user_request-&gt;Stream_id])<br>    &#123;<br>        <span class="hljs-keyword">case</span> Caching_Mode::TURNED_OFF:<br>        <span class="hljs-keyword">case</span> Caching_Mode::READ_CACHE:<br>            <span class="hljs-comment">// 如果缓存模式为 TURNED_OFF 或 READ_CACHE，则直接调用地址映射单元处理请求</span><br>            <span class="hljs-keyword">static_cast</span>&lt;FTL*&gt;(nvm_firmware)-&gt;Address_Mapping_Unit-&gt;<span class="hljs-built_in">Translate_lpa_to_ppa_and_dispatch</span>(user_request-&gt;Transaction_list);<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">case</span> Caching_Mode::WRITE_CACHE:<br>        <span class="hljs-keyword">case</span> Caching_Mode::WRITE_READ_CACHE:<br>            <span class="hljs-comment">// 如果是 WRITE_CACHE 或 WRITE_READ_CACHE 模式，则写入到destage buffer</span><br>            <span class="hljs-built_in">write_to_destage_buffer</span>(user_request);<br>            <span class="hljs-keyword">return</span>;<br>    &#125;<br>&#125;<br><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这段代码实现了一个高级的数据缓存管理器，根据不同的缓存模式处理<strong>读写</strong>请求。读请求根据缓存命中情况从缓存中服务数据，并将未命中的部分继续交给地址映射单元处理；写请求根据缓存模式直接写入 destage buffer 或者交给地址映射单元处理。整体流程包括了对缓存命中的处理和对DRAM访问请求的管理</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Data_Cache_Manager_Flash_Advanced::write_to_destage_buffer</span><span class="hljs-params">(User_Request* user_request)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 为了消除竞争条件，MQSim假设管理信息和用户数据存储在单独的DRAM模块中</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> cache_eviction_read_size_in_sectors = <span class="hljs-number">0</span>; <span class="hljs-comment">// 从缓存驱逐出的数据大小（单位：扇区）</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> flash_written_back_write_size_in_sectors = <span class="hljs-number">0</span>; <span class="hljs-comment">// 同时写回到闪存和DRAM的数据大小（单位：扇区）</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> dram_write_size_in_sectors = <span class="hljs-number">0</span>; <span class="hljs-comment">// 写入到DRAM的数据大小（必须 &gt;= flash_written_back_write_size_in_sectors）</span><br>    std::list&lt;NVM_Transaction*&gt; *evicted_cache_slots = <span class="hljs-keyword">new</span> std::list&lt;NVM_Transaction*&gt;; <span class="hljs-comment">// 被驱逐的缓存事务列表</span><br>    std::list&lt;NVM_Transaction*&gt; writeback_transactions; <span class="hljs-comment">// 待写回的事务列表</span><br>    <span class="hljs-keyword">auto</span> it = user_request-&gt;Transaction_list.<span class="hljs-built_in">begin</span>(); <span class="hljs-comment">// 迭代器，指向用户请求的事务列表的开头</span><br><br>    <span class="hljs-keyword">int</span> queue_id = user_request-&gt;Stream_id; <span class="hljs-comment">// 队列ID默认为用户请求的流ID</span><br>    <span class="hljs-keyword">if</span> (shared_dram_request_queue) &#123;<br>        queue_id = <span class="hljs-number">0</span>; <span class="hljs-comment">// 如果使用共享的DRAM请求队列，队列ID设为0</span><br>    &#125;<br><br>    <span class="hljs-comment">// 遍历用户请求的事务列表</span><br>    <span class="hljs-keyword">while</span> (it != user_request-&gt;Transaction_list.<span class="hljs-built_in">end</span>()) &#123;<br>        NVM_Transaction_Flash_WR* tr = (NVM_Transaction_Flash_WR*)(*it); <span class="hljs-comment">// 获取事务对象</span><br><br>        <span class="hljs-comment">// 如果逻辑地址已经存在于缓存中</span><br>        <span class="hljs-keyword">if</span> (per_stream_cache[tr-&gt;Stream_id]-&gt;<span class="hljs-built_in">Exists</span>(tr-&gt;Stream_id, tr-&gt;LPA)) &#123;<br>            <span class="hljs-comment">// 更新缓存中的数据，处理可能的脏数据写回</span><br>            Data_Cache_Slot_Type slot = per_stream_cache[tr-&gt;Stream_id]-&gt;<span class="hljs-built_in">Get_slot</span>(tr-&gt;Stream_id, tr-&gt;LPA);<br>            sim_time_type timestamp = slot.Timestamp;<br>            NVM::memory_content_type content = slot.Content;<br>            <span class="hljs-keyword">if</span> (tr-&gt;DataTimeStamp &gt; timestamp) &#123;<br>                timestamp = tr-&gt;DataTimeStamp;<br>                content = tr-&gt;Content;<br>            &#125;<br>            per_stream_cache[tr-&gt;Stream_id]-&gt;<span class="hljs-built_in">Update_data</span>(tr-&gt;Stream_id, tr-&gt;LPA, content, timestamp, tr-&gt;write_sectors_bitmap | slot.State_bitmap_of_existing_sectors);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 如果逻辑地址不在缓存中</span><br>            <span class="hljs-keyword">if</span> (!per_stream_cache[tr-&gt;Stream_id]-&gt;<span class="hljs-built_in">Check_free_slot_availability</span>()) &#123;<br>                <span class="hljs-comment">// 如果缓存没有空闲槽位，则进行LRU算法的缓存替换</span><br>                Data_Cache_Slot_Type evicted_slot = per_stream_cache[tr-&gt;Stream_id]-&gt;<span class="hljs-built_in">Evict_one_slot_lru</span>();<br>                <span class="hljs-keyword">if</span> (evicted_slot.Status == Cache_Slot_Status::DIRTY_NO_FLASH_WRITEBACK) &#123;<br>                    <span class="hljs-comment">// 如果驱逐的槽位是脏数据，需要写回到闪存</span><br>                    evicted_cache_slots-&gt;<span class="hljs-built_in">push_back</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">NVM_Transaction_Flash_WR</span>(Transaction_Source_Type::CACHE,<br>                        tr-&gt;Stream_id, <span class="hljs-built_in">count_sector_no_from_status_bitmap</span>(evicted_slot.State_bitmap_of_existing_sectors) * SECTOR_SIZE_IN_BYTE,<br>                        evicted_slot.LPA, user_request, IO_Flow_Priority_Class::URGENT, evicted_slot.Content, evicted_slot.State_bitmap_of_existing_sectors, evicted_slot.Timestamp));<br>                    cache_eviction_read_size_in_sectors += <span class="hljs-built_in">count_sector_no_from_status_bitmap</span>(evicted_slot.State_bitmap_of_existing_sectors);<br>                    back_pressure_buffer_depth[queue_id]++;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 将数据插入到缓存中</span><br>            per_stream_cache[tr-&gt;Stream_id]-&gt;<span class="hljs-built_in">Insert_write_data</span>(tr-&gt;Stream_id, tr-&gt;LPA, tr-&gt;Content, tr-&gt;DataTimeStamp, tr-&gt;write_sectors_bitmap);<br>        &#125;<br>        dram_write_size_in_sectors += <span class="hljs-built_in">count_sector_no_from_status_bitmap</span>(tr-&gt;write_sectors_bitmap); <span class="hljs-comment">// 更新写入到DRAM的数据大小</span><br><br>        <span class="hljs-comment">// 处理热/冷数据分离（部分代码被注释掉）</span><br><br>        <span class="hljs-comment">// 删除已处理的事务并释放其内存</span><br>        NVM_Transaction *todel = (*it);<br>        user_request-&gt;Transaction_list.<span class="hljs-built_in">erase</span>(it++);<br>        <span class="hljs-keyword">delete</span> todel;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 更新用户请求从缓存服务的扇区数</span><br>    user_request-&gt;Sectors_serviced_from_cache += dram_write_size_in_sectors;<br><br>    <span class="hljs-comment">// 如果有缓存驱逐的数据，则发起内存读请求</span><br>    <span class="hljs-keyword">if</span> (evicted_cache_slots-&gt;<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>) &#123;<br>        Memory_Transfer_Info* read_transfer_info = <span class="hljs-keyword">new</span> Memory_Transfer_Info;<br>        read_transfer_info-&gt;Size_in_bytes = cache_eviction_read_size_in_sectors * SECTOR_SIZE_IN_BYTE;<br>        read_transfer_info-&gt;Related_request = evicted_cache_slots;<br>        read_transfer_info-&gt;next_event_type = Data_Cache_Simulation_Event_Type::MEMORY_READ_FOR_CACHE_EVICTION_FINISHED;<br>        read_transfer_info-&gt;Stream_id = user_request-&gt;Stream_id;<br>        <span class="hljs-comment">// 将驱逐的缓存事务添加回用户请求的事务列表中</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;evicted_cache_slot : *evicted_cache_slots)&#123;<br>            user_request-&gt;Transaction_list.<span class="hljs-built_in">push_back</span>(evicted_cache_slot);<br>        &#125;<br>        <span class="hljs-comment">// 发起DRAM访问请求</span><br>        <span class="hljs-built_in">service_dram_access_request</span>(read_transfer_info);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">delete</span> evicted_cache_slots; <span class="hljs-comment">// 如果没有需要驱逐的缓存数据，释放evicted_cache_slots的内存</span><br>    &#125;<br><br>    <span class="hljs-comment">// 如果有数据需要写入到DRAM，则发起内存写请求</span><br>    <span class="hljs-keyword">if</span> (dram_write_size_in_sectors &gt; <span class="hljs-number">0</span>) &#123;<br>        Memory_Transfer_Info* write_transfer_info = <span class="hljs-keyword">new</span> Memory_Transfer_Info;<br>        write_transfer_info-&gt;Size_in_bytes = dram_write_size_in_sectors * SECTOR_SIZE_IN_BYTE;<br>        write_transfer_info-&gt;Related_request = user_request;<br>        write_transfer_info-&gt;next_event_type = Data_Cache_Simulation_Event_Type::MEMORY_WRITE_FOR_USERIO_FINISHED;<br>        write_transfer_info-&gt;Stream_id = user_request-&gt;Stream_id;<br>        <span class="hljs-comment">// 发起DRAM访问请求</span><br>        <span class="hljs-built_in">service_dram_access_request</span>(write_transfer_info);<br>    &#125;<br><br>    <span class="hljs-comment">// 如果有数据需要写回到闪存，则发起闪存写请求</span><br>    <span class="hljs-keyword">if</span> (writeback_transactions.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">static_cast</span>&lt;FTL*&gt;(nvm_firmware)-&gt;Address_Mapping_Unit-&gt;<span class="hljs-built_in">Translate_lpa_to_ppa_and_dispatch</span>(writeback_transactions);<br>        <span class="hljs-comment">// 将写回的事务添加回用户请求的事务列表中</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;writeback_transaction : writeback_transactions)&#123;<br>            user_request-&gt;Transaction_list.<span class="hljs-built_in">push_back</span>(writeback_transaction);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 更新restWrite统计值，可能是剩余待处理事务的数量</span><br>    restWrite += user_request-&gt;Transaction_list.<span class="hljs-built_in">size</span>();\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\<br><br>    <span class="hljs-comment">// 如果当前模拟时间超过布隆过滤器重置里程碑时间，则重置布隆过滤器</span><br>    <span class="hljs-keyword">if</span> (Simulator-&gt;<span class="hljs-built_in">Time</span>() &gt; next_bloom_filter_reset_milestone) &#123;<br>        bloom_filter[user_request-&gt;Stream_id].<span class="hljs-built_in">clear</span>();<br>        next_bloom_filter_reset_milestone = Simulator-&gt;<span class="hljs-built_in">Time</span>() + bloom_filter_reset_step;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>这个函数的作用是处理用户请求，将数据写入到闪存高级数据缓存管理器的destage（下放）缓冲区，并执行相关的数据管理操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Data_Cache_Manager_Flash_Advanced::handle_transaction_serviced_signal_from_PHY</span><span class="hljs-params">(NVM_Transaction_Flash* transaction)</span></span><br></code></pre></td></tr></table></figure>

<p>这个函数的作用是处理来自<strong>物理层</strong>（PHY，Physical Layer）的<strong>事务服务信号</strong>。在存储系统中，特别是涉及闪存（Flash）的数据缓存管理中，物理层通常负责处理底层硬件和驱动器之间的通信，包括处理事务完成或服务的信号。</p>
<p>因此，<code>handle_transaction_serviced_signal_from_PHY</code> 函数很可能的功能是接收一个闪存事务的完成信号或者服务信号，然后根据信号进行相应的处理。这可能涉及更新管理器内部的状态、通知上层逻辑或者驱动程序等操作，具体的实现会依赖于系统的设计和需求。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Data_Cache_Manager_Flash_Advanced::service_dram_access_request</span><span class="hljs-params">(Memory_Transfer_Info* request_info)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (memory_channel_is_busy) &#123;<span class="hljs-comment">//检查内存通道是否忙碌。如果内存通道忙碌，意味着当前有其他请求正在处理，需要将新的请求放入队列中等待。</span><br>        <span class="hljs-keyword">if</span> (shared_dram_request_queue) &#123;<br>            dram_execution_queue[<span class="hljs-number">0</span>].<span class="hljs-built_in">push</span>(request_info);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            dram_execution_queue[request_info-&gt;Stream_id].<span class="hljs-built_in">push</span>(request_info);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        Simulator-&gt;<span class="hljs-built_in">Register_sim_event</span>(<br>            Simulator-&gt;<span class="hljs-built_in">Time</span>() + <span class="hljs-built_in">estimate_dram_access_time</span>(request_info-&gt;Size_in_bytes, dram_row_size,<br>                dram_burst_size, dram_burst_transfer_time_ddr, dram_tRCD, dram_tCL, dram_tRP),<br>            <span class="hljs-keyword">this</span>, request_info, <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&gt;(request_info-&gt;next_event_type));<br>        memory_channel_is_busy = <span class="hljs-literal">true</span>;<br>        dram_execution_list_turn = request_info-&gt;Stream_id;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>该函数的主要功能是<strong>根据当前内存通道的状态来处理DRAM访问请求</strong>。如果内存通道忙碌，则根据配置将请求放入相应的队列中等待；如果内存通道空闲，则注册一个模拟事件来计划DRAM访问，并更新相关状态以表示内存通道忙碌和当前处理的请求流ID</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Data_Cache_Manager_Flash_Advanced::Execute_simulator_event</span><span class="hljs-params">(MQSimEngine::Sim_Event* ev)</span></span><br></code></pre></td></tr></table></figure>

<p>该函数 <code>Execute_simulator_event</code> 的主要功能是根据不同类型的<strong>模拟器事件</strong>，执行相应的处理逻辑，包括更新用户请求状态、执行地址映射和事务分派等操作。此外，它还负责管理内存通道的忙闲状态，并根据配置处理DRAM请求队列中的下一个请求</p>
<h2 id="Flash-Block-Manager"><a href="#Flash-Block-Manager" class="headerlink" title="Flash_Block_Manager"></a>Flash_Block_Manager</h2><p><strong>Flash_Block_Manager::Allocate_block_and_page_in_plane_for_user_write：</strong>在给定的平面（plane）中为用户写入操作分配块和页面。</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs xl">void Flash_Block_Manager::Allocate_block_and_page_in_plane_for_user_write(const stream_id_type stream_id, NVM::FlashMemory::Physical_Page_Address&amp; page_address)<br>&#123;<br>    <span class="hljs-comment">// 获取对应平面的记录</span><br>    PlaneBookKeepingType *plane_record = &amp;plane_manager[page_address.ChannelID][page_address.ChipID][page_address.DieID][page_address.PlaneID];<br>    <br>    <span class="hljs-comment">// 更新平面的有效页面计数和空闲页面计数</span><br>    <span class="hljs-function"><span class="hljs-title">plane_record</span>-&gt;</span>Valid_pages_count++;<br>    <span class="hljs-function"><span class="hljs-title">plane_record</span>-&gt;</span>Free_pages_count--;	<br><br>    <span class="hljs-comment">// 如果当前流的写前沿块（write frontier block）为空，则分配一个新的空闲块</span><br>    <span class="hljs-function"><span class="hljs-title">if</span>(plane_record-&gt;</span>Data_wf[stream_id] == NULL) &#123;<br>        <span class="hljs-function"><span class="hljs-title">plane_record</span>-&gt;</span>D<span class="hljs-function"><span class="hljs-title">ata_wf</span>[stream_id] = plane_record-&gt;</span>Get_a_free_block(stream_id, <span class="hljs-literal">false</span>);<br>        <span class="hljs-function"><span class="hljs-title">gc_and_wl_unit</span>-&gt;</span>C<span class="hljs-function"><span class="hljs-title">heck_gc_required</span>(plane_record-&gt;</span>Get_free_block_pool_size(), page_address);<br>    &#125;<br><br>    <span class="hljs-comment">// 设置页面地址的块ID和页ID，并更新当前写前沿块的写索引</span><br>    <span class="hljs-function"><span class="hljs-title">page_address</span>.BlockID = plane_record-&gt;</span>D<span class="hljs-function"><span class="hljs-title">ata_wf</span>[stream_id]-&gt;</span>BlockID;<br>    <span class="hljs-function"><span class="hljs-title">page_address</span>.PageID = plane_record-&gt;</span>D<span class="hljs-function"><span class="hljs-title">ata_wf</span>[stream_id]-&gt;</span>Current_page_write_index++;<br>    program_transaction_issued(page_address);<br><br>    <span class="hljs-comment">// 如果当前写前沿块已写满，则分配一个新的空闲块作为新的写前沿块</span><br>    <span class="hljs-function"><span class="hljs-title">if</span>(plane_record-&gt;</span>D<span class="hljs-function"><span class="hljs-title">ata_wf</span>[stream_id]-&gt;</span>Current_page_write_index == pages_no_per_block) &#123;<br>        <span class="hljs-function"><span class="hljs-title">plane_record</span>-&gt;</span>D<span class="hljs-function"><span class="hljs-title">ata_wf</span>[stream_id] = plane_record-&gt;</span>Get_a_free_block(stream_id, <span class="hljs-literal">false</span>);<br>        <span class="hljs-function"><span class="hljs-title">gc_and_wl_unit</span>-&gt;</span>C<span class="hljs-function"><span class="hljs-title">heck_gc_required</span>(plane_record-&gt;</span>Get_free_block_pool_size(), page_address);<br>    &#125;<br><br>    <span class="hljs-comment">// 检查平面记录的正确性</span><br>    <span class="hljs-function"><span class="hljs-title">plane_record</span>-&gt;</span>Check_bookkeeping_correctness(page_address);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>Flash_Block_Manager::Allocate_block_and_page_in_plane_for_gc_write：</strong>用于在给定的平面（plane）中为用户写入操作分配块和页面。分配操作的步骤和上面函数类似，区别在于这个是引导GC的。</p>
<p><strong>Flash_Block_Manager::Allocate_Pages_in_block_and_invalidate_remaining_for_preconditioning：</strong>用于为预处理操作分配块中的页面并将其余页面设置为无效。</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs xl">void Flash_Block_Manager::Allocate_Pages_in_block_and_invalidate_remaining_for_preconditioning(const stream_id_type stream_id, const NVM::FlashMemory::Physical_Page_Address&amp; plane_address, std::vector&lt;NVM::FlashMemory::Physical_Page_Address&gt;&amp; page_addresses)<br>&#123;<br>    <span class="hljs-comment">// 检查提供的页面地址列表的大小是否超过块中的页面数</span><br>    <span class="hljs-keyword">if</span>(page_addresses.size() &gt; pages_no_per_block) &#123;<br>        PRINT_ERROR(<span class="hljs-string">&quot;Error while precondition a physical block: the size of the address list is larger than the pages_no_per_block!&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-comment">// 获取平面的记录</span><br>    PlaneBookKeepingType *plane_record = &amp;plane_manager[plane_address.ChannelID][plane_address.ChipID][plane_address.DieID][plane_address.PlaneID];<br><br>    <span class="hljs-comment">// 检查当前写前沿块的写入索引是否大于0，预处理应在已擦除的块上执行</span><br>    <span class="hljs-function"><span class="hljs-title">if</span> (plane_record-&gt;</span>D<span class="hljs-function"><span class="hljs-title">ata_wf</span>[stream_id]-&gt;</span>Current_page_write_index &gt; <span class="hljs-number">0</span>) &#123;<br>        PRINT_ERROR(<span class="hljs-string">&quot;Illegal operation: the Allocate_Pages_in_block_and_invalidate_remaining_for_preconditioning function should be executed for an erased block!&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-comment">// 如果当前流的写前沿块为空，则分配一个新的空闲块</span><br>    <span class="hljs-function"><span class="hljs-title">if</span>(plane_record-&gt;</span>Data_wf[stream_id] == NULL)&#123;<br>        <span class="hljs-function"><span class="hljs-title">plane_record</span>-&gt;</span>D<span class="hljs-function"><span class="hljs-title">ata_wf</span>[stream_id] = plane_record-&gt;</span>Get_a_free_block(stream_id, <span class="hljs-literal">false</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 分配物理地址</span><br>    <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; page_addresses.size(); i++) &#123;<br>        <span class="hljs-function"><span class="hljs-title">plane_record</span>-&gt;</span>Valid_pages_count++;<br>        <span class="hljs-function"><span class="hljs-title">plane_record</span>-&gt;</span>Free_pages_count--;<br>        <span class="hljs-function"><span class="hljs-title">page_addresses</span>[i].BlockID = plane_record-&gt;</span>D<span class="hljs-function"><span class="hljs-title">ata_wf</span>[stream_id]-&gt;</span>BlockID;<br>        <span class="hljs-function"><span class="hljs-title">page_addresses</span>[i].PageID = plane_record-&gt;</span>D<span class="hljs-function"><span class="hljs-title">ata_wf</span>[stream_id]-&gt;</span>Current_page_write_index++;<br>        <span class="hljs-function"><span class="hljs-title">plane_record</span>-&gt;</span>Check_bookkeeping_correctness(page_addresses[i]);<br>    &#125;<br><br>    <span class="hljs-comment">// 将块中剩余的页面设置为无效</span><br>    NVM::FlashMemory::Physical_Page_Address target_address(plane_address);<br>    <span class="hljs-function"><span class="hljs-title">while</span> (plane_record-&gt;</span>D<span class="hljs-function"><span class="hljs-title">ata_wf</span>[stream_id]-&gt;</span>Current_page_write_index &lt; pages_no_per_block) &#123;<br>        <span class="hljs-function"><span class="hljs-title">plane_record</span>-&gt;</span>Free_pages_count--;<br>        <span class="hljs-function"><span class="hljs-title">target_address</span>.BlockID = plane_record-&gt;</span>D<span class="hljs-function"><span class="hljs-title">ata_wf</span>[stream_id]-&gt;</span>BlockID;<br>        <span class="hljs-function"><span class="hljs-title">target_address</span>.PageID = plane_record-&gt;</span>D<span class="hljs-function"><span class="hljs-title">ata_wf</span>[stream_id]-&gt;</span>Current_page_write_index++;<br>        Invalidate_page_in_block_for_preconditioning(stream_id, target_address);<br>        <span class="hljs-function"><span class="hljs-title">plane_record</span>-&gt;</span>Check_bookkeeping_correctness(plane_address);<br>    &#125;<br><br>    <span class="hljs-comment">// 更新写前沿块</span><br>    <span class="hljs-function"><span class="hljs-title">plane_record</span>-&gt;</span>D<span class="hljs-function"><span class="hljs-title">ata_wf</span>[stream_id] = plane_record-&gt;</span>Get_a_free_block(stream_id, <span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>Flash_Block_Manager::Allocate_block_and_page_in_plane_for_translation_write：</strong>用于为翻译写操作（包括普通写和GC写）分配块和页面。</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs xl">void Flash_Block_Manager::Allocate_block_and_page_in_plane_for_translation_write(const stream_id_type streamID, NVM::FlashMemory::Physical_Page_Address&amp; page_address, bool is_for_gc)<br>&#123;<br>    <span class="hljs-comment">// 获取平面记录</span><br>    PlaneBookKeepingType *plane_record = &amp;plane_manager[page_address.ChannelID][page_address.ChipID][page_address.DieID][page_address.PlaneID];<br><br>    <span class="hljs-comment">// 更新有效页面计数和空闲页面计数</span><br>    <span class="hljs-function"><span class="hljs-title">plane_record</span>-&gt;</span>Valid_pages_count++;<br>    <span class="hljs-function"><span class="hljs-title">plane_record</span>-&gt;</span>Free_pages_count--;<br><br>    <span class="hljs-comment">// 如果当前流的翻译写前沿块为空，则分配一个新的空闲块</span><br>    <span class="hljs-function"><span class="hljs-title">if</span>(plane_record-&gt;</span>Translation_wf[streamID] == NULL)&#123;<br>        <span class="hljs-function"><span class="hljs-title">plane_record</span>-&gt;</span>T<span class="hljs-function"><span class="hljs-title">ranslation_wf</span>[streamID] = plane_record-&gt;</span>Get_a_free_block(streamID, <span class="hljs-literal">true</span>);<br>        <span class="hljs-keyword">if</span> (!is_for_gc) &#123;<br>            <span class="hljs-function"><span class="hljs-title">gc_and_wl_unit</span>-&gt;</span>C<span class="hljs-function"><span class="hljs-title">heck_gc_required</span>(plane_record-&gt;</span>Get_free_block_pool_size(), page_address);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 分配页面地址</span><br>    <span class="hljs-function"><span class="hljs-title">page_address</span>.BlockID = plane_record-&gt;</span>T<span class="hljs-function"><span class="hljs-title">ranslation_wf</span>[streamID]-&gt;</span>BlockID;<br>    <span class="hljs-function"><span class="hljs-title">page_address</span>.PageID = plane_record-&gt;</span>T<span class="hljs-function"><span class="hljs-title">ranslation_wf</span>[streamID]-&gt;</span>Current_page_write_index++;<br>    <span class="hljs-keyword">if</span>(!is_for_gc)<br>        program_transaction_issued(page_address);<br><br>    <span class="hljs-comment">// 如果当前翻译写前沿块已经写满</span><br>    <span class="hljs-function"><span class="hljs-title">if</span> (plane_record-&gt;</span>T<span class="hljs-function"><span class="hljs-title">ranslation_wf</span>[streamID]-&gt;</span>Current_page_write_index == pages_no_per_block) &#123;<br>        <span class="hljs-comment">// 分配一个新的空闲块</span><br>        <span class="hljs-function"><span class="hljs-title">plane_record</span>-&gt;</span>T<span class="hljs-function"><span class="hljs-title">ranslation_wf</span>[streamID] = plane_record-&gt;</span>Get_a_free_block(streamID, <span class="hljs-literal">true</span>);<br>        <span class="hljs-keyword">if</span> (!is_for_gc) &#123;<br>            <span class="hljs-function"><span class="hljs-title">gc_and_wl_unit</span>-&gt;</span>C<span class="hljs-function"><span class="hljs-title">heck_gc_required</span>(plane_record-&gt;</span>Get_free_block_pool_size(), page_address);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 检查记录正确性</span><br>    <span class="hljs-function"><span class="hljs-title">plane_record</span>-&gt;</span>Check_bookkeeping_correctness(page_address);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>Flash_Block_Manager::Allocate_block_and_page_in_plane_for_RAID_write：</strong>上一个函数的raid版本</p>
<p><strong>Flash_Block_Manager::Invalidate_page_in_block：</strong>用于在给定的流和页面地址下将页面标记为无效</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs php">inline <span class="hljs-keyword">void</span> Flash_Block_Manager::Invalidate_page_in_block(<span class="hljs-keyword">const</span> stream_id_type stream_id, <span class="hljs-keyword">const</span> NVM::FlashMemory::Physical_Page_Address&amp; page_address)<br>&#123;<br>    <span class="hljs-comment">// 获取对应的平面记录</span><br>    PlaneBookKeepingType* plane_record = &amp;plane_manager[page_address.ChannelID][page_address.ChipID][page_address.DieID][page_address.PlaneID];<br><br>    <span class="hljs-comment">// 更新无效页面计数和有效页面计数</span><br>    plane_record-&gt;Invalid_pages_count++;<br>    plane_record-&gt;Valid_pages_count--;<br><br>    <span class="hljs-comment">// 检查块的所有权和数据类型的一致性</span><br>    <span class="hljs-keyword">if</span> (!plane_record-&gt;Blocks[page_address.BlockID].Holds_RAID_data &amp;&amp; plane_record-&gt;Blocks[page_address.BlockID].Stream_id != stream_id) &#123;<br>        PRINT_ERROR(<span class="hljs-string">&quot;Inconsistent status in the Invalidate_page_in_block function! The accessed block is not allocated to stream &quot;</span> &lt;&lt; stream_id &lt;&lt;<span class="hljs-string">&quot; &quot;</span> &lt;&lt; plane_record-&gt;Blocks[page_address.BlockID].Stream_id)<br>    &#125;<br><br>    <span class="hljs-comment">// 更新块内的无效页面计数和无效页面位图</span><br>    plane_record-&gt;Blocks[page_address.BlockID].Invalid_page_count++;<br>    plane_record-&gt;Blocks[page_address.BlockID].Invalid_page_bitmap[page_address.PageID / <span class="hljs-number">64</span>] |= ((uint64_t)<span class="hljs-number">0x1</span>) &lt;&lt; (page_address.PageID % <span class="hljs-number">64</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>Flash_Block_Manager::Invalidate_page_in_block_for_preconditioning：</strong>预处理阶段将页面标记为无效。预处理阶段通常用于在系统开始正常操作之前，模拟和测试存储系统的行为。</p>
<p>为什么需要将页面标记为无效？</p>
<ol>
<li><strong>模拟真实工作负载</strong>:<ul>
<li>在预处理阶段，通过将页面标记为无效，可以模拟真实系统在长时间使用后的状态。这有助于测试系统在不同使用条件下的性能和稳定性。</li>
</ul>
</li>
<li><strong>准备数据迁移和垃圾回收</strong>:<ul>
<li>无效页面信息对于垃圾回收过程非常重要。在垃圾回收过程中，系统需要知道哪些页面是无效的，以便在回收块时只移动有效数据。</li>
</ul>
</li>
<li><strong>磨损均衡</strong>:<ul>
<li>标记无效页面有助于均衡磨损。在均衡过程中，系统可以将数据从磨损较严重的块迁移到磨损较少的块，从而延长设备的使用寿命。</li>
</ul>
</li>
</ol>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs php">inline <span class="hljs-keyword">void</span> Flash_Block_Manager::Invalidate_page_in_block_for_preconditioning(<span class="hljs-keyword">const</span> stream_id_type stream_id, <span class="hljs-keyword">const</span> NVM::FlashMemory::Physical_Page_Address&amp; page_address)<br>&#123;<br>    <span class="hljs-comment">// 获取与指定页面地址相关的平面记录</span><br>    PlaneBookKeepingType* plane_record = &amp;plane_manager[page_address.ChannelID][page_address.ChipID][page_address.DieID][page_address.PlaneID];<br><br>    <span class="hljs-comment">// 增加平面中无效页面的计数</span><br>    plane_record-&gt;Invalid_pages_count++;<br>    <br>    <span class="hljs-comment">// 检查要标记为无效的页面所在的块是否属于指定的流ID</span><br>    <span class="hljs-keyword">if</span> (plane_record-&gt;Blocks[page_address.BlockID].Stream_id != stream_id) &#123;<br>        <span class="hljs-comment">// 如果不一致，打印错误信息</span><br>        PRINT_ERROR(<span class="hljs-string">&quot;Inconsistent status in the Invalidate_page_in_block function! The accessed block is not allocated to stream &quot;</span> &lt;&lt; stream_id)<br>    &#125;<br>    <br>    <span class="hljs-comment">// 增加块中无效页面的计数</span><br>    plane_record-&gt;Blocks[page_address.BlockID].Invalid_page_count++;<br>    <br>    <span class="hljs-comment">// 更新无效页面的位图</span><br>    <span class="hljs-comment">// 位图使用位操作，将页面ID对应的位置为1，表示该页面无效</span><br>    plane_record-&gt;Blocks[page_address.BlockID].Invalid_page_bitmap[page_address.PageID / <span class="hljs-number">64</span>] |= ((uint64_t)<span class="hljs-number">0x1</span>) &lt;&lt; (page_address.PageID % <span class="hljs-number">64</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>Flash_Block_Manager::Add_erased_block_to_pool：</strong>用于在闪存块擦除后将其添加到空闲块池中的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Flash_Block_Manager::Add_erased_block_to_pool</span><span class="hljs-params">(<span class="hljs-keyword">const</span> NVM::FlashMemory::Physical_Page_Address&amp; block_address)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 1. 获取指定块地址所在的平面记录</span><br>    PlaneBookKeepingType *plane_record = &amp;plane_manager[block_address.ChannelID][block_address.ChipID][block_address.DieID][block_address.PlaneID];<br>    <br>    <span class="hljs-comment">// 2. 获取指定块地址的块对象</span><br>    Block_Pool_Slot_Type* block = &amp;(plane_record-&gt;Blocks[block_address.BlockID]);<br>    <br>    <span class="hljs-comment">// 3. 更新平面中的页面计数</span><br>    <span class="hljs-comment">// 将块中的无效页面数量添加到平面的自由页面计数中</span><br>    <span class="hljs-comment">// 从平面的无效页面计数中减去块中的无效页面数量</span><br>    plane_record-&gt;Free_pages_count += block-&gt;Invalid_page_count;<br>    plane_record-&gt;Invalid_pages_count -= block-&gt;Invalid_page_count;<br><br>    <span class="hljs-comment">// 4. 更新块擦除次数的直方图</span><br>    <span class="hljs-comment">// 从直方图中减少当前擦除次数的计数</span><br>    Stats::Block_erase_histogram[block_address.ChannelID][block_address.ChipID][block_address.DieID][block_address.PlaneID][block-&gt;Erase_count]--;<br>    <br>    <span class="hljs-comment">// 5. 擦除块</span><br>    block-&gt;<span class="hljs-built_in">Erase</span>();<br>    <br>    <span class="hljs-comment">// 6. 擦除后，更新块擦除次数的直方图</span><br>    <span class="hljs-comment">// 增加当前擦除次数的计数</span><br>    Stats::Block_erase_histogram[block_address.ChannelID][block_address.ChipID][block_address.DieID][block_address.PlaneID][block-&gt;Erase_count]++;<br>    <br>    <span class="hljs-comment">// 7. 将擦除后的块添加到空闲块池中</span><br>    <span class="hljs-comment">// 使用动态磨损均衡策略决定是否需要进行动态磨损均衡</span><br>    plane_record-&gt;<span class="hljs-built_in">Add_to_free_block_pool</span>(block, gc_and_wl_unit-&gt;<span class="hljs-built_in">Use_dynamic_wearleveling</span>());<br>    <br>    <span class="hljs-comment">// 8. 检查平面记录的正确性，确保书籍记录的准确性</span><br>    plane_record-&gt;<span class="hljs-built_in">Check_bookkeeping_correctness</span>(block_address);<br>&#125;<br><br></code></pre></td></tr></table></figure>



<h2 id="Flash-Block-Manager-Base"><a href="#Flash-Block-Manager-Base" class="headerlink" title="Flash_Block_Manager_Base"></a>Flash_Block_Manager_Base</h2><p><strong>Block_Pool_Slot_Type::Erase()：</strong>函数用于擦除闪存块并将其恢复为“干净”状态，以便可以重新使用。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs awk">void Block_Pool_Slot_Type::Erase()<br>&#123;<br>    <span class="hljs-regexp">//</span> <span class="hljs-number">1</span>. 重置当前页面写入索引<br>    Current_page_write_index = <span class="hljs-number">0</span>;<br>    <span class="hljs-regexp">//</span> <span class="hljs-number">2</span>. 重置无效页面计数<br>    Invalid_page_count = <span class="hljs-number">0</span>;<br>    <span class="hljs-regexp">//</span> <span class="hljs-number">3</span>. 重置半有效页面计数<br>    Semi_page_count = <span class="hljs-number">0</span>;<br>    <span class="hljs-regexp">//</span> <span class="hljs-number">4</span>. 增加擦除计数<br>    Erase_count++;<br>    <br>    <span class="hljs-regexp">//</span> <span class="hljs-number">5</span>. 遍历所有页面的位图<br>    <span class="hljs-keyword">for</span> (unsigned int i = <span class="hljs-number">0</span>; i &lt; Block_Pool_Slot_Type::Page_vector_size; i++) &#123;<br>        <span class="hljs-regexp">//</span> <span class="hljs-number">6</span>. 将所有页面标记为有效<br>        Invalid_page_bitmap[i] = All_VALID_PAGE;<br>        <br>        <span class="hljs-regexp">//</span> <span class="hljs-number">7</span>. 检查半有效页面位图是否有被设置的标志位，如果有，则抛出异常<br>        <span class="hljs-keyword">if</span>(Semi_page_bitmap[i])&#123;<br>            throw <span class="hljs-string">&quot;if(Semi_page_bitmap[i])&quot;</span>;<br>        &#125;<br>        <br>        <span class="hljs-regexp">//</span> <span class="hljs-number">8</span>. 将半有效页面位图中的所有页面标记为有效<br>        Semi_page_bitmap[i] = All_VALID_PAGE;<br>    &#125;<br>    <br>    <span class="hljs-regexp">//</span> <span class="hljs-number">9</span>. 清除块的流 ID，设置为 NO_STREAM（表示块不再属于任何流）<br>    Stream_id = NO_STREAM;<br>    <span class="hljs-regexp">//</span> <span class="hljs-number">10</span>. 清除块的映射数据标志<br>    Holds_mapping_data = false;<br>    <span class="hljs-regexp">//</span> <span class="hljs-number">11</span>. 清除擦除事务指针<br>    Erase_transaction = NULL;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>PlaneBookKeepingType::Get_a_free_block：</strong>此函数从空闲块池中获取一个块，并将其配置为适合新的写入操作。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Block_Pool_Slot_Type* PlaneBookKeepingType::<span class="hljs-constructor">Get_a_free_block(<span class="hljs-params">stream_id_type</span> <span class="hljs-params">stream_id</span>, <span class="hljs-params">bool</span> <span class="hljs-params">for_mapping_data</span>)</span><br>&#123;<br>    Block_Pool_Slot_Type* new_block = NULL;  <span class="hljs-comment">// 声明一个指针，初始为 NULL</span><br>    <br>    <span class="hljs-comment">// 从空闲块池中获取一个块</span><br>    new_block = (*<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Free_block_pool</span>.</span></span><span class="hljs-keyword">begin</span><span class="hljs-literal">()</span>).second;  <span class="hljs-comment">// 选择池中的第一个块</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Free_block_pool</span>.</span></span>size<span class="hljs-literal">()</span><span class="hljs-operator"> == </span><span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 如果空闲块池为空</span><br>        <span class="hljs-constructor">PRINT_ERROR(<span class="hljs-string">&quot;Requesting a free block from an empty pool!&quot;</span>)</span>  <span class="hljs-comment">// 打印错误信息</span><br>    &#125;<br>    <br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Free_block_pool</span>.</span></span>erase(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Free_block_pool</span>.</span></span><span class="hljs-keyword">begin</span><span class="hljs-literal">()</span>);  <span class="hljs-comment">// 从空闲块池中移除已分配的块</span><br>    new_block-&gt;Stream_id = stream_id;  <span class="hljs-comment">// 设置块的流 ID</span><br>    <br>    new_block-&gt;Holds_mapping_data = for_mapping_data;  <span class="hljs-comment">// 设置块是否持有映射数据</span><br>    new_block-&gt;Holds_RAID_data = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 设置块是否持有 RAID 数据（默认为 false）</span><br>    <br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Block_usage_history</span>.</span></span>push(new_block-&gt;BlockID);  <span class="hljs-comment">// 将块的 ID 记录到使用历史中</span><br><br>    return new_block;  <span class="hljs-comment">// 返回分配的块</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>PlaneBookKeepingType::Check_bookkeeping_correctness：</strong>此函数用于检查平面级别的记账记录是否一致，并在出现不一致或资源耗尽时打印错误信息。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void PlaneBookKeepingType::<span class="hljs-constructor">Check_bookkeeping_correctness(<span class="hljs-params">const</span> NVM::FlashMemory::Physical_Page_Address&amp; <span class="hljs-params">plane_address</span>)</span><br>&#123;<br>    <span class="hljs-comment">// 检查总页数是否等于空闲页数、有效页数和无效页数之和</span><br>    <span class="hljs-keyword">if</span> (Total_pages_count != Free_pages_count + Valid_pages_count + Invalid_pages_count) &#123;<br>        <span class="hljs-constructor">PRINT_ERROR(<span class="hljs-string">&quot;Inconsistent status in the plane bookkeeping record!&quot;</span>)</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 检查空闲页数是否为零</span><br>    <span class="hljs-keyword">if</span> (Free_pages_count<span class="hljs-operator"> == </span><span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-constructor">PRINT_ERROR(<span class="hljs-string">&quot;Plane &quot;</span> &lt;&lt; <span class="hljs-string">&quot;@&quot;</span> &lt;&lt; <span class="hljs-params">plane_address</span>.ChannelID &lt;&lt; <span class="hljs-string">&quot;@&quot;</span> &lt;&lt; <span class="hljs-params">plane_address</span>.ChipID &lt;&lt; <span class="hljs-string">&quot;@&quot;</span> &lt;&lt; <span class="hljs-params">plane_address</span>.DieID &lt;&lt; <span class="hljs-string">&quot;@&quot;</span> &lt;&lt; <span class="hljs-params">plane_address</span>.PlaneID &lt;&lt; <span class="hljs-string">&quot; pool size: &quot;</span> &lt;&lt; Get_free_block_pool_size()</span> &lt;&lt; <span class="hljs-string">&quot; ran out of free pages! Bad resource management! It is not safe to continue simulation!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>PlaneBookKeepingType::Add_to_free_block_pool：</strong>此函数用于将一个块添加到空闲块池中，并根据是否考虑动态磨损均衡（wear leveling）来确定插入的优先级。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void PlaneBookKeepingType::<span class="hljs-constructor">Add_to_free_block_pool(Block_Pool_Slot_Type<span class="hljs-operator">*</span> <span class="hljs-params">block</span>, <span class="hljs-params">bool</span> <span class="hljs-params">consider_dynamic_wl</span>)</span><br>&#123;<br>    <span class="hljs-comment">// 如果考虑动态磨损均衡</span><br>    <span class="hljs-keyword">if</span> (consider_dynamic_wl) &#123;<br>        <span class="hljs-comment">// 使用块的擦除次数作为优先级，将块插入空闲块池中</span><br>        std::pair&lt;unsigned <span class="hljs-built_in">int</span>, Block_Pool_Slot_Type*&gt; entry(block-&gt;Erase_count, block);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Free_block_pool</span>.</span></span>insert(entry);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 如果不考虑动态磨损均衡，使用固定优先级（0）将块插入空闲块池中</span><br>        std::pair&lt;unsigned <span class="hljs-built_in">int</span>, Block_Pool_Slot_Type*&gt; entry(<span class="hljs-number">0</span>, block);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Free_block_pool</span>.</span></span>insert(entry);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>Flash_Block_Manager_Base::Get_min_max_erase_difference：</strong>此函数用于计算给定平面中块擦除次数的最大差异（max-min）。</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> Flash_Block_Manager_Base::Get_min_max_erase_difference(<span class="hljs-keyword">const</span> NVM::FlashMemory::Physical_Page_Address&amp; plane_address)<br>&#123;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> min_erased_block = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 记录擦除次数最少的块的索引</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> max_erased_block = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 记录擦除次数最多的块的索引</span><br>    PlaneBookKeepingType *plane_record = &amp;plane_manager[plane_address.ChannelID][plane_address.ChipID][plane_address.DieID][plane_address.PlaneID];<br><br>    <span class="hljs-comment">// 遍历平面中的所有块以找到擦除次数最小和最大的块</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; block_no_per_plane; i++) &#123;<br>        <span class="hljs-keyword">if</span> (plane_record-&gt;Blocks[i].Erase_count &gt; plane_record-&gt;Blocks[max_erased_block].Erase_count) &#123;<br>            max_erased_block = i;  <span class="hljs-comment">// 更新最大擦除次数块的索引</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (plane_record-&gt;Blocks[i].Erase_count &lt; plane_record-&gt;Blocks[min_erased_block].Erase_count) &#123;<br>            min_erased_block = i;  <span class="hljs-comment">// 更新最小擦除次数块的索引</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 返回擦除次数最大块与最小块的擦除次数差异</span><br>    <span class="hljs-keyword">return</span> plane_record-&gt;Blocks[max_erased_block].Erase_count - plane_record-&gt;Blocks[min_erased_block].Erase_count;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>Flash_Block_Manager_Base::Get_coldest_block_id：</strong>此函数用于在给定平面中找到擦除次数最少的块（即“最冷”的块）的ID。</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs zephir">flash_block_ID_type Flash_Block_Manager_Base::Get_coldest_block_id(<span class="hljs-keyword">const</span> NVM::FlashMemory::Physical_Page_Address&amp; plane_address)<br>&#123;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> min_erased_block = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 记录擦除次数最少的块的索引</span><br>    PlaneBookKeepingType *plane_record = &amp;plane_manager[plane_address.ChannelID][plane_address.ChipID][plane_address.DieID][plane_address.PlaneID];<br><br>    <span class="hljs-comment">// 遍历平面中的所有块以找到擦除次数最少的块</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; block_no_per_plane; i++) &#123;<br>        <span class="hljs-keyword">if</span> (plane_record-&gt;Blocks[i].Erase_count &lt; plane_record-&gt;Blocks[min_erased_block].Erase_count) &#123;<br>            min_erased_block = i;  <span class="hljs-comment">// 更新最小擦除次数块的索引</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 返回擦除次数最少的块的索引</span><br>    <span class="hljs-keyword">return</span> min_erased_block;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>Flash_Block_Manager_Base::Block_has_ongoing_gc_wl：</strong>此函数用于检查指定块是否正在进行垃圾回收（GC）或磨损均衡（WL）。</p>
<p><strong>Flash_Block_Manager_Base::Can_execute_gc_wl：</strong>此函数用于检查指定块是否可以执行垃圾回收（GC）或磨损均衡（WL）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Flash_Block_Manager_Base::Can_execute_gc_wl</span><span class="hljs-params">(<span class="hljs-keyword">const</span> NVM::FlashMemory::Physical_Page_Address&amp; block_address)</span></span><br><span class="hljs-function"></span>&#123;<br>    PlaneBookKeepingType *plane_record = &amp;plane_manager[block_address.ChannelID][block_address.ChipID][block_address.DieID][block_address.PlaneID];<br>    <br>    <span class="hljs-comment">// 检查正在进行的用户程序计数是否小于0，这是一个错误状态</span><br>    <span class="hljs-keyword">if</span> (plane_record-&gt;Blocks[block_address.BlockID].Ongoing_user_program_count &lt; <span class="hljs-number">0</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;1 &quot;</span> &lt;&lt; plane_record-&gt;Blocks[block_address.BlockID].Ongoing_user_program_count &lt;&lt; std::endl;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 检查正在进行的用户读取计数是否小于0，这是一个错误状态</span><br>    <span class="hljs-keyword">if</span> (plane_record-&gt;Blocks[block_address.BlockID].Ongoing_user_read_count &lt; <span class="hljs-number">0</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;2 &quot;</span> &lt;&lt; plane_record-&gt;Blocks[block_address.BlockID].Ongoing_user_read_count &lt;&lt; std::endl;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 返回该块是否没有进行中的用户程序和读取操作</span><br>    <span class="hljs-keyword">return</span> (plane_record-&gt;Blocks[block_address.BlockID].Ongoing_user_program_count + plane_record-&gt;Blocks[block_address.BlockID].Ongoing_user_read_count == <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>Flash_Block_Manager_Base::program_transaction_issued：</strong>此函数用于记录用户发起的程序操作，将相应块的正在进行的用户程序计数增加。</p>
<p><strong>Flash_Block_Manager_Base::Program_transaction_serviced：</strong>program_transaction_issued是Ongoing_user_program_count加一，Program_transaction_service是Ongoing_user_program_count减一。</p>
<p><strong>Flash_Block_Manager_Base::Read_transaction_issued：</strong>此函数用于记录用户发起的读操作，将相应块的正在进行的用户读计数（Ongoing_user_read_count）增加。</p>
<p><strong>Flash_Block_Manager_Base::Read_transaction_serviced：</strong>块上的Ongoing_user_read_count计数减一。</p>
<p><strong>Flash_Block_Manager_Base::Is_having_ongoing_program：</strong>判断Ongoing_user_program_count</p>
<p>是否大于0，由此判断块上是否还有执行程序。</p>
<p><strong>Flash_Block_Manager_Base::GC_WL_finished：</strong>将是否在GC和WL的状态改为false</p>
<p><strong>Flash_Block_Manager_Base::Insemilate_page_in_block：</strong>此函数用于半页状态的更新，确保页面不再处于半页状态，并更新相关的统计信息。</p>
<p>半页状态：特别是在处理闪存块中的页时。它通常用于描述在页编程或写入过程中尚未完全写入的页的状态。</p>
<p><strong>半页（Semi Page）：</strong> 该页面只写入了一部分数据，或者是该页面在写入过程中部分完成的状态。这可能是由于写入操作中断、页面编程中出现错误或故障，导致该页面只有部分数据被写入。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">void</span> Flash_Block_Manager_Base::Insemilate_page_in_block(<span class="hljs-keyword">const</span> stream_id_type stream_id, <span class="hljs-keyword">const</span> NVM::FlashMemory::Physical_Page_Address&amp; page_address)<br>&#123;<br>    <span class="hljs-comment">// 获取平面记录</span><br>    PlaneBookKeepingType* plane_record = &amp;plane_manager[page_address.ChannelID][page_address.ChipID][page_address.DieID][page_address.PlaneID];<br><br>    <span class="hljs-comment">// 检查并处理半页状态</span><br>    <span class="hljs-keyword">if</span> (plane_record-&gt;Blocks[page_address.BlockID].Semi_page_bitmap[page_address.PageID / <span class="hljs-number">64</span>] &amp; (((uint64_t)<span class="hljs-number">0x1</span>) &lt;&lt; (page_address.PageID % <span class="hljs-number">64</span>))) &#123;<br>        <span class="hljs-comment">// 清除半页状态位</span><br>        plane_record-&gt;Blocks[page_address.BlockID].Semi_page_bitmap[page_address.PageID / <span class="hljs-number">64</span>] &amp;= (~(((uint64_t)<span class="hljs-number">0x1</span>) &lt;&lt; (page_address.PageID % <span class="hljs-number">64</span>)));<br>        <br>        <span class="hljs-comment">// 减少半页计数</span><br>        plane_record-&gt;Blocks[page_address.BlockID].Semi_page_count--;<br><br>        <span class="hljs-comment">// 确认块的流ID一致性</span><br>        <span class="hljs-keyword">if</span> (!plane_record-&gt;Blocks[page_address.BlockID].Holds_RAID_data &amp;&amp; plane_record-&gt;Blocks[page_address.BlockID].Stream_id != stream_id) &#123;<br>            PRINT_ERROR(<span class="hljs-string">&quot;Inconsistent status in the Insemilate_page_in_block function! The accessed block is not allocated to stream &quot;</span> &lt;&lt; stream_id &lt;&lt;<span class="hljs-string">&quot; &quot;</span> &lt;&lt; plane_record-&gt;Blocks[page_address.BlockID].Stream_id)<br>        &#125;<br><br>        <span class="hljs-comment">// 确认半页状态位已清除</span><br>        <span class="hljs-keyword">if</span> (plane_record-&gt;Blocks[page_address.BlockID].Semi_page_bitmap[page_address.PageID / <span class="hljs-number">64</span>] &amp; (((uint64_t)<span class="hljs-number">0x1</span>) &lt;&lt; (page_address.PageID % <span class="hljs-number">64</span>))) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;Insemilate_page_in_block fail!!&quot;</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;plane_record-&gt;Blocks[page_address.BlockID].Semi_page_bitmap[page_address.PageID / 64] &amp; ((uint64_t)0x1) &lt;&lt; (page_address.PageID % 64&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>Flash_Block_Manager_Base::Semilate_page_in_block：</strong>函数用于管理闪存块中页的状态，特别是在写入过程中标记半页。它确保了块的状态正确，并更新了半页计数和位图，以便后续的操作可以正确处理这些半页。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">void</span> Flash_Block_Manager_Base::Semilate_page_in_block(<span class="hljs-keyword">const</span> stream_id_type stream_id, <span class="hljs-keyword">const</span> NVM::FlashMemory::Physical_Page_Address&amp; page_address) &#123;<br>    <span class="hljs-comment">// 获取与给定页面地址相关的平面记录</span><br>    PlaneBookKeepingType* plane_record = &amp;plane_manager[page_address.ChannelID][page_address.ChipID][page_address.DieID][page_address.PlaneID];<br>    <br>    <span class="hljs-comment">// 检查页面所属的块是否与传入的流ID匹配</span><br>    <span class="hljs-comment">// 如果块不持有RAID数据且流ID不匹配，打印错误信息</span><br>    <span class="hljs-keyword">if</span> (!plane_record-&gt;Blocks[page_address.BlockID].Holds_RAID_data &amp;&amp; plane_record-&gt;Blocks[page_address.BlockID].Stream_id != stream_id) &#123;<br>        PRINT_ERROR(<span class="hljs-string">&quot;Inconsistent status in the Semilate_page_in_block function! The accessed block is not allocated to stream &quot;</span> &lt;&lt; stream_id &lt;&lt;<span class="hljs-string">&quot; &quot;</span> &lt;&lt;plane_record-&gt;Blocks[page_address.BlockID].Stream_id)<br>    &#125;<br>    <br>    <span class="hljs-comment">// 增加块的半页计数</span><br>    plane_record-&gt;Blocks[page_address.BlockID].Semi_page_count++;<br>    <br>    <span class="hljs-comment">// 更新半页位图</span><br>    <span class="hljs-comment">// 计算页面在位图中的位置，并将对应位置的位设置为1，标记该页面为半页</span><br>    plane_record-&gt;Blocks[page_address.BlockID].Semi_page_bitmap[page_address.PageID / <span class="hljs-number">64</span>] |= (((uint64_t)<span class="hljs-number">0x1</span>) &lt;&lt; (page_address.PageID % <span class="hljs-number">64</span>));<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>Flash_Block_Manager_Base::Is_page_Semil：</strong>判断是否半页</p>
<p><strong>代码解释</strong></p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lisp">if ((<span class="hljs-name">block-&gt;Semi_page_bitmap</span>[page_id / <span class="hljs-number">64</span>] &amp; (((<span class="hljs-name">uint64_t</span>)<span class="hljs-number">1</span>) &lt;&lt; (<span class="hljs-name">page_id</span> % <span class="hljs-number">64</span>))) == <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure>

<p><strong>组成部分：</strong></p>
<ol>
<li><p><strong><code>block-&gt;Semi_page_bitmap[page_id / 64]</code></strong></p>
<ul>
<li>这是一个访问位图的操作。<code>Semi_page_bitmap</code> 是一个数组或容器，用于表示块中每个页面的状态。由于位图可能使用多个 <code>uint64_t</code> 元素来存储信息，<code>page_id / 64</code> 计算出页面 ID 所在的 <code>uint64_t</code> 元素的索引。</li>
</ul>
</li>
<li><p><strong><code>(((uint64_t)1) &lt;&lt; (page_id % 64))</code></strong></p>
<ul>
<li>这是一个位掩码操作。<code>(page_id % 64)</code> 计算出页面 ID 在当前 <code>uint64_t</code> 元素中的位置。通过将 <code>1</code> 左移该位置的位数，创建一个掩码，用于检查或设置位图中的特定位。</li>
</ul>
</li>
<li><p><strong><code>block-&gt;Semi_page_bitmap[page_id / 64] &amp; (((uint64_t)1) &lt;&lt; (page_id % 64))</code></strong></p>
<ul>
<li>这是一个按位与操作，用于检查 <code>Semi_page_bitmap</code> 中对应位置的位是否被设置。如果结果为非零，说明该位置的位已经被设置（即页面是半页状态）；如果结果为零，则说明该位置的位未被设置。</li>
</ul>
</li>
</ol>
<h2 id="Flash-Transaction-Queue"><a href="#Flash-Transaction-Queue" class="headerlink" title="Flash_Transaction_Queue"></a>Flash_Transaction_Queue</h2><p><strong>Flash_Transaction_Queue::push_back：</strong>尾插入</p>
<p><strong><code>RequestQueueProbe.EnqueueRequest(transaction);</code></strong></p>
<ul>
<li>这个调用向 <code>RequestQueueProbe</code> 发送了一个事务对象。<code>RequestQueueProbe</code> 是一个用于监控或处理事务请求的对象或组件，<code>EnqueueRequest</code> 方法将事务添加到 <code>RequestQueueProbe</code> 内部的队列中。这通常用于跟踪或管理进入队列的事务。</li>
</ul>
<p><strong><code>return list&lt;NVM_Transaction_Flash\*&gt;::push_back(transaction);</code></strong></p>
<ul>
<li>这里调用了 <code>list&lt;NVM_Transaction_Flash*&gt;::push_back(transaction)</code> 方法，将事务对象添加到 <code>Flash_Transaction_Queue</code> 类的 <code>list</code> 容器的末尾。<code>list</code> 是一个双向链表，它提供了高效的插入和删除操作。</li>
<li><code>push_back</code> 是 <code>list</code> 类提供的成员函数，用于将一个元素添加到链表的末尾。</li>
</ul>
<p><strong>Flash_Transaction_Queue::push_front：</strong>头插入</p>
<p><strong>Flash_Transaction_Queue::insert：</strong>指定位置插入</p>
<p><strong>Flash_Transaction_Queue::remove：</strong>删除对应条目</p>
<p><strong>remove第二个版本：通过迭代器</strong></p>
<p><strong>主要区别</strong></p>
<ol>
<li><strong>参数类型</strong>：<ul>
<li>第一个 <code>remove</code> 函数使用事务对象的指针作为参数。</li>
<li>第二个 <code>remove</code> 函数使用指向事务对象的迭代器作为参数。</li>
</ul>
</li>
<li><strong>删除方式</strong>：<ul>
<li>第一个 <code>remove</code> 函数在链表中查找并删除与给定指针匹配的事务对象。这种方式可能会遍历整个链表，找到并删除该事务对象。</li>
<li>第二个 <code>remove</code> 函数直接通过迭代器位置删除事务对象，这种方式更高效，因为它不需要遍历链表。</li>
</ul>
</li>
</ol>
<p><strong>Flash_Transaction_Queue::pop_front()：</strong>弹出第一个</p>
<p><strong>Flash_Transaction_Queue::Report_results_in_XML：</strong>用于将事务队列的统计结果输出到XML格式中。它接收一个前缀字符串和一个XML写入对象，并将队列的各项统计数据写入XML。</p>
<h2 id="FTL"><a href="#FTL" class="headerlink" title="FTL"></a>FTL</h2><p><strong>FTL::Validate_simulation_config()：</strong>模拟配置的完整性，确保在模拟运行前，各个关键组件都已正确设置。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FTL::Validate_simulation_config</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 调用父类 NVM_Firmware 的配置验证方法</span><br>    NVM_Firmware::<span class="hljs-built_in">Validate_simulation_config</span>();<br>    <br>    <span class="hljs-comment">// 检查数据缓存管理器是否已设置</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;Data_cache_manager == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">logic_error</span>(<span class="hljs-string">&quot;The cache manager is not set for FTL!&quot;</span>);<br>    <br>    <span class="hljs-comment">// 检查地址映射单元是否已设置</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;Address_Mapping_Unit == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">logic_error</span>(<span class="hljs-string">&quot;The mapping module is not set for FTL!&quot;</span>);<br>    <br>    <span class="hljs-comment">// 检查块管理器是否已设置</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;BlockManager == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">logic_error</span>(<span class="hljs-string">&quot;The block manager is not set for FTL!&quot;</span>);<br>    <br>    <span class="hljs-comment">// 检查垃圾收集和磨损均衡单元是否已设置</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;GC_and_WL_Unit == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">logic_error</span>(<span class="hljs-string">&quot;The garbage collector is not set for FTL!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>FTL::Perform_precondition：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FTL::Perform_precondition</span><span class="hljs-params">(std::vector&lt;Utils::Workload_Statistics*&gt; workload_stats)</span></span><br><span class="hljs-function">	</span>&#123;<br>		Address_Mapping_Unit-&gt;<span class="hljs-built_in">Store_mapping_table_on_flash_at_start</span>();<br><br>		<span class="hljs-keyword">double</span> overall_rate = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 以下for循环，它根据每个工作负载统计对象的属性，来计算请求到达的平均速率，并将其累加到 overall_rate 中。</span><br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> <span class="hljs-keyword">const</span> &amp;stat : workload_stats)<br>		&#123;<br>			<span class="hljs-keyword">if</span> (stat-&gt;Type == Utils::Workload_Type::SYNTHETIC)<br>			&#123;<br>				<span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (stat-&gt;generator_type)<br>				&#123;<br>				<span class="hljs-keyword">case</span> Utils::Request_Generator_Type::BANDWIDTH:<br>					overall_rate += <span class="hljs-number">1.0</span> / <span class="hljs-built_in"><span class="hljs-keyword">double</span></span>(stat-&gt;Average_inter_arrival_time_nano_sec) * SIM_TIME_TO_SECONDS_COEFF * stat-&gt;Average_request_size_sector;<br>					<span class="hljs-keyword">break</span>;<br>				<span class="hljs-keyword">case</span> Utils::Request_Generator_Type::QUEUE_DEPTH:<br>				&#123;<br>					sim_time_type max_arrival_time = <span class="hljs-built_in">sim_time_type</span>(stat-&gt;Read_ratio * <span class="hljs-built_in"><span class="hljs-keyword">double</span></span>(avg_flash_read_latency) + (<span class="hljs-number">1</span> - stat-&gt;Read_ratio) * <span class="hljs-built_in"><span class="hljs-keyword">double</span></span>(avg_flash_program_latency));<br>					<span class="hljs-keyword">double</span> avg_arrival_time = <span class="hljs-built_in"><span class="hljs-keyword">double</span></span>(max_arrival_time) / <span class="hljs-built_in"><span class="hljs-keyword">double</span></span>(stat-&gt;Request_queue_depth);<br>					overall_rate += <span class="hljs-number">1.0</span> / avg_arrival_time * SIM_TIME_TO_SECONDS_COEFF * stat-&gt;Average_request_size_sector;<br>					<span class="hljs-keyword">break</span>;<br>				&#125;<br>				<span class="hljs-keyword">default</span>:<br>					<span class="hljs-built_in">PRINT_ERROR</span>(<span class="hljs-string">&quot;Unknown request type generator in the FTL preconditioning function.&quot;</span>)<br>				&#125;<br>			&#125;<br>			<span class="hljs-keyword">else</span><br>			&#123;<br>				overall_rate += <span class="hljs-number">1.0</span> / <span class="hljs-built_in"><span class="hljs-keyword">double</span></span>(stat-&gt;Average_inter_arrival_time_nano_sec) * SIM_TIME_TO_SECONDS_COEFF * stat-&gt;Average_request_size_sector;<br>			&#125;<br>		&#125;<br><br>		<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> total_accessed_cmt_entries = <span class="hljs-number">0</span>;<br><br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;stat : workload_stats)<br>		&#123;<br>			LPA_type no_of_logical_pages_in_steadystate = (LPA_type)(stat-&gt;Initial_occupancy_ratio * Address_Mapping_Unit-&gt;<span class="hljs-built_in">Get_logical_pages_count</span>(stat-&gt;Stream_id));<br>			<span class="hljs-comment">// 用于处理和生成逻辑地址（LHA）和逻辑页面地址（LPA）的预处理部分</span><br>			<span class="hljs-comment">//Step 1: generate LPAs that are accessed in the steady-state（加载已经就位的LPAS）</span><br>            <span class="hljs-comment">// 决策地址分布类型</span><br>            Utils::Address_Distribution_Type decision_dist_type = stat-&gt;Address_distribution_type;<br>            <span class="hljs-comment">// 存储被访问的LPA集合</span><br>            std::map&lt;LPA_type, page_status_type&gt; lpa_set_for_preconditioning;<br>            <span class="hljs-comment">// 仅用于跟踪工作负载的LPA排序直方图</span><br>            std::multimap&lt;<span class="hljs-keyword">int</span>, LPA_type, std::greater&lt;<span class="hljs-keyword">int</span>&gt;&gt; trace_lpas_sorted_histogram;<br>            <span class="hljs-comment">// 仅用于跟踪工作负载以检测热地址的热区最后索引</span><br>            <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> hot_region_last_index_in_histogram = <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">// 最小LHA（逻辑主机地址）</span><br>            LHA_type min_lha = stat-&gt;Min_LHA;<br>            <span class="hljs-comment">// 最大LHA（逻辑主机地址）</span><br>            LHA_type max_lha = stat-&gt;Max_LHA - <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">// 将最小LHA转换为设备地址中的LPA</span><br>            LPA_type min_lpa = <span class="hljs-built_in">Convert_host_logical_address_to_device_address</span>(min_lha);<br>            <span class="hljs-comment">// 如果需要生成对齐的地址</span><br>            <span class="hljs-keyword">if</span> (stat-&gt;generate_aligned_addresses)<br>            &#123;<br>                <span class="hljs-comment">// 确保min_lha是对齐的</span><br>                <span class="hljs-keyword">if</span> (min_lha % stat-&gt;alignment_value != <span class="hljs-number">0</span>)<br>                    min_lha += stat-&gt;alignment_value - (min_lha % stat-&gt;alignment_value);<br>                <span class="hljs-comment">// 确保max_lha是对齐的</span><br>                <span class="hljs-keyword">if</span> (max_lha % stat-&gt;alignment_value != <span class="hljs-number">0</span>)<br>                    max_lha -= min_lha % stat-&gt;alignment_value;<br>            &#125;<br>            <span class="hljs-comment">// 将最大LHA转换为设备地址中的LPA，并减去1</span><br>            LPA_type max_lpa = <span class="hljs-built_in">Convert_host_logical_address_to_device_address</span>(max_lha) - <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">// 计算总共访问的CMT条目数</span><br>            total_accessed_cmt_entries += (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)(<span class="hljs-built_in">Convert_host_logical_address_to_device_address</span>(max_lha) / page_size_in_sectors - <span class="hljs-built_in">Convert_host_logical_address_to_device_address</span>(min_lha) / page_size_in_sectors) + <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">// 标记热范围是否完成（用于热/冷流量模式的快速地址生成）</span><br>            <span class="hljs-keyword">bool</span> hot_range_finished = <span class="hljs-literal">false</span>;<br>            <span class="hljs-comment">// 用于热/冷流量模式快速地址生成的热区结束LSA和生成用的热LHA</span><br>            LHA_type hot_region_end_lsa = <span class="hljs-number">0</span>, hot_lha_used_for_generation = <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">// 最后一个热LPA</span><br>            LPA_type last_hot_lpa = <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">// 这段代码片段用于生成合成工作负载的请求，主要处理各种地址分布类型以及请求大小分布类型。</span><br>		   <span class="hljs-keyword">if</span> (stat-&gt;Type == Utils::Workload_Type::SYNTHETIC)<br>            &#123;<br>                <span class="hljs-comment">// 初始化变量</span><br>                <span class="hljs-keyword">bool</span> is_read = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> size = <span class="hljs-number">0</span>;<br>                LHA_type start_LBA = <span class="hljs-number">0</span>, streaming_next_address = <span class="hljs-number">0</span>;<br><br>                <span class="hljs-comment">// 初始化随机生成器</span><br>                Utils::RandomGenerator* random_request_type_generator = <span class="hljs-keyword">new</span> Utils::<span class="hljs-built_in">RandomGenerator</span>(stat-&gt;random_request_type_generator_seed);<br>                Utils::RandomGenerator* random_address_generator = <span class="hljs-keyword">new</span> Utils::<span class="hljs-built_in">RandomGenerator</span>(stat-&gt;random_address_generator_seed);<br>                Utils::RandomGenerator* random_hot_address_generator = <span class="hljs-literal">NULL</span>;<br>                Utils::RandomGenerator* random_hot_cold_generator = <span class="hljs-literal">NULL</span>;<br>                Utils::RandomGenerator* random_request_size_generator = <span class="hljs-literal">NULL</span>;<br>                <span class="hljs-keyword">bool</span> fully_include_hot_addresses = <span class="hljs-literal">false</span>;<br><br>                <span class="hljs-comment">// 如果地址分布类型是RANDOM_HOTCOLD并且热地址比例大于0.3，则视为RANDOM_UNIFORM</span><br>                <span class="hljs-keyword">if</span> (stat-&gt;Address_distribution_type == Utils::Address_Distribution_Type::RANDOM_HOTCOLD)<br>                    <span class="hljs-keyword">if</span> (stat-&gt;Ratio_of_hot_addresses_to_whole_working_set &gt; <span class="hljs-number">0.3</span>)<br>                        decision_dist_type = Utils::Address_Distribution_Type::RANDOM_UNIFORM;<br><br>                <span class="hljs-comment">// 准备地址生成参数</span><br>                <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (decision_dist_type)<br>                &#123;<br>                    <span class="hljs-keyword">case</span> Utils::Address_Distribution_Type::RANDOM_HOTCOLD:<br>                    &#123;<br>                        <span class="hljs-comment">// 初始化热地址和冷热地址生成器</span><br>                        random_hot_address_generator = <span class="hljs-keyword">new</span> Utils::<span class="hljs-built_in">RandomGenerator</span>(stat-&gt;random_hot_address_generator_seed);<br>                        random_hot_cold_generator = <span class="hljs-keyword">new</span> Utils::<span class="hljs-built_in">RandomGenerator</span>(stat-&gt;random_hot_cold_generator_seed);<br><br>                        <span class="hljs-comment">// 计算热区结束地址</span><br>                        hot_region_end_lsa = min_lha + (LHA_type)((<span class="hljs-keyword">double</span>)(max_lha - min_lha) * stat-&gt;Ratio_of_hot_addresses_to_whole_working_set);<br>                        last_hot_lpa = <span class="hljs-built_in">Convert_host_logical_address_to_device_address</span>(hot_region_end_lsa) - <span class="hljs-number">1</span>;<br><br>                        <span class="hljs-comment">// 初始化热地址生成</span><br>                        hot_lha_used_for_generation = min_lha;<br><br>                        <span class="hljs-comment">// 检查是否能在工作集中生成足够的LPA</span><br>                        <span class="hljs-keyword">if</span> ((last_hot_lpa - min_lpa) &lt; no_of_logical_pages_in_steadystate)<br>                            fully_include_hot_addresses = <span class="hljs-literal">true</span>;<br><br>                        <span class="hljs-keyword">if</span> ((max_lpa - last_hot_lpa) &lt; <span class="hljs-number">1.1</span> * (no_of_logical_pages_in_steadystate - (last_hot_lpa - min_lpa)))<br>                        &#123;<br>                            <span class="hljs-built_in">PRINT_MESSAGE</span>(<span class="hljs-string">&quot;The specified initial occupancy value could not be satisfied as the working set of workload #&quot;</span> &lt;&lt; stat-&gt;Stream_id &lt;&lt; <span class="hljs-string">&quot; is small. MQSim made some adjustments!&quot;</span>);<br>                            max_lha = min_lha + <span class="hljs-built_in">LHA_type</span>(<span class="hljs-built_in"><span class="hljs-keyword">double</span></span>(max_lha - min_lha) / stat-&gt;Working_set_ratio);<br>                            <span class="hljs-keyword">if</span> (stat-&gt;generate_aligned_addresses)<br>                                <span class="hljs-keyword">if</span> (max_lha % stat-&gt;alignment_value != <span class="hljs-number">0</span>)<br>                                    max_lha -= min_lha % stat-&gt;alignment_value;<br>                            max_lpa = <span class="hljs-built_in">Convert_host_logical_address_to_device_address</span>(max_lha);<br>                        &#125;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">case</span> Utils::Address_Distribution_Type::STREAMING:<br>                    &#123;<br>                        <span class="hljs-comment">// 生成流式地址</span><br>                        streaming_next_address = random_address_generator-&gt;<span class="hljs-built_in">Uniform_ulong</span>(min_lha, max_lha);<br>                        stat-&gt;First_Accessed_Address = streaming_next_address;<br><br>                        <span class="hljs-comment">// 检查是否能在工作集中生成足够的LPA</span><br>                        <span class="hljs-keyword">if</span> ((max_lpa - min_lpa) &lt; no_of_logical_pages_in_steadystate)<br>                        &#123;<br>                            <span class="hljs-built_in">PRINT_MESSAGE</span>(<span class="hljs-string">&quot;The specified initial occupancy value could not be satisfied as the working set of workload #&quot;</span> &lt;&lt; stat-&gt;Stream_id &lt;&lt; <span class="hljs-string">&quot; is small. MQSim made some adjustments!&quot;</span>);<br>                            max_lha = min_lha + <span class="hljs-built_in">LHA_type</span>(<span class="hljs-built_in"><span class="hljs-keyword">double</span></span>(max_lha - min_lha) / stat-&gt;Working_set_ratio);<br>                            <span class="hljs-keyword">if</span> (stat-&gt;generate_aligned_addresses)<br>                                <span class="hljs-keyword">if</span> (max_lha % stat-&gt;alignment_value != <span class="hljs-number">0</span>)<br>                                    max_lha -= min_lha % stat-&gt;alignment_value;<br>                            max_lpa = <span class="hljs-built_in">Convert_host_logical_address_to_device_address</span>(max_lha);<br><br>                            <span class="hljs-keyword">if</span> ((max_lpa - min_lpa) &lt; no_of_logical_pages_in_steadystate)<br>                                no_of_logical_pages_in_steadystate = max_lpa - min_lpa + <span class="hljs-number">1</span>;<br>                        &#125;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">case</span> Utils::Address_Distribution_Type::RANDOM_UNIFORM:<br>                    &#123;<br>                        <span class="hljs-comment">// 检查是否能在工作集中生成足够的LPA</span><br>                        <span class="hljs-keyword">if</span> ((max_lpa - min_lpa) &lt; <span class="hljs-number">1.1</span> * no_of_logical_pages_in_steadystate)<br>                        &#123;<br>                            <span class="hljs-built_in">PRINT_MESSAGE</span>(<span class="hljs-string">&quot;The specified initial occupancy value could not be satisfied as the working set of workload #&quot;</span> &lt;&lt; stat-&gt;Stream_id &lt;&lt; <span class="hljs-string">&quot; is small. MQSim made some adjustments!&quot;</span>);<br>                            max_lha = min_lha + <span class="hljs-built_in">LHA_type</span>(<span class="hljs-built_in"><span class="hljs-keyword">double</span></span>(max_lha - min_lha) / stat-&gt;Working_set_ratio);<br>                            <span class="hljs-keyword">if</span> (stat-&gt;generate_aligned_addresses)<br>                                <span class="hljs-keyword">if</span> (max_lha % stat-&gt;alignment_value != <span class="hljs-number">0</span>)<br>                                    max_lha -= min_lha % stat-&gt;alignment_value;<br>                            max_lpa = <span class="hljs-built_in">Convert_host_logical_address_to_device_address</span>(max_lha);<br><br>                            <span class="hljs-keyword">if</span> ((max_lpa - min_lpa) &lt; <span class="hljs-number">1.1</span> * no_of_logical_pages_in_steadystate)<br>                            &#123;<br>                                no_of_logical_pages_in_steadystate = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)(<span class="hljs-built_in"><span class="hljs-keyword">double</span></span>(max_lpa - min_lpa) * <span class="hljs-number">0.9</span>);<br>                            &#125;<br>                        &#125;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">default</span>:<br>                        <span class="hljs-keyword">break</span>;<br>                &#125;<br><br>                <span class="hljs-comment">// 初始化请求大小生成器</span><br>                <span class="hljs-keyword">if</span> (stat-&gt;Request_size_distribution_type == Utils::Request_Size_Distribution_Type::NORMAL)<br>                &#123;<br>                    random_request_size_generator = <span class="hljs-keyword">new</span> Utils::<span class="hljs-built_in">RandomGenerator</span>(stat-&gt;random_request_size_generator_seed);<br>                &#125;<br><br>                <span class="hljs-comment">// 生成预处理LPA集合</span><br>                <span class="hljs-keyword">while</span> (lpa_set_for_preconditioning.<span class="hljs-built_in">size</span>() &lt; no_of_logical_pages_in_steadystate)<br>                &#123;<br>                    <span class="hljs-comment">// 生成读写请求</span><br>                    <span class="hljs-keyword">if</span> (random_request_type_generator-&gt;<span class="hljs-built_in">Uniform</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>) &lt;= stat-&gt;Read_ratio)<br>                        is_read = <span class="hljs-literal">true</span>;<br><br>                    <span class="hljs-comment">// 生成请求大小</span><br>                    <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (stat-&gt;Request_size_distribution_type)<br>                    &#123;<br>                        <span class="hljs-keyword">case</span> Utils::Request_Size_Distribution_Type::FIXED:<br>                            size = stat-&gt;Average_request_size_sector;<br>                            <span class="hljs-keyword">break</span>;<br>                        <span class="hljs-keyword">case</span> Utils::Request_Size_Distribution_Type::NORMAL:<br>                        &#123;<br>                            <span class="hljs-keyword">double</span> temp_request_size = random_request_size_generator-&gt;<span class="hljs-built_in">Normal</span>(stat-&gt;Average_request_size_sector, stat-&gt;STDEV_reuqest_size);<br>                            size = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)(std::<span class="hljs-built_in">ceil</span>(temp_request_size));<br>                            <span class="hljs-keyword">if</span> (size &lt;= <span class="hljs-number">0</span>)<br>                                size = <span class="hljs-number">1</span>;<br>                            <span class="hljs-keyword">break</span>;<br>                        &#125;<br>                    &#125;<br><br>                    <span class="hljs-keyword">bool</span> is_hot_address = <span class="hljs-literal">false</span>;<br><br>                    <span class="hljs-comment">// 生成地址</span><br>                    <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (decision_dist_type)<br>                    &#123;<br>                        <span class="hljs-keyword">case</span> Utils::Address_Distribution_Type::STREAMING:<br>                            start_LBA = streaming_next_address;<br>                            <span class="hljs-keyword">if</span> (start_LBA + size &gt; max_lha)<br>                                start_LBA = min_lha;<br>                            streaming_next_address += size;<br>                            <span class="hljs-keyword">if</span> (streaming_next_address &gt; max_lha)<br>                                streaming_next_address = min_lha;<br>                            <span class="hljs-keyword">if</span> (stat-&gt;generate_aligned_addresses)<br>                                <span class="hljs-keyword">if</span> (streaming_next_address % stat-&gt;alignment_value != <span class="hljs-number">0</span>)<br>                                    streaming_next_address += stat-&gt;alignment_value - (streaming_next_address % stat-&gt;alignment_value);<br>                            <span class="hljs-keyword">break</span>;<br>                        <span class="hljs-keyword">case</span> Utils::Address_Distribution_Type::RANDOM_HOTCOLD:<br>                        &#123;<br>                            <span class="hljs-keyword">if</span> (fully_include_hot_addresses)<br>                            &#123;<br>                                <span class="hljs-keyword">if</span> (!hot_range_finished)<br>                                &#123;<br>                                    start_LBA = hot_lha_used_for_generation;<br>                                    hot_lha_used_for_generation += size;<br>                                    <span class="hljs-keyword">if</span> (start_LBA &gt; hot_region_end_lsa)<br>                                        hot_range_finished = <span class="hljs-literal">true</span>;<br>                                    is_hot_address = <span class="hljs-literal">true</span>;<br>                                &#125;<br>                                <span class="hljs-keyword">else</span><br>                                &#123;<br>                                    start_LBA = random_hot_address_generator-&gt;<span class="hljs-built_in">Uniform_ulong</span>(hot_region_end_lsa + <span class="hljs-number">1</span>, max_lha);<br>                                    <span class="hljs-keyword">if</span> (start_LBA &lt; hot_region_end_lsa + <span class="hljs-number">1</span> || start_LBA &gt; max_lha)<br>                                        <span class="hljs-built_in">PRINT_ERROR</span>(<span class="hljs-string">&quot;Out of range address is generated in IO_Flow_Synthetic!\n&quot;</span>)<br>                                    <span class="hljs-keyword">if</span> (start_LBA + size &gt; max_lha)<br>                                        start_LBA = hot_region_end_lsa + <span class="hljs-number">1</span>;<br>                                    is_hot_address = <span class="hljs-literal">false</span>;<br>                                &#125;<br>                            &#125;							<br>                            <span class="hljs-keyword">else</span><br>                            &#123;<br>                                <span class="hljs-keyword">if</span> (random_hot_cold_generator-&gt;<span class="hljs-built_in">Uniform</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>) &lt; stat-&gt;Ratio_of_hot_addresses_to_whole_working_set)<br>                                &#123;<br>                                    start_LBA = random_hot_address_generator-&gt;<span class="hljs-built_in">Uniform_ulong</span>(hot_region_end_lsa + <span class="hljs-number">1</span>, max_lha);<br>                                    <span class="hljs-keyword">if</span> (start_LBA &lt; hot_region_end_lsa + <span class="hljs-number">1</span> || start_LBA &gt; max_lha)<br>                                        <span class="hljs-built_in">PRINT_ERROR</span>(<span class="hljs-string">&quot;Out of range address is generated in IO_Flow_Synthetic!\n&quot;</span>)<br>                                    <span class="hljs-keyword">if</span> (start_LBA + size &gt; max_lha)<br>                                        start_LBA = hot_region_end_lsa + <span class="hljs-number">1</span>;<br>                                    is_hot_address = <span class="hljs-literal">false</span>;<br>                                &#125;<br>                                <span class="hljs-keyword">else</span><br>                                &#123;<br>                                    start_LBA = random_hot_address_generator-&gt;<span class="hljs-built_in">Uniform_ulong</span>(min_lha, hot_region_end_lsa);<br>                                    <span class="hljs-keyword">if</span> (start_LBA &lt; min_lha || start_LBA &gt; hot_region_end_lsa)<br>                                        <span class="hljs-built_in">PRINT_ERROR</span>(<span class="hljs-string">&quot;Out of range address is generated in IO_Flow_Synthetic!\n&quot;</span>)<br>                                    is_hot_address = <span class="hljs-literal">true</span>;<br>                                &#125;<br>                            &#125;<br>                        &#125;<br>                            <span class="hljs-keyword">break</span>;<br>                        <span class="hljs-keyword">case</span> Utils::Address_Distribution_Type::RANDOM_UNIFORM:<br>                            start_LBA = random_address_generator-&gt;<span class="hljs-built_in">Uniform_ulong</span>(min_lha, max_lha);<br>                            <span class="hljs-keyword">if</span> (start_LBA &lt; min_lha || max_lha &lt; start_LBA)<br>                                <span class="hljs-built_in">PRINT_ERROR</span>(<span class="hljs-string">&quot;Out of range address is generated in IO_Flow_Synthetic!\n&quot;</span>)<br>                            <span class="hljs-keyword">if</span> (start_LBA + size &gt; max_lha)<br>                                start_LBA = min_lha;<br>                            <span class="hljs-keyword">break</span>;<br>                        <span class="hljs-keyword">default</span>:<br>                            <span class="hljs-keyword">break</span>;<br>                    &#125;<br><br>                    <span class="hljs-keyword">if</span> (stat-&gt;generate_aligned_addresses)<br>                        start_LBA -= start_LBA % stat-&gt;alignment_value;<br><br>                    <span class="hljs-comment">// 处理生成的LPA</span><br>                    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> handled_sectors_count = <span class="hljs-number">0</span>;<br>                    LHA_type lsa = start_LBA - min_lha;<br>                    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> transaction_size = <span class="hljs-number">0</span>;<br>                    page_status_type access_status_bitmap = <span class="hljs-number">0</span>;<br>                    LPA_type max_lpa_within_device = <span class="hljs-built_in">Convert_host_logical_address_to_device_address</span>(stat-&gt;Max_LHA) - <span class="hljs-built_in">Convert_host_logical_address_to_device_address</span>(stat-&gt;Min_LHA);<br>                    <span class="hljs-keyword">while</span> (handled_sectors_count &lt; size)<br>                    &#123;<br>                        transaction_size = page_size_in_sectors - (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)(lsa % page_size_in_sectors);<br>                        <span class="hljs-keyword">if</span> (handled_sectors_count + transaction_size &gt;= size)<br>                        &#123;<br>                            transaction_size = size - handled_sectors_count;<br>                        &#125;<br>                        LPA_type lpa = <span class="hljs-built_in">Convert_host_logical_address_to_device_address</span>(lsa);<br>                        page_status_type access_status_bitmap = <span class="hljs-built_in">Find_NVM_subunit_access_bitmap</span>(lsa);<br><br>                        lsa = lsa + transaction_size;<br>                        handled_sectors_count += transaction_size;<br><br>                        <span class="hljs-keyword">if</span> (lpa_set_for_preconditioning.<span class="hljs-built_in">find</span>(lpa) == lpa_set_for_preconditioning.<span class="hljs-built_in">end</span>()) &#123;<br>                            lpa_set_for_preconditioning[lpa] = access_status_bitmap;<br>                            <span class="hljs-keyword">if</span> (lpa &lt;= max_lpa_within_device) &#123;<br>                                <span class="hljs-keyword">if</span> (!is_hot_address &amp;&amp; hot_region_last_index_in_histogram == <span class="hljs-number">0</span>) &#123;<br>                                    hot_region_last_index_in_histogram = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)(trace_lpas_sorted_histogram.<span class="hljs-built_in">size</span>());<br>                                &#125;<br>                                <span class="hljs-function">std::pair&lt;<span class="hljs-keyword">int</span>, LPA_type&gt; <span class="hljs-title">entry</span><span class="hljs-params">((is_hot_address ? <span class="hljs-number">1000</span> : <span class="hljs-number">1</span>), lpa)</span></span>;<br>                                trace_lpas_sorted_histogram.<span class="hljs-built_in">insert</span>(entry);<br>                            &#125;<br>                        &#125; <span class="hljs-keyword">else</span> &#123;<br>                            lpa_set_for_preconditioning[lpa] = access_status_bitmap | lpa_set_for_preconditioning[lpa];<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> itr = stat-&gt;Write_read_shared_addresses.<span class="hljs-built_in">begin</span>(); itr != stat-&gt;Write_read_shared_addresses.<span class="hljs-built_in">end</span>(); itr++) &#123;<br>                    LPA_type lpa = (*itr);<br>                    <span class="hljs-keyword">if</span> (lpa_set_for_preconditioning.<span class="hljs-built_in">size</span>() &lt; no_of_logical_pages_in_steadystate) &#123;<br>                        lpa_set_for_preconditioning[lpa] = stat-&gt;Write_address_access_pattern[lpa].Accessed_sub_units | stat-&gt;Read_address_access_pattern[lpa].Accessed_sub_units;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br><br><span class="hljs-comment">// 这段代码的目的是从Read_address_access_pattern中提取LPA（逻辑页面地址），并将其添加到lpa_set_for_preconditioning中。</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> itr = stat-&gt;Read_address_access_pattern.<span class="hljs-built_in">begin</span>(); itr != stat-&gt;Read_address_access_pattern.<span class="hljs-built_in">end</span>(); itr++) &#123;<br>    LPA_type lpa = (*itr).first; <span class="hljs-comment">// 获取当前迭代器指向的LPA</span><br>    <span class="hljs-keyword">if</span> (lpa_set_for_preconditioning.<span class="hljs-built_in">size</span>() &lt; no_of_logical_pages_in_steadystate) &#123;<br>        <span class="hljs-keyword">if</span> (lpa_set_for_preconditioning.<span class="hljs-built_in">find</span>(lpa) == lpa_set_for_preconditioning.<span class="hljs-built_in">end</span>()) &#123;<br>            <span class="hljs-comment">// 如果LPA不在lpa_set_for_preconditioning中，则添加</span><br>            lpa_set_for_preconditioning[lpa] = stat-&gt;Read_address_access_pattern[lpa].Accessed_sub_units;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 如果达到预设的逻辑页面数量，则退出循环</span><br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">// Step 1-2: 如果读取的LPA不足以满足稳态，则使用写入LPA填充lpa_set_for_preconditioning</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> itr = stat-&gt;Write_address_access_pattern.<span class="hljs-built_in">begin</span>(); itr != stat-&gt;Write_address_access_pattern.<span class="hljs-built_in">end</span>(); itr++) &#123;<br>    LPA_type lpa = (*itr).first; <span class="hljs-comment">// 获取当前迭代器指向的LPA</span><br>    <span class="hljs-keyword">if</span> (lpa_set_for_preconditioning.<span class="hljs-built_in">size</span>() &lt; no_of_logical_pages_in_steadystate) &#123;<br>        <span class="hljs-keyword">if</span> (lpa_set_for_preconditioning.<span class="hljs-built_in">find</span>(lpa) == lpa_set_for_preconditioning.<span class="hljs-built_in">end</span>()) &#123;<br>            <span class="hljs-comment">// 如果LPA不在lpa_set_for_preconditioning中，则添加</span><br>            lpa_set_for_preconditioning[lpa] = stat-&gt;Write_address_access_pattern[lpa].Accessed_sub_units;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 将LPA和其访问计数插入到trace_lpas_sorted_histogram中</span><br>    <span class="hljs-function">std::pair&lt;<span class="hljs-keyword">int</span>, LPA_type&gt; <span class="hljs-title">entry</span><span class="hljs-params">((*itr).second.Access_count, lpa)</span></span>;<br>    trace_lpas_sorted_histogram.<span class="hljs-built_in">insert</span>(entry);<br>&#125;<br><br><br><span class="hljs-comment">// Step 1-3: 确定输入轨迹的地址分布类型</span><br>stat-&gt;Address_distribution_type = Utils::Address_Distribution_Type::RANDOM_HOTCOLD; <span class="hljs-comment">// 初步假设轨迹有热/冷访问模式</span><br><br><span class="hljs-comment">// 首先检查工作负载中是否有足够的写请求来做出统计上正确的决定，如果没有，MQSim假设工作负载具有均匀访问模式</span><br><span class="hljs-keyword">if</span> (stat-&gt;Write_address_access_pattern.<span class="hljs-built_in">size</span>() &gt; STATISTICALLY_SUFFICIENT_WRITES_FOR_PRECONDITIONING) &#123;<br>    <span class="hljs-keyword">int</span> hot_region_write_count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> prev_value = (*trace_lpas_sorted_histogram.<span class="hljs-built_in">begin</span>()).first;<br>    <span class="hljs-keyword">double</span> f_temp = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">double</span> r_temp = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">double</span> step = <span class="hljs-number">0.01</span>;<br>    <span class="hljs-keyword">double</span> next_milestone = <span class="hljs-number">0.01</span>;<br>    <span class="hljs-keyword">double</span> prev_r = <span class="hljs-number">0.0</span>;<br><br>    <span class="hljs-comment">// 遍历轨迹直方图来计算热区域的访问比例</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> itr = trace_lpas_sorted_histogram.<span class="hljs-built_in">begin</span>(); itr != trace_lpas_sorted_histogram.<span class="hljs-built_in">end</span>(); itr++) &#123;<br>        hot_region_last_index_in_histogram++;<br>        hot_region_write_count += (*itr).first;<br><br>        f_temp = <span class="hljs-built_in"><span class="hljs-keyword">double</span></span>(hot_region_last_index_in_histogram) / <span class="hljs-built_in"><span class="hljs-keyword">double</span></span>(trace_lpas_sorted_histogram.<span class="hljs-built_in">size</span>());<br>        r_temp = <span class="hljs-built_in"><span class="hljs-keyword">double</span></span>(hot_region_write_count) / <span class="hljs-built_in"><span class="hljs-keyword">double</span></span>(stat-&gt;Total_accessed_lbas);<br><br>        <span class="hljs-keyword">if</span> (f_temp &gt;= next_milestone) &#123;<br>            <span class="hljs-keyword">if</span> ((r_temp - prev_r) &lt; step) &#123;<br>                r_temp = prev_r;<br>                f_temp = next_milestone - step;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            prev_r = r_temp;<br>            next_milestone += step;<br>        &#125;<br><br>        prev_value = (*itr).first;<br>    &#125;<br><br>    <span class="hljs-comment">// 判断是否符合热区域的标准</span><br>    <span class="hljs-keyword">if</span> ((r_temp &gt; MIN_HOT_REGION_TRAFFIC_RATIO) &amp;&amp; ((r_temp / f_temp) &gt; HOT_REGION_METRIC)) &#123;<br>        stat-&gt;Ratio_of_hot_addresses_to_whole_working_set = f_temp;<br>        stat-&gt;Ratio_of_traffic_accessing_hot_region = r_temp;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        stat-&gt;Address_distribution_type = Utils::Address_Distribution_Type::RANDOM_UNIFORM;<br>    &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    stat-&gt;Address_distribution_type = Utils::Address_Distribution_Type::RANDOM_UNIFORM;<br>&#125;<br><br><span class="hljs-comment">// 初始化随机地址生成器</span><br>Utils::RandomGenerator* random_address_generator = <span class="hljs-keyword">new</span> Utils::<span class="hljs-built_in">RandomGenerator</span>(preconditioning_seed++);<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> size = stat-&gt;Average_request_size_sector;<br>LHA_type start_LHA = <span class="hljs-number">0</span>;<br><br>				<br><span class="hljs-comment">// Step 1-4: 如果读写LPA不足以预处理闪存存储空间，则填充剩余空间</span><br><span class="hljs-comment">// 目的：确保即使读写地址不足，预处理阶段仍有足够的逻辑页面以满足稳态条件。</span><br><br><span class="hljs-keyword">while</span> (lpa_set_for_preconditioning.<span class="hljs-built_in">size</span>() &lt; no_of_logical_pages_in_steadystate) &#123;<br>    <span class="hljs-comment">// 生成一个随机的起始逻辑地址，范围在 min_lha 和 max_lha 之间</span><br>    start_LHA = random_address_generator-&gt;<span class="hljs-built_in">Uniform_ulong</span>(min_lha, max_lha);<br>    <br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> handled_sectors_count = <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录当前处理的扇区数</span><br>    LHA_type lsa = start_LHA; <span class="hljs-comment">// 当前逻辑地址</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> transaction_size = <span class="hljs-number">0</span>; <span class="hljs-comment">// 当前处理的事务大小（扇区数）</span><br>    <br>    <span class="hljs-comment">// 处理直到当前请求的扇区数足够</span><br>    <span class="hljs-keyword">while</span> (handled_sectors_count &lt; size) &#123;<br>        <span class="hljs-comment">// 如果逻辑地址超出范围，将其调整到有效范围内</span><br>        <span class="hljs-keyword">if</span> (lsa &lt; min_lha || lsa &gt; max_lha) &#123;<br>            lsa = min_lha + (lsa % (max_lha - min_lha + <span class="hljs-number">1</span>));<br>        &#125;<br>        <br>        LHA_type internal_lsa = lsa - min_lha; <span class="hljs-comment">// 计算内部逻辑地址（相对于 min_lha）</span><br>        <br>        <span class="hljs-comment">// 计算当前逻辑地址可处理的最大扇区数</span><br>        transaction_size = page_size_in_sectors - (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)(internal_lsa % page_size_in_sectors);<br>        <br>        <span class="hljs-comment">// 如果处理的扇区数加上当前事务的大小超出了请求的大小，则调整事务大小</span><br>        <span class="hljs-keyword">if</span> (handled_sectors_count + transaction_size &gt;= size) &#123;<br>            transaction_size = size - handled_sectors_count;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 将逻辑地址转换为设备地址</span><br>        LPA_type lpa = <span class="hljs-built_in">Convert_host_logical_address_to_device_address</span>(internal_lsa);<br>        <br>        <span class="hljs-comment">// 获取当前逻辑地址的访问状态位图</span><br>        page_status_type access_status_bitmap = <span class="hljs-built_in">Find_NVM_subunit_access_bitmap</span>(internal_lsa);<br>        <br>        <span class="hljs-comment">// 更新 LPA 的状态：如果已存在，则更新状态；如果不存在，则添加新条目</span><br>        <span class="hljs-keyword">if</span> (lpa_set_for_preconditioning.<span class="hljs-built_in">find</span>(lpa) != lpa_set_for_preconditioning.<span class="hljs-built_in">end</span>()) &#123;<br>            lpa_set_for_preconditioning[lpa] = access_status_bitmap;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            lpa_set_for_preconditioning[lpa] = access_status_bitmap | lpa_set_for_preconditioning[lpa];<br>        &#125;<br>        <br>        <span class="hljs-comment">// 更新逻辑地址和处理的扇区数</span><br>        lsa = lsa + transaction_size;<br>        handled_sectors_count += transaction_size;<br>    &#125;<br>&#125;<br><br>			<br><span class="hljs-comment">// Step 2: 确定稳态下块中有效页面的概率分布函数</span><br><span class="hljs-comment">// 注意：如果需要热/冷分离，则以下估算应根据Van Houdt在2014年Performance Evaluation中的论文进行修改。</span><br>std::vector&lt;<span class="hljs-keyword">double</span>&gt; steadystate_block_status_probability; <span class="hljs-comment">// 稳态下块中有效页面的概率分布函数</span><br><span class="hljs-keyword">double</span> rho = stat-&gt;Initial_occupancy_ratio * (<span class="hljs-number">1</span> - over_provisioning_ratio) / (<span class="hljs-number">1</span> - <span class="hljs-built_in"><span class="hljs-keyword">double</span></span>(GC_and_WL_Unit-&gt;<span class="hljs-built_in">Get_minimum_number_of_free_pages_before_GC</span>()) / block_no_per_plane);<br><br><span class="hljs-comment">// 根据不同的地址分布类型进行估算</span><br><span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (decision_dist_type) &#123;<br>    <span class="hljs-keyword">case</span> Utils::Address_Distribution_Type::RANDOM_HOTCOLD: <span class="hljs-comment">// 热/冷访问模式的估算</span><br>    &#123;<br>        <span class="hljs-keyword">double</span> r_to_f_ratio = std::<span class="hljs-built_in">sqrt</span>(<span class="hljs-built_in"><span class="hljs-keyword">double</span></span>(stat-&gt;Ratio_of_traffic_accessing_hot_region) / <span class="hljs-built_in"><span class="hljs-keyword">double</span></span>(stat-&gt;Ratio_of_hot_addresses_to_whole_working_set));<br><br>        <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (GC_and_WL_Unit-&gt;<span class="hljs-built_in">Get_gc_policy</span>()) &#123;<br>            <span class="hljs-keyword">case</span> GC_Block_Selection_Policy_Type::GREEDY: <span class="hljs-comment">// 贪婪策略</span><br>            <span class="hljs-keyword">case</span> GC_Block_Selection_Policy_Type::FIFO:  <span class="hljs-comment">// 先进先出策略（对于大块页面数量可以估算为贪婪策略）</span><br>            &#123;<br>                <span class="hljs-comment">// 计算每个可能的有效页面数的概率</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= page_no_per_block; i++) &#123;<br>                    steadystate_block_status_probability.<span class="hljs-built_in">push_back</span>(Utils::<span class="hljs-built_in">Combination_count</span>(page_no_per_block, i) * std::<span class="hljs-built_in">pow</span>(rho, i) * std::<span class="hljs-built_in">pow</span>(<span class="hljs-number">1</span> - rho, page_no_per_block - i));<br>                &#125;<br>                <span class="hljs-comment">// 使用Euler估算稳态概率分布</span><br>                Utils::<span class="hljs-built_in">Euler_estimation</span>(steadystate_block_status_probability, page_no_per_block, rho, <span class="hljs-number">30</span>, <span class="hljs-number">0.001</span>, <span class="hljs-number">0.0000000001</span>, <span class="hljs-number">10000</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">case</span> GC_Block_Selection_Policy_Type::RGA: <span class="hljs-comment">// 随机贪婪算法</span><br>            &#123;<br>                <span class="hljs-comment">// 计算每个可能的有效页面数的概率</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= page_no_per_block; i++) &#123;<br>                    steadystate_block_status_probability.<span class="hljs-built_in">push_back</span>(Utils::<span class="hljs-built_in">Combination_count</span>(page_no_per_block, i) * std::<span class="hljs-built_in">pow</span>(rho, i) * std::<span class="hljs-built_in">pow</span>(<span class="hljs-number">1</span> - rho, page_no_per_block - i));<br>                &#125;<br>                <span class="hljs-comment">// 使用Euler估算稳态概率分布</span><br>                Utils::<span class="hljs-built_in">Euler_estimation</span>(steadystate_block_status_probability, page_no_per_block, rho, GC_and_WL_Unit-&gt;<span class="hljs-built_in">Get_GC_policy_specific_parameter</span>(), <span class="hljs-number">0.001</span>, <span class="hljs-number">0.0000000001</span>, <span class="hljs-number">10000</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">case</span> GC_Block_Selection_Policy_Type::RANDOM: <span class="hljs-comment">// 随机选择策略</span><br>            <span class="hljs-keyword">case</span> GC_Block_Selection_Policy_Type::RANDOM_P: <span class="hljs-comment">// 随机选择P策略</span><br>            &#123;<br>                <span class="hljs-comment">// 计算每个可能的有效页面数的概率</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= page_no_per_block; i++) &#123;<br>                    steadystate_block_status_probability.<span class="hljs-built_in">push_back</span>(rho / (rho + std::<span class="hljs-built_in">pow</span>(<span class="hljs-number">1</span> - rho, i)));<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt;= page_no_per_block; j++) &#123;<br>                        steadystate_block_status_probability[i] *= ((<span class="hljs-number">1</span> - rho) * j) / (rho + (<span class="hljs-number">1</span> - rho) * j);<br>                    &#125;<br>                &#125;<br>                <span class="hljs-comment">// 调整概率分布</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = page_no_per_block; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>                    steadystate_block_status_probability[i] = steadystate_block_status_probability[i] - steadystate_block_status_probability[i - <span class="hljs-number">1</span>];<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">case</span> GC_Block_Selection_Policy_Type::RANDOM_PP: <span class="hljs-comment">// 随机优先策略</span><br>            &#123;<br>                <span class="hljs-comment">// 初始化概率分布值</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= page_no_per_block; i++) &#123;<br>                    steadystate_block_status_probability.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>                &#125;<br><br>                <span class="hljs-keyword">double</span> rho = stat-&gt;Initial_occupancy_ratio * (<span class="hljs-number">1</span> - over_provisioning_ratio);<br>                <span class="hljs-keyword">double</span> S_rho_b = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> j = GC_and_WL_Unit-&gt;<span class="hljs-built_in">Get_GC_policy_specific_parameter</span>() + <span class="hljs-number">1</span>; j &lt;= page_no_per_block; j++) &#123;<br>                    S_rho_b += <span class="hljs-number">1.0</span> / <span class="hljs-built_in"><span class="hljs-keyword">double</span></span>(j);<br>                &#125;<br>                <span class="hljs-keyword">double</span> a_r = page_no_per_block - GC_and_WL_Unit-&gt;<span class="hljs-built_in">Get_GC_policy_specific_parameter</span>() - page_no_per_block * S_rho_b;<br>                <span class="hljs-keyword">double</span> b_r = rho * S_rho_b + <span class="hljs-number">1</span> - rho;<br>                <span class="hljs-keyword">double</span> c_r = <span class="hljs-number">-1</span> * rho / page_no_per_block;<br>                <span class="hljs-keyword">double</span> mu_b = (<span class="hljs-number">-1</span> * b_r + std::<span class="hljs-built_in">sqrt</span>(b_r * b_r - <span class="hljs-number">4</span> * a_r * c_r)) / (<span class="hljs-number">2</span> * a_r); <span class="hljs-comment">// 计算均值</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = page_no_per_block; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>                    <span class="hljs-keyword">if</span> (i &lt;= <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(GC_and_WL_Unit-&gt;<span class="hljs-built_in">Get_GC_policy_specific_parameter</span>())) &#123;<br>                        steadystate_block_status_probability[i] = ((i + <span class="hljs-number">1</span>) * steadystate_block_status_probability[i + <span class="hljs-number">1</span>])<br>                            / (i + (rho / (<span class="hljs-number">1</span> - rho - mu_b * (page_no_per_block * S_rho_b - page_no_per_block + GC_and_WL_Unit-&gt;<span class="hljs-built_in">Get_GC_policy_specific_parameter</span>()))));<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(page_no_per_block)) &#123;<br>                        steadystate_block_status_probability[i] = <span class="hljs-built_in"><span class="hljs-keyword">double</span></span>(page_no_per_block * mu_b) / <span class="hljs-built_in"><span class="hljs-keyword">double</span></span>(i);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        steadystate_block_status_probability[i] = mu_b;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 计算热/冷访问模式下的概率分布</span><br>        <span class="hljs-keyword">double</span> average_page_no_per_block = <span class="hljs-number">0</span>;<br>        std::vector&lt;<span class="hljs-keyword">double</span>&gt; steadystate_block_status_probability_temp;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(page_no_per_block) + <span class="hljs-number">1</span>; i++) &#123;<br>            steadystate_block_status_probability_temp.<span class="hljs-built_in">push_back</span>(steadystate_block_status_probability[i]);<br>            average_page_no_per_block += steadystate_block_status_probability[i] * i;<br>        &#125;<br><br>        <span class="hljs-comment">// 调整概率分布以适应热/冷访问模式</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(page_no_per_block) + <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-keyword">int</span> phi_index = <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>((<span class="hljs-built_in"><span class="hljs-keyword">double</span></span>(i) - average_page_no_per_block) * r_to_f_ratio);<br>            <span class="hljs-keyword">if</span> (phi_index &lt; <span class="hljs-number">0</span> || phi_index &gt;= <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(page_no_per_block)) &#123;<br>                steadystate_block_status_probability[i] = <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                steadystate_block_status_probability[i] = r_to_f_ratio * steadystate_block_status_probability_temp[phi_index];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">double</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= page_no_per_block; i++) &#123;<br>            sum += steadystate_block_status_probability[i];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= page_no_per_block; i++) &#123;<br>            steadystate_block_status_probability[i] /= sum; <span class="hljs-comment">// 归一化</span><br>        &#125;<br><br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">case</span> Utils::Address_Distribution_Type::STREAMING: <span class="hljs-comment">// 流式访问模式</span><br>    &#123;<br>        <span class="hljs-comment">// 流式访问模式的简单估算</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= page_no_per_block; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;<br>                steadystate_block_status_probability.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span> - rho);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == page_no_per_block) &#123;<br>                steadystate_block_status_probability.<span class="hljs-built_in">push_back</span>(rho);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                steadystate_block_status_probability.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// GC策略对流式访问模式下块的状态没有影响</span><br>        <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (GC_and_WL_Unit-&gt;<span class="hljs-built_in">Get_gc_policy</span>()) &#123;<br>            <span class="hljs-keyword">case</span> GC_Block_Selection_Policy_Type::GREEDY:<br>            <span class="hljs-keyword">case</span> GC_Block_Selection_Policy_Type::RANDOM_PP:<br>            <span class="hljs-keyword">case</span> GC_Block_Selection_Policy_Type::RGA:<br>            <span class="hljs-keyword">case</span> GC_Block_Selection_Policy_Type::FIFO:<br>            <span class="hljs-keyword">case</span> GC_Block_Selection_Policy_Type::RANDOM:<br>            <span class="hljs-keyword">case</span> GC_Block_Selection_Policy_Type::RANDOM_P:<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">case</span> Utils::Address_Distribution_Type::RANDOM_UNIFORM: <span class="hljs-comment">// 随机均匀访问模式</span><br>    &#123;<br>        <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (GC_and_WL_Unit-&gt;<span class="hljs-built_in">Get_gc_policy</span>()) &#123;<br>            <span class="hljs-keyword">case</span> GC_Block_Selection_Policy_Type::GREEDY: <span class="hljs-comment">// 贪婪策略</span><br>            <span class="hljs-keyword">case</span> GC_Block_Selection_Policy_Type::FIFO:  <span class="hljs-comment">// 先进先出策略</span><br>            &#123;<br>                <span class="hljs-comment">// 计算每个可能的有效页面数的概率</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= page_no_per_block; i++) &#123;<br>                    steadystate_block_status_probability.<span class="hljs-built_in">push_back</span>(Utils::<span class="hljs-built_in">Combination_count</span>(page_no_per_block, i) * std::<span class="hljs-built_in">pow</span>(rho, i) * std::<span class="hljs-built_in">pow</span>(<span class="hljs-number">1</span> - rho, page_no_per_block - i));<br>                &#125;<br>                <span class="hljs-comment">// 使用Euler估算稳态概率分布</span><br>                Utils::<span class="hljs-built_in">Euler_estimation</span>(steadystate_block_status_probability, page_no_per_block, rho, <span class="hljs-number">30</span>, <span class="hljs-number">0.001</span>, <span class="hljs-number">0.0000000001</span>, <span class="hljs-number">10000</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">case</span> GC_Block_Selection_Policy_Type::RGA: <span class="hljs-comment">// 随机贪婪算法</span><br>            &#123;<br>                <span class="hljs-comment">// 计算每个可能的有效页面数的概率</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= page_no_per_block; i++) &#123;<br>                    steadystate_block_status_probability.<span class="hljs-built_in">push_back</span>(Utils::<span class="hljs-built_in">Combination_count</span>(page_no_per_block, i) * std::<span class="hljs-built_in">pow</span>(rho, i) * std::<span class="hljs-built_in">pow</span>(<span class="hljs-number">1</span> - rho, page_no_per_block - i));<br>                &#125;<br>                <span class="hljs-comment">// 使用Euler估算稳态概率分布</span><br>                Utils::<span class="hljs-built_in">Euler_estimation</span>(steadystate_block_status_probability, page_no_per_block, rho, GC_and_WL_Unit-&gt;<span class="hljs-built_in">Get_GC_policy_specific_parameter</span>(), <span class="hljs-number">0.001</span>, <span class="hljs-number">0.0000000001</span>, <span class="hljs-number">10000</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">case</span> GC_Block_Selection_Policy_Type::RANDOM: <span class="hljs-comment">// 随机选择策略</span><br>            <span class="hljs-keyword">case</span> GC_Block_Selection_Policy_Type::RANDOM_P: <span class="hljs-comment">// 随机选择P策略</span><br>            &#123;<br>                <span class="hljs-comment">// 计算每个可能的有效页面数的概率</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= page_no_per_block; i++) &#123;<br>                    steadystate_block_status_probability.<span class="hljs-built_in">push_back</span>(rho / (rho + std::<span class="hljs-built_in">pow</span>(<span class="hljs-number">1</span> - rho, i)));<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt;= page_no_per_block; j++) &#123;<br>                        steadystate_block_status_probability[i] *= ((<span class="hljs-number">1</span> - rho) * j) / (rho + (<span class="hljs-number">1</span> - rho) * j);<br>                    &#125;<br>                &#125;<br>                <span class="hljs-comment">// 调整概率分布</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = page_no_per_block; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>                    steadystate_block_status_probability[i] = steadystate_block_status_probability[i] - steadystate_block_status_probability[i - <span class="hljs-number">1</span>];<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">case</span> GC_Block_Selection_Policy_Type::RANDOM_PP: <span class="hljs-comment">// 随机优先策略</span><br>            &#123;<br>                <span class="hljs-comment">// 初始化概率分布值</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= page_no_per_block; i++) &#123;<br>                    steadystate_block_status_probability.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>                &#125;<br><br>                <span class="hljs-keyword">double</span> rho = stat-&gt;Initial_occupancy_ratio * (<span class="hljs-number">1</span> - over_provisioning_ratio);<br>                <span class="hljs-keyword">double</span> S_rho_b = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> j = GC_and_WL_Unit-&gt;<span class="hljs-built_in">Get_GC_policy_specific_parameter</span>() + <span class="hljs-number">1</span>; j &lt;= page_no_per_block; j++) &#123;<br>                    S_rho_b += <span class="hljs-number">1.0</span> / <span class="hljs-built_in"><span class="hljs-keyword">double</span></span>(j);<br>                &#125;<br>                <span class="hljs-keyword">double</span> a_r = page_no_per_block - GC_and_WL_Unit-&gt;<span class="hljs-built_in">Get_GC_policy_specific_parameter</span>() - page_no_per_block * S_rho_b;<br>                <span class="hljs-keyword">double</span> b_r = rho * S_rho_b + <span class="hljs-number">1</span> - rho;<br>                <span class="hljs-keyword">double</span> c_r = <span class="hljs-number">-1</span> * rho / page_no_per_block;<br>                <span class="hljs-keyword">double</span> mu_b = (<span class="hljs-number">-1</span> * b_r + std::<span class="hljs-built_in">sqrt</span>(b_r * b_r - <span class="hljs-number">4</span> * a_r * c_r)) / (<span class="hljs-number">2</span> * a_r); <span class="hljs-comment">// 计算均值</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = page_no_per_block; i &gt;= <span class="hljs-number">0</span> ; i--) &#123;<br>                    <span class="hljs-keyword">if</span> (i &lt;= <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(GC_and_WL_Unit-&gt;<span class="hljs-built_in">Get_GC_policy_specific_parameter</span>())) &#123;<br>                        steadystate_block_status_probability[i] = ((i + <span class="hljs-number">1</span>) * steadystate_block_status_probability[i + <span class="hljs-number">1</span>])<br>                            / (i + (rho / (<span class="hljs-number">1</span> - rho - mu_b * (page_no_per_block * S_rho_b - page_no_per_block + GC_and_WL_Unit-&gt;<span class="hljs-built_in">Get_GC_policy_specific_parameter</span>()))));<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(page_no_per_block)) &#123;<br>                        steadystate_block_status_probability[i] = <span class="hljs-built_in"><span class="hljs-keyword">double</span></span>(page_no_per_block * mu_b) / <span class="hljs-built_in"><span class="hljs-keyword">double</span></span>(i);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        steadystate_block_status_probability[i] = mu_b;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-built_in">PRINT_ERROR</span>(<span class="hljs-string">&quot;未处理的地址分布类型在FTL的预处理函数中。&quot;</span>)<br>&#125;<br><br><br><span class="hljs-comment">// Step 3: 在整个闪存空间中分配逻辑页地址（LPA）</span><br><span class="hljs-keyword">double</span> sum = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 检查概率分布是否正确</span><br><span class="hljs-comment">// 遍历每个可能的有效页面数，累加其概率</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= page_no_per_block; i++) &#123;<br>    sum += steadystate_block_status_probability[i];<br>&#125;<br><br><span class="hljs-comment">// 由于某些精度错误，概率分布的总和可能不会完全等于1</span><br><span class="hljs-comment">// 因此，我们设置了一个合理的误差范围来检查概率分布的正确性</span><br><span class="hljs-comment">// 如果总和超出预设范围（0.99到1.001），则打印错误信息并停止预处理</span><br><span class="hljs-keyword">if</span> (sum &gt; <span class="hljs-number">1.001</span> || sum &lt; <span class="hljs-number">0.99</span>) &#123;<br>    <span class="hljs-built_in">PRINT_ERROR</span>(<span class="hljs-string">&quot;Wrong probability distribution function for the number of valid pages in flash blocks in the steady-state! It is not safe to continue preconditioning!&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 如果概率分布正确，则继续进行LPA的分配</span><br><span class="hljs-comment">// 调用Address_Mapping_Unit的Allocate_address_for_preconditioning函数进行地址分配</span><br><span class="hljs-comment">// 使用steadystate_block_status_probability来指导LPA的分配</span><br>Address_Mapping_Unit-&gt;<span class="hljs-built_in">Allocate_address_for_preconditioning</span>(stat-&gt;Stream_id, lpa_set_for_preconditioning, steadystate_block_status_probability);<br><br><br><span class="hljs-comment">//Step 4: Touch the LPAs and bring them to CMT to warmup address mapping unit</span><br><span class="hljs-keyword">if</span> (!Address_Mapping_Unit-&gt;<span class="hljs-built_in">Is_ideal_mapping_table</span>()) &#123;<br><span class="hljs-comment">// 这段代码的目的是确定CMT（Content Management Table）中应该填充多少条目。这取决于流量到达率和访问模式。</span><br><span class="hljs-comment">// Step 4-1: 根据流量到达率和访问模式确定应填充整个CMT的多少份额</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> no_of_entries_in_cmt = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 用于存储要填充到CMT中的条目数</span><br>LPA_type min_LPA = <span class="hljs-built_in">Convert_host_logical_address_to_device_address</span>(stat-&gt;Min_LHA);  <span class="hljs-comment">// 将最小逻辑地址转换为设备地址</span><br>LPA_type max_LPA = <span class="hljs-built_in">Convert_host_logical_address_to_device_address</span>(stat-&gt;Max_LHA);  <span class="hljs-comment">// 将最大逻辑地址转换为设备地址</span><br><br><span class="hljs-comment">// 根据CMT的共享模式来决定如何填充CMT</span><br><span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (Address_Mapping_Unit-&gt;<span class="hljs-built_in">Get_CMT_sharing_mode</span>()) &#123;<br>    <span class="hljs-keyword">case</span> CMT_Sharing_Mode::SHARED: &#123;<br>        <span class="hljs-keyword">double</span> flow_rate = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 流量到达率</span><br><br>        <span class="hljs-keyword">if</span> (stat-&gt;Type == Utils::Workload_Type::SYNTHETIC) &#123;<br>            <span class="hljs-comment">// 如果工作负载类型是合成的</span><br>            <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (stat-&gt;generator_type) &#123;<br>                <span class="hljs-keyword">case</span> Utils::Request_Generator_Type::BANDWIDTH:<br>                    <span class="hljs-comment">// 如果请求生成器类型是带宽</span><br>                    flow_rate = <span class="hljs-number">1.0</span> / <span class="hljs-built_in"><span class="hljs-keyword">double</span></span>(stat-&gt;Average_inter_arrival_time_nano_sec) * SIM_TIME_TO_SECONDS_COEFF * stat-&gt;Average_request_size_sector;<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> Utils::Request_Generator_Type::QUEUE_DEPTH:<br>                &#123;<br>                    <span class="hljs-comment">// 如果请求生成器类型是队列深度</span><br>                    sim_time_type max_arrival_time = <span class="hljs-built_in">sim_time_type</span>(stat-&gt;Read_ratio * <span class="hljs-built_in"><span class="hljs-keyword">double</span></span>(avg_flash_read_latency) + (<span class="hljs-number">1</span> - stat-&gt;Read_ratio) * <span class="hljs-built_in"><span class="hljs-keyword">double</span></span>(avg_flash_program_latency));<br>                    <span class="hljs-keyword">double</span> avg_arrival_time = <span class="hljs-built_in"><span class="hljs-keyword">double</span></span>(max_arrival_time) / <span class="hljs-built_in"><span class="hljs-keyword">double</span></span>(stat-&gt;Request_queue_depth);<br>                    flow_rate = <span class="hljs-number">1.0</span> / avg_arrival_time * SIM_TIME_TO_SECONDS_COEFF * stat-&gt;Average_request_size_sector;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">default</span>:<br>                    <span class="hljs-comment">// 如果请求生成器类型未知，打印错误信息</span><br>                    <span class="hljs-built_in">PRINT_ERROR</span>(<span class="hljs-string">&quot;Unknown request type generator in the FTL preconditioning function.&quot;</span>)<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 如果工作负载类型不是合成的</span><br>            flow_rate = <span class="hljs-number">1.0</span> / <span class="hljs-built_in"><span class="hljs-keyword">double</span></span>(stat-&gt;Average_inter_arrival_time_nano_sec) * SIM_TIME_TO_SECONDS_COEFF * stat-&gt;Average_request_size_sector;<br>        &#125;<br><br>        <span class="hljs-comment">// 计算CMT中应填充的条目数</span><br>        no_of_entries_in_cmt = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)(<span class="hljs-built_in"><span class="hljs-keyword">double</span></span>(flow_rate) / <span class="hljs-built_in"><span class="hljs-keyword">double</span></span>(overall_rate) * Address_Mapping_Unit-&gt;<span class="hljs-built_in">Get_cmt_capacity</span>());<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">case</span> CMT_Sharing_Mode::EQUAL_SIZE_PARTITIONING:<br>        <span class="hljs-comment">// 如果CMT共享模式是等大小分区</span><br>        no_of_entries_in_cmt = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)(<span class="hljs-number">1.0</span> / <span class="hljs-built_in"><span class="hljs-keyword">double</span></span>(workload_stats.<span class="hljs-built_in">size</span>()) * Address_Mapping_Unit-&gt;<span class="hljs-built_in">Get_cmt_capacity</span>());<br>        <span class="hljs-comment">// 确保CMT条目数不超过逻辑地址范围</span><br>        <span class="hljs-keyword">if</span> (max_LPA - min_LPA + <span class="hljs-number">1</span> &lt; <span class="hljs-built_in">LPA_type</span>(no_of_entries_in_cmt)) &#123;<br>            no_of_entries_in_cmt = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)(max_LPA - min_LPA + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-comment">// 如果CMT共享模式未知，打印错误信息</span><br>        <span class="hljs-built_in">PRINT_ERROR</span>(<span class="hljs-string">&quot;Unknown mapping table sharing mode in the FTL preconditioning function.&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 确保CMT条目数不低于已排序LPA直方图的大小</span><br><span class="hljs-keyword">if</span> (max_LPA - min_LPA + <span class="hljs-number">1</span> &lt; <span class="hljs-built_in">LPA_type</span>(trace_lpas_sorted_histogram.<span class="hljs-built_in">size</span>())) &#123;<br>    no_of_entries_in_cmt = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)(trace_lpas_sorted_histogram.<span class="hljs-built_in">size</span>());<br>&#125;<br>    <br><span class="hljs-comment">// 这段代码的目的是根据不同的地址分布类型将逻辑地址（LPA）填充到CMT（Content Management Table）中，以进行预处理。不同的地址分布类型会导致不同的填充策略。</span><br><span class="hljs-comment">// Step 4-2: 根据流量访问模式将LPA引入CMT</span><br><span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (decision_dist_type) &#123;<br>    <span class="hljs-keyword">case</span> Utils::Address_Distribution_Type::RANDOM_HOTCOLD:<br>    &#123;<br>        <span class="hljs-comment">// 首先将热地址引入CMT</span><br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> required_no_of_hot_cmt_entries = (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)(stat-&gt;Ratio_of_hot_addresses_to_whole_working_set * no_of_entries_in_cmt);<br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> entries_to_bring_into_cmt = required_no_of_hot_cmt_entries;<br>        <br>        <span class="hljs-comment">// 如果需要的热地址条目超过了热区域直方图的最后索引，则只引入热区域直方图中的条目</span><br>        <span class="hljs-keyword">if</span> (required_no_of_hot_cmt_entries &gt; hot_region_last_index_in_histogram) &#123;<br>            entries_to_bring_into_cmt = hot_region_last_index_in_histogram;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 将热地址引入CMT</span><br>        <span class="hljs-keyword">auto</span> itr = trace_lpas_sorted_histogram.<span class="hljs-built_in">begin</span>();<br>        <span class="hljs-keyword">while</span> (Address_Mapping_Unit-&gt;<span class="hljs-built_in">Get_current_cmt_occupancy_for_stream</span>(stat-&gt;Stream_id) &lt; entries_to_bring_into_cmt) &#123;<br>            Address_Mapping_Unit-&gt;<span class="hljs-built_in">Bring_to_CMT_for_preconditioning</span>(stat-&gt;Stream_id, (*itr).second);<br>            trace_lpas_sorted_histogram.<span class="hljs-built_in">erase</span>(itr++);<br>        &#125;<br><br>        <span class="hljs-comment">// 如果CMT中还有剩余空间，则将剩余的地址引入CMT</span><br>        no_of_entries_in_cmt -= entries_to_bring_into_cmt;<br>        <span class="hljs-keyword">auto</span> itr2 = trace_lpas_sorted_histogram.<span class="hljs-built_in">begin</span>();<br>        std::<span class="hljs-built_in">advance</span>(itr2, hot_region_last_index_in_histogram);<br>        <span class="hljs-keyword">while</span> (Address_Mapping_Unit-&gt;<span class="hljs-built_in">Get_current_cmt_occupancy_for_stream</span>(stat-&gt;Stream_id) &lt; no_of_entries_in_cmt) &#123;<br>            Address_Mapping_Unit-&gt;<span class="hljs-built_in">Bring_to_CMT_for_preconditioning</span>(stat-&gt;Stream_id, (*itr2++).second);<br>            <span class="hljs-keyword">if</span> (itr2 == trace_lpas_sorted_histogram.<span class="hljs-built_in">end</span>()) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">case</span> Utils::Address_Distribution_Type::STREAMING:<br>    &#123;<br>        LPA_type lpa;<br>        LPA_type first_lpa_streaming = <span class="hljs-built_in">Convert_host_logical_address_to_device_address</span>(stat-&gt;First_Accessed_Address);<br>        <span class="hljs-keyword">auto</span> itr = lpa_set_for_preconditioning.<span class="hljs-built_in">find</span>(lpa);<br>        <span class="hljs-keyword">if</span> (itr != lpa_set_for_preconditioning.<span class="hljs-built_in">begin</span>()) &#123;<br>            itr--;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 按照流模式将地址引入CMT</span><br>        <span class="hljs-keyword">while</span> (Address_Mapping_Unit-&gt;<span class="hljs-built_in">Get_current_cmt_occupancy_for_stream</span>(stat-&gt;Stream_id) &lt; no_of_entries_in_cmt) &#123;<br>            Address_Mapping_Unit-&gt;<span class="hljs-built_in">Bring_to_CMT_for_preconditioning</span>(stat-&gt;Stream_id, (*itr).first);<br>            <span class="hljs-keyword">if</span> (itr == lpa_set_for_preconditioning.<span class="hljs-built_in">begin</span>()) &#123;<br>                itr = lpa_set_for_preconditioning.<span class="hljs-built_in">end</span>();<br>                itr--;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                itr--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">case</span> Utils::Address_Distribution_Type::RANDOM_UNIFORM:<br>    &#123;<br>        <span class="hljs-keyword">int</span> random_walker = <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(random_generator.<span class="hljs-built_in">Uniform</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">uint32_t</span>(trace_lpas_sorted_histogram.<span class="hljs-built_in">size</span>()) - <span class="hljs-number">2</span>));<br>        <span class="hljs-keyword">int</span> random_step = random_generator.<span class="hljs-built_in">Uniform_uint</span>(<span class="hljs-number">0</span>, (<span class="hljs-keyword">uint32_t</span>)(trace_lpas_sorted_histogram.<span class="hljs-built_in">size</span>()) / no_of_entries_in_cmt);<br>        <span class="hljs-keyword">auto</span> itr = trace_lpas_sorted_histogram.<span class="hljs-built_in">begin</span>();<br>        <br>        <span class="hljs-comment">// 按照随机均匀分布将地址引入CMT</span><br>        <span class="hljs-keyword">while</span> (Address_Mapping_Unit-&gt;<span class="hljs-built_in">Get_current_cmt_occupancy_for_stream</span>(stat-&gt;Stream_id) &lt; no_of_entries_in_cmt) &#123;<br>            std::<span class="hljs-built_in">advance</span>(itr, random_step);<br>            Address_Mapping_Unit-&gt;<span class="hljs-built_in">Bring_to_CMT_for_preconditioning</span>(stat-&gt;Stream_id, (*itr).second);<br>            <span class="hljs-keyword">if</span> (trace_lpas_sorted_histogram.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>) &#123;<br>                trace_lpas_sorted_histogram.<span class="hljs-built_in">erase</span>(itr++);<br>                <span class="hljs-keyword">if</span> (random_walker + random_step &gt;= <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(trace_lpas_sorted_histogram.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) || random_walker + random_step &lt; <span class="hljs-number">0</span>) &#123;<br>                    random_step *= <span class="hljs-number">-1</span>;<br>                &#125;<br>                random_walker += random_step;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                trace_lpas_sorted_histogram.<span class="hljs-built_in">erase</span>(itr);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-keyword">break</span>;<br>&#125;<br><br>		&#125;<br>	&#125;<br></code></pre></td></tr></table></figure>

<p><strong>FTL::Report_results_in_XML：</strong>与Flash_Transaction_Queue中的Report_results_in_XML函数类似，将实验结果写到XML文件中。</p>
<h2 id="GC-and-WL-Unit-Base"><a href="#GC-and-WL-Unit-Base" class="headerlink" title="GC_and_WL_Unit_Base"></a>GC_and_WL_Unit_Base</h2><p><strong>GC_and_WL_Unit_Base::Setup_triggers()：</strong>设置触发器（trigger）</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">void</span> GC_and_WL_Unit_Base::Setup_triggers()<br>&#123;<br>    <span class="hljs-comment">// 调用基类中的 Setup_triggers 方法，确保基类中定义的触发器也被正确设置</span><br>    Sim_Object::Setup_triggers();<br><br>    <span class="hljs-comment">// 将 handle_transaction_serviced_signal_from_PHY 函数连接到 flash_controller 对象的 TransactionServicedSignal 信号</span><br>    flash_controller-&gt;ConnectToTransactionServicedSignal(handle_transaction_serviced_signal_from_PHY);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>GC_and_WL_Unit_Base::create_gc_wl_transaction：</strong></p>
<p><strong>事务创建</strong>: 函数的主要作用是创建和处理与垃圾回收和写入日志相关的事务，包括擦除、读取和写入操作。</p>
<p><strong>页面处理</strong>: 根据页面的有效性和数据类型选择合适的处理方式，包括 RAID 数据的处理和非 RAID 数据的处理。</p>
<p><strong>缓存提交</strong>: 对于半有效页面，进行缓存提交操作，以确保数据的正确性和一致性。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">GC_and_WL_Unit_Base::create_gc_wl_transaction</span><span class="hljs-params">(NVM::FlashMemory::Physical_Page_Address gc_wl_candidate_address, PlaneBookKeepingType* pbke)</span> </span>&#123;<br>    <span class="hljs-comment">// 获取指定 BlockID 的 Block</span><br>    Block_Pool_Slot_Type* block = &amp;pbke-&gt;Blocks[gc_wl_candidate_address.BlockID];<br>    <br>    <span class="hljs-comment">// 准备提交事务</span><br>    _my_instance-&gt;tsu-&gt;<span class="hljs-built_in">Prepare_for_transaction_submit</span>();<br>    <br>    <span class="hljs-comment">// 创建垃圾回收和写入日志的擦除事务</span><br>    NVM_Transaction_Flash_ER* gc_wl_erase_tr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">NVM_Transaction_Flash_ER</span>(Transaction_Source_Type::GC_WL, block-&gt;Stream_id, gc_wl_candidate_address);<br>    <br>    <span class="hljs-comment">// 用于存储缓存提交信息</span><br>    std::vector&lt;std::pair&lt;stream_id_type, LPA_type&gt;&gt; cacheCommits;<br>    <br>    <span class="hljs-comment">// 检查是否需要进行页面处理</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> || block-&gt;Current_page_write_index - block-&gt;Invalid_page_count &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 遍历当前 Block 中的所有有效页面</span><br>        NVM_Transaction_Flash_RD* gc_wl_read = <span class="hljs-literal">NULL</span>;<br>        NVM_Transaction_Flash_WR* gc_wl_write = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">int</span> Pcount = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-keyword">for</span> (flash_page_ID_type pageID = <span class="hljs-number">0</span>; pageID &lt; block-&gt;Current_page_write_index; pageID++) &#123;<br>            gc_wl_candidate_address.PageID = pageID;<br>            LPA_type lpa = _my_instance-&gt;flash_controller-&gt;<span class="hljs-built_in">Get_metadata</span>(<br>                gc_wl_candidate_address.ChannelID,<br>                gc_wl_candidate_address.ChipID,<br>                gc_wl_candidate_address.DieID,<br>                gc_wl_candidate_address.PlaneID,<br>                gc_wl_candidate_address.BlockID,<br>                gc_wl_candidate_address.PageID<br>            );<br>            <br>            <span class="hljs-comment">// 检查页面是否有效</span><br>            <span class="hljs-keyword">if</span> (_my_instance-&gt;block_manager-&gt;<span class="hljs-built_in">Is_page_valid</span>(block, pageID)) &#123;<br>                Pcount++;<br>                <span class="hljs-keyword">if</span> (block-&gt;isWL) &#123;<br>                    Stats::Total_page_movements_for_wl++;<br>                &#125;<br>                <br>                <span class="hljs-keyword">if</span> (block-&gt;Holds_RAID_data) &#123;<br>                    <span class="hljs-comment">// 处理 RAID 数据</span><br>                    Address_Mapping_Unit_Page_Level_And_RAID *address_mapping_unit = <span class="hljs-keyword">dynamic_cast</span>&lt;Address_Mapping_Unit_Page_Level_And_RAID*&gt;(_my_instance-&gt;address_mapping_unit);<br>                    <br>                    <span class="hljs-keyword">if</span> (_my_instance-&gt;use_copyback) &#123;<br>                        <span class="hljs-comment">// 使用 Copyback 模式进行写操作</span><br>                        gc_wl_write = <span class="hljs-keyword">new</span> <span class="hljs-built_in">NVM_Transaction_Flash_WR</span>(<br>                            Transaction_Source_Type::GC_WL,<br>                            address_mapping_unit-&gt;<span class="hljs-built_in">get_RAID_stream</span>(gc_wl_candidate_address.ChannelID),<br>                            _my_instance-&gt;sector_no_per_page * SECTOR_SIZE_IN_BYTE,<br>                            NO_LPA,<br>                            _my_instance-&gt;address_mapping_unit-&gt;<span class="hljs-built_in">Convert_address_to_ppa</span>(gc_wl_candidate_address),<br>                            <span class="hljs-literal">NULL</span>,<br>                            <span class="hljs-number">0</span>,<br>                            <span class="hljs-literal">NULL</span>,<br>                            <span class="hljs-number">0</span>,<br>                            INVALID_TIME_STAMP<br>                        );<br>                        gc_wl_write-&gt;ExecutionMode = WriteExecutionModeType::COPYBACK;<br>                        _my_instance-&gt;tsu-&gt;<span class="hljs-built_in">Submit_transaction</span>(gc_wl_write);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-comment">// 先进行读取，再进行写入</span><br>                        gc_wl_read = <span class="hljs-keyword">new</span> <span class="hljs-built_in">NVM_Transaction_Flash_RD</span>(<br>                            Transaction_Source_Type::GC_WL,<br>                            address_mapping_unit-&gt;<span class="hljs-built_in">get_RAID_stream</span>(gc_wl_candidate_address.ChannelID),<br>                            _my_instance-&gt;sector_no_per_page * SECTOR_SIZE_IN_BYTE,<br>                            NO_LPA,<br>                            _my_instance-&gt;address_mapping_unit-&gt;<span class="hljs-built_in">Convert_address_to_ppa</span>(gc_wl_candidate_address),<br>                            gc_wl_candidate_address,<br>                            <span class="hljs-literal">NULL</span>,<br>                            <span class="hljs-number">0</span>,<br>                            <span class="hljs-literal">NULL</span>,<br>                            <span class="hljs-number">0</span>,<br>                            INVALID_TIME_STAMP<br>                        );<br>                        gc_wl_write = <span class="hljs-keyword">new</span> <span class="hljs-built_in">NVM_Transaction_Flash_WR</span>(<br>                            Transaction_Source_Type::GC_WL,<br>                            address_mapping_unit-&gt;<span class="hljs-built_in">get_RAID_stream</span>(gc_wl_candidate_address.ChannelID),<br>                            _my_instance-&gt;sector_no_per_page * SECTOR_SIZE_IN_BYTE,<br>                            NO_LPA,<br>                            NO_PPA,<br>                            gc_wl_candidate_address,<br>                            <span class="hljs-literal">NULL</span>,<br>                            <span class="hljs-number">0</span>,<br>                            gc_wl_read,<br>                            <span class="hljs-number">0</span>,<br>                            INVALID_TIME_STAMP<br>                        );<br>                        gc_wl_write-&gt;ExecutionMode = WriteExecutionModeType::SIMPLE;<br>                        gc_wl_write-&gt;RelatedErase = gc_wl_erase_tr;<br>                        gc_wl_read-&gt;RelatedWrite = gc_wl_write;<br>                        <br>                        <span class="hljs-comment">// 只提交读事务，写事务在读事务完成后提交</span><br>                        _my_instance-&gt;tsu-&gt;<span class="hljs-built_in">Submit_transaction</span>(gc_wl_read);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (_my_instance-&gt;use_copyback) &#123;<br>                    <span class="hljs-comment">// 处理非 RAID 数据的 Copyback 模式</span><br>                    gc_wl_write = <span class="hljs-keyword">new</span> <span class="hljs-built_in">NVM_Transaction_Flash_WR</span>(<br>                        Transaction_Source_Type::GC_WL,<br>                        block-&gt;Stream_id,<br>                        _my_instance-&gt;sector_no_per_page * SECTOR_SIZE_IN_BYTE,<br>                        NO_LPA,<br>                        _my_instance-&gt;address_mapping_unit-&gt;<span class="hljs-built_in">Convert_address_to_ppa</span>(gc_wl_candidate_address),<br>                        <span class="hljs-literal">NULL</span>,<br>                        <span class="hljs-number">0</span>,<br>                        <span class="hljs-literal">NULL</span>,<br>                        <span class="hljs-number">0</span>,<br>                        INVALID_TIME_STAMP<br>                    );<br>                    gc_wl_write-&gt;ExecutionMode = WriteExecutionModeType::COPYBACK;<br>                    _my_instance-&gt;tsu-&gt;<span class="hljs-built_in">Submit_transaction</span>(gc_wl_write);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 处理非 RAID 数据的读取和写入</span><br>                    gc_wl_read = <span class="hljs-keyword">new</span> <span class="hljs-built_in">NVM_Transaction_Flash_RD</span>(<br>                        Transaction_Source_Type::GC_WL,<br>                        block-&gt;Stream_id,<br>                        _my_instance-&gt;sector_no_per_page * SECTOR_SIZE_IN_BYTE,<br>                        NO_LPA,<br>                        _my_instance-&gt;address_mapping_unit-&gt;<span class="hljs-built_in">Convert_address_to_ppa</span>(gc_wl_candidate_address),<br>                        gc_wl_candidate_address,<br>                        <span class="hljs-literal">NULL</span>,<br>                        <span class="hljs-number">0</span>,<br>                        <span class="hljs-literal">NULL</span>,<br>                        <span class="hljs-number">0</span>,<br>                        INVALID_TIME_STAMP<br>                    );<br>                    gc_wl_write = <span class="hljs-keyword">new</span> <span class="hljs-built_in">NVM_Transaction_Flash_WR</span>(<br>                        Transaction_Source_Type::GC_WL,<br>                        block-&gt;Stream_id,<br>                        _my_instance-&gt;sector_no_per_page * SECTOR_SIZE_IN_BYTE,<br>                        NO_LPA,<br>                        NO_PPA,<br>                        gc_wl_candidate_address,<br>                        <span class="hljs-literal">NULL</span>,<br>                        <span class="hljs-number">0</span>,<br>                        gc_wl_read,<br>                        <span class="hljs-number">0</span>,<br>                        INVALID_TIME_STAMP<br>                    );<br>                    gc_wl_write-&gt;ExecutionMode = WriteExecutionModeType::SIMPLE;<br>                    gc_wl_write-&gt;RelatedErase = gc_wl_erase_tr;<br>                    gc_wl_read-&gt;RelatedWrite = gc_wl_write;<br>                    <br>                    <span class="hljs-comment">// 只提交读事务，写事务在读事务完成后提交</span><br>                    _my_instance-&gt;tsu-&gt;<span class="hljs-built_in">Submit_transaction</span>(gc_wl_read);<br>                &#125;<br>                <span class="hljs-comment">// 将写事务加入擦除事务的活动列表</span><br>                gc_wl_erase_tr-&gt;Page_movement_activities.<span class="hljs-built_in">push_back</span>(gc_wl_write);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (_my_instance-&gt;block_manager-&gt;<span class="hljs-built_in">Is_page_Semil</span>(block, pageID)) &#123;<br>                <span class="hljs-comment">// 处理半有效页面</span><br>                Address_Mapping_Unit_Page_Level_And_RAID *address_mapping_unit = <span class="hljs-keyword">dynamic_cast</span>&lt;Address_Mapping_Unit_Page_Level_And_RAID*&gt;(_my_instance-&gt;address_mapping_unit);<br>                LPA_type raidLPA = address_mapping_unit-&gt;<span class="hljs-built_in">Get_And_Create_RAIDID</span>(block-&gt;Stream_id, lpa);<br>                stream_id_type stream = (raidLPA &amp; (NO_LPA &lt;&lt; <span class="hljs-number">56</span>)) &gt;&gt; <span class="hljs-number">56</span>;<br>                raidLPA = <span class="hljs-built_in">UNIQUE_KEY_TO_LPN</span>(stream, raidLPA);<br>                cacheCommits.<span class="hljs-built_in">emplace_back</span>(stream, raidLPA);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 如果有半有效页面，处理缓存提交</span><br>        <span class="hljs-keyword">if</span> (cacheCommits.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>) &#123;<br>            Data_Cache_Manager_Flash_RAID *dcm = <span class="hljs-keyword">dynamic_cast</span>&lt;Data_Cache_Manager_Flash_RAID*&gt;(_my_instance-&gt;address_mapping_unit-&gt;<span class="hljs-built_in">get_FTL</span>()-&gt;Data_cache_manager);<br>            dcm-&gt;<span class="hljs-built_in">gc_eviction</span>(cacheCommits, gc_wl_erase_tr);<br>        &#125;<br>        <span class="hljs-comment">// 设置擦除事务到 Block 的擦除事务槽</span><br>        block-&gt;Erase_transaction = gc_wl_erase_tr;<br>        <br>        <span class="hljs-comment">// 提交擦除事务并安排事务调度</span><br>        _my_instance-&gt;tsu-&gt;<span class="hljs-built_in">Submit_transaction</span>(gc_wl_erase_tr);<br>        _my_instance-&gt;tsu-&gt;<span class="hljs-built_in">Schedule</span>();<br>    &#125;<br></code></pre></td></tr></table></figure>

<p><strong>GC_and_WL_Unit_Base::gc_continue：</strong>检查事务地址的块状: 该函数首先检查指定地址的块是否有正在进行的垃圾回收或写入日志操作。条件执行事务创建: 如果块可以执行垃圾回收或写入日志操作，函数会创建并执行相应的事务。调试支持: 提供了一些调试信息，帮助开发者在需要时输出事务相关信息。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs awk">void GC_and_WL_Unit_Base::gc_continue(NVM_Transaction_Flash* transaction, PlaneBookKeepingType* pbke) &#123;<br>    <span class="hljs-regexp">//</span> 检查给定地址的 Block 是否正在进行垃圾回收或写入日志<br>    <span class="hljs-keyword">if</span> (_my_instance-&gt;block_manager-&gt;Block_has_ongoing_gc_wl(transaction-&gt;Address)) &#123;<br>        <span class="hljs-regexp">//</span> 如果可以执行垃圾回收或写入日志操作<br>        <span class="hljs-keyword">if</span> (_my_instance-&gt;block_manager-&gt;Can_execute_gc_wl(transaction-&gt;Address)) &#123;<br>            <span class="hljs-regexp">//</span> 创建并执行垃圾回收和写入日志事务<br>            create_gc_wl_transaction(transaction-&gt;Address, pbke);<br>            <br>            <span class="hljs-regexp">//</span> 注释掉的调试信息，可以用于输出事务地址信息和事务来源类型<br>            <span class="hljs-regexp">//</span> std::cout &lt;&lt; transaction-&gt;Address.ChannelID &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; transaction-&gt;Address.ChipID &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; transaction-&gt;Address.PlaneID &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; transaction-&gt;Address.BlockID &lt;&lt; std::endl;<br>            <span class="hljs-regexp">//</span> <span class="hljs-keyword">if</span>(transaction-&gt;Source == Transaction_Source_Type::GC_WL) &#123;<br>            <span class="hljs-regexp">//</span>     std::cout &lt;&lt; <span class="hljs-string">&quot;transaction_Source_Type::GC_WL&quot;</span> &lt;&lt; std::endl;<br>            <span class="hljs-regexp">//</span> &#125;<br>            <span class="hljs-regexp">//</span> throw <span class="hljs-string">&quot; 1&quot;</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>GC_and_WL_Unit_Base::handle_transaction_serviced_signal_from_PHY：</strong></p>
<p><strong>更新统计信息</strong>: 更新垃圾回收计数器和总时间统计。</p>
<p><strong>处理特定来源的事务</strong>: 根据事务的来源（USERIO、MAPPING、CACHE）和类型（READ、WRITE），执行块管理器相应的读写服务操作，并调用<code>gc_continue</code>函数继续垃圾回收过程。</p>
<p><strong>处理带有<code>cacheEj</code>标记的事务</strong>: 如果事务具有<code>cacheEj</code>标记，则处理相关读写事务，并调用<code>gc_continue</code>函数。</p>
<p><strong>根据事务类型进行处理</strong>:</p>
<ul>
<li><strong>READ事务</strong>: 处理持有RAID数据、映射数据或普通数据的块，确保数据一致性，并为GC分配新页面。</li>
<li><strong>WRITE事务</strong>: 更新总的页面移动计数，处理相关的RAID或映射数据屏障，并移除相应的页面移动活动。</li>
<li><strong>ERASE事务</strong>: 移除正在进行的擦除操作，将擦除的块添加回块池，调用GC和WL完成函数，并检查是否需要执行静态磨损均衡和停止服务写入事务。</li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">void</span> GC_and_WL_Unit_Base::handle_transaction_serviced_signal_from_PHY(NVM_Transaction_Flash* transaction) &#123;<br>    <span class="hljs-built_in">static</span> <span class="hljs-keyword">int</span> gcCount = <span class="hljs-number">0</span>; <span class="hljs-comment">// 静态变量，用于统计处理的垃圾回收事务数量</span><br>    PlaneBookKeepingType* pbke = &amp;(_my_instance-&gt;block_manager-&gt;plane_manager[transaction-&gt;Address.ChannelID][transaction-&gt;Address.ChipID][transaction-&gt;Address.DieID][transaction-&gt;Address.PlaneID]);<br>    <br>    <span class="hljs-comment">// 更新实例的垃圾回收统计信息</span><br>    _my_instance-&gt;desGC++;<br>    _my_instance-&gt;timeAll += Simulator-&gt;Time() - transaction-&gt;Issue_time;<br><br>    <span class="hljs-comment">// 调试代码，可以用于特定条件下的输出和模拟停止</span><br>    <span class="hljs-comment">// if(_my_instance-&gt;desGC == 15583283)&#123; </span><br>    <span class="hljs-comment">//     std::cout &lt;&lt; (transaction-&gt;Source == Transaction_Source_Type::GC_WL) &lt;&lt; std::endl;</span><br>    <span class="hljs-comment">//     std::cout &lt;&lt; transaction &lt;&lt; &quot; &quot; &lt;&lt; transaction-&gt;Stream_id &lt;&lt; &quot; &quot; &lt;&lt; transaction-&gt;LPA &lt;&lt; std::endl;</span><br>    <span class="hljs-comment">//     std::cout &lt;&lt; transaction-&gt;cacheEj &lt;&lt; std::endl;</span><br>    <span class="hljs-comment">//     std::cout &lt;&lt; (transaction-&gt;Type == Transaction_Type::READ) &lt;&lt; std::endl;</span><br>    <span class="hljs-comment">//     std::cout &lt;&lt; transaction-&gt;Address.ChannelID &lt;&lt; &quot; &quot; &lt;&lt; transaction-&gt;Address.ChipID;</span><br>    <span class="hljs-comment">//     std::cout &lt;&lt; &quot; &quot; &lt;&lt; transaction-&gt;Address.DieID &lt;&lt; &quot; &quot; &lt;&lt; transaction-&gt;Address.PlaneID;</span><br>    <span class="hljs-comment">//     std::cout &lt;&lt; &quot; &quot; &lt;&lt; transaction-&gt;Address.BlockID &lt;&lt; &quot; &quot; &lt;&lt; transaction-&gt;Address.PageID &lt;&lt; std::endl;</span><br>    <span class="hljs-comment">//     gcCount = 0;</span><br>    <span class="hljs-comment">//     Simulator-&gt;Stop_simulation();</span><br>    <span class="hljs-comment">// &#125;</span><br><br>    <span class="hljs-comment">// 根据事务的来源和类型处理事务</span><br>    <span class="hljs-keyword">switch</span> (transaction-&gt;Source) &#123;<br>        <span class="hljs-keyword">case</span> Transaction_Source_Type::USERIO:<br>        <span class="hljs-keyword">case</span> Transaction_Source_Type::MAPPING:<br>        <span class="hljs-keyword">case</span> Transaction_Source_Type::CACHE:<br>            <span class="hljs-keyword">switch</span> (transaction-&gt;Type) &#123;<br>                <span class="hljs-keyword">case</span> Transaction_Type::READ:<br>                    _my_instance-&gt;block_manager-&gt;Read_transaction_serviced(transaction-&gt;Address);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> Transaction_Type::WRITE:<br>                    _my_instance-&gt;block_manager-&gt;Program_transaction_serviced(transaction-&gt;Address);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">default</span>:<br>                    PRINT_ERROR(<span class="hljs-string">&quot;Unexpected situation in the GC_and_WL_Unit_Base function!&quot;</span>)<br>            &#125;<br>            gc_continue(transaction, pbke);<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 处理带有 cacheEj 标记的事务</span><br>    <span class="hljs-keyword">if</span> (transaction-&gt;cacheEj) &#123;<br>        <span class="hljs-keyword">if</span> (--(*transaction-&gt;relatedCount) == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// std::cout &lt;&lt; 0 &lt;&lt; std::endl;</span><br>            <span class="hljs-comment">// ((NVM_Transaction_Flash_RD*)transaction)-&gt;RelatedWrite-&gt;RelatedRead = NULL;</span><br>            <span class="hljs-comment">// delete transaction-&gt;relatedCount;</span><br>        &#125;<br>        NVM_Transaction_Flash_RD* tr = (NVM_Transaction_Flash_RD*)transaction;<br>        <span class="hljs-keyword">if</span> (tr-&gt;RelatedErase) &#123;<br>            NVM_Transaction_Flash_ER* gc_tr = (NVM_Transaction_Flash_ER*)(tr-&gt;RelatedErase);<br>            gc_tr-&gt;Page_movement_activities.remove(tr);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        _my_instance-&gt;block_manager-&gt;Read_transaction_serviced(transaction-&gt;Address);<br>        gc_continue(transaction, pbke);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 根据事务类型进行处理</span><br>    <span class="hljs-keyword">switch</span> (transaction-&gt;Type) &#123;<br>        <span class="hljs-keyword">case</span> Transaction_Type::READ:<br>        &#123;<br>            PPA_type ppa;<br>            MPPN_type mppa;<br>            page_status_type page_status_bitmap;<br><br>            <span class="hljs-comment">// 处理持有RAID数据的块</span><br>            <span class="hljs-keyword">if</span> (pbke-&gt;Blocks[transaction-&gt;Address.BlockID].Holds_RAID_data) &#123;<br>                Address_Mapping_Unit_Page_Level_And_RAID* address_mapping_unit = dynamic_cast&lt;Address_Mapping_Unit_Page_Level_And_RAID*&gt;(_my_instance-&gt;address_mapping_unit);<br>                address_mapping_unit-&gt;Get_RAID_mapping_info_for_gc(transaction-&gt;Stream_id, transaction-&gt;LPA, ppa, page_status_bitmap);<br>                <span class="hljs-keyword">if</span> (ppa == transaction-&gt;PPA) &#123;<br>                    _my_instance-&gt;tsu-&gt;Prepare_for_transaction_submit();<br>                    ((NVM_Transaction_Flash_RD*)transaction)-&gt;RelatedWrite-&gt;write_sectors_bitmap = page_status_bitmap;<br>                    ((NVM_Transaction_Flash_RD*)transaction)-&gt;RelatedWrite-&gt;LPA = transaction-&gt;LPA;<br>                    ((NVM_Transaction_Flash_RD*)transaction)-&gt;RelatedWrite-&gt;RelatedRead = <span class="hljs-literal">NULL</span>;<br>                    address_mapping_unit-&gt;Allocate_new_page_for_gc(((NVM_Transaction_Flash_RD*)transaction)-&gt;RelatedWrite, pbke-&gt;Blocks[transaction-&gt;Address.BlockID].Holds_mapping_data);<br>                    _my_instance-&gt;tsu-&gt;Submit_transaction(((NVM_Transaction_Flash_RD*)transaction)-&gt;RelatedWrite);<br>                    _my_instance-&gt;tsu-&gt;Schedule();<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    std::cout &lt;&lt; transaction-&gt;LPA &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; transaction-&gt;PPA &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; ppa &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; NO_PPA &lt;&lt; std::endl;<br>                    std::cout &lt;&lt; transaction-&gt;Stream_id &lt;&lt; std::endl;<br>                    PRINT_ERROR(<span class="hljs-string">&quot;Inconsistency found when moving a page for GC/WL!&quot;</span>)<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pbke-&gt;Blocks[transaction-&gt;Address.BlockID].Holds_mapping_data) &#123;<br>                _my_instance-&gt;address_mapping_unit-&gt;Get_translation_mapping_info_for_gc(transaction-&gt;Stream_id, (MVPN_type)transaction-&gt;LPA, mppa, page_status_bitmap);<br>                <span class="hljs-keyword">if</span> (mppa == transaction-&gt;PPA) &#123;<br>                    _my_instance-&gt;tsu-&gt;Prepare_for_transaction_submit();<br>                    ((NVM_Transaction_Flash_RD*)transaction)-&gt;RelatedWrite-&gt;write_sectors_bitmap = FULL_PROGRAMMED_PAGE;<br>                    ((NVM_Transaction_Flash_RD*)transaction)-&gt;RelatedWrite-&gt;LPA = transaction-&gt;LPA;<br>                    ((NVM_Transaction_Flash_RD*)transaction)-&gt;RelatedWrite-&gt;RelatedRead = <span class="hljs-literal">NULL</span>;<br>                    _my_instance-&gt;address_mapping_unit-&gt;Allocate_new_page_for_gc(((NVM_Transaction_Flash_RD*)transaction)-&gt;RelatedWrite, pbke-&gt;Blocks[transaction-&gt;Address.BlockID].Holds_mapping_data);<br>                    _my_instance-&gt;tsu-&gt;Submit_transaction(((NVM_Transaction_Flash_RD*)transaction)-&gt;RelatedWrite);<br>                    _my_instance-&gt;tsu-&gt;Schedule();<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    PRINT_ERROR(<span class="hljs-string">&quot;Inconsistency found when moving a page for GC/WL!&quot;</span>)<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                _my_instance-&gt;address_mapping_unit-&gt;Get_data_mapping_info_for_gc(transaction-&gt;Stream_id, transaction-&gt;LPA, ppa, page_status_bitmap);<br>                Address_Mapping_Unit_Page_Level_And_RAID* address_mapping_unit = dynamic_cast&lt;Address_Mapping_Unit_Page_Level_And_RAID*&gt;(_my_instance-&gt;address_mapping_unit);<br>                address_mapping_unit = <span class="hljs-literal">NULL</span>;<br>                <span class="hljs-keyword">if</span> (address_mapping_unit) &#123;<br>                    ppa = address_mapping_unit-&gt;Get_ppa(<span class="hljs-literal">true</span>, transaction-&gt;Stream_id, transaction-&gt;LPA);<br>                    page_status_bitmap = address_mapping_unit-&gt;Get_page_status(<span class="hljs-literal">true</span>, transaction-&gt;Stream_id, transaction-&gt;LPA);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (ppa == transaction-&gt;PPA) &#123;<br>                    _my_instance-&gt;tsu-&gt;Prepare_for_transaction_submit();<br>                    ((NVM_Transaction_Flash_RD*)transaction)-&gt;RelatedWrite-&gt;write_sectors_bitmap = page_status_bitmap;<br>                    ((NVM_Transaction_Flash_RD*)transaction)-&gt;RelatedWrite-&gt;LPA = transaction-&gt;LPA;<br>                    ((NVM_Transaction_Flash_RD*)transaction)-&gt;RelatedWrite-&gt;RelatedRead = <span class="hljs-literal">NULL</span>;<br>                    _my_instance-&gt;address_mapping_unit-&gt;Allocate_new_page_for_gc(((NVM_Transaction_Flash_RD*)transaction)-&gt;RelatedWrite, pbke-&gt;Blocks[transaction-&gt;Address.BlockID].Holds_mapping_data);<br>                    _my_instance-&gt;tsu-&gt;Submit_transaction(((NVM_Transaction_Flash_RD*)transaction)-&gt;RelatedWrite);<br>                    _my_instance-&gt;tsu-&gt;Schedule();<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    std::cout &lt;&lt; transaction-&gt;LPA &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; transaction-&gt;PPA &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; ppa &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; NO_PPA &lt;&lt; std::endl;<br>                    std::cout &lt;&lt; transaction-&gt;Stream_id &lt;&lt; std::endl;<br>                    PRINT_ERROR(<span class="hljs-string">&quot;Inconsistency found when moving a page for GC/WL!&quot;</span>)<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (((NVM_Transaction_Flash_RD*)transaction)-&gt;RelatedWrite) &#123;<br>                ((NVM_Transaction_Flash_RD*)transaction)-&gt;RelatedWrite-&gt;RelatedRead = <span class="hljs-literal">NULL</span>;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">case</span> Transaction_Type::WRITE:<br>            Stats::Total_page_movements_for_gc++;<br>            <span class="hljs-keyword">if</span> (pbke-&gt;Blocks[((NVM_Transaction_Flash_WR*)transaction)-&gt;RelatedErase-&gt;Address.BlockID].Holds_RAID_data) &#123;<br>                auto* address_mapping_unit = dynamic_cast&lt;Address_Mapping_Unit_Page_Level_And_RAID*&gt;(_my_instance-&gt;address_mapping_unit);<br>                stream_id_type streamId = address_mapping_unit-&gt;get_RAID_stream(((NVM_Transaction_Flash_WR*)transaction)-&gt;RelatedErase-&gt;Address.ChannelID);<br>                address_mapping_unit-&gt;Remove_barrier_for_accessing_RAID(streamId, transaction-&gt;LPA);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pbke-&gt;Blocks[((NVM_Transaction_Flash_WR*)transaction)-&gt;RelatedErase-&gt;Address.BlockID].Holds_mapping_data) &#123;<br>                _my_instance-&gt;address_mapping_unit-&gt;Remove_barrier_for_accessing_mvpn(transaction-&gt;Stream_id, (MVPN_type)transaction-&gt;LPA);<br>                DEBUG(Simulator-&gt;Time() &lt;&lt; <span class="hljs-string">&quot;: MVPN=&quot;</span> &lt;&lt; (MVPN_type)transaction-&gt;LPA &lt;&lt; <span class="hljs-string">&quot; unlocked!!&quot;</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                _my_instance-&gt;address_mapping_unit-&gt;Remove_barrier_for_accessing_lpa(transaction-&gt;Stream_id, transaction-&gt;LPA);<br>                DEBUG(Simulator-&gt;Time() &lt;&lt; <span class="hljs-string">&quot;: LPA=&quot;</span> &lt;&lt; (MVPN_type)transaction-&gt;LPA &lt;&lt; <span class="hljs-string">&quot; unlocked!!&quot;</span>);<br>                <span class="hljs-comment">// std::cout &lt;&lt; Simulator-&gt;Time() &lt;&lt; &quot;: LPA=&quot; &lt;&lt; (MVPN_type)transaction-&gt;LPA &lt;&lt; &quot; unlocked!!&quot; &lt;&lt; std::endl;</span><br>            &#125;<br>            pbke-&gt;Blocks[((NVM_Transaction_Flash_WR*)transaction)-&gt;RelatedErase-&gt;Address.BlockID].Erase_transaction-&gt;Page_movement_activities.remove((NVM_Transaction_Flash_WR*)transaction);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> Transaction_Type::ERASE:<br>            pbke-&gt;Ongoing_erase_operations.erase(pbke-&gt;Ongoing_erase_operations.find(transaction-&gt;Address.BlockID));<br>            _my_instance-&gt;block_manager-&gt;Add_erased_block_to_pool(transaction-&gt;Address);<br>            _my_instance-&gt;block_manager-&gt;GC_WL_finished(transaction-&gt;Address);<br>            _my_instance-&gt;address_mapping_unit-&gt;Start_servicing_writes_for_overfull_plane(transaction-&gt;Address);<br>            <br>            <span class="hljs-comment">// 调试代码，可以用于统计特定数量的垃圾回收事务后停止模拟</span><br>            <span class="hljs-comment">// if (++gcCount == 3629) &#123;</span><br>            <span class="hljs-comment">//     gcCount = 0;</span><br>            <span class="hljs-comment">//     Simulator-&gt;Stop_simulation();</span><br>            <span class="hljs-comment">// &#125;</span><br><br>            <span class="hljs-comment">// 检查是否需要静态磨损均衡</span><br>            <span class="hljs-keyword">if</span> (_my_instance-&gt;check_static_wl_required(transaction-&gt;Address)) &#123;<br>                _my_instance-&gt;run_static_wearleveling(transaction-&gt;Address);<br>            &#125;<br><br>            <span class="hljs-comment">// 检查是否需要停止服务写入事务</span><br>            <span class="hljs-keyword">if</span> (_my_instance-&gt;Stop_servicing_writes_inter(transaction-&gt;Address)) &#123;<br>                _my_instance-&gt;Check_gc_required(pbke-&gt;Get_free_block_pool_size(), transaction-&gt;Address);<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>GC_and_WL_Unit_Base::Get_GC_policy_specific_parameter()：</strong>用于根据当前垃圾回收（GC）策略选择的类型，返回相应的策略参数值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> <span class="hljs-title">GC_and_WL_Unit_Base::Get_GC_policy_specific_parameter</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 根据当前的块选择策略（block_selection_policy），返回相应的策略参数值</span><br>    <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (block_selection_policy) &#123;<br>        <span class="hljs-comment">// 如果策略是 RGA（Random Greedy Algorithm），返回 rga_set_size</span><br>        <span class="hljs-keyword">case</span> GC_Block_Selection_Policy_Type::RGA:<br>            <span class="hljs-keyword">return</span> rga_set_size;<br><br>        <span class="hljs-comment">// 如果策略是 RANDOM_PP（Random with Probability and Priority），返回 random_pp_threshold</span><br>        <span class="hljs-keyword">case</span> GC_Block_Selection_Policy_Type::RANDOM_PP:<br>            <span class="hljs-keyword">return</span> random_pp_threshold;<br><br>        <span class="hljs-comment">// 如果策略不匹配上述情况，默认返回 0</span><br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 默认返回值为 0</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>GC_and_WL_Unit_Base::Get_minimum_number_of_free_pages_before_GC()：</strong>获取GC阈值</p>
<p><strong>GC_and_WL_Unit_Base::Use_dynamic_wearleveling()：</strong>这个函数的作用是返回 <code>dynamic_wearleveling_enabled</code> 变量的值，以确定是否启用了动态均衡磨损功能。</p>
<p><strong>GC_and_WL_Unit_Base::Use_static_wearleveling()：</strong>这个函数的作用是返回 <code>static_wearleveling_enabled</code> 变量的值，以确定是否启用了静态均衡磨损功能。</p>
<p><strong>GC_and_WL_Unit_Base::Stop_servicing_writes_inter：</strong>这个函数的作用是确定是否需要停止对某个平面的写操作服务。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">bool</span> GC_and_WL_Unit_Base::Stop_servicing_writes_inter(<span class="hljs-keyword">const</span> NVM::FlashMemory::Physical_Page_Address&amp; plane_address) &#123;<br>    <span class="hljs-comment">// 获取与指定平面地址相关的 PlaneBookKeepingType 对象指针</span><br>    PlaneBookKeepingType* pbke = &amp;(_my_instance-&gt;block_manager-&gt;plane_manager[plane_address.ChannelID][plane_address.ChipID][plane_address.DieID][plane_address.PlaneID]);<br>    <br>    <span class="hljs-comment">// 检查平面的池大小是否大于等于 max_ongoing_gc_reqs_per_plane</span><br>    <span class="hljs-keyword">if</span>(block_manager-&gt;Get_pool_size(plane_address) &gt;= max_ongoing_gc_reqs_per_plane) &#123;<br>        <span class="hljs-comment">// 如果池大小大于等于阈值，返回 false，不需要停止写操作服务</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 遍历平面中的所有块</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; block_no_per_plane; ++i) &#123;<br>            <span class="hljs-comment">// 检查是否有任何块正在进行 GC/WL 操作</span><br>            <span class="hljs-keyword">if</span>(pbke-&gt;Blocks[i].Has_ongoing_gc_wl) &#123;<br>                <span class="hljs-comment">// 如果找到一个块正在进行 GC/WL 操作，返回 false，不需要停止写操作服务</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 如果池大小小于阈值且没有任何块正在进行 GC/WL 操作，返回 true，需要停止写操作服务</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>GC_and_WL_Unit_Base::Stop_servicing_writes：</strong>首先获取与指定平面地址相关的 PlaneBookKeepingType 对象指针，然后遍历平面中的所有块，<strong>如果找到一个块正在进行 GC/WL 操作，返回 true，需要停止写操作服务</strong>，如果没有任何块正在进行 GC/WL 操作，返回 false，不需要停止写操作服务</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">bool</span> GC_and_WL_Unit_Base::Stop_servicing_writes(<span class="hljs-keyword">const</span> NVM::FlashMemory::Physical_Page_Address&amp; plane_address) &#123;<br>    <span class="hljs-comment">// 获取与指定平面地址相关的 PlaneBookKeepingType 对象指针</span><br>    PlaneBookKeepingType* pbke = &amp;(_my_instance-&gt;block_manager-&gt;plane_manager[plane_address.ChannelID][plane_address.ChipID][plane_address.DieID][plane_address.PlaneID]);<br>    <br>    <span class="hljs-comment">// 检查平面的池大小是否大于等于 max_ongoing_gc_reqs_per_plane</span><br>    <span class="hljs-comment">// if(block_manager-&gt;Get_pool_size(plane_address) &gt;= max_ongoing_gc_reqs_per_plane)&#123;</span><br>    <span class="hljs-comment">//  return false;</span><br>    <span class="hljs-comment">// &#125;else&#123;</span><br>    <span class="hljs-comment">// &#125;</span><br><br>    <span class="hljs-comment">// 遍历平面中的所有块</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; block_no_per_plane; ++i) &#123;<br>        <span class="hljs-comment">// 检查是否有任何块正在进行 GC/WL 操作</span><br>        <span class="hljs-keyword">if</span>(pbke-&gt;Blocks[i].Has_ongoing_gc_wl) &#123;<br>            <span class="hljs-comment">// 如果找到一个块正在进行 GC/WL 操作，返回 true，需要停止写操作服务</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 如果没有任何块正在进行 GC/WL 操作，返回 false，不需要停止写操作服务</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>GC_and_WL_Unit_Base::is_safe_gc_wl_candidate：</strong>该函数用于判断是否这个块是安全的GC/WL块，使用for循环遍历所有输入流，检查候选块是否有正在进行的用户编程请求，然后检查候选块是否正在进行GC、WL操作，如果检查都通过则返回true。</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-keyword">bool</span> GC_and_WL_Unit_Base::is_safe_gc_wl_candidate(<span class="hljs-keyword">const</span> PlaneBookKeepingType* plane_record, <span class="hljs-keyword">const</span> flash_block_ID_type gc_wl_candidate_block_id) &#123;<br>    <span class="hljs-comment">// 遍历所有输入流</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> stream_id = <span class="hljs-number">0</span>; stream_id &lt; address_mapping_unit-&gt;Get_no_of_input_streams(); stream_id++) &#123;<br>        <span class="hljs-comment">// 检查候选块是否是当前的写前沿块</span><br>        <span class="hljs-keyword">if</span> ((&amp;plane_record-&gt;Blocks[gc_wl_candidate_block_id]) == plane_record-&gt;Data_wf[stream_id]<br>            || (&amp;plane_record-&gt;Blocks[gc_wl_candidate_block_id]) == plane_record-&gt;Translation_wf[stream_id]<br>            || (&amp;plane_record-&gt;Blocks[gc_wl_candidate_block_id]) == plane_record-&gt;GC_wf[stream_id]) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 检查候选块是否有正在进行的用户编程请求（所有页面必须已经写完）</span><br>    <span class="hljs-keyword">if</span> (plane_record-&gt;Blocks[gc_wl_candidate_block_id].Ongoing_user_program_count &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 检查候选块是否有正在进行的 GC/WL 操作</span><br>    <span class="hljs-keyword">if</span> (plane_record-&gt;Blocks[gc_wl_candidate_block_id].Has_ongoing_gc_wl) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果所有检查都通过，则返回 true，表示该块是安全的 GC/WL 候选块</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>GC_and_WL_Unit_Base::check_static_wl_required：</strong>该函数的目的是确定是否需要在特定平面上执行静态磨损均衡操作。这取决于两个条件：静态磨损均衡是否启用，以及平面中块的最小和最大擦除次数的差异是否超过了预设的阈值。</p>
<p>使用函数检查了这两个参数，第一个为是否启用了静态磨损均衡，第二个检查了是否超过阈值</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php">inline <span class="hljs-keyword">bool</span> GC_and_WL_Unit_Base::check_static_wl_required(<span class="hljs-keyword">const</span> NVM::FlashMemory::Physical_Page_Address plane_address)<br>&#123;<br>    <span class="hljs-comment">// 检查是否启用了静态磨损均衡，并且最小和最大擦除次数的差异是否大于等于静态磨损均衡的阈值</span><br>    <span class="hljs-keyword">return</span> static_wearleveling_enabled &amp;&amp; (block_manager-&gt;Get_min_max_erase_difference(plane_address) &gt;= static_wearleveling_threshold);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>GC_and_WL_Unit_Base::run_static_wearleveling：</strong>该函数的主要目的是进行块GC/WL的检查工作，在检查完成之后进行GC、WL的事务提交。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">GC_and_WL_Unit_Base::run_static_wearleveling</span><span class="hljs-params">(<span class="hljs-keyword">const</span> NVM::FlashMemory::Physical_Page_Address plane_address)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 获取指定平面的书籍记录条目</span><br>    PlaneBookKeepingType* pbke = block_manager-&gt;<span class="hljs-built_in">Get_plane_bookkeeping_entry</span>(plane_address);<br>    <br>    <span class="hljs-comment">// 获取最冷的块的ID</span><br>    flash_block_ID_type wl_candidate_block_id = block_manager-&gt;<span class="hljs-built_in">Get_coldest_block_id</span>(plane_address);<br>    <br>    <span class="hljs-comment">// 检查候选块是否安全用于GC/WL，或者是否有正在进行的擦除操作，或者当前页写入索引是否等于块中页面数</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">is_safe_gc_wl_candidate</span>(pbke, wl_candidate_block_id) <br>        || pbke-&gt;Ongoing_erase_operations.<span class="hljs-built_in">find</span>(wl_candidate_block_id) != pbke-&gt;Ongoing_erase_operations.<span class="hljs-built_in">end</span>()<br>        || pbke-&gt;Blocks[wl_candidate_block_id].Current_page_write_index != pages_no_per_block) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 设置候选块的物理页地址</span><br>    NVM::<span class="hljs-function">FlashMemory::Physical_Page_Address <span class="hljs-title">wl_candidate_address</span><span class="hljs-params">(plane_address)</span></span>;<br>    wl_candidate_address.BlockID = wl_candidate_block_id;<br>    Block_Pool_Slot_Type* block = &amp;pbke-&gt;Blocks[wl_candidate_block_id];<br><br>    <span class="hljs-comment">// 保护状态机以防止竞态条件</span><br>    block_manager-&gt;<span class="hljs-built_in">GC_WL_started</span>(wl_candidate_address);<br><br>    <span class="hljs-comment">// 将候选块ID插入正在进行的擦除操作集合</span><br>    pbke-&gt;Ongoing_erase_operations.<span class="hljs-built_in">insert</span>(wl_candidate_block_id);<br><br>    <span class="hljs-comment">// 为访问物理块设置屏障，锁定该块以防止在GC进行时有用户请求干扰</span><br>    address_mapping_unit-&gt;<span class="hljs-built_in">Set_barrier_for_accessing_physical_block</span>(wl_candidate_address);<br><br>    <span class="hljs-comment">// 统计静态磨损均衡执行次数</span><br>    Stats::Total_wl_executions++;<br><br>    <span class="hljs-comment">// 标记候选块为磨损均衡块</span><br>    pbke-&gt;Blocks[wl_candidate_address.BlockID].isWL = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-comment">// 如果可以执行GC/WL，则创建GC/WL事务；否则，延迟执行</span><br>    <span class="hljs-keyword">if</span> (block_manager-&gt;<span class="hljs-built_in">Can_execute_gc_wl</span>(wl_candidate_address)) &#123;<br>        <span class="hljs-built_in">create_gc_wl_transaction</span>(wl_candidate_address, pbke);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="GC-and-WL-Unit-Page-Level："><a href="#GC-and-WL-Unit-Page-Level：" class="headerlink" title="GC_and_WL_Unit_Page_Level："></a>GC_and_WL_Unit_Page_Level：</h2><p>相比于上个文件，在更细的粒度上进行GC/WL的管理</p>
<p><strong>GC_and_WL_Unit_Page_Level::GC_is_in_urgent_mode：</strong>用于判断垃圾回收（GC）是否处于紧急模式。</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-keyword">bool</span> GC_and_WL_Unit_Page_Level::GC_is_in_urgent_mode(<span class="hljs-keyword">const</span> NVM::FlashMemory::Flash_Chip* chip)<br>&#123;<br>    <span class="hljs-comment">// 如果不可抢占的GC被禁用，则GC始终处于紧急模式</span><br>    <span class="hljs-keyword">if</span> (!preemptible_gc_enabled) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 创建一个物理页面地址对象</span><br>    NVM::FlashMemory::Physical_Page_Address addr;<br>    addr.ChannelID = chip-&gt;ChannelID;<br>    addr.ChipID = chip-&gt;ChipID;<br><br>    <span class="hljs-comment">// 遍历芯片中的每个die和plane</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> die_id = <span class="hljs-number">0</span>; die_id &lt; die_no_per_chip; die_id++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> plane_id = <span class="hljs-number">0</span>; plane_id &lt; plane_no_per_die; plane_id++) &#123;<br>            addr.DieID = die_id;<br>            addr.PlaneID = plane_id;<br>            <br>            <span class="hljs-comment">// 如果任何plane的块池大小小于硬阈值，则GC处于紧急模式</span><br>            <span class="hljs-keyword">if</span> (block_manager-&gt;Get_pool_size(addr) &lt; block_pool_gc_hard_threshold)<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果所有plane的块池大小都大于或等于硬阈值，则GC不处于紧急模式</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>


                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/SSD/" class="category-chain-item">SSD</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/SSD/">#SSD</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>MQSim源码解析</div>
      <div>http://yoursite.com/2024/07/19/MQSim源码/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Tspigeon</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年7月19日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/07/21/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1_python/" title="数学建模">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">数学建模</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/07/19/SSD%E7%9B%B8%E5%85%B3%E7%8E%AF%E5%A2%83/" title="SSD环境安装">
                        <span class="hidden-mobile">SSD环境安装</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>No pigeon</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>




  
<script src="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/yinghua.js"></script>
<script src="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/love.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":300,"height":600},"mobile":{"show":false},"rect":"opacity:0.7","log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
